<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Handling Errors &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Editing" href="data_editing.html" />
    <link rel="prev" title="Importing Data" href="importing_data.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_on_HPC.html">Deploy MsPASS on HPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started_overview.html">MsPASS Setup In-Depth Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="importing_data.html">Importing Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Handling Errors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exceptions-and-error-handlers">Exceptions and Error Handlers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-logger">Error Logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kills">Kills</a></li>
<li class="toctree-l2"><a class="reference internal" href="#undertaker">Undertaker</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">I/O in MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Handling Errors</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/mspass-team/mspass/blob/master/docs/source/user_manual/handling_errors.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="handling-errors">
<span id="id1"></span><h1>Handling Errors<a class="headerlink" href="#handling-errors" title="Permalink to this heading"></a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>Errors are a universal issue in large scale data processing.
In single threaded applications it was common to follow the classic unix
model of writing error messages to stderr.  Anyone processing large
amounts of data that can generate hundreds to thousands of error messages
know that stderr logging is problematic because the critical errors
can be hard to find in the debris.  A common solution used for single
threading was to use a log file that could be searched post mortem to
find problems.   In a multi-threaded situation that solution can work, but
requires specialized io libraries to avoid write collisions if two threads
try to write the to same file.  An example that may be familiar to many
seismologists of that approach is the elog library used in
<a class="reference external" href="https://brtt.com">Antelope</a>.  That approach can work for a shared memory
system but is more problematic in a large cluster of distributed machines
or (worse) a cloud system.  In a distributed system a centralized error
logger would need to maintain a connection to every running process, which
would to a challenge to implement from scratch.   We originally considered
using python’s logging mechanism, but recognized that would not solve the
large log file issue.</p>
<p>The above issues led us to a completely different solution for error logging.
We include an ErrorLogger class a member of all supported data
objects.  That model simplifies the error handling because the error
handling model can be stated as two simple rules:</p>
<ol class="arabic simple">
<li><p>If there is any error that the user needs to be warned about, post
an informative message to the error log.  Error are not always black
and white so the message should define the severity level of the error.</p></li>
<li><p>If the error invalidates the data, mark the data dead.  We expand
on this concept further below in the section titled “Kills”.</p></li>
</ol>
<p>This section is organized around three key concepts used in the
error handling system of MsPASS:   standardized exception handling,
the error logger api, and concepts related to marking data dead.  The
last item has two important subtopics:  the kill concept and
special class we tag with the descriptive, albeit perhaps overly cute,
name of <code class="code docutils literal notranslate"><span class="pre">Undertaker</span></code>.</p>
</section>
<section id="exceptions-and-error-handlers">
<h2>Exceptions and Error Handlers<a class="headerlink" href="#exceptions-and-error-handlers" title="Permalink to this heading"></a></h2>
<p>Any book on programming in any language will address the issue of error handling.
The reason, of course, is that most algorithms have limitations on
what they receive as inputs or can evolve to a state that is untenable.
There are multiple standard ways to handle errors.   In MsPASS we aimed to
treat errors with one of three approaches.</p>
<ol class="arabic simple">
<li><p>The python language is flexible, but standard practice encourages the
use of the try-raise-except construct (the try-throw-catch keywords in C++).
We use that exception mechanism internally to handle most error conditions.
To provide some regularity any error raised by a MsPASS function or
method will be the exception class called MsPASSError.   Following
standard practice the MsPASSError is defined as a subclass of the
base class Exception.  That allows generic error handlers like the
following to catch MsPASSError exceptions as described in most
books and online python tutorials
(<a class="reference external" href="https://medium.com/better-programming/a-comprehensive-guide-to-handling-exceptions-in-python-7175f0ce81f7">Follow this link for a good example</a>)</p></li>
<li><p>As with most python packages, with some algorithms we sometimes return
something that can indicate full or partial success.   We reserve that
model to situations where “partial success” is not really an error but
the result of an algorithm that is expected to behave in different ways
with different inputs.  For example, the save_inventory method of
<a class="reference external" href="../python_api/mspasspy.db.html#module-mspasspy.db.database">database</a>
returns a tuple with three numbers: number of site documents added,
number of channel documents added, and the number of stations in the
obspy Inventory object that the method received.  The result is dependent
on history of what was saved previously because this particular algorithm
tests the input to not add duplicates to the database.</p></li>
<li><p>Processing functions in MsPASS that are properly designed for the
framework MUST obey a very important rule:  a function to be run in
parallel should never throw an exception, but use the error log and (optional)
kill method described below.</p></li>
</ol>
</section>
<section id="error-logger">
<h2>Error Logger<a class="headerlink" href="#error-logger" title="Permalink to this heading"></a></h2>
<p>As discussed in the overview section above, handling errors in a parallel
environment presents special problems.  A key issue is that the schedulers
MsPASS supports (Spark and Dask) both will abort a job if any function
throws an unhandled exception.  For that reason, if a MsPASS processing
function ever throws an exception it is a bug.  Instead, we always aim
to handle errors with what we call our ErrorLogger and a classic approach
using a kill mechanism.</p>
<p>The atomic data objects of MsPASS, which we call TimeSeries and Seismogram,
are defined and implemented in C++.  (They are bound to python through
wrappers using a package called pybind11.)  Both atomic data objects
have a C++ class called <a class="reference external" href="../_static/html/classmspass_1_1utility_1_1_error_logger.html">ErrorLogger</a>
as a public attribute we define with the symbol <code class="code docutils literal notranslate"><span class="pre">elog</span></code>.  That mechanism
allows processing functions to handle all exceptions without aborting
through constructs similar to the following pythonic pseudocode:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="c1"># code that may throw an error processing data object &quot;d&quot;</span>
<span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
    <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">merr</span><span class="o">.</span><span class="n">severity</span><span class="p">()</span> <span class="o">==</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">d</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s1">&#39;Unexcepted exception: more details&#39;</span><span class="p">,</span><span class="s1">&#39;Invalid&#39;</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
</pre></div>
</div>
<p>The kill method is described further in the next section.  The key point
is that generic error handlers catch any exceptions and post message to
the ErrorLogger carried with the data in a container
with the symbolic name elog.   An error posted to the ErrorLogger
always contains two components:  (1) a (hopefully informative)
string that describes the error, and (2) a severity tag.   The
class description
describes the severity method that returns a special class called
ErrorSeverity.   ErrorSeverity is technically a binding to a C++ enum
class that defines a finite set of values that should be understood
as follows:</p>
<p><code class="code docutils literal notranslate"><span class="pre">Fatal</span></code>: A serious error that should cause the job to abort.   This
is reserved only for completely unrecoverable errors such as a malloc error.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Invalid</span></code>: This error indicates the algorithm could not produce valid
data.  Data with Invalid errors will always be marked dead.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Suspect</span></code>:  Suspect is reserved for the condition where the datum
is not killed, but the algorithm that posted it wants to give a hint that
you should consider not using it for additional processing.  There are currently
no examples of this error being posted, but we include it in the api
to allow that option.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Complaint</span></code>:  A complaint is posted for an error that was handled and
fully corrected.   Complaints are posted largely as informational messages
to warn the user there were problems with data they may want to correct
to avoid problems with different downstream algorithms.  Such errors can
also often be useful in determining why a later stage of processing aborts.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Debug</span></code>:  Reserved for verbose logging to track a problem.  Useful to
insert in a long running job where something is going wrong that is
yielding invalid data but the job is not aborting or logging errors that
define the problem.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Informative</span></code>:  Used for very verbose options on some algorithms to
extract some auxiliary information needed for some other purpose.</p>
<p>A final point about error logs is to how they are preserved.  Error
messages should always be examined after a processing sequence is completed
to appraise the validity of the result.  With a large data set is it is
very easy to generate huge error logs.  To make the result more manageable
all save operators automatically write any error log entries to
a special collection in MongoDB we call the <code class="code docutils literal notranslate"><span class="pre">elog</span></code> collection.</p>
</section>
<section id="kills">
<h2>Kills<a class="headerlink" href="#kills" title="Permalink to this heading"></a></h2>
<p>The approach of marking a piece of seismic data bad/dead is familiar to
anyone who has ever done seismic reflection processing.  All seismic
processing systems have a set of trace editing functions to mark
bad data.  That approach goes back to the earliest days of seismic reflection
processing as evidenced by a trace id field (technically an
unsigned int16) in SEGY that when set to a particular value (2) defines
that datum as dead.</p>
<p>The kill concept is useful in the MsPASS framework as a way to simplify
parallel workflows.  Spark and Dask both use a mechanism to abstract
an entire data set as a single container (called an RDD in Spark and a “Bag”
in Dask).  As described in detail in the section of this manual on
parallel processing, the model used by MsPASS assumes a processing function
to run in parallel applies the same function to every member of the dataset
defined by the RDD or Bag container.  The kill mechanism is a simple
mechanism to define data that should be considered no longer valid.   All
properly designed python functions in MsPASS automatically do nothing if
data are marked dead leaving the dead data as elements of the RDD/Bag.</p>
<p>A final point is that if a job is expected to kill a large fraction of data
there is a point where it becomes more efficient to clear the dataset of
dead data.   That needs to be done with some care if one wishes to preserve
error log entries that document why a datum was killed.   The
<code class="code docutils literal notranslate"><span class="pre">Undertaker</span></code> class, which described in the next section was designed
to handle such issues.</p>
</section>
<section id="undertaker">
<h2>Undertaker<a class="headerlink" href="#undertaker" title="Permalink to this heading"></a></h2>
<p>The class name is a programming joke, but the name is descriptive;  its jobs
is to deal with dead data.  The class is an extension of Database and has
three methods that are most useful for parallel jobs handling ensembles.</p>
<ol class="arabic simple">
<li><p>The <code class="code docutils literal notranslate"><span class="pre">bury_the_dead</span></code> method is the recommended method for many workflows
to clear dead data from ensembles.
It saves error logs and metadata for killed data
in the elog collection as a subdocument with the key “tombstone”.
It returns an edited version of the
ensemble with the dead data removed.</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">cremate</span></code> method is a variant of <code class="code docutils literal notranslate"><span class="pre">bury_the_dead</span></code>  It
also clears the dead data members from an ensemble and returns a clean
copy with he dead data removed.  We call it <code class="code docutils literal notranslate"><span class="pre">cremate</span></code> because
all traces of the data vanish; neither the error log or any identifiers
of the destroyed data will be retained.</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">bring_out_your_dead</span></code> method, other than being the best python programming
joke ever, is more specialized.  It returns two ensembles:  one with all the live and one
with all the dead data.  That approach can be used, for example, in
testing automatic editing code.  An interactive job to evaluate
how well the editing worked could use this method.</p></li>
</ol>
<p>The <code class="code docutils literal notranslate"><span class="pre">Undertaker</span></code> class only works on ensembles because clearing a
dead datum in a serial job makes little sense.   In all cases we know
the same functionality is achieved in a python script by conditionals to
test if the datum is marked live.  Furthermore, the user should recognize that
any call to the <code class="code docutils literal notranslate"><span class="pre">save_data</span></code> method will lead to a <code class="code docutils literal notranslate"><span class="pre">tombstone</span></code>
subdocument being written for all data marked dead.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="importing_data.html" class="btn btn-neutral float-left" title="Importing Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="data_editing.html" class="btn btn-neutral float-right" title="Data Editing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>