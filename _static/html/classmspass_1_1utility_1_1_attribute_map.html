<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::utility::AttributeMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>utility</b></li><li class="navelem"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmspass_1_1utility_1_1_attribute_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mspass::utility::AttributeMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An object to map internal and external attribute names.  
 <a href="classmspass_1_1utility_1_1_attribute_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_attribute_map_8h_source.html">AttributeMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3282c7d9e7472e1febde63658bcc5598"><td class="memItemLeft" align="right" valign="top"><a id="a3282c7d9e7472e1febde63658bcc5598"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a3282c7d9e7472e1febde63658bcc5598">AttributeMap</a> ()</td></tr>
<tr class="memdesc:a3282c7d9e7472e1febde63658bcc5598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. The default assumes the css3.0 schema and will load the name definitions defined for that schema. <br  />
 <br /></td></tr>
<tr class="separator:a3282c7d9e7472e1febde63658bcc5598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2233a03c6a1cdbbccc00720f81b5cca2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a2233a03c6a1cdbbccc00720f81b5cca2">AttributeMap</a> (const std::string tag)</td></tr>
<tr class="memdesc:a2233a03c6a1cdbbccc00720f81b5cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapping for a specified namespace tag (usually a schema name).  <a href="classmspass_1_1utility_1_1_attribute_map.html#a2233a03c6a1cdbbccc00720f81b5cca2">More...</a><br /></td></tr>
<tr class="separator:a2233a03c6a1cdbbccc00720f81b5cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214aa12322835675b7622c6b7f6d8ac4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a214aa12322835675b7622c6b7f6d8ac4">AttributeMap</a> (const <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp;am0)</td></tr>
<tr class="separator:a214aa12322835675b7622c6b7f6d8ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e3b521f85b0f7d011c38aafee191b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a402e3b521f85b0f7d011c38aafee191b">operator=</a> (const <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp;am0)</td></tr>
<tr class="separator:a402e3b521f85b0f7d011c38aafee191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b308d94ea4122dc3f90aae8ad950ac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a3b308d94ea4122dc3f90aae8ad950ac8">operator[]</a> (const std::string key) const</td></tr>
<tr class="separator:a3b308d94ea4122dc3f90aae8ad950ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f63cb8cd0d0836de3beeba798ead681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a2f63cb8cd0d0836de3beeba798ead681">operator[]</a> (const char *key) const</td></tr>
<tr class="separator:a2f63cb8cd0d0836de3beeba798ead681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1df686651e0e3d138f1a3d73bdda77"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#aeb1df686651e0e3d138f1a3d73bdda77">aliases</a> (const std::string key) const</td></tr>
<tr class="separator:aeb1df686651e0e3d138f1a3d73bdda77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317f95eb543fb740c3a4f72fcb8513b9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a317f95eb543fb740c3a4f72fcb8513b9">aliases</a> (const char *key) const</td></tr>
<tr class="separator:a317f95eb543fb740c3a4f72fcb8513b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7ec0194d2f25a916efd5f9d75f82ac"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a5b7ec0194d2f25a916efd5f9d75f82ac">aliastables</a> (const std::string key) const</td></tr>
<tr class="separator:a5b7ec0194d2f25a916efd5f9d75f82ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e3d5e3ef78ceb5d4d27491b185836"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#a4e0e3d5e3ef78ceb5d4d27491b185836">aliastables</a> (const char *key) const</td></tr>
<tr class="separator:a4e0e3d5e3ef78ceb5d4d27491b185836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60bebd12b9f3ca2aa5254c451b7bd1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#ad60bebd12b9f3ca2aa5254c451b7bd1e">is_alias</a> (const std::string key) const</td></tr>
<tr class="separator:ad60bebd12b9f3ca2aa5254c451b7bd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c8d949716c73c516a7cf9f83af8db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#aa3c8d949716c73c516a7cf9f83af8db1">is_alias</a> (const char *key) const</td></tr>
<tr class="separator:aa3c8d949716c73c516a7cf9f83af8db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa69adffd236ccf42ec87afdb34d7c419"><td class="memItemLeft" align="right" valign="top"><a id="aa69adffd236ccf42ec87afdb34d7c419"></a>
std::map&lt; std::string, <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a></td></tr>
<tr class="memdesc:aa69adffd236ccf42ec87afdb34d7c419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps internal to external names. This object is little more than a wrapper around this Standard Template library map container. The map is keyed by the internal name used to for a particular parameter. Each internal name known to the object will have an <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html" title="Defines properties of a database attribute and link to internal names.">AttributeProperties</a> associated with it through this map (same as an associative array for perl and tcl geeks). The user will need to be familiar with the STL map container to deal with this object correctly. I made an intentional design decision to not hide this beast behind the interface because the STL has become a standardized component of C++. I took the attitude that STL would outlast my interface definition and cost of hiding this was too high in computational burden. The key thing a user must know is the proper way to retrieve an element from a map and handle the possibility that the requested item is not known to the map. Consult the web or the source code for libMsPASS if you don't know how to do this. <br  />
 <br /></td></tr>
<tr class="separator:aa69adffd236ccf42ec87afdb34d7c419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object to map internal and external attribute names. </p>
<p>This object is used to link a set of internally defined parameters tagged with a name to an external name convention. The working model for external names is attribute names defined in a relational database schema, but the concept involved is more general. That is, the intent of this interface is a general way to between one set of parameter names and another. This could be used, for example, to map between header variable names in SEGY or SAC and some internal name convention. The relation of the map defined by this object is implicitly assumed to be one-to-one because of the use of the STL map to define the relationship. Because the map is keyed by the internal name lookup is also intended only for finding the external names associated with a particular internal parameter. The primary use of this object in the MsPASS library is to define a global mapping operator for a particular database schema. That is, the most common construct is to build this object early on using a call like: <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html" title="An object to map internal and external attribute names.">AttributeMap</a>("css3.0"). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2233a03c6a1cdbbccc00720f81b5cca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2233a03c6a1cdbbccc00720f81b5cca2">&#9670;&nbsp;</a></span>AttributeMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::AttributeMap::AttributeMap </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create mapping for a specified namespace tag (usually a schema name). </p>
<p>This is the normal constructor for this object. A one word tag is used to define a particular title to a namespace mapping. Normally this is a database schema name like css3.0 or Trace4.0, but the interface allows it to be anything. For example, although it isn't currently defined one could easily create a "SacHeader" definition that defined mapping between SAC header fields and an internal name convention. The interface simply assumes this keyword can be used to establish a mechanism for creating this beast through an unspecified mechanism. i.e. the interface is blind to the details and assumes what you want is to know how to map between A and B and someone else worried about the format for doing this already. In the current implementation we use an Antelope parameter file to create this object, but this interface does not depend upon that choice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>name tag used to define this map (usually a schema name). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214aa12322835675b7622c6b7f6d8ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214aa12322835675b7622c6b7f6d8ac4">&#9670;&nbsp;</a></span>AttributeMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::AttributeMap::AttributeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>am0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard copy constructor. </p>
<div class="fragment"><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;{</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a> = am.attributes;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    aliasmap=am.aliasmap;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_attribute_map_html_aa69adffd236ccf42ec87afdb34d7c419"><div class="ttname"><a href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">mspass::utility::AttributeMap::attributes</a></div><div class="ttdeci">std::map&lt; std::string, AttributeProperties &gt; attributes</div><div class="ttdoc">Maps internal to external names. This object is little more than a wrapper around this Standard Templ...</div><div class="ttdef"><b>Definition:</b> AttributeMap.h:116</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a317f95eb543fb740c3a4f72fcb8513b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317f95eb543fb740c3a4f72fcb8513b9">&#9670;&nbsp;</a></span>aliases() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> &gt; mspass::utility::AttributeMap::aliases </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload for literals. </p>
<div class="fragment"><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;{</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">return</span> this-&gt;<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#aeb1df686651e0e3d138f1a3d73bdda77">aliases</a>(<span class="keywordtype">string</span>(key));</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }<span class="keywordflow">catch</span>(...){<span class="keywordflow">throw</span>;};</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_attribute_map_html_aeb1df686651e0e3d138f1a3d73bdda77"><div class="ttname"><a href="classmspass_1_1utility_1_1_attribute_map.html#aeb1df686651e0e3d138f1a3d73bdda77">mspass::utility::AttributeMap::aliases</a></div><div class="ttdeci">std::map&lt; std::string, AttributeProperties &gt; aliases(const std::string key) const</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb1df686651e0e3d138f1a3d73bdda77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1df686651e0e3d138f1a3d73bdda77">&#9670;&nbsp;</a></span>aliases() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string,<a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a>&gt; mspass::utility::AttributeMap::aliases </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of aliases for a key.</p>
<p>A universal issue in a relational database interface is that an attribute can occur in more than one table. One can give a fully qualified name through this interface, but it is often convenient to have a simple name (the alias) that is a shorthand for a particular instance of that attribute in one table. Further, it is sometimes useful to have a list of possible meanings for an alias that can be searched in order. Thus this method returns a list of <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html" title="Defines properties of a database attribute and link to internal names.">AttributeProperties</a> that are tied to an alias. The idea would be that the caller would try each member of this list in order before throwing an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>is the alias name to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STL map of <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html" title="Defines properties of a database attribute and link to internal names.">AttributeProperties</a> that are aliases for the given keyword. The map is keyed by the table name. This provides a clean interface for output of attributes as it allows an output function to use an alias efficiently. The assumption in all cases is that the alias name provides the unique tag or an attribute. An application must avoid modifying attributes that are part of the alias definition. The alias name is the only one that should normally be assumed current. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html" title="Base class for error object thrown by MsPASS library routines.">MsPASSError</a></td><td>is thrown if an attribute listed in aliases is not defined for the <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html" title="An object to map internal and external attribute names.">AttributeMap</a> itself. This always indicates an error in the definition of the <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html" title="An object to map internal and external attribute names.">AttributeMap</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e0e3d5e3ef78ceb5d4d27491b185836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0e3d5e3ef78ceb5d4d27491b185836">&#9670;&nbsp;</a></span>aliastables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; string &gt; mspass::utility::AttributeMap::aliastables </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload for literals </p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;{</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        <span class="keywordflow">return</span> this-&gt;<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#a5b7ec0194d2f25a916efd5f9d75f82ac">aliastables</a>(<span class="keywordtype">string</span>(key));</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    }<span class="keywordflow">catch</span>(...){<span class="keywordflow">throw</span>;};</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_attribute_map_html_a5b7ec0194d2f25a916efd5f9d75f82ac"><div class="ttname"><a href="classmspass_1_1utility_1_1_attribute_map.html#a5b7ec0194d2f25a916efd5f9d75f82ac">mspass::utility::AttributeMap::aliastables</a></div><div class="ttdeci">std::list&lt; std::string &gt; aliastables(const std::string key) const</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b7ec0194d2f25a916efd5f9d75f82ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7ec0194d2f25a916efd5f9d75f82ac">&#9670;&nbsp;</a></span>aliastables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::string&gt; mspass::utility::AttributeMap::aliastables </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ordered list of table names to try in extracting an alias named.</p>
<p>Aliases present an issue on input. Because many attribute names appear in multiple tables (an essential thing, in fact, for a relational database to work) input of an attribute that is a generic label for such an attribute can be problematic. This method returns an ordered list of tables that provide guidance for extracting an attribute defined by such a generic name. The order is very important as readers will generally need to try qualfied names for each table in the list returned by this method. Hence the order matters and the list should be inclusive but no longer than necessary as long lists could generate some overead problems in some situations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the alias name for which this information is desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of table names in a recommended order of access. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html" title="Base class for error object thrown by MsPASS library routines.">MsPASSError</a></td><td>will be thrown if there are inconsistencies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3c8d949716c73c516a7cf9f83af8db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c8d949716c73c516a7cf9f83af8db1">&#9670;&nbsp;</a></span>is_alias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::AttributeMap::is_alias </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded for string literal. </p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;{</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#ad60bebd12b9f3ca2aa5254c451b7bd1e">is_alias</a>(<span class="keywordtype">string</span>(key));</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_attribute_map_html_ad60bebd12b9f3ca2aa5254c451b7bd1e"><div class="ttname"><a href="classmspass_1_1utility_1_1_attribute_map.html#ad60bebd12b9f3ca2aa5254c451b7bd1e">mspass::utility::AttributeMap::is_alias</a></div><div class="ttdeci">bool is_alias(const std::string key) const</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad60bebd12b9f3ca2aa5254c451b7bd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60bebd12b9f3ca2aa5254c451b7bd1e">&#9670;&nbsp;</a></span>is_alias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::AttributeMap::is_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if an attribute name is an alias.</p>
<p>For efficiency and convience it is useful to have a simple way to ask if an attribute name is defined as an alias. This abstracts this process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the attribute name to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key is an alias. Otherwise return false. </dd></dl>

</div>
</div>
<a id="a402e3b521f85b0f7d011c38aafee191b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402e3b521f85b0f7d011c38aafee191b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp; mspass::utility::AttributeMap::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html">AttributeMap</a> &amp;&#160;</td>
          <td class="paramname"><em>am0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard assignment operator. </p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;{</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">this</span>!=&amp;am)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a> = am.attributes;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        aliasmap=am.aliasmap;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keywordflow">return</span> (*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a>.</p>

</div>
</div>
<a id="a2f63cb8cd0d0836de3beeba798ead681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f63cb8cd0d0836de3beeba798ead681">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> mspass::utility::AttributeMap::operator[] </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded operator for C strings constants. </p>
<div class="fragment"><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;{</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordflow">return</span> this-&gt;<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#a3b308d94ea4122dc3f90aae8ad950ac8">operator[]</a>(<span class="keywordtype">string</span>(key));</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    }<span class="keywordflow">catch</span>(...){<span class="keywordflow">throw</span>;};</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_attribute_map_html_a3b308d94ea4122dc3f90aae8ad950ac8"><div class="ttname"><a href="classmspass_1_1utility_1_1_attribute_map.html#a3b308d94ea4122dc3f90aae8ad950ac8">mspass::utility::AttributeMap::operator[]</a></div><div class="ttdeci">AttributeProperties operator[](const std::string key) const</div><div class="ttdef"><b>Definition:</b> AttributeMap.cc:325</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b308d94ea4122dc3f90aae8ad950ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b308d94ea4122dc3f90aae8ad950ac8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html">AttributeProperties</a> mspass::utility::AttributeMap::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch attribute properties by internal name key.</p>
<p>This is the more conventional interface and the bombproof version to fetch <a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html" title="Defines properties of a database attribute and link to internal names.">AttributeProperties</a> using a specified key. It is safe because if the key does not match the map an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the internal name for which properties are requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmspass_1_1utility_1_1_attribute_properties.html" title="Defines properties of a database attribute and link to internal names.">AttributeProperties</a> that are defined for that name key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html" title="Base class for error object thrown by MsPASS library routines.">MsPASSError</a></td><td>thrown if the key is not found. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    map&lt;std::string,AttributeProperties&gt;::const_iterator amptr;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    amptr=<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a>.find(key);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordflow">if</span>(amptr==<a class="code" href="classmspass_1_1utility_1_1_attribute_map.html#aa69adffd236ccf42ec87afdb34d7c419">attributes</a>.end())</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(<span class="keywordtype">string</span>(<span class="stringliteral">&quot;AttributeMap::opertor[]: key=&quot;</span>)</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                + key + <span class="stringliteral">&quot; has not entry in this AttributeMap&quot;</span>);</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    }</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordflow">return</span> amptr-&gt;second;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_ms_p_a_s_s_error_html"><div class="ttname"><a href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">mspass::utility::MsPASSError</a></div><div class="ttdoc">Base class for error object thrown by MsPASS library routines.</div><div class="ttdef"><b>Definition:</b> MsPASSError.h:40</div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/utility/<a class="el" href="_attribute_map_8h_source.html">AttributeMap.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/utility/AttributeMap.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
