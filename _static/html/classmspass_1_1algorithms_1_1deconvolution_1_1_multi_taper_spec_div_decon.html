<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::algorithms::deconvolution::MultiTaperSpecDivDecon Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><b>deconvolution</b></li><li class="navelem"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html">MultiTaperSpecDivDecon</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mspass::algorithms::deconvolution::MultiTaperSpecDivDecon:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.png" usemap="#mspass::algorithms::deconvolution::MultiTaperSpecDivDecon_map" alt=""/>
  <map id="mspass::algorithms::deconvolution::MultiTaperSpecDivDecon_map" name="mspass::algorithms::deconvolution::MultiTaperSpecDivDecon_map">
<area href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html" title="Object to hold components needed in all fft based decon algorithms." alt="mspass::algorithms::deconvolution::FFTDeconOperator" shape="rect" coords="0,56,352,80"/>
<area href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html" title="Base class decon operator for single station 3C decon (receiver functions)." alt="mspass::algorithms::deconvolution::ScalarDecon" shape="rect" coords="362,56,714,80"/>
<area href="classmspass_1_1algorithms_1_1deconvolution_1_1_basic_decon_operator.html" alt="mspass::algorithms::deconvolution::BasicDeconOperator" shape="rect" coords="362,0,714,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dfef507037010412809c6362c20fd30" id="r_a3dfef507037010412809c6362c20fd30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a3dfef507037010412809c6362c20fd30">MultiTaperSpecDivDecon</a> ()</td></tr>
<tr class="separator:a3dfef507037010412809c6362c20fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff2b4201cbaa5f887440cf9055f94ab" id="r_a8ff2b4201cbaa5f887440cf9055f94ab"><td class="memItemLeft" align="right" valign="top"><a id="a8ff2b4201cbaa5f887440cf9055f94ab" name="a8ff2b4201cbaa5f887440cf9055f94ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MultiTaperSpecDivDecon</b> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md, const std::vector&lt; double &gt; &amp;noise, const std::vector&lt; double &gt; &amp;wavelet, const std::vector&lt; double &gt; &amp;data)</td></tr>
<tr class="separator:a8ff2b4201cbaa5f887440cf9055f94ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7259239fcbb029580aac2335d6d7019" id="r_ac7259239fcbb029580aac2335d6d7019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#ac7259239fcbb029580aac2335d6d7019">MultiTaperSpecDivDecon</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:ac7259239fcbb029580aac2335d6d7019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4641820fcc2f7cc515886f61477ca183" id="r_a4641820fcc2f7cc515886f61477ca183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a4641820fcc2f7cc515886f61477ca183">MultiTaperSpecDivDecon</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html">MultiTaperSpecDivDecon</a> &amp;parent)</td></tr>
<tr class="separator:a4641820fcc2f7cc515886f61477ca183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b91406f4bd73b8da5b6d66ac85930a" id="r_a86b91406f4bd73b8da5b6d66ac85930a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a86b91406f4bd73b8da5b6d66ac85930a">changeparameter</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:a86b91406f4bd73b8da5b6d66ac85930a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3dcbad2b532b15c6ac8403d5192774" id="r_a2a3dcbad2b532b15c6ac8403d5192774"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a2a3dcbad2b532b15c6ac8403d5192774">loadnoise</a> (const std::vector&lt; double &gt; &amp;noise)</td></tr>
<tr class="memdesc:a2a3dcbad2b532b15c6ac8403d5192774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a section of preevent noise.  <br /></td></tr>
<tr class="separator:a2a3dcbad2b532b15c6ac8403d5192774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aac5b64d95deaba2de7eadb1292d0c9" id="r_a8aac5b64d95deaba2de7eadb1292d0c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a8aac5b64d95deaba2de7eadb1292d0c9">load</a> (const std::vector&lt; double &gt; &amp;w, const std::vector&lt; double &gt; &amp;d, const std::vector&lt; double &gt; &amp;n)</td></tr>
<tr class="memdesc:a8aac5b64d95deaba2de7eadb1292d0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">load all data components.  <br /></td></tr>
<tr class="separator:a8aac5b64d95deaba2de7eadb1292d0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e2e07d1c536ea0b26e90d400ea120e" id="r_a99e2e07d1c536ea0b26e90d400ea120e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a99e2e07d1c536ea0b26e90d400ea120e">process</a> ()</td></tr>
<tr class="separator:a99e2e07d1c536ea0b26e90d400ea120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435c55ed82fb753b3a6d6874c90e7a59" id="r_a435c55ed82fb753b3a6d6874c90e7a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a435c55ed82fb753b3a6d6874c90e7a59">actual_output</a> ()</td></tr>
<tr class="separator:a435c55ed82fb753b3a6d6874c90e7a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d12e4f7a3c5cc21e7caad79eb4b6a60" id="r_a7d12e4f7a3c5cc21e7caad79eb4b6a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a7d12e4f7a3c5cc21e7caad79eb4b6a60">inverse_wavelet</a> (const double t0parent=0.0)</td></tr>
<tr class="memdesc:a7d12e4f7a3c5cc21e7caad79eb4b6a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a FIR respresentation of the inverse filter.  <br /></td></tr>
<tr class="separator:a7d12e4f7a3c5cc21e7caad79eb4b6a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737a908e543303d994adf292d5552dce" id="r_a737a908e543303d994adf292d5552dce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a737a908e543303d994adf292d5552dce">inverse_wavelet</a> ()</td></tr>
<tr class="memdesc:a737a908e543303d994adf292d5552dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return default FIR represesentation of the inverse filter.  <br /></td></tr>
<tr class="separator:a737a908e543303d994adf292d5552dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f24a2b7f65adaacc908e3486215e2a1" id="r_a8f24a2b7f65adaacc908e3486215e2a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a8f24a2b7f65adaacc908e3486215e2a1">all_inverse_wavelets</a> (const double t0parent=0.0)</td></tr>
<tr class="separator:a8f24a2b7f65adaacc908e3486215e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc2849e6de3afcb14caa685ec727ffe" id="r_a0cc2849e6de3afcb14caa685ec727ffe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a0cc2849e6de3afcb14caa685ec727ffe">all_rfestimates</a> (const double t0parent=0.0)</td></tr>
<tr class="separator:a0cc2849e6de3afcb14caa685ec727ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7fbfa50708b7d879fdc19c4f63d636" id="r_afa7fbfa50708b7d879fdc19c4f63d636"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#afa7fbfa50708b7d879fdc19c4f63d636">all_actual_outputs</a> (const double t0parent=0.0)</td></tr>
<tr class="separator:afa7fbfa50708b7d879fdc19c4f63d636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe73bf7bdbd568b1d2066942886aebbc" id="r_abe73bf7bdbd568b1d2066942886aebbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#abe73bf7bdbd568b1d2066942886aebbc">QCMetrics</a> ()</td></tr>
<tr class="memdesc:abe73bf7bdbd568b1d2066942886aebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return appropriate quality measures.  <br /></td></tr>
<tr class="separator:abe73bf7bdbd568b1d2066942886aebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bba98e4616d76ccc75dd850412d4eac" id="r_a3bba98e4616d76ccc75dd850412d4eac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a3bba98e4616d76ccc75dd850412d4eac">get_taperlen</a> ()</td></tr>
<tr class="separator:a3bba98e4616d76ccc75dd850412d4eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af164e41880aecea1a6304006b38f2bbb" id="r_af164e41880aecea1a6304006b38f2bbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#af164e41880aecea1a6304006b38f2bbb">get_number_tapers</a> ()</td></tr>
<tr class="separator:af164e41880aecea1a6304006b38f2bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a6ae86a30b0c0859231ec2fd41b67e" id="r_ae9a6ae86a30b0c0859231ec2fd41b67e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#ae9a6ae86a30b0c0859231ec2fd41b67e">get_time_bandwidth_product</a> ()</td></tr>
<tr class="separator:ae9a6ae86a30b0c0859231ec2fd41b67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html">mspass::algorithms::deconvolution::FFTDeconOperator</a></td></tr>
<tr class="memitem:a6851bec74d3f288eaf1de36cf1d7953b inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a6851bec74d3f288eaf1de36cf1d7953b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a6851bec74d3f288eaf1de36cf1d7953b">FFTDeconOperator</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:a6851bec74d3f288eaf1de36cf1d7953b inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3df395f4ff5bae8b891bee33f107e46 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_af3df395f4ff5bae8b891bee33f107e46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#af3df395f4ff5bae8b891bee33f107e46">FFTDeconOperator</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html">FFTDeconOperator</a> &amp;parent)</td></tr>
<tr class="separator:af3df395f4ff5bae8b891bee33f107e46 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1040f97ddf7bb7bd2c33ac9a7f99a79 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_ae1040f97ddf7bb7bd2c33ac9a7f99a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html">FFTDeconOperator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#ae1040f97ddf7bb7bd2c33ac9a7f99a79">operator=</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html">FFTDeconOperator</a> &amp;parent)</td></tr>
<tr class="separator:ae1040f97ddf7bb7bd2c33ac9a7f99a79 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce6831f67065f17fe7b30aa014eaaf3 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a0ce6831f67065f17fe7b30aa014eaaf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a0ce6831f67065f17fe7b30aa014eaaf3">changeparameter</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:a0ce6831f67065f17fe7b30aa014eaaf3 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaceb977e9797e483bf3a8ba030743c6 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_aeaceb977e9797e483bf3a8ba030743c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#aeaceb977e9797e483bf3a8ba030743c6">change_size</a> (const int nfft_new)</td></tr>
<tr class="separator:aeaceb977e9797e483bf3a8ba030743c6 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3f1776e68b20fff386d4bc19e51550 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a3d3f1776e68b20fff386d4bc19e51550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3d3f1776e68b20fff386d4bc19e51550">change_shift</a> (const int shift)</td></tr>
<tr class="separator:a3d3f1776e68b20fff386d4bc19e51550 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf21bce1d1519ece5e9879d03e7f7e5a inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_abf21bce1d1519ece5e9879d03e7f7e5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#abf21bce1d1519ece5e9879d03e7f7e5a">get_size</a> ()</td></tr>
<tr class="separator:abf21bce1d1519ece5e9879d03e7f7e5a inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63458bb8ad8a04a66de1c140152fc96 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_ad63458bb8ad8a04a66de1c140152fc96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#ad63458bb8ad8a04a66de1c140152fc96">get_shift</a> ()</td></tr>
<tr class="separator:ad63458bb8ad8a04a66de1c140152fc96 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494e951fb5fceffc545e411a8932d782 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a494e951fb5fceffc545e411a8932d782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a494e951fb5fceffc545e411a8932d782">operator_size</a> ()</td></tr>
<tr class="separator:a494e951fb5fceffc545e411a8932d782 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f399747b50f4f98f46b643f23af0ee1 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a6f399747b50f4f98f46b643f23af0ee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a6f399747b50f4f98f46b643f23af0ee1">operator_shift</a> ()</td></tr>
<tr class="separator:a6f399747b50f4f98f46b643f23af0ee1 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf84c339f3b540543ee8c3487997908a inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_adf84c339f3b540543ee8c3487997908a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#adf84c339f3b540543ee8c3487997908a">df</a> (const double dt)</td></tr>
<tr class="separator:adf84c339f3b540543ee8c3487997908a inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3473dc7f359332dbf5a685efe30a684b inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a3473dc7f359332dbf5a685efe30a684b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">FourierInverse</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_complex_array.html">ComplexArray</a> &amp;winv, const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_complex_array.html">ComplexArray</a> &amp;sw, const double dt, const double t0parent)</td></tr>
<tr class="memdesc:a3473dc7f359332dbf5a685efe30a684b inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return inverse wavelet for Fourier methods.  <br /></td></tr>
<tr class="separator:a3473dc7f359332dbf5a685efe30a684b inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">mspass::algorithms::deconvolution::ScalarDecon</a></td></tr>
<tr class="memitem:ab7e5ecd4bce2d9da9cb7724cf0c50690 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_ab7e5ecd4bce2d9da9cb7724cf0c50690"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#ab7e5ecd4bce2d9da9cb7724cf0c50690">ScalarDecon</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:ab7e5ecd4bce2d9da9cb7724cf0c50690 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e500a76366d00c1b1d6ebc03084668e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a5e500a76366d00c1b1d6ebc03084668e"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarDecon</b> (const std::vector&lt; double &gt; &amp;d, const std::vector&lt; double &gt; &amp;w)</td></tr>
<tr class="separator:a5e500a76366d00c1b1d6ebc03084668e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2488963949a1161f7a3b4f908a78807 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_ae2488963949a1161f7a3b4f908a78807"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#ae2488963949a1161f7a3b4f908a78807">ScalarDecon</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">ScalarDecon</a> &amp;parent)</td></tr>
<tr class="separator:ae2488963949a1161f7a3b4f908a78807 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9478e366652c54b4331e14b5a0eb85ea inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a9478e366652c54b4331e14b5a0eb85ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a9478e366652c54b4331e14b5a0eb85ea">load</a> (const std::vector&lt; double &gt; &amp;wavelet, const std::vector&lt; double &gt; &amp;data)</td></tr>
<tr class="memdesc:a9478e366652c54b4331e14b5a0eb85ea inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all data required for decon.  <br /></td></tr>
<tr class="separator:a9478e366652c54b4331e14b5a0eb85ea inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac358e4143a01c4f979f3f09e401b8e7c inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_ac358e4143a01c4f979f3f09e401b8e7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#ac358e4143a01c4f979f3f09e401b8e7c">loaddata</a> (const std::vector&lt; double &gt; &amp;data)</td></tr>
<tr class="separator:ac358e4143a01c4f979f3f09e401b8e7c inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb57cb76746708723cac9a860221f2e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_abfb57cb76746708723cac9a860221f2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#abfb57cb76746708723cac9a860221f2e">loadwavelet</a> (const std::vector&lt; double &gt; &amp;wavelet)</td></tr>
<tr class="separator:abfb57cb76746708723cac9a860221f2e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e82a9c95e7d55501e24e1cc95508f1 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a87e82a9c95e7d55501e24e1cc95508f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">ScalarDecon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a87e82a9c95e7d55501e24e1cc95508f1">operator=</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">ScalarDecon</a> &amp;parent)</td></tr>
<tr class="separator:a87e82a9c95e7d55501e24e1cc95508f1 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27885f8cd4880c643f09dbe636396a9 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_ae27885f8cd4880c643f09dbe636396a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#ae27885f8cd4880c643f09dbe636396a9">getresult</a> ()</td></tr>
<tr class="separator:ae27885f8cd4880c643f09dbe636396a9 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf90914fa1571e88978b0b810fad805 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a8cf90914fa1571e88978b0b810fad805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a8cf90914fa1571e88978b0b810fad805">changeparameter</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:a8cf90914fa1571e88978b0b810fad805 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a28202041cf426f01ef1e10032c744 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a94a28202041cf426f01ef1e10032c744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a94a28202041cf426f01ef1e10032c744">change_shaping_wavelet</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html">ShapingWavelet</a> &amp;nsw)</td></tr>
<tr class="separator:a94a28202041cf426f01ef1e10032c744 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051ad1d54899f0d64beb0249220c3405 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a051ad1d54899f0d64beb0249220c3405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html">ShapingWavelet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a051ad1d54899f0d64beb0249220c3405">get_shaping_wavelet</a> () const</td></tr>
<tr class="separator:a051ad1d54899f0d64beb0249220c3405 inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889e54f83b86f0bb0087ba3da18db14e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a889e54f83b86f0bb0087ba3da18db14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a889e54f83b86f0bb0087ba3da18db14e">ideal_output</a> ()</td></tr>
<tr class="separator:a889e54f83b86f0bb0087ba3da18db14e inherit pub_methods_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html">mspass::algorithms::deconvolution::FFTDeconOperator</a></td></tr>
<tr class="memitem:aa8619effc38e9e0f3927c73eb9b838f0 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_aa8619effc38e9e0f3927c73eb9b838f0"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>nfft</b></td></tr>
<tr class="separator:aa8619effc38e9e0f3927c73eb9b838f0 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7034bf16dcf7ea16563a7032ce19b08e inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a7034bf16dcf7ea16563a7032ce19b08e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>sample_shift</b></td></tr>
<tr class="separator:a7034bf16dcf7ea16563a7032ce19b08e inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3480b78a08228fc2b2c79809b98335d5 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a3480b78a08228fc2b2c79809b98335d5"><td class="memItemLeft" align="right" valign="top">
gsl_fft_complex_wavetable *&#160;</td><td class="memItemRight" valign="bottom"><b>wavetable</b></td></tr>
<tr class="separator:a3480b78a08228fc2b2c79809b98335d5 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121967f87437c76cfbb1d8a8fb592e8 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a1121967f87437c76cfbb1d8a8fb592e8"><td class="memItemLeft" align="right" valign="top">
gsl_fft_complex_workspace *&#160;</td><td class="memItemRight" valign="bottom"><b>workspace</b></td></tr>
<tr class="separator:a1121967f87437c76cfbb1d8a8fb592e8 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66026b54b517bc3797a1992ca332bc64 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator" id="r_a66026b54b517bc3797a1992ca332bc64"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_complex_array.html">ComplexArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>winv</b></td></tr>
<tr class="separator:a66026b54b517bc3797a1992ca332bc64 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">mspass::algorithms::deconvolution::ScalarDecon</a></td></tr>
<tr class="memitem:a3352f80170606ad4b543493a9168bc9d inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a3352f80170606ad4b543493a9168bc9d"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a3352f80170606ad4b543493a9168bc9d inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f2182a7e7b1c7d63011a9c53c4ee1 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_aa48f2182a7e7b1c7d63011a9c53c4ee1"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>wavelet</b></td></tr>
<tr class="separator:aa48f2182a7e7b1c7d63011a9c53c4ee1 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be7fa5b5fcf4928874f0e4c3c6a2022 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_a0be7fa5b5fcf4928874f0e4c3c6a2022"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:a0be7fa5b5fcf4928874f0e4c3c6a2022 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fe50f72e9cea048e1fa13061c26010 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon" id="r_ae0fe50f72e9cea048e1fa13061c26010"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html">ShapingWavelet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>shapingwavelet</b></td></tr>
<tr class="separator:ae0fe50f72e9cea048e1fa13061c26010 inherit pro_attribs_classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3dfef507037010412809c6362c20fd30" name="a3dfef507037010412809c6362c20fd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfef507037010412809c6362c20fd30">&#9670;&#160;</a></span>MultiTaperSpecDivDecon() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::MultiTaperSpecDivDecon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Do not use - only for declarations </p>
<div class="fragment"><div class="line"><span class="lineno">   19</span>: FFTDeconOperator(), ScalarDecon() {};</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7259239fcbb029580aac2335d6d7019" name="ac7259239fcbb029580aac2335d6d7019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7259239fcbb029580aac2335d6d7019">&#9670;&#160;</a></span>MultiTaperSpecDivDecon() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::MultiTaperSpecDivDecon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   20</span>    : FFTDeconOperator(md), ScalarDecon(md) {</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">   23</span>    this-&gt;read_metadata(md, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">   24</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">   25</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">   26</span>  };</div>
<div class="line"><span class="lineno">   27</span>  <span class="comment">/* assume tapers matrix is created in read_metadata.   We call reserve</span></div>
<div class="line"><span class="lineno">   28</span><span class="comment">  on the three stl vector containers for efficiency. */</span></div>
<div class="line"><span class="lineno">   29</span>  ScalarDecon::data.reserve(nfft);</div>
<div class="line"><span class="lineno">   30</span>  ScalarDecon::wavelet.reserve(nfft);</div>
<div class="line"><span class="lineno">   31</span>  noise.reserve(nfft);</div>
<div class="line"><span class="lineno">   32</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4641820fcc2f7cc515886f61477ca183" name="a4641820fcc2f7cc515886f61477ca183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4641820fcc2f7cc515886f61477ca183">&#9670;&#160;</a></span>MultiTaperSpecDivDecon() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::MultiTaperSpecDivDecon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html">MultiTaperSpecDivDecon</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   36</span>    : FFTDeconOperator(parent), ScalarDecon(parent), tapers(parent.tapers),</div>
<div class="line"><span class="lineno">   37</span>      noise(parent.noise), ao_fft(parent.ao_fft),</div>
<div class="line"><span class="lineno">   38</span>      rfestimates(parent.rfestimates), winv_taper(parent.winv_taper) {</div>
<div class="line"><span class="lineno">   39</span>  nw = parent.nw;</div>
<div class="line"><span class="lineno">   40</span>  nseq = parent.nseq;</div>
<div class="line"><span class="lineno">   41</span>  damp = parent.damp;</div>
<div class="line"><span class="lineno">   42</span>  taperlen = parent.taperlen;</div>
<div class="line"><span class="lineno">   43</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5d3fb34585431d671be19bef574f061" name="ab5d3fb34585431d671be19bef574f061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d3fb34585431d671be19bef574f061">&#9670;&#160;</a></span>~MultiTaperSpecDivDecon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::~MultiTaperSpecDivDecon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   26</span>{};</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a435c55ed82fb753b3a6d6874c90e7a59" name="a435c55ed82fb753b3a6d6874c90e7a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435c55ed82fb753b3a6d6874c90e7a59">&#9670;&#160;</a></span>actual_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::actual_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\brif Return the actual output of the deconvolution operator.</p>
<p>The actual output is defined as w^-1*w and is compable to resolution kernels in linear inverse theory. Although not required we would normally expect this function to be peaked at 0. Offsets from 0 would imply a bias. </p>

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a84f320ad48e8bfc9c292f8dde33c0593">mspass::algorithms::deconvolution::ScalarDecon</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  349</span>                                                     {</div>
<div class="line"><span class="lineno">  350</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  351</span>    <span class="keywordtype">int</span> i, k;</div>
<div class="line"><span class="lineno">  352</span>    vector&lt;double&gt; ao;</div>
<div class="line"><span class="lineno">  353</span>    ao.reserve(nfft);</div>
<div class="line"><span class="lineno">  354</span>    <span class="keywordflow">for</span> (k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  355</span>      ao.push_back(0.0);</div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  357</span>      ComplexArray work(ao_fft[i]);</div>
<div class="line"><span class="lineno">  358</span>      work = (*shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>()) * work;</div>
<div class="line"><span class="lineno">  359</span>      gsl_fft_complex_inverse(work.ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  360</span>      <span class="keywordflow">for</span> (k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  361</span>        ao[k] += work[k].real();</div>
<div class="line"><span class="lineno">  362</span>    }</div>
<div class="line"><span class="lineno">  363</span>    <span class="keywordtype">double</span> nrmscl = 1.0 / ((double)nseq);</div>
<div class="line"><span class="lineno">  364</span>    <span class="keywordflow">for</span> (k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  365</span>      ao[k] *= nrmscl;</div>
<div class="line"><span class="lineno">  366</span>    <span class="comment">/* We always shift this wavelet to the center of the data vector.</span></div>
<div class="line"><span class="lineno">  367</span><span class="comment">    We handle the time through the CoreTimeSeries object. */</span></div>
<div class="line"><span class="lineno">  368</span>    <span class="keywordtype">int</span> i0 = nfft / 2;</div>
<div class="line"><span class="lineno">  369</span>    ao = circular_shift(ao, i0);</div>
<div class="line"><span class="lineno">  370</span>    ao = normalize&lt;double&gt;(ao);</div>
<div class="line"><span class="lineno">  371</span>    CoreTimeSeries result(nfft);</div>
<div class="line"><span class="lineno">  372</span>    <span class="comment">/* Getting dt from here is unquestionably a flaw in the api, but will</span></div>
<div class="line"><span class="lineno">  373</span><span class="comment">    retain for now.   Perhaps should a copy of dt in the ScalarDecon object. */</span></div>
<div class="line"><span class="lineno">  374</span>    <span class="keywordtype">double</span> dt = this-&gt;shapingwavelet.sample_interval();</div>
<div class="line"><span class="lineno">  375</span>    <span class="comment">/* t0 is time of sample zero - hence normally negative*/</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="comment">/* Old API</span></div>
<div class="line"><span class="lineno">  377</span><span class="comment">    result.t0=dt*(-(double)i0);</span></div>
<div class="line"><span class="lineno">  378</span><span class="comment">    result.dt=dt;</span></div>
<div class="line"><span class="lineno">  379</span><span class="comment">    result.live=true;</span></div>
<div class="line"><span class="lineno">  380</span><span class="comment">    result.tref=TimeReferenceType::Relative;</span></div>
<div class="line"><span class="lineno">  381</span><span class="comment">    result.s=ao;</span></div>
<div class="line"><span class="lineno">  382</span><span class="comment">    result.ns=nfft;</span></div>
<div class="line"><span class="lineno">  383</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>    result.set_t0(dt * (-(<span class="keywordtype">double</span>)i0));</div>
<div class="line"><span class="lineno">  386</span>    result.set_dt(dt);</div>
<div class="line"><span class="lineno">  387</span>    result.set_live();</div>
<div class="line"><span class="lineno">  388</span>    result.set_npts(nfft);</div>
<div class="line"><span class="lineno">  389</span>    result.set_tref(TimeReferenceType::Relative);</div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">for</span> (k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  391</span>      result.s[k] = ao[k];</div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  393</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  395</span>  };</div>
<div class="line"><span class="lineno">  396</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet_html_ac922b603ff03a691075724bcd53e396f"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">mspass::algorithms::deconvolution::ShapingWavelet::wavelet</a></div><div class="ttdeci">ComplexArray * wavelet()</div><div class="ttdef"><b>Definition</b> ShapingWavelet.h:75</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">mspass::seismic::CoreTimeSeries::s</a>, <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#a97ff6732aa816b0c327c5bf667ffe841">mspass::seismic::CoreTimeSeries::set_dt()</a>, <a class="el" href="classmspass_1_1seismic_1_1_basic_time_series.html#a1ca7ba8bcd8337bd49d438664e74966d">mspass::seismic::BasicTimeSeries::set_live()</a>, <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#ae538485ac0aed2f8691477dffce6cda8">mspass::seismic::CoreTimeSeries::set_npts()</a>, <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#ae90b28cff0bc1997aa65a1693d8562d0">mspass::seismic::CoreTimeSeries::set_t0()</a>, and <a class="el" href="classmspass_1_1seismic_1_1_basic_time_series.html#ac3f8c8200710fe0d3ef211c7c758e864">mspass::seismic::BasicTimeSeries::set_tref()</a>.</p>

</div>
</div>
<a id="afa7fbfa50708b7d879fdc19c4f63d636" name="afa7fbfa50708b7d879fdc19c4f63d636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7fbfa50708b7d879fdc19c4f63d636">&#9670;&#160;</a></span>all_actual_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> &gt; mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::all_actual_outputs </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0parent</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ensemble of actual outputs </p>
<div class="fragment"><div class="line"><span class="lineno">  466</span>                                                                {</div>
<div class="line"><span class="lineno">  467</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  468</span>    std::vector&lt;CoreTimeSeries&gt; all;</div>
<div class="line"><span class="lineno">  469</span>    all.reserve(nseq);</div>
<div class="line"><span class="lineno">  470</span>    <span class="keywordtype">double</span> dt = this-&gt;shapingwavelet.sample_interval();</div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  472</span>      <span class="comment">/* Althought this method of FFTDeconOperator was originally</span></div>
<div class="line"><span class="lineno">  473</span><span class="comment">       * written to return inverse wavelet, it can work in this</span></div>
<div class="line"><span class="lineno">  474</span><span class="comment">       * contest too*/</span></div>
<div class="line"><span class="lineno">  475</span>      CoreTimeSeries work(this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">FFTDeconOperator::FourierInverse</a>(</div>
<div class="line"><span class="lineno">  476</span>          this-&gt;ao_fft[i], *shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>(), dt, t0parent));</div>
<div class="line"><span class="lineno">  477</span>      all.push_back(work);</div>
<div class="line"><span class="lineno">  478</span>    }</div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">return</span> all;</div>
<div class="line"><span class="lineno">  480</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  481</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  482</span>  };</div>
<div class="line"><span class="lineno">  483</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator_html_a3473dc7f359332dbf5a685efe30a684b"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">mspass::algorithms::deconvolution::FFTDeconOperator::FourierInverse</a></div><div class="ttdeci">mspass::seismic::CoreTimeSeries FourierInverse(const ComplexArray &amp;winv, const ComplexArray &amp;sw, const double dt, const double t0parent)</div><div class="ttdoc">Return inverse wavelet for Fourier methods.</div><div class="ttdef"><b>Definition</b> FFTDeconOperator.cc:115</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f24a2b7f65adaacc908e3486215e2a1" name="a8f24a2b7f65adaacc908e3486215e2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f24a2b7f65adaacc908e3486215e2a1">&#9670;&#160;</a></span>all_inverse_wavelets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> &gt; mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::all_inverse_wavelets </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0parent</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ensemble for number of tapers inverse wavelets. </p>
<div class="fragment"><div class="line"><span class="lineno">  431</span>                                                                  {</div>
<div class="line"><span class="lineno">  432</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  433</span>    std::vector&lt;CoreTimeSeries&gt; all;</div>
<div class="line"><span class="lineno">  434</span>    all.reserve(nseq);</div>
<div class="line"><span class="lineno">  435</span>    <span class="keywordtype">double</span> dt = this-&gt;shapingwavelet.sample_interval();</div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  437</span>      CoreTimeSeries work(this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">FFTDeconOperator::FourierInverse</a>(</div>
<div class="line"><span class="lineno">  438</span>          this-&gt;winv_taper[i], *shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>(), dt, t0parent));</div>
<div class="line"><span class="lineno">  439</span>      all.push_back(work);</div>
<div class="line"><span class="lineno">  440</span>    }</div>
<div class="line"><span class="lineno">  441</span>    <span class="keywordflow">return</span> all;</div>
<div class="line"><span class="lineno">  442</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  443</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  444</span>  };</div>
<div class="line"><span class="lineno">  445</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0cc2849e6de3afcb14caa685ec727ffe" name="a0cc2849e6de3afcb14caa685ec727ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc2849e6de3afcb14caa685ec727ffe">&#9670;&#160;</a></span>all_rfestimates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> &gt; mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::all_rfestimates </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0parent</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ensemble of rf estimates </p>
<div class="fragment"><div class="line"><span class="lineno">  447</span>                                                             {</div>
<div class="line"><span class="lineno">  448</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  449</span>    std::vector&lt;CoreTimeSeries&gt; all;</div>
<div class="line"><span class="lineno">  450</span>    all.reserve(nseq);</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordtype">double</span> dt = this-&gt;shapingwavelet.sample_interval();</div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  453</span>      <span class="comment">/* Althought this method of FFTDeconOperator was originally</span></div>
<div class="line"><span class="lineno">  454</span><span class="comment">       * written to return inverse wavelet, it can work in this</span></div>
<div class="line"><span class="lineno">  455</span><span class="comment">       * contest too*/</span></div>
<div class="line"><span class="lineno">  456</span>      CoreTimeSeries work(this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">FFTDeconOperator::FourierInverse</a>(</div>
<div class="line"><span class="lineno">  457</span>          this-&gt;rfestimates[i], *shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>(), dt, t0parent));</div>
<div class="line"><span class="lineno">  458</span>      all.push_back(work);</div>
<div class="line"><span class="lineno">  459</span>    }</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">return</span> all;</div>
<div class="line"><span class="lineno">  461</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  463</span>  };</div>
<div class="line"><span class="lineno">  464</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a86b91406f4bd73b8da5b6d66ac85930a" name="a86b91406f4bd73b8da5b6d66ac85930a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b91406f4bd73b8da5b6d66ac85930a">&#9670;&#160;</a></span>changeparameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::changeparameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_basic_decon_operator.html">mspass::algorithms::deconvolution::BasicDeconOperator</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   27</span>                                                        {</div>
<div class="line"><span class="lineno">   28</span>    this-&gt;read_metadata(md, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">   29</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<a id="af164e41880aecea1a6304006b38f2bbb" name="af164e41880aecea1a6304006b38f2bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af164e41880aecea1a6304006b38f2bbb">&#9670;&#160;</a></span>get_number_tapers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::get_number_tapers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  103</span>{ <span class="keywordflow">return</span> nseq; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bba98e4616d76ccc75dd850412d4eac" name="a3bba98e4616d76ccc75dd850412d4eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bba98e4616d76ccc75dd850412d4eac">&#9670;&#160;</a></span>get_taperlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::get_taperlen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  102</span>{ <span class="keywordflow">return</span> taperlen; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9a6ae86a30b0c0859231ec2fd41b67e" name="ae9a6ae86a30b0c0859231ec2fd41b67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a6ae86a30b0c0859231ec2fd41b67e">&#9670;&#160;</a></span>get_time_bandwidth_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::get_time_bandwidth_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  104</span>{ <span class="keywordflow">return</span> nw; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a737a908e543303d994adf292d5552dce" name="a737a908e543303d994adf292d5552dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737a908e543303d994adf292d5552dce">&#9670;&#160;</a></span>inverse_wavelet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::inverse_wavelet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return default FIR represesentation of the inverse filter. </p>
<p>This is an overloaded version of the parameterized method. It is equivalent to this-&gt;inverse_wavelet(0.0,0.0); </p>

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a078d038467a3be52d1e91e0d080d503e">mspass::algorithms::deconvolution::ScalarDecon</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  423</span>                                                       {</div>
<div class="line"><span class="lineno">  424</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  425</span>    <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a737a908e543303d994adf292d5552dce">inverse_wavelet</a>(0.0);</div>
<div class="line"><span class="lineno">  426</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  428</span>  };</div>
<div class="line"><span class="lineno">  429</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon_html_a737a908e543303d994adf292d5552dce"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a737a908e543303d994adf292d5552dce">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::inverse_wavelet</a></div><div class="ttdeci">mspass::seismic::CoreTimeSeries inverse_wavelet()</div><div class="ttdoc">Return default FIR represesentation of the inverse filter.</div><div class="ttdef"><b>Definition</b> MultiTaperSpecDivDecon.cc:423</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d12e4f7a3c5cc21e7caad79eb4b6a60" name="a7d12e4f7a3c5cc21e7caad79eb4b6a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d12e4f7a3c5cc21e7caad79eb4b6a60">&#9670;&#160;</a></span>inverse_wavelet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::inverse_wavelet </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0parent</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a FIR respresentation of the inverse filter. </p>
<p>An inverse filter has an impulse response. For some wavelets this can be respresented by a FIR filter with finite numbers of coefficients. Since this is a Fourier method the best we can do is return the inverse fft of the regularized operator. The output usually needs to be phase shifted to be most useful. For typical seismic source wavelets that are approximately minimum phase the shift can be small, but for zero phase input it should be approximately half the window size. This method also has an optional argument for t0parent. Because this processor was written to be agnostic about a time standard it implicitly assumes time 0 is sample 0 of the input waveforms. If the original data have a nonzero start time this should be passed as t0parent or the output will contain a time shift of t0parent. Note that tshift and t0parent do very different things. tshift is used to apply circular phase shift to the output (e.g. a shift of 10 samples causes the last 10 samples in the wavelet to be wrapped to the first 10 samples). t0parent only changes the time standard so the output has t0 -= parent.t0.</p>
<p>Output wavelet is always circular shifted with 0 lag at center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t0parent</td><td>- time zero of parent seismograms (see above). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">mspass::algorithms::deconvolution::ScalarDecon</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  398</span>                                                                            {</div>
<div class="line"><span class="lineno">  399</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  400</span>    <span class="comment">/* Getting dt from here is unquestionably a flaw in the api, but will</span></div>
<div class="line"><span class="lineno">  401</span><span class="comment">     *         retain for now.   Perhaps should a copy of dt in the ScalarDecon</span></div>
<div class="line"><span class="lineno">  402</span><span class="comment">     * object. */</span></div>
<div class="line"><span class="lineno">  403</span>    <span class="keywordtype">double</span> dt = this-&gt;shapingwavelet.sample_interval();</div>
<div class="line"><span class="lineno">  404</span>    <span class="comment">/*algorithm assumes this data vector in result is initialized to nfft zeos</span></div>
<div class="line"><span class="lineno">  405</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  406</span>    CoreTimeSeries result(this-&gt;nfft);</div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  408</span>      CoreTimeSeries work(this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_f_f_t_decon_operator.html#a3473dc7f359332dbf5a685efe30a684b">FFTDeconOperator::FourierInverse</a>(</div>
<div class="line"><span class="lineno">  409</span>          this-&gt;winv_taper[i], *shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>(), dt, t0parent));</div>
<div class="line"><span class="lineno">  410</span>      <span class="keywordflow">if</span> (i == 0)</div>
<div class="line"><span class="lineno">  411</span>        result = work;</div>
<div class="line"><span class="lineno">  412</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  413</span>        result += work;</div>
<div class="line"><span class="lineno">  414</span>    }</div>
<div class="line"><span class="lineno">  415</span>    <span class="keywordtype">double</span> nrmscal = 1.0 / ((double)nseq);</div>
<div class="line"><span class="lineno">  416</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; result.s.size(); ++k)</div>
<div class="line"><span class="lineno">  417</span>      result.s[k] *= nrmscal;</div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  419</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  420</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  421</span>  };</div>
<div class="line"><span class="lineno">  422</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">mspass::seismic::CoreTimeSeries::s</a>.</p>

</div>
</div>
<a id="a8aac5b64d95deaba2de7eadb1292d0c9" name="a8aac5b64d95deaba2de7eadb1292d0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aac5b64d95deaba2de7eadb1292d0c9">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::load </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load all data components. </p>
<p>This method should be called immediately befor process. It loads the wavelet and data to which teh deconvolution is to be applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>is expected to contain the wavelet data \paarm e is the data to be deconvolved with w. </td></tr>
    <tr><td class="paramname">n</td><td>is the vector of noise used for regularization in this method.. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  149</span>                                                          {</div>
<div class="line"><span class="lineno">  150</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordtype">int</span> lnr = this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a2a3dcbad2b532b15c6ac8403d5192774">loadnoise</a>(n);</div>
<div class="line"><span class="lineno">  152</span>    <span class="keywordtype">int</span> ldr;</div>
<div class="line"><span class="lineno">  153</span>    ldr = this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a9478e366652c54b4331e14b5a0eb85ea">ScalarDecon::load</a>(w, d);</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">return</span> (lnr + ldr);</div>
<div class="line"><span class="lineno">  155</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  157</span>  };</div>
<div class="line"><span class="lineno">  158</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon_html_a2a3dcbad2b532b15c6ac8403d5192774"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_multi_taper_spec_div_decon.html#a2a3dcbad2b532b15c6ac8403d5192774">mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::loadnoise</a></div><div class="ttdeci">int loadnoise(const std::vector&lt; double &gt; &amp;noise)</div><div class="ttdoc">Load a section of preevent noise.</div><div class="ttdef"><b>Definition</b> MultiTaperSpecDivDecon.cc:127</div></div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon_html_a9478e366652c54b4331e14b5a0eb85ea"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a9478e366652c54b4331e14b5a0eb85ea">mspass::algorithms::deconvolution::ScalarDecon::load</a></div><div class="ttdeci">int load(const std::vector&lt; double &gt; &amp;wavelet, const std::vector&lt; double &gt; &amp;data)</div><div class="ttdoc">Load all data required for decon.</div><div class="ttdef"><b>Definition</b> ScalarDecon.cc:33</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a3dcbad2b532b15c6ac8403d5192774" name="a2a3dcbad2b532b15c6ac8403d5192774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3dcbad2b532b15c6ac8403d5192774">&#9670;&#160;</a></span>loadnoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::loadnoise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>noise</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a section of preevent noise. </p>
<p>The multitaper algorithm requires a preevent noise it uses to compute a frequency dependent regularization. This method loads the noise data but does not initiate a computation. It should be called before calling the <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#a9478e366652c54b4331e14b5a0eb85ea" title="Load all data required for decon.">ScalarDecon::load</a> method which will initiate a computation of the result. </p>
<div class="fragment"><div class="line"><span class="lineno">  127</span>                                                             {</div>
<div class="line"><span class="lineno">  128</span>  <span class="comment">/* For this implementation we insist n be the same length</span></div>
<div class="line"><span class="lineno">  129</span><span class="comment">   * as d (assumed taperlen) to avoid constant recomputing slepians. */</span></div>
<div class="line"><span class="lineno">  130</span>  <span class="keywordflow">if</span> (n.size() == taperlen)</div>
<div class="line"><span class="lineno">  131</span>    noise = n;</div>
<div class="line"><span class="lineno">  132</span>  <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordtype">int</span> nn = n.size();</div>
<div class="line"><span class="lineno">  134</span>    <span class="keywordtype">int</span> k;</div>
<div class="line"><span class="lineno">  135</span>    noise.clear();</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">for</span> (k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  137</span>      noise.push_back(0.0);</div>
<div class="line"><span class="lineno">  138</span>    <span class="comment">/* This zero padds noise on right when input series length</span></div>
<div class="line"><span class="lineno">  139</span><span class="comment">     * is short.   If ns is long we always take the leading portion */</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">if</span> (nn &gt; taperlen)</div>
<div class="line"><span class="lineno">  141</span>      nn = taperlen;</div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">for</span> (k = 0; k &lt; nn; ++k)</div>
<div class="line"><span class="lineno">  143</span>      noise[k] = n[k];</div>
<div class="line"><span class="lineno">  144</span>  }</div>
<div class="line"><span class="lineno">  145</span>  <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  146</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99e2e07d1c536ea0b26e90d400ea120e" name="a99e2e07d1c536ea0b26e90d400ea120e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e2e07d1c536ea0b26e90d400ea120e">&#9670;&#160;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html">mspass::algorithms::deconvolution::ScalarDecon</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  202</span>                                     {</div>
<div class="line"><span class="lineno">  203</span>  <span class="keyword">const</span> <span class="keywordtype">string</span> base_error(<span class="stringliteral">&quot;MultiTaperSpecDivDecon::process():  &quot;</span>);</div>
<div class="line"><span class="lineno">  204</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  205</span>    <span class="comment">/* WARNING about this algorithm. At present there is nothing to stop</span></div>
<div class="line"><span class="lineno">  206</span><span class="comment">    a coding error of calling the algorithm with inconsistent signal and</span></div>
<div class="line"><span class="lineno">  207</span><span class="comment">    noise data vectors. */</span></div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordflow">if</span> (noise.size() &lt;= 0) {</div>
<div class="line"><span class="lineno">  209</span>      <span class="keywordflow">throw</span> MsPASSError(base_error + <span class="stringliteral">&quot;noise data is empty.&quot;</span>,</div>
<div class="line"><span class="lineno">  210</span>                        ErrorSeverity::Invalid);</div>
<div class="line"><span class="lineno">  211</span>    }</div>
<div class="line"><span class="lineno">  212</span> </div>
<div class="line"><span class="lineno">  213</span>    <span class="comment">/* The tapered data are stored in this vector of arrays */</span></div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordtype">int</span> i, j;</div>
<div class="line"><span class="lineno">  215</span>    vector&lt;ComplexArray&gt; tdata;</div>
<div class="line"><span class="lineno">  216</span>    tdata = taper_data(data);</div>
<div class="line"><span class="lineno">  217</span>    <span class="comment">/* Apply fft to each tapered data vector */</span></div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  219</span>      gsl_fft_complex_forward(tdata[i].ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  220</span>    }</div>
<div class="line"><span class="lineno">  221</span> </div>
<div class="line"><span class="lineno">  222</span>    <span class="comment">/* Now we need to do the same for the wavelet data */</span></div>
<div class="line"><span class="lineno">  223</span>    vector&lt;ComplexArray&gt; wdata;</div>
<div class="line"><span class="lineno">  224</span>    wdata = taper_data(wavelet);</div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  226</span>      gsl_fft_complex_forward(wdata[i].ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  227</span>    }</div>
<div class="line"><span class="lineno">  228</span>    <span class="comment">/* And the noise data - although with noise we quickly turn to power</span></div>
<div class="line"><span class="lineno">  229</span><span class="comment">     * spectrum */</span></div>
<div class="line"><span class="lineno">  230</span>    vector&lt;ComplexArray&gt; ndata;</div>
<div class="line"><span class="lineno">  231</span>    ndata = taper_data(noise);</div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  233</span>      gsl_fft_complex_forward(ndata[i].ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  234</span>    }</div>
<div class="line"><span class="lineno">  235</span>    vector&lt;double&gt; noise_spectrum(ndata[0].abs());</div>
<div class="line"><span class="lineno">  236</span>    <span class="keywordflow">for</span> (i = 1; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  237</span>      vector&lt;double&gt; nwork(ndata[i].abs());</div>
<div class="line"><span class="lineno">  238</span>      <span class="keywordflow">for</span> (j = 0; j &lt; noise_spectrum.size(); ++j) {</div>
<div class="line"><span class="lineno">  239</span>        noise_spectrum[j] += nwork[j];</div>
<div class="line"><span class="lineno">  240</span>      }</div>
<div class="line"><span class="lineno">  241</span>    }</div>
<div class="line"><span class="lineno">  242</span>    <span class="comment">/* normalize and add damping */</span></div>
<div class="line"><span class="lineno">  243</span>    vector&lt;double&gt;::iterator nptr;</div>
<div class="line"><span class="lineno">  244</span>    <span class="comment">/* This makes the scaling indepndent of the choise for tiem bandwidth</span></div>
<div class="line"><span class="lineno">  245</span><span class="comment">     * product*/</span></div>
<div class="line"><span class="lineno">  246</span>    <span class="keywordtype">double</span> scale = damp / (<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(nseq));</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">for</span> (nptr = noise_spectrum.begin(); nptr != noise_spectrum.end(); ++nptr) {</div>
<div class="line"><span class="lineno">  248</span>      (*nptr) *= scale;</div>
<div class="line"><span class="lineno">  249</span>    }</div>
<div class="line"><span class="lineno">  250</span>    <span class="comment">/* We compute a RF estimate for each taper independently usinga  variant of</span></div>
<div class="line"><span class="lineno">  251</span><span class="comment">    the water level method.  The variant is that the level is frequency</span></div>
<div class="line"><span class="lineno">  252</span><span class="comment">    dependent defined by sacled noise level.</span></div>
<div class="line"><span class="lineno">  253</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  254</span>    <span class="comment">/* We need this for amplitude scaling - depend on Parseval&#39;s theorem*/</span></div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordtype">double</span> wnrm = dnrm2(wavelet.size(), &amp;(wavelet[0]), 1);</div>
<div class="line"><span class="lineno">  256</span>    vector&lt;ComplexArray&gt; denominator;</div>
<div class="line"><span class="lineno">  257</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  258</span>      ComplexArray work(wdata[i]);</div>
<div class="line"><span class="lineno">  259</span>      <span class="comment">/* This is kind of messy as the noise_spectrum is a vector of real</span></div>
<div class="line"><span class="lineno">  260</span><span class="comment">      numbers while the wdata vector is a complex fft outputs in fortran</span></div>
<div class="line"><span class="lineno">  261</span><span class="comment">      style.  We use two different indices, but that is a tad dangerous</span></div>
<div class="line"><span class="lineno">  262</span><span class="comment">      UNLESS constructor guarantees nfft is ndata.size()*2 doubles*/</span></div>
<div class="line"><span class="lineno">  263</span>      <span class="keywordtype">int</span> number_regularized(0);</div>
<div class="line"><span class="lineno">  264</span>      <span class="keywordflow">for</span> (j = 0; j &lt; nfft; ++j) {</div>
<div class="line"><span class="lineno">  265</span>        <span class="comment">/* We do this with pointers.  It makes the code more obscure, but</span></div>
<div class="line"><span class="lineno">  266</span><span class="comment">        works efficiently.  Note this assumes the ComplexArray implementation</span></div>
<div class="line"><span class="lineno">  267</span><span class="comment">        uses FortranComplex64*/</span></div>
<div class="line"><span class="lineno">  268</span>        <span class="keywordtype">double</span> *z = work.ptr(j);</div>
<div class="line"><span class="lineno">  269</span>        <span class="keywordtype">double</span> re = (*z);</div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordtype">double</span> im = (*(z + 1));</div>
<div class="line"><span class="lineno">  271</span>        <span class="keywordtype">double</span> amp = sqrt(re * re + im * im);</div>
<div class="line"><span class="lineno">  272</span>        <span class="comment">/* this normalization assumes noise_spectrum is amplitude NOT</span></div>
<div class="line"><span class="lineno">  273</span><span class="comment">         * power spectrum values */</span></div>
<div class="line"><span class="lineno">  274</span>        <span class="keywordflow">if</span> (amp &lt; noise_spectrum[j]) {</div>
<div class="line"><span class="lineno">  275</span>          <span class="keywordtype">double</span> wlscal;</div>
<div class="line"><span class="lineno">  276</span>          <span class="comment">/* Avoid divide by zero if amp is tiny */</span></div>
<div class="line"><span class="lineno">  277</span>          <span class="keywordflow">if</span> (fabs(amp) / wnrm &lt; DBL_EPSILON) {</div>
<div class="line"><span class="lineno">  278</span>            (*z) = noise_spectrum[j];</div>
<div class="line"><span class="lineno">  279</span>            (*(z + 1)) = noise_spectrum[j];</div>
<div class="line"><span class="lineno">  280</span>          } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  281</span>            wlscal = noise_spectrum[j] / amp;</div>
<div class="line"><span class="lineno">  282</span>            (*z) *= wlscal;</div>
<div class="line"><span class="lineno">  283</span>            (*(z + 1)) *= wlscal;</div>
<div class="line"><span class="lineno">  284</span>          }</div>
<div class="line"><span class="lineno">  285</span>          ++number_regularized;</div>
<div class="line"><span class="lineno">  286</span>        }</div>
<div class="line"><span class="lineno">  287</span>      }</div>
<div class="line"><span class="lineno">  288</span>      denominator.push_back(work);</div>
<div class="line"><span class="lineno">  289</span>    }</div>
<div class="line"><span class="lineno">  290</span>    <span class="comment">/* Probably should save these in private area for this estimator*/</span></div>
<div class="line"><span class="lineno">  291</span>    <span class="comment">// vector&lt;ComplexArray&gt; rfestimates;</span></div>
<div class="line"><span class="lineno">  292</span>    <span class="comment">/* Must clear rfestimate and winv_taper containers or they accumulate */</span></div>
<div class="line"><span class="lineno">  293</span>    rfestimates.clear();</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  295</span>      ComplexArray work(tdata[i]);</div>
<div class="line"><span class="lineno">  296</span>      work = work / denominator[i];</div>
<div class="line"><span class="lineno">  297</span>      rfestimates.push_back(work);</div>
<div class="line"><span class="lineno">  298</span>    }</div>
<div class="line"><span class="lineno">  299</span>    <span class="comment">/* Now we want to compute the inverse filter.</span></div>
<div class="line"><span class="lineno">  300</span><span class="comment">    For consistency with related methods we&#39;ll store the frequency domain</span></div>
<div class="line"><span class="lineno">  301</span><span class="comment">    values, BUT these now become essentially a matrix - actually stored</span></div>
<div class="line"><span class="lineno">  302</span><span class="comment">    as a vector of vectors */</span></div>
<div class="line"><span class="lineno">  303</span>    winv_taper.clear();</div>
<div class="line"><span class="lineno">  304</span>    ao_fft.clear();</div>
<div class="line"><span class="lineno">  305</span>    <span class="keywordtype">double</span> *d0 = <span class="keyword">new</span> <span class="keywordtype">double</span>[nfft];</div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nfft; ++k)</div>
<div class="line"><span class="lineno">  307</span>      d0[k] = 0.0;</div>
<div class="line"><span class="lineno">  308</span>    d0[0] = 1.0;</div>
<div class="line"><span class="lineno">  309</span>    ComplexArray delta0(nfft, d0);</div>
<div class="line"><span class="lineno">  310</span>    <span class="keyword">delete</span>[] d0;</div>
<div class="line"><span class="lineno">  311</span>    gsl_fft_complex_forward(delta0.ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  313</span>      ComplexArray work(delta0);</div>
<div class="line"><span class="lineno">  314</span>      work = work / denominator[i];</div>
<div class="line"><span class="lineno">  315</span>      winv_taper.push_back(work);</div>
<div class="line"><span class="lineno">  316</span>    }</div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  318</span>      ComplexArray work(wdata[i]);</div>
<div class="line"><span class="lineno">  319</span>      work = work / denominator[i];</div>
<div class="line"><span class="lineno">  320</span>      ao_fft.push_back(work);</div>
<div class="line"><span class="lineno">  321</span>    }</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>    <span class="comment">/* To mesh with the API of other methods we now compute the average</span></div>
<div class="line"><span class="lineno">  324</span><span class="comment">    rf estimate.  We compute this as a simple average. */</span></div>
<div class="line"><span class="lineno">  325</span>    result.clear();</div>
<div class="line"><span class="lineno">  326</span>    <span class="keywordflow">for</span> (j = 0; j &lt; nfft; ++j)</div>
<div class="line"><span class="lineno">  327</span>      result.push_back(0.0);</div>
<div class="line"><span class="lineno">  328</span>    vector&lt;double&gt; wtmp;</div>
<div class="line"><span class="lineno">  329</span>    <span class="keywordflow">for</span> (i = 0; i &lt; nseq; ++i) {</div>
<div class="line"><span class="lineno">  330</span>      ComplexArray work(rfestimates[i]);</div>
<div class="line"><span class="lineno">  331</span>      <span class="comment">/* We always apply the shaping wavelet to the rf estimate.  We do it</span></div>
<div class="line"><span class="lineno">  332</span><span class="comment">      here before averaging. */</span></div>
<div class="line"><span class="lineno">  333</span>      work = (*shapingwavelet.<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_shaping_wavelet.html#ac922b603ff03a691075724bcd53e396f">wavelet</a>()) * work;</div>
<div class="line"><span class="lineno">  334</span>      gsl_fft_complex_inverse(work.ptr(), 1, nfft, wavetable, workspace);</div>
<div class="line"><span class="lineno">  335</span>      <span class="keywordflow">for</span> (j = 0; j &lt; nfft; ++j) {</div>
<div class="line"><span class="lineno">  336</span>        result[j] += work[j].real();</div>
<div class="line"><span class="lineno">  337</span>      }</div>
<div class="line"><span class="lineno">  338</span>    }</div>
<div class="line"><span class="lineno">  339</span>    <span class="keywordtype">double</span> nrmscl = 1.0 / ((double)nseq);</div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">for</span> (j = 0; j &lt; nfft; ++j)</div>
<div class="line"><span class="lineno">  341</span>      result[j] *= nrmscl;</div>
<div class="line"><span class="lineno">  342</span>    <span class="comment">/* Finally do a circular shift if requested. */</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">if</span> (sample_shift &gt; 0)</div>
<div class="line"><span class="lineno">  344</span>      result = circular_shift(result, -sample_shift);</div>
<div class="line"><span class="lineno">  345</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  346</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  347</span>  };</div>
<div class="line"><span class="lineno">  348</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abe73bf7bdbd568b1d2066942886aebbc" name="abe73bf7bdbd568b1d2066942886aebbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe73bf7bdbd568b1d2066942886aebbc">&#9670;&#160;</a></span>QCMetrics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> mspass::algorithms::deconvolution::MultiTaperSpecDivDecon::QCMetrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return appropriate quality measures. </p>
<p>Each operator commonly has different was to measure the quality of the result. This method should return these in a generic Metadata object. </p>

<p>Implements <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_scalar_decon.html#af683c2f25e91155c2bc1f81f9b62bbb1">mspass::algorithms::deconvolution::ScalarDecon</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  485</span>                                           {</div>
<div class="line"><span class="lineno">  486</span>  <span class="comment">/* Return only an empty Metadata container.  Done as it is</span></div>
<div class="line"><span class="lineno">  487</span><span class="comment">  easier to maintain the code letting python do this work.</span></div>
<div class="line"><span class="lineno">  488</span><span class="comment">  This also anticipates new metrics being added which would be</span></div>
<div class="line"><span class="lineno">  489</span><span class="comment">  easier in python.*/</span></div>
<div class="line"><span class="lineno">  490</span>  Metadata md;</div>
<div class="line"><span class="lineno">  491</span>  <span class="keywordflow">return</span> md;</div>
<div class="line"><span class="lineno">  492</span>}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/algorithms/deconvolution/<a class="el" href="_multi_taper_spec_div_decon_8h_source.html">MultiTaperSpecDivDecon.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/algorithms/deconvolution/<b>MultiTaperSpecDivDecon.cc</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
