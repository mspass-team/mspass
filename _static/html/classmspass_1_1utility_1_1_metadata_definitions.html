<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::utility::MetadataDefinitions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>utility</b></li><li class="navelem"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmspass_1_1utility_1_1_metadata_definitions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mspass::utility::MetadataDefinitions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Define properties of <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> known to mspass.  
 <a href="classmspass_1_1utility_1_1_metadata_definitions.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_metadata_definitions_8h_source.html">MetadataDefinitions.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5cca4385b19e235ff08215a6b731dc23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a5cca4385b19e235ff08215a6b731dc23">MetadataDefinitions</a> ()</td></tr>
<tr class="separator:a5cca4385b19e235ff08215a6b731dc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f1c50f29344550f6726996a60ac3d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#aa6f1c50f29344550f6726996a60ac3d7">MetadataDefinitions</a> (const std::string mdname)</td></tr>
<tr class="memdesc:aa6f1c50f29344550f6726996a60ac3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a namespace title.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#aa6f1c50f29344550f6726996a60ac3d7">More...</a><br /></td></tr>
<tr class="separator:aa6f1c50f29344550f6726996a60ac3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02457e4d234a24bbbbde8537963d339a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a02457e4d234a24bbbbde8537963d339a">MetadataDefinitions</a> (const std::string mdname, const mspass::utility::MDDefFormat form)</td></tr>
<tr class="memdesc:a02457e4d234a24bbbbde8537963d339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a file with variable formats.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a02457e4d234a24bbbbde8537963d339a">More...</a><br /></td></tr>
<tr class="separator:a02457e4d234a24bbbbde8537963d339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04131e10864ad00fb773a7dc83129bbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a04131e10864ad00fb773a7dc83129bbe">MetadataDefinitions</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;parent)</td></tr>
<tr class="separator:a04131e10864ad00fb773a7dc83129bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9c9a40eb60eebb24ec84f2fa961319"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#adf9c9a40eb60eebb24ec84f2fa961319">is_defined</a> (const std::string key) const noexcept</td></tr>
<tr class="separator:adf9c9a40eb60eebb24ec84f2fa961319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d131b51d99fb29753295847891ff2de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a5d131b51d99fb29753295847891ff2de">concept</a> (const std::string key) const</td></tr>
<tr class="separator:a5d131b51d99fb29753295847891ff2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8472df22024cde279e81c84e9129e4fd"><td class="memItemLeft" align="right" valign="top">mspass::utility::MDtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a8472df22024cde279e81c84e9129e4fd">type</a> (const std::string key) const</td></tr>
<tr class="separator:a8472df22024cde279e81c84e9129e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147efc8e0ed9c49d83ec78e4011ce4d1"><td class="memItemLeft" align="right" valign="top"><a id="a147efc8e0ed9c49d83ec78e4011ce4d1"></a>
std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keys</b> () const</td></tr>
<tr class="separator:a147efc8e0ed9c49d83ec78e4011ce4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555a85e15897c780964a7e4f7018dca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a555a85e15897c780964a7e4f7018dca6">add</a> (const std::string key, const std::string concept_, const MDtype mdt)</td></tr>
<tr class="separator:a555a85e15897c780964a7e4f7018dca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0debbe39d36bf46eb6ced6de89dc5bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a0debbe39d36bf46eb6ced6de89dc5bd1">has_alias</a> (const std::string key) const</td></tr>
<tr class="memdesc:a0debbe39d36bf46eb6ced6de89dc5bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods to handle aliases.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a0debbe39d36bf46eb6ced6de89dc5bd1">More...</a><br /></td></tr>
<tr class="separator:a0debbe39d36bf46eb6ced6de89dc5bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d73a129374c69d01c9cf23bf4157ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias</a> (const std::string key) const</td></tr>
<tr class="memdesc:a63d73a129374c69d01c9cf23bf4157ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask if a key is a registered alias.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">More...</a><br /></td></tr>
<tr class="separator:a63d73a129374c69d01c9cf23bf4157ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fde4797c14a07b55818a305ef544315"><td class="memItemLeft" align="right" valign="top"><a id="a8fde4797c14a07b55818a305ef544315"></a>
std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>aliases</b> (const std::string key) const</td></tr>
<tr class="separator:a8fde4797c14a07b55818a305ef544315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6f48e89b074e16112475d7d620e747"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, mspass::utility::MDtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a> (const std::string aliasname) const</td></tr>
<tr class="separator:a7f6f48e89b074e16112475d7d620e747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07447e104a6d689730d53c68a4c1f07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a07447e104a6d689730d53c68a4c1f07a">add_alias</a> (const std::string key, const std::string aliasname)</td></tr>
<tr class="separator:a07447e104a6d689730d53c68a4c1f07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9424f37c2535492b34061b8c06e88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a2dc9424f37c2535492b34061b8c06e88">writeable</a> (const std::string key) const</td></tr>
<tr class="separator:a2dc9424f37c2535492b34061b8c06e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86b8ddbe4917e7748698aad348d60ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#ac86b8ddbe4917e7748698aad348d60ec">readonly</a> (const std::string key) const</td></tr>
<tr class="separator:ac86b8ddbe4917e7748698aad348d60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434ba3fc278489639212ae2dbe46f3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a434ba3fc278489639212ae2dbe46f3d8">set_readonly</a> (const std::string key)</td></tr>
<tr class="memdesc:a434ba3fc278489639212ae2dbe46f3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a parameter to assure it will not be saved.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a434ba3fc278489639212ae2dbe46f3d8">More...</a><br /></td></tr>
<tr class="separator:a434ba3fc278489639212ae2dbe46f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e8edac3715cb830a9fe0487186cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a883e8edac3715cb830a9fe0487186cb6">set_writeable</a> (const std::string key)</td></tr>
<tr class="memdesc:a883e8edac3715cb830a9fe0487186cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a key:value pair to be writeable.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a883e8edac3715cb830a9fe0487186cb6">More...</a><br /></td></tr>
<tr class="separator:a883e8edac3715cb830a9fe0487186cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d61c6559d2d239631543b40de1d46d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#ae4d61c6559d2d239631543b40de1d46d">is_normalized</a> (const std::string key) const</td></tr>
<tr class="memdesc:ae4d61c6559d2d239631543b40de1d46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a key:value pair is set as normalized.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#ae4d61c6559d2d239631543b40de1d46d">More...</a><br /></td></tr>
<tr class="separator:ae4d61c6559d2d239631543b40de1d46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e9a750135d00f9ca1db95d3986f214"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a80e9a750135d00f9ca1db95d3986f214">unique_id_key</a> (const std::string key) const</td></tr>
<tr class="memdesc:a80e9a750135d00f9ca1db95d3986f214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique identifier for a normalized attribute.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a80e9a750135d00f9ca1db95d3986f214">More...</a><br /></td></tr>
<tr class="separator:a80e9a750135d00f9ca1db95d3986f214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18055de8c51df811e25d2784eb0db01"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#ad18055de8c51df811e25d2784eb0db01">collection</a> (const std::string key) const</td></tr>
<tr class="separator:ad18055de8c51df811e25d2784eb0db01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd20b79e7b66246e186deae88e391b94"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#acd20b79e7b66246e186deae88e391b94">normalize_data</a> (const std::string key) const</td></tr>
<tr class="memdesc:acd20b79e7b66246e186deae88e391b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special method for efficiency.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#acd20b79e7b66246e186deae88e391b94">More...</a><br /></td></tr>
<tr class="separator:acd20b79e7b66246e186deae88e391b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ac6dba59505eac6f2c9a627d89654"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a282ac6dba59505eac6f2c9a627d89654">apply_aliases</a> (<a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;d, const std::list&lt; std::string &gt; aliaslist)</td></tr>
<tr class="memdesc:a282ac6dba59505eac6f2c9a627d89654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a set of aliases to data.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a282ac6dba59505eac6f2c9a627d89654">More...</a><br /></td></tr>
<tr class="separator:a282ac6dba59505eac6f2c9a627d89654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0cfa4c13b688f301e261c0c404632e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a4f0cfa4c13b688f301e261c0c404632e">clear_aliases</a> (<a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;d)</td></tr>
<tr class="memdesc:a4f0cfa4c13b688f301e261c0c404632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore any aliases to unique names.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a4f0cfa4c13b688f301e261c0c404632e">More...</a><br /></td></tr>
<tr class="separator:a4f0cfa4c13b688f301e261c0c404632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7987fbfff442e9375c7363b1d3fcc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a2d7987fbfff442e9375c7363b1d3fcc1">operator=</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;other)</td></tr>
<tr class="separator:a2d7987fbfff442e9375c7363b1d3fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b80f9ce3024698504f06700d2d0cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a71b80f9ce3024698504f06700d2d0cd8">operator+=</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;other)</td></tr>
<tr class="memdesc:a71b80f9ce3024698504f06700d2d0cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate additional definitions.  <a href="classmspass_1_1utility_1_1_metadata_definitions.html#a71b80f9ce3024698504f06700d2d0cd8">More...</a><br /></td></tr>
<tr class="separator:a71b80f9ce3024698504f06700d2d0cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Define properties of <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> known to mspass. </p>
<p>The metadata system in mspass was designed to be infinitely flexible. However, to be maintainable and provide some stability we need a method to define the full properties of the keys that define attributes known to the system. This object does that through wwhat I hope is a simple interface. The expectation is the main use of this class is in python code that will read and write to mongo. Mongo is type sensitive but python tries hard to by loosy goosy about types. The main use is then expected that all gets and puts to <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> will be preceded by calls to the type method here. Based on the return the right get or put method can be called.</p>
<p>The overhead of creating this thing is not small. It will likely be recommended as an initialization step for most mspass processing scripts. Ultimately it perhaps should have a database constructor, but initially we will build it only from data file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5cca4385b19e235ff08215a6b731dc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cca4385b19e235ff08215a6b731dc23">&#9670;&nbsp;</a></span>MetadataDefinitions() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::MetadataDefinitions::MetadataDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Loads default schema name of mspass. </p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      <span class="keywordtype">string</span> datadir=mspass::utility::data_directory();</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      <span class="keywordtype">string</span> path;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;      path=datadir+<span class="stringliteral">&quot;/yaml/&quot;</span>+DefaultSchemaName+<span class="stringliteral">&quot;.yaml&quot;</span>;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> tmp(path,MDDefFormat::YAML);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      *<span class="keyword">this</span>=tmp;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }<span class="keywordflow">catch</span>(...){<span class="keywordflow">throw</span>;};</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html">mspass::utility::MetadataDefinitions</a></div><div class="ttdoc">Define properties of Metadata known to mspass.</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.h:31</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6f1c50f29344550f6726996a60ac3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f1c50f29344550f6726996a60ac3d7">&#9670;&nbsp;</a></span>MetadataDefinitions() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::MetadataDefinitions::MetadataDefinitions </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>mdname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a namespace title. </p>
<p>How this is to be implemented is to be determined, but for many uses a simple one line description of the name space for attributes would be a helpful api. At this time it is not implemented and attempts to use this will throw an exception. </p>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;      <span class="comment">/* silent try to recover if the user adds .yaml to mdname*/</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      std::size_t ipos;  <span class="comment">//size_t seems essential here for this to work -weird</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;      <span class="keywordtype">string</span> name_to_use;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      ipos=mdname.find(<span class="stringliteral">&quot;.yaml&quot;</span>);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      <span class="keywordflow">if</span>(ipos==std::string::npos)</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;      {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    name_to_use=mdname;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      }</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      <span class="comment">/* We throw an exception if the name is a path with / characters*/</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mdname.find(<span class="stringliteral">&quot;/&quot;</span>)!=std::string::npos)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;      {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(<span class="stringliteral">&quot;MetadataDefinitions:  name passed seems to be a full path name that is not allowed\nReceived this:  &quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        +mdname,ErrorSeverity::Invalid);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      }</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        name_to_use.assign(mdname,0,ipos);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      }</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      <span class="keywordtype">string</span> datadir=mspass::utility::data_directory();</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      <span class="keywordtype">string</span> path;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      path=datadir+<span class="stringliteral">&quot;/yaml/&quot;</span>+name_to_use+<span class="stringliteral">&quot;.yaml&quot;</span>;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      <a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> tmp(path,MDDefFormat::YAML);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;      *<span class="keyword">this</span>=tmp;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }<span class="keywordflow">catch</span>(...){<span class="keywordflow">throw</span>;};</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_ms_p_a_s_s_error_html"><div class="ttname"><a href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">mspass::utility::MsPASSError</a></div><div class="ttdoc">Base class for error object thrown by MsPASS library routines.</div><div class="ttdef"><b>Definition:</b> MsPASSError.h:40</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a02457e4d234a24bbbbde8537963d339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02457e4d234a24bbbbde8537963d339a">&#9670;&nbsp;</a></span>MetadataDefinitions() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::MetadataDefinitions::MetadataDefinitions </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>mdname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mspass::utility::MDDefFormat&#160;</td>
          <td class="paramname"><em>form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a file with variable formats. </p>
<p>This constructor reads from a file to build the object. The API allows multiple formats through the enum class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdname</td><td>is the file to read </td></tr>
    <tr><td class="paramname">form</td><td>defines the format (limited by MDDefFormat definitions) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04131e10864ad00fb773a7dc83129bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04131e10864ad00fb773a7dc83129bbe">&#9670;&nbsp;</a></span>MetadataDefinitions() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::MetadataDefinitions::MetadataDefinitions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard copy constructor. </p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  : tmap(parent.tmap),cmap(parent.cmap),</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  aliasmap(parent.aliasmap),</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  alias_xref(parent.alias_xref),roset(parent.roset),</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  unique_id_data(parent.unique_id_data)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a555a85e15897c780964a7e4f7018dca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555a85e15897c780964a7e4f7018dca6">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::MetadataDefinitions::add </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>concept_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MDtype&#160;</td>
          <td class="paramname"><em>mdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basic putter.</p>
<p>Use to add a new entry to the definitions. Note that because this is implemented with C++ map containers if data for the defined key is already present it will be silently replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the key for indexing this attribute </td></tr>
    <tr><td class="paramname">concept_</td><td>is brief description saved as the concept for this key </td></tr>
    <tr><td class="paramname">type</td><td>defines the type to be defined for this key. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;{</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  cmap[key]=concept_;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  tmap[key]=mdt;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07447e104a6d689730d53c68a4c1f07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07447e104a6d689730d53c68a4c1f07a">&#9670;&nbsp;</a></span>add_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::MetadataDefinitions::add_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>aliasname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an alias for key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the main key for which an alias is to be defined </td></tr>
    <tr><td class="paramname">aliasname</td><td>is the the alternative name to define. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;{</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">/* We could use operator[] but this is more bombproof if not as clear */</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  aliasmap.insert(std::pair&lt;string,string&gt;(key,aliasname));</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  alias_xref.insert(std::pair&lt;string,string&gt;(aliasname,key));</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a282ac6dba59505eac6f2c9a627d89654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282ac6dba59505eac6f2c9a627d89654">&#9670;&nbsp;</a></span>apply_aliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; string &gt; mspass::utility::MetadataDefinitions::apply_aliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>aliaslist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a set of aliases to data. </p>
<p>This method should be called in processing workflows to apply a series of defined aliases to data. The method uses the is_alias method to verify if an alias name is valid. It will not change the key if the name is not defined as a valid alias. The keys that fail that test will be posted to the std::list that is returned. Callers should test the size of the return and if it is not empty take appropriate action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is the data to alter (usually actually a TimeSeries of Seismogram) </td></tr>
    <tr><td class="paramname">aliaslist</td><td>is a list of aliases names to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::list of srings of failed changes. Callers should test the size of this return and take action if needed. </dd></dl>
<div class="fragment"><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;{</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;  list&lt;string&gt; failures;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  list&lt;string&gt;::const_iterator aptr;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  std::pair&lt;string,MDtype&gt; nmpair;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  <span class="keywordflow">for</span>(aptr=aliaslist.begin();aptr!=aliaslist.end();++aptr)</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias</a>(*aptr))</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    {</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;      nmpair=this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a>(*aptr);</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;      <span class="keywordtype">string</span> ukey=nmpair.first;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;      <span class="comment">/* Silently skip any aliases not defined.  That assures that if the</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">      name had already been changed to this alias it will be prserved. */</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;      <span class="keywordflow">if</span>(d.<a class="code" href="classmspass_1_1utility_1_1_metadata.html#a1e96e8682297fe8b21acf09b4d399cc6">is_defined</a>(ukey))</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;      {</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        d.<a class="code" href="classmspass_1_1utility_1_1_metadata.html#a20c1da469f6e0a073b291a680425f9e8">change_key</a>(ukey,*aptr);</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;      }</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    }</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      failures.push_back(*aptr);</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  }</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <span class="keywordflow">return</span> failures;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html_a63d73a129374c69d01c9cf23bf4157ed"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">mspass::utility::MetadataDefinitions::is_alias</a></div><div class="ttdeci">bool is_alias(const std::string key) const</div><div class="ttdoc">Ask if a key is a registered alias.</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.cc:168</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html_a7f6f48e89b074e16112475d7d620e747"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">mspass::utility::MetadataDefinitions::unique_name</a></div><div class="ttdeci">std::pair&lt; std::string, mspass::utility::MDtype &gt; unique_name(const std::string aliasname) const</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.cc:179</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_html_a1e96e8682297fe8b21acf09b4d399cc6"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata.html#a1e96e8682297fe8b21acf09b4d399cc6">mspass::utility::Metadata::is_defined</a></div><div class="ttdeci">bool is_defined(const std::string key) const noexcept</div><div class="ttdef"><b>Definition:</b> Metadata.cc:73</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_html_a20c1da469f6e0a073b291a680425f9e8"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata.html#a20c1da469f6e0a073b291a680425f9e8">mspass::utility::Metadata::change_key</a></div><div class="ttdeci">void change_key(const std::string oldkey, const std::string newkey)</div><div class="ttdoc">Change the keyword to access an attribute.</div><div class="ttdef"><b>Definition:</b> Metadata.cc:324</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata.html#a20c1da469f6e0a073b291a680425f9e8">mspass::utility::Metadata::change_key()</a>, <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias()</a>, <a class="el" href="classmspass_1_1utility_1_1_metadata.html#a1e96e8682297fe8b21acf09b4d399cc6">mspass::utility::Metadata::is_defined()</a>, and <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name()</a>.</p>

</div>
</div>
<a id="a4f0cfa4c13b688f301e261c0c404632e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0cfa4c13b688f301e261c0c404632e">&#9670;&nbsp;</a></span>clear_aliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::MetadataDefinitions::clear_aliases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore any aliases to unique names. </p>
<p>Aliases are needed to support legacy packages, but can cause downstream problem if left intact. This method clears any aliases and sets them to the unique_name defined by this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is data to be altered. Normally a Seismogram of TimeSeries but can be a raw <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmspass_1_1utility_1_1_error_logger.html" title="Container to hold error logs for a data object.">ErrorLogger</a> containing any problems encountered. This function always returns and treats any problems as nonfatal errors and posts a log entry into this returned object. Caller should test the size of the return and handle or ignore errors as appropriate. </dd></dl>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;{</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  std::set&lt;string&gt; keys;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  keys=d.<a class="code" href="classmspass_1_1utility_1_1_metadata.html#a52e2040555616a39b900aa0831c3bd10">keys</a>();</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  std::set&lt;string&gt;::iterator kptr;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  std::pair&lt;string,MDtype&gt; nmpair;</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="keywordflow">for</span> (kptr=keys.begin();kptr!=keys.end();++kptr)</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias</a>(*kptr))</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    {</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;      nmpair=this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a>(*kptr);</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;      <span class="keywordtype">string</span> ukey=nmpair.first;</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;      d.<a class="code" href="classmspass_1_1utility_1_1_metadata.html#a20c1da469f6e0a073b291a680425f9e8">change_key</a>(*kptr,ukey);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    }</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  }</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_html_a52e2040555616a39b900aa0831c3bd10"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata.html#a52e2040555616a39b900aa0831c3bd10">mspass::utility::Metadata::keys</a></div><div class="ttdeci">std::set&lt; std::string &gt; keys() const noexcept</div><div class="ttdef"><b>Definition:</b> Metadata.cc:140</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata.html#a20c1da469f6e0a073b291a680425f9e8">mspass::utility::Metadata::change_key()</a>, <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias()</a>, <a class="el" href="classmspass_1_1utility_1_1_metadata.html#a52e2040555616a39b900aa0831c3bd10">mspass::utility::Metadata::keys()</a>, and <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name()</a>.</p>

</div>
</div>
<a id="ad18055de8c51df811e25d2784eb0db01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18055de8c51df811e25d2784eb0db01">&#9670;&nbsp;</a></span>collection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::MetadataDefinitions::collection </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\Brief return the master collection (table) for a key used as a unique id.</p>
<p>Support for normalized <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> requires static tables (collection in MongoDB) that contain the data using normalization. In seismic data type examples are receiver location tables, receiver response tables, and source location data. This method should nearly always be paired with a call to unique_id_key. The idea is to first ask for the unique_id_key and then ask what collection (table) contains the key returned by unique_id_key. This provides a fast and convenient lookup for normalized data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the normally the return from unique_id_key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string defining the collection(table) the key can be used for locating the unique tuple/document required to access related <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a>. String will be empty if the search fails. </dd></dl>
<div class="fragment"><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;{</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  map&lt;string,tuple&lt;string,string&gt;&gt;::const_iterator uidptr;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  uidptr=unique_id_data.find(key);</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="keywordflow">if</span>(uidptr==unique_id_data.end())</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  {</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordflow">return</span> (<span class="keywordtype">string</span>(<span class="stringliteral">&quot;&quot;</span>));</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">return</span>(get&lt;0&gt;(uidptr-&gt;second));</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  }</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d131b51d99fb29753295847891ff2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d131b51d99fb29753295847891ff2de">&#9670;&nbsp;</a></span>concept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mspass::utility::MetadataDefinitions::concept </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a description of the concept this attribute defines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the name that defines the attribute of interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with a terse description of the concept this attribute defines. </dd></dl>
<div class="fragment"><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;{</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">string</span> base_error(<span class="stringliteral">&quot;MetadataDefinitions::concept:  &quot;</span>);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  map&lt;string,string&gt;::const_iterator cptr;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  cptr=cmap.find(key);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="keywordflow">if</span>(cptr==cmap.end())</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    stringstream ss;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    ss&lt;&lt;base_error&lt;&lt;<span class="stringliteral">&quot;no match for key=&quot;</span>&lt;&lt;key&lt;&lt;<span class="stringliteral">&quot; found&quot;</span>&lt;&lt;endl;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(ss.str(),ErrorSeverity::Invalid);</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordflow">return</span> cptr-&gt;second;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0debbe39d36bf46eb6ced6de89dc5bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0debbe39d36bf46eb6ced6de89dc5bd1">&#9670;&nbsp;</a></span>has_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::has_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methods to handle aliases. </p>
<p>Sometimes it is helpful to have alias keys to define a common concept. For instance, if an attribute is loaded from a ralational db one might want to use alias names of the form table.attribute as an alias to attribute. has_alias should be called first to establish if a name has an alias. To get a list of aliases call the aliases method. </p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;{</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  multimap&lt;string,string&gt;::const_iterator aptr;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  aptr=aliasmap.find(key);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="keywordflow">if</span>(aptr==aliasmap.end())</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a63d73a129374c69d01c9cf23bf4157ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d73a129374c69d01c9cf23bf4157ed">&#9670;&nbsp;</a></span>is_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::is_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask if a key is a registered alias. </p>
<p>This asks the inverse question to has_alias. That is, it yields true of the key is registered as a valid alias. It returns false if the key is not defined at all. Note it will yield false if the key is a registered unique name and not an alias. </p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;{</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  map&lt;string,string&gt;::const_iterator mptr;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  mptr=alias_xref.find(key);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordflow">if</span>(mptr==alias_xref.end())</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf9c9a40eb60eebb24ec84f2fa961319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9c9a40eb60eebb24ec84f2fa961319">&#9670;&nbsp;</a></span>is_defined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::is_defined </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a key is defined either as a unique key or an alias </p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">/* test type map because concept can be empty for a key */</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  map&lt;string,MDtype&gt;::const_iterator tptr;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  tptr=tmap.find(key);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="keywordflow">if</span>(tptr!=tmap.end())</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  }</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    pair&lt;string,MDtype&gt; unr;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">/* A bit weird to catch an exception as a way to test for a false, but</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">    the way the api currently is defined requires this. */</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      unr=this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a>(key);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }<span class="keywordflow">catch</span>(<a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>&amp; mderr)</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  }</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4d61c6559d2d239631543b40de1d46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d61c6559d2d239631543b40de1d46d">&#9670;&nbsp;</a></span>is_normalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::is_normalized </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a key:value pair is set as normalized. </p>
<p>In MongoDB a normalized attribute is one that has a master copy in one and only one place. This method returns true if an attribute is marked normalized and false otherwise (It will also return false for any key that is undefined.). </p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;{</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keywordflow">if</span>(unique_id_data.find(key)!=unique_id_data.end())</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd20b79e7b66246e186deae88e391b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd20b79e7b66246e186deae88e391b94">&#9670;&nbsp;</a></span>normalize_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; mspass::utility::MetadataDefinitions::normalize_data </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special method for efficiency. </p>
<p>For mspass using mongodb normalization for all currently supported <a class="el" href="classmspass_1_1utility_1_1_metadata.html">Metadata</a> can be reduced to a collection(table)-attribute name pair. The unique_id_key and collection methods can be called to obtained this information, but doing so requires a purely duplicate (internal map container) search. This convenience method is best used with MongoDB for efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the flat namespace key for which normalizing data is needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an std::pair with of strings with first=collection and second=attribute name. </dd></dl>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;{</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  map&lt;string,tuple&lt;string,string&gt;&gt;::const_iterator uidptr;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  uidptr=unique_id_data.find(key);</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <span class="keywordflow">if</span>(uidptr==unique_id_data.end())</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(<span class="stringliteral">&quot;MetadataDefinitions::normalize_data:  key=&quot;</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      + key + <span class="stringliteral">&quot; has no normalization data&quot;</span>);</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  }</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  {</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    pair&lt;string,string&gt; result;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    result.first=get&lt;0&gt;(uidptr-&gt;second);</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    result.second=get&lt;1&gt;(uidptr-&gt;second);</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71b80f9ce3024698504f06700d2d0cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b80f9ce3024698504f06700d2d0cd8">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp; mspass::utility::MetadataDefinitions::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate additional definitions. </p>
<p>Appends data in other to current. The behavior or this operator is not really a pure + operation as one would think of it as with arithmetic. Because the model is that we are defining the properties of unique keys handling the case where other has a duplicate key to the instance of the left hand side is ambiguous. We choose the more intuitive case where the right hand side overrides the left. i.e. if other has duplicate data for a key the right hand side version replaces the left. There are two exceptions. Aliases are multivalued so they accumulate. i.e. this mechanism can be used to do little more than add an alias if the others data are the same. The second case is more trivial and rarely of importance. That is, other can have empty concept data for a key and it will be silently set empty. The reason is concept is purely for human readers and is not expected to ever be used by processors. </p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;{</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="keywordflow">if</span>(<span class="keyword">this</span>==&amp;other) <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  list&lt;string&gt; kvals=other.keys();</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  list&lt;string&gt;::iterator kptr;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <span class="keywordflow">for</span>(kptr=kvals.begin();kptr!=kvals.end();++kptr)</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    MDtype mdt=other.<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a8472df22024cde279e81c84e9129e4fd">type</a>(*kptr);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="comment">/* Note this will silently overwrite previous if the key was already present*/</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    this-&gt;tmap[*kptr]=mdt;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      <span class="keywordtype">string</span> cother=other.<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a5d131b51d99fb29753295847891ff2de">concept</a>(*kptr);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;      this-&gt;cmap[*kptr]=cother;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    }<span class="keywordflow">catch</span>(<a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>&amp; merr)</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      <span class="comment">//Assume the only error here comes from concept methode failing</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      cerr &lt;&lt; <span class="stringliteral">&quot;MetadataDefinitions operator+= (Warning): concept description is missing for key=&quot;</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;         &lt;&lt;*kptr&lt;&lt;endl&lt;&lt;<span class="stringliteral">&quot;Error will be ignored&quot;</span>&lt;&lt;endl;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="comment">/* The alias_xref is a multimap so we just append other data - no such thing as duplicates*/</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    map&lt;string,string&gt;::const_iterator aptr;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">for</span>(aptr=other.alias_xref.begin();aptr!=other.alias_xref.end();++aptr)</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    {</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      this-&gt;alias_xref.insert(*aptr);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    }</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">/* These behave like the type map above - we silently replace any entry</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">    that was present before.  i.e. other overrides */</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    set&lt;string&gt;::const_iterator sptr;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keywordflow">for</span>(sptr=other.roset.begin();sptr!=roset.end();++sptr)</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      this-&gt;roset.insert(*sptr);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    }</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    map&lt;string,tuple&lt;string,string&gt;&gt;::const_iterator uptr;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">for</span>(uptr=other.unique_id_data.begin();uptr!=other.unique_id_data.end();++uptr)</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    {</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      this-&gt;unique_id_data.insert(*uptr);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html_a5d131b51d99fb29753295847891ff2de"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html#a5d131b51d99fb29753295847891ff2de">mspass::utility::MetadataDefinitions::concept</a></div><div class="ttdeci">std::string concept(const std::string key) const</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.cc:102</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html_a8472df22024cde279e81c84e9129e4fd"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html#a8472df22024cde279e81c84e9129e4fd">mspass::utility::MetadataDefinitions::type</a></div><div class="ttdeci">mspass::utility::MDtype type(const std::string key) const</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.cc:116</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a5d131b51d99fb29753295847891ff2de">concept()</a>, and <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a8472df22024cde279e81c84e9129e4fd">type()</a>.</p>

</div>
</div>
<a id="a2d7987fbfff442e9375c7363b1d3fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7987fbfff442e9375c7363b1d3fcc1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp; mspass::utility::MetadataDefinitions::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html">MetadataDefinitions</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard assignment operator. </p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;{</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="keywordflow">if</span>(<span class="keyword">this</span>!=&amp;parent)</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    tmap=parent.tmap;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    cmap=parent.cmap;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    aliasmap=parent.aliasmap;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    alias_xref=parent.alias_xref;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    roset=parent.roset;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    unique_id_data=parent.unique_id_data;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  }</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac86b8ddbe4917e7748698aad348d60ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86b8ddbe4917e7748698aad348d60ec">&#9670;&nbsp;</a></span>readonly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::readonly </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a key:value pair is marked readonly. Inverted logic of similar writeable method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is key used to access the parameter to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true of the data linked to this keys IS marked readonly. (if the key is undefined this method silently returns true) </dd></dl>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;{</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="keywordflow">return</span>( ! (this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a2dc9424f37c2535492b34061b8c06e88">writeable</a>(key)));</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_metadata_definitions_html_a2dc9424f37c2535492b34061b8c06e88"><div class="ttname"><a href="classmspass_1_1utility_1_1_metadata_definitions.html#a2dc9424f37c2535492b34061b8c06e88">mspass::utility::MetadataDefinitions::writeable</a></div><div class="ttdeci">bool writeable(const std::string key) const</div><div class="ttdef"><b>Definition:</b> MetadataDefinitions.cc:271</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a2dc9424f37c2535492b34061b8c06e88">writeable()</a>.</p>

</div>
</div>
<a id="a434ba3fc278489639212ae2dbe46f3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434ba3fc278489639212ae2dbe46f3d8">&#9670;&nbsp;</a></span>set_readonly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::MetadataDefinitions::set_readonly </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a parameter to assure it will not be saved. </p>
<p>Parameters can be defined readonly. That is a standard feature of this class, but is normally expected to be set on construction of the object. There are sometimes reason to lock out a parameter to keep it from being saved in output. This method allows this. On the other hand, use this feature only if you fully understand the downstream implications or you may experience unintended consequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the key for the attribute with properties to be redefined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;{</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">/* Silently return if key is already set as readonly */</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="keywordflow">if</span>(roset.find(key)==roset.end())</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    roset.insert(key);</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  }</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a883e8edac3715cb830a9fe0487186cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883e8edac3715cb830a9fe0487186cb6">&#9670;&nbsp;</a></span>set_writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::MetadataDefinitions::set_writeable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a key:value pair to be writeable. </p>
<p>Normally some parameters are marked readonly on construction to avoid corrupting the database with inconsistent data defined with a common key. (e.g. sta) This method overrides such definitions for any key so marked. It does nothing except a pointles search if the key hasn't been marked readonly previously. This method should be used with caution as it could have unintended side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is key for the attribute to be redefined. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;{</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  set&lt;string&gt;::const_iterator roptr;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  roptr=roset.find(key);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="comment">/* Here we silently do nothing if the key is not in roset */</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keywordflow">if</span>(roptr!=roset.end())</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    roset.erase(roptr);</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8472df22024cde279e81c84e9129e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8472df22024cde279e81c84e9129e4fd">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::MDtype mspass::utility::MetadataDefinitions::type </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of an attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the name that defines the attribute of interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MDtype enum that can be used to establish the proper type. </dd></dl>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;{</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">string</span> base_error(<span class="stringliteral">&quot;MetadataDefinitions::type:  &quot;</span>);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  map&lt;std::string,mspass::utility::MDtype&gt;::const_iterator tptr;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias</a>(key))</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">return</span> this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a>(key).second;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  tptr=tmap.find(key);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="keywordflow">if</span>(tptr==tmap.end())</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    stringstream ss;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    ss&lt;&lt;base_error&lt;&lt;<span class="stringliteral">&quot;no match for key=&quot;</span>&lt;&lt;key&lt;&lt;<span class="stringliteral">&quot; found&quot;</span>&lt;&lt;endl;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(ss.str(),ErrorSeverity::Invalid);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">return</span> tptr-&gt;second;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias()</a>, and <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name()</a>.</p>

</div>
</div>
<a id="a80e9a750135d00f9ca1db95d3986f214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e9a750135d00f9ca1db95d3986f214">&#9670;&nbsp;</a></span>unique_id_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::MetadataDefinitions::unique_id_key </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unique identifier for a normalized attribute. </p>
<p>In MongoDB a normalized attribute is one that has a master copy in one and only one place. This method returns a unique identifier, which defines a key that can be used to access the attribute used as an index to identify a unique location for an otherwise potentially ambiguous identifier (e.g. sta can be used in may contexts). The type of attribute to which the returned key is linked is expected to normally be acquired by am immediate call to the type method of this class using the return key. It is the callers responsibility to handle errors if the request for the type information fails. Note for MongoDB the most common (and recommended) type for the unique id is an Object_ID. The design of the API, however, should not preclude some other index or an index oriented toward a relational database. (e.g. chanid is an integer key with a one-to-one relation for channel data in the CSS3.0 schema.)</p>
<p>Some unique id specifications require a table/collection qualifier. See related collection method that is designed to handle that.</p>
<p>This method should normally be used only on read operations to select the correct entry for what could otherwise be a potentially ambiguous key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is the flat namespace key for which normalizing data is needed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name for unique id for requested key. Returns an empty string if the key is not defined as normalized. In multiple calls it is more efficient to test for a null return and handle such entries inline instead of a double search required if preceded by is_normalized. </dd></dl>
<div class="fragment"><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;{</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  map&lt;string,tuple&lt;string,string&gt;&gt;::const_iterator uidptr;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  uidptr=unique_id_data.find(key);</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160; </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  <span class="keywordflow">if</span>(uidptr!=unique_id_data.end())</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  {</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">return</span>(get&lt;1&gt;(uidptr-&gt;second));</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  }</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keywordflow">return</span> (<span class="keywordtype">string</span>(<span class="stringliteral">&quot;&quot;</span>));</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  }</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f6f48e89b074e16112475d7d620e747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6f48e89b074e16112475d7d620e747">&#9670;&nbsp;</a></span>unique_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, mspass::utility::MDtype &gt; mspass::utility::MetadataDefinitions::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>aliasname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get definitive name for an alias.</p>
<p>This method is used to ask the opposite question as aliases. The aliases method returns all acceptable alternatives to a definitive name defined as the key to get said list. This method asks what definitive key should be used to fetch an attribute and what it's type is. It does this by returning an std::pair with first being the key and second the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aliasname</td><td>is the name of the alias for which we want the definitive key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair with the definitive key as the first of the pair and the type in the second field. </dd></dl>
<div class="fragment"><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;{</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">string</span> base_error(<span class="stringliteral">&quot;MetadataDefinitions::unique_name:  &quot;</span>);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    map&lt;std::string,std::string&gt;::const_iterator aptr;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    aptr=alias_xref.find(aliasname);</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="keywordflow">if</span>(aptr==alias_xref.end())</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(base_error+<span class="stringliteral">&quot;alias name=&quot;</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;          + aliasname + <span class="stringliteral">&quot; is not defined&quot;</span>,ErrorSeverity::Invalid);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;      <span class="comment">/* We do not assume the key returned from alias_xref resolves. Small</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">      cost for a stability gain*/</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      <span class="keywordtype">string</span> kname=aptr-&gt;second;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      map&lt;std::string,MDtype&gt;::const_iterator tptr;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      tptr=tmap.find(kname);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      <span class="keywordflow">if</span>(tptr==tmap.end()) <span class="keywordflow">throw</span> <a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a>(base_error+<span class="stringliteral">&quot;alias name=&quot;</span>+aliasname</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        + <span class="stringliteral">&quot; has no matching entry in alias tables\n&quot;</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        + <span class="stringliteral">&quot;SETUP ERROR - FIX CONFIGURATION FILES&quot;</span>,</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        ErrorSeverity::Fatal);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      <span class="keywordflow">return</span>(pair&lt;std::string,mspass::utility::MDtype&gt;(kname,tptr-&gt;second));</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2dc9424f37c2535492b34061b8c06e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc9424f37c2535492b34061b8c06e88">&#9670;&nbsp;</a></span>writeable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::MetadataDefinitions::writeable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a key:value pair is mutable(writeable). Inverted logic from similar readonly method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>is key used to access the parameter to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data linked to this not not marked readonly. (if the key is undefined a false is silently returned) </dd></dl>
<div class="fragment"><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;{</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  set&lt;string&gt;::const_iterator roptr;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  roptr=roset.find(key);</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="keywordflow">if</span>(roptr==roset.end())</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias</a>(key))</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="comment">/* roset only contains unique key entries.  This checks any possible</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">    aliases. */</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    pair&lt;string,MDtype&gt; kp;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">/* unique_name method returns an exception if the key is not defined.</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">    We avoid that and silently return false if that happens, although</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment">    that situation will likely create downstream problems. */</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      kp=this-&gt;<a class="code" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name</a>(key);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    }<span class="keywordflow">catch</span>(<a class="code" href="classmspass_1_1utility_1_1_ms_p_a_s_s_error.html">MsPASSError</a> &amp;mderr)</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      cerr &lt;&lt; <span class="stringliteral">&quot;MetadataDefinitions::writeable method (WARNING):  Requested key &quot;</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;     &lt;&lt; key&lt;&lt;<span class="stringliteral">&quot; is undefined and is not a registered alias&quot;</span>&lt;&lt;endl</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;         &lt;&lt;<span class="stringliteral">&quot;This may cause downstream problems&quot;</span>&lt;&lt;endl;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    roptr=roset.find(kp.first);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordflow">if</span>(roptr==roset.end())</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">/* A bit confusing layout here.  We land here if the</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment">     * key was marked read only and was not an alias.  */</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  }</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a63d73a129374c69d01c9cf23bf4157ed">is_alias()</a>, and <a class="el" href="classmspass_1_1utility_1_1_metadata_definitions.html#a7f6f48e89b074e16112475d7d620e747">unique_name()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/utility/<a class="el" href="_metadata_definitions_8h_source.html">MetadataDefinitions.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/utility/MetadataDefinitions.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
