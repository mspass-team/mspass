<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::utility::ProcessingHistory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>utility</b></li><li class="navelem"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmspass_1_1utility_1_1_processing_history-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mspass::utility::ProcessingHistory Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lightweight class to preserve procesing chain of atomic objects.  
 <a href="classmspass_1_1utility_1_1_processing_history.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_processing_history_8h_source.html">ProcessingHistory.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mspass::utility::ProcessingHistory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmspass_1_1utility_1_1_processing_history.png" usemap="#mspass::utility::ProcessingHistory_map" alt=""/>
  <map id="mspass::utility::ProcessingHistory_map" name="mspass::utility::ProcessingHistory_map">
<area href="classmspass_1_1utility_1_1_basic_processing_history.html" alt="mspass::utility::BasicProcessingHistory" shape="rect" coords="119,0,347,24"/>
<area href="classmspass_1_1seismic_1_1_seismogram.html" title="Implemntation of Seismogram for MsPASS." alt="mspass::seismic::Seismogram" shape="rect" coords="0,112,228,136"/>
<area href="classmspass_1_1seismic_1_1_time_series.html" title="Implemntation of TimeSeries for MsPASS." alt="mspass::seismic::TimeSeries" shape="rect" coords="238,112,466,136"/>
<area href="classmspass_1_1seismic_1_1_seismogram_w_gaps.html" alt="mspass::seismic::SeismogramWGaps" shape="rect" coords="0,168,228,192"/>
<area href="classmspass_1_1seismic_1_1_time_series_w_gaps.html" alt="mspass::seismic::TimeSeriesWGaps" shape="rect" coords="238,168,466,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78c4def2e3503ba2fbdadf3c02b733a7" id="r_a78c4def2e3503ba2fbdadf3c02b733a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a78c4def2e3503ba2fbdadf3c02b733a7">ProcessingHistory</a> ()</td></tr>
<tr class="separator:a78c4def2e3503ba2fbdadf3c02b733a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e2e1941f342f3764c2c27854ad2f6" id="r_a225e2e1941f342f3764c2c27854ad2f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a225e2e1941f342f3764c2c27854ad2f6">ProcessingHistory</a> (const std::string jobnm, const std::string jid)</td></tr>
<tr class="separator:a225e2e1941f342f3764c2c27854ad2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dc3ba4e28743d0b13c105dc62428aa" id="r_a80dc3ba4e28743d0b13c105dc62428aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a80dc3ba4e28743d0b13c105dc62428aa">ProcessingHistory</a> (const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;parent)</td></tr>
<tr class="separator:a80dc3ba4e28743d0b13c105dc62428aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e42309bb4dfb0c0ea38496a3235f069" id="r_a8e42309bb4dfb0c0ea38496a3235f069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a> () const</td></tr>
<tr class="separator:a8e42309bb4dfb0c0ea38496a3235f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440cedfda00fd0b7211ed4673f09426e" id="r_a440cedfda00fd0b7211ed4673f09426e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a440cedfda00fd0b7211ed4673f09426e">is_raw</a> () const</td></tr>
<tr class="separator:a440cedfda00fd0b7211ed4673f09426e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477b2020ad7e3c753999e3906cd8eb58" id="r_a477b2020ad7e3c753999e3906cd8eb58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a477b2020ad7e3c753999e3906cd8eb58">is_origin</a> () const</td></tr>
<tr class="separator:a477b2020ad7e3c753999e3906cd8eb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd15514483fc2701e53ba1be8412e9" id="r_a8cfd15514483fc2701e53ba1be8412e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8cfd15514483fc2701e53ba1be8412e9">is_volatile</a> () const</td></tr>
<tr class="separator:a8cfd15514483fc2701e53ba1be8412e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cd2643171f354ded06e1a34681961d" id="r_a35cd2643171f354ded06e1a34681961d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a35cd2643171f354ded06e1a34681961d">is_saved</a> () const</td></tr>
<tr class="separator:a35cd2643171f354ded06e1a34681961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eaa592369744d85f54da21b8de9776" id="r_a04eaa592369744d85f54da21b8de9776"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a04eaa592369744d85f54da21b8de9776">number_of_stages</a> () override</td></tr>
<tr class="memdesc:a04eaa592369744d85f54da21b8de9776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of processing stages that have been applied to this object.  <br /></td></tr>
<tr class="separator:a04eaa592369744d85f54da21b8de9776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0621aa8adf8ebaab44a375a299c14fd8" id="r_a0621aa8adf8ebaab44a375a299c14fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a0621aa8adf8ebaab44a375a299c14fd8">set_as_origin</a> (const std::string alg, const std::string algid, const std::string uuid, const AtomicType typ, bool define_as_raw=false)</td></tr>
<tr class="separator:a0621aa8adf8ebaab44a375a299c14fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986da6a438099a371a0b0a9556f2c8b3" id="r_a986da6a438099a371a0b0a9556f2c8b3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a986da6a438099a371a0b0a9556f2c8b3">new_ensemble_process</a> (const std::string alg, const std::string algid, const AtomicType typ, const std::vector&lt; <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> * &gt; parents, const bool create_newid=true)</td></tr>
<tr class="separator:a986da6a438099a371a0b0a9556f2c8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf871538f6024bebc2b1512ba1e58ff7" id="r_abf871538f6024bebc2b1512ba1e58ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#abf871538f6024bebc2b1512ba1e58ff7">add_one_input</a> (const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;data_to_add)</td></tr>
<tr class="memdesc:abf871538f6024bebc2b1512ba1e58ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one datum as an input for current data.  <br /></td></tr>
<tr class="separator:abf871538f6024bebc2b1512ba1e58ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e046c02eb06959c3632c9157161b6" id="r_a667e046c02eb06959c3632c9157161b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a667e046c02eb06959c3632c9157161b6">add_many_inputs</a> (const std::vector&lt; <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> * &gt; &amp;d)</td></tr>
<tr class="memdesc:a667e046c02eb06959c3632c9157161b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define several data objects as inputs.  <br /></td></tr>
<tr class="separator:a667e046c02eb06959c3632c9157161b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2cb1d5af0500a526fa8745aa52db36" id="r_a4f2cb1d5af0500a526fa8745aa52db36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a4f2cb1d5af0500a526fa8745aa52db36">merge</a> (const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;data_to_add)</td></tr>
<tr class="memdesc:a4f2cb1d5af0500a526fa8745aa52db36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the history nodes from another.  <br /></td></tr>
<tr class="separator:a4f2cb1d5af0500a526fa8745aa52db36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc16a9d2c81e0fce08669573ffa8d741" id="r_afc16a9d2c81e0fce08669573ffa8d741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#afc16a9d2c81e0fce08669573ffa8d741">accumulate</a> (const std::string alg, const std::string algid, const AtomicType typ, const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;newinput)</td></tr>
<tr class="memdesc:afc16a9d2c81e0fce08669573ffa8d741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to use with a spark reduce algorithm.  <br /></td></tr>
<tr class="separator:afc16a9d2c81e0fce08669573ffa8d741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd32c36bbabff34fb51e382da69d83" id="r_afbcd32c36bbabff34fb51e382da69d83"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#afbcd32c36bbabff34fb51e382da69d83">clean_accumulate_uuids</a> ()</td></tr>
<tr class="memdesc:afbcd32c36bbabff34fb51e382da69d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up inconsistent uuids that can be produced by reduce.  <br /></td></tr>
<tr class="separator:afbcd32c36bbabff34fb51e382da69d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75af2861c06a905968cc9c727b8cc877" id="r_a75af2861c06a905968cc9c727b8cc877"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a75af2861c06a905968cc9c727b8cc877">new_map</a> (const std::string alg, const std::string algid, const AtomicType typ, const ProcessingStatus newstatus=ProcessingStatus::VOLATILE)</td></tr>
<tr class="memdesc:a75af2861c06a905968cc9c727b8cc877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define this algorithm as a one-to-one map of same type data.  <br /></td></tr>
<tr class="separator:a75af2861c06a905968cc9c727b8cc877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0225ef6ba03dc64ebb711bb54b1554d" id="r_ae0225ef6ba03dc64ebb711bb54b1554d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#ae0225ef6ba03dc64ebb711bb54b1554d">new_map</a> (const std::string alg, const std::string algid, const AtomicType typ, const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;data_to_clone, const ProcessingStatus newstatus=ProcessingStatus::VOLATILE)</td></tr>
<tr class="memdesc:ae0225ef6ba03dc64ebb711bb54b1554d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define this algorithm as a one-to-one map.  <br /></td></tr>
<tr class="separator:ae0225ef6ba03dc64ebb711bb54b1554d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5152d2f6a4706e635d6ca16e68b9bcc" id="r_ab5152d2f6a4706e635d6ca16e68b9bcc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#ab5152d2f6a4706e635d6ca16e68b9bcc">map_as_saved</a> (const std::string alg, const std::string algid, const AtomicType typ)</td></tr>
<tr class="memdesc:ab5152d2f6a4706e635d6ca16e68b9bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the current data for saving.  <br /></td></tr>
<tr class="separator:ab5152d2f6a4706e635d6ca16e68b9bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42865512c68a26b85b394825a1629729" id="r_a42865512c68a26b85b394825a1629729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">clear</a> ()</td></tr>
<tr class="separator:a42865512c68a26b85b394825a1629729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b0394b444f6db307945284ac6e5f8a" id="r_a52b0394b444f6db307945284ac6e5f8a"><td class="memItemLeft" align="right" valign="top">std::multimap&lt; std::string, <a class="el" href="classmspass_1_1utility_1_1_node_data.html">mspass::utility::NodeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes</a> () const</td></tr>
<tr class="separator:a52b0394b444f6db307945284ac6e5f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe65cff0547c9b75ea3ce9a7aa6b20f7" id="r_afe65cff0547c9b75ea3ce9a7aa6b20f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#afe65cff0547c9b75ea3ce9a7aa6b20f7">stage</a> () const</td></tr>
<tr class="separator:afe65cff0547c9b75ea3ce9a7aa6b20f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef35389afcd6d4305442a3720398a34" id="r_a1ef35389afcd6d4305442a3720398a34"><td class="memItemLeft" align="right" valign="top">ProcessingStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a1ef35389afcd6d4305442a3720398a34">status</a> () const</td></tr>
<tr class="separator:a1ef35389afcd6d4305442a3720398a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf60368ca5c699cc9186fa145d04376d" id="r_adf60368ca5c699cc9186fa145d04376d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">id</a> () const</td></tr>
<tr class="separator:adf60368ca5c699cc9186fa145d04376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89df41edb1ff1e92abd5a4f864c36673" id="r_a89df41edb1ff1e92abd5a4f864c36673"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a89df41edb1ff1e92abd5a4f864c36673">created_by</a> () const</td></tr>
<tr class="separator:a89df41edb1ff1e92abd5a4f864c36673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110c300dfa2a6f5236a7d254fa7bf663" id="r_a110c300dfa2a6f5236a7d254fa7bf663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_node_data.html">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata</a> () const</td></tr>
<tr class="separator:a110c300dfa2a6f5236a7d254fa7bf663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8bf8bc3632660c91fd9d82a79f8411" id="r_a9a8bf8bc3632660c91fd9d82a79f8411"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a> ()</td></tr>
<tr class="separator:a9a8bf8bc3632660c91fd9d82a79f8411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d681c60d2e64fab12b92e3244ce052" id="r_a82d681c60d2e64fab12b92e3244ce052"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a82d681c60d2e64fab12b92e3244ce052">number_inputs</a> () const</td></tr>
<tr class="separator:a82d681c60d2e64fab12b92e3244ce052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95006e7f8009c6d9a5c43d7e086c441b" id="r_a95006e7f8009c6d9a5c43d7e086c441b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a95006e7f8009c6d9a5c43d7e086c441b">number_inputs</a> (const std::string uuidstr) const</td></tr>
<tr class="separator:a95006e7f8009c6d9a5c43d7e086c441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec67690fe76c0d6c41dc096bc2f400ae" id="r_aec67690fe76c0d6c41dc096bc2f400ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#aec67690fe76c0d6c41dc096bc2f400ae">set_id</a> (const std::string <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a>)</td></tr>
<tr class="separator:aec67690fe76c0d6c41dc096bc2f400ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec695e46a390b9cf55f1919af803fb33" id="r_aec695e46a390b9cf55f1919af803fb33"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classmspass_1_1utility_1_1_node_data.html">mspass::utility::NodeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#aec695e46a390b9cf55f1919af803fb33">inputs</a> (const std::string id_to_find) const</td></tr>
<tr class="memdesc:aec695e46a390b9cf55f1919af803fb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of data that define the inputs to a give uuids.  <br /></td></tr>
<tr class="separator:aec695e46a390b9cf55f1919af803fb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6203063df0564c57f28d76f8d5969ac" id="r_ab6203063df0564c57f28d76f8d5969ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html#ab6203063df0564c57f28d76f8d5969ac">operator=</a> (const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;parent)</td></tr>
<tr class="separator:ab6203063df0564c57f28d76f8d5969ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmspass_1_1utility_1_1_basic_processing_history')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">mspass::utility::BasicProcessingHistory</a></td></tr>
<tr class="memitem:a8b077e34de9e1e0a25c24e781c1d235d inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_a8b077e34de9e1e0a25c24e781c1d235d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#a8b077e34de9e1e0a25c24e781c1d235d">BasicProcessingHistory</a> (const std::string jobname, const std::string jobid)</td></tr>
<tr class="separator:a8b077e34de9e1e0a25c24e781c1d235d inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db83159f5d5fd204c2a8d74a43649a inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_a50db83159f5d5fd204c2a8d74a43649a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#a50db83159f5d5fd204c2a8d74a43649a">BasicProcessingHistory</a> (const <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">BasicProcessingHistory</a> &amp;parent)</td></tr>
<tr class="separator:a50db83159f5d5fd204c2a8d74a43649a inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42047587403f5f37567a870f23554da6 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_a42047587403f5f37567a870f23554da6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#a42047587403f5f37567a870f23554da6">jobid</a> () const</td></tr>
<tr class="separator:a42047587403f5f37567a870f23554da6 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8702f0b485cea3357b92c9f0226023 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_abe8702f0b485cea3357b92c9f0226023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#abe8702f0b485cea3357b92c9f0226023">set_jobid</a> (const std::string &amp;newjid)</td></tr>
<tr class="separator:abe8702f0b485cea3357b92c9f0226023 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16963d48a18867fe480a276ac5d32844 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_a16963d48a18867fe480a276ac5d32844"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#a16963d48a18867fe480a276ac5d32844">jobname</a> () const</td></tr>
<tr class="separator:a16963d48a18867fe480a276ac5d32844 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7149734faa2c0b4d51fa8e317db27 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_af6c7149734faa2c0b4d51fa8e317db27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#af6c7149734faa2c0b4d51fa8e317db27">set_jobname</a> (const std::string jobname)</td></tr>
<tr class="separator:af6c7149734faa2c0b4d51fa8e317db27 inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b552f2657fdad975723d9fc73e7875a inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history" id="r_a4b552f2657fdad975723d9fc73e7875a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">BasicProcessingHistory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#a4b552f2657fdad975723d9fc73e7875a">operator=</a> (const <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">BasicProcessingHistory</a> &amp;parent)</td></tr>
<tr class="separator:a4b552f2657fdad975723d9fc73e7875a inherit pub_methods_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6e1075575bf136ef4639c6b45f9c5402" id="r_a6e1075575bf136ef4639c6b45f9c5402"><td class="memItemLeft" align="right" valign="top"><a id="a6e1075575bf136ef4639c6b45f9c5402" name="a6e1075575bf136ef4639c6b45f9c5402"></a>
<a class="el" href="classmspass_1_1utility_1_1_error_logger.html">ErrorLogger</a>&#160;</td><td class="memItemRight" valign="bottom"><b>elog</b></td></tr>
<tr class="separator:a6e1075575bf136ef4639c6b45f9c5402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad6acef2beb453d7034ab86087a3936aa" id="r_ad6acef2beb453d7034ab86087a3936aa"><td class="memItemLeft" align="right" valign="top"><a id="ad6acef2beb453d7034ab86087a3936aa" name="ad6acef2beb453d7034ab86087a3936aa"></a>
std::multimap&lt; std::string, <a class="el" href="classmspass_1_1utility_1_1_node_data.html">mspass::utility::NodeData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:ad6acef2beb453d7034ab86087a3936aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmspass_1_1utility_1_1_basic_processing_history"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmspass_1_1utility_1_1_basic_processing_history')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">mspass::utility::BasicProcessingHistory</a></td></tr>
<tr class="memitem:ac3ffa201ded102104675f2daccd379d9 inherit pro_attribs_classmspass_1_1utility_1_1_basic_processing_history" id="r_ac3ffa201ded102104675f2daccd379d9"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>jid</b></td></tr>
<tr class="separator:ac3ffa201ded102104675f2daccd379d9 inherit pro_attribs_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8756ffc6b2b0a3b068d2014c2f8a6c inherit pro_attribs_classmspass_1_1utility_1_1_basic_processing_history" id="r_a6d8756ffc6b2b0a3b068d2014c2f8a6c"><td class="memItemLeft" align="right" valign="top">
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>jnm</b></td></tr>
<tr class="separator:a6d8756ffc6b2b0a3b068d2014c2f8a6c inherit pro_attribs_classmspass_1_1utility_1_1_basic_processing_history"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lightweight class to preserve procesing chain of atomic objects. </p>
<p>This class is intended to be used as a parent for any data object in MsPASS that should be considered atomic. It is designed to completely preserve the chain of processing algorithms applied to any atomic data to put it in it's current state. It is designed to save that information during processing with the core information that can then be saved to define the state. Writers for atomic objects inheriting this class should arrange to save the data contained in it to history collection in MongoDB. Note that actually doing the inverse is a different problem that are expected to be implemented as extesions of this class to be used in special programs used to reconstrut a data workflow and the processing chain applied to produce any final output.</p>
<p>The design was complicated by the need to keep the history data from causing memory bloat. A careless implementation could be prone to that problem even for modest chains, but we were particularly worried about iterative algorithms that could conceivably multiply the size of out of control. There was also the fundamental problem of dealing with transient versus data stored in longer term storage instead of just in memory. Our implementation was simplified by using the concept of a unique id with a Universal Unique IDentifier. (UUID) Our history mechanism assumes each data object has a uuid assigned to it on creation by an implementation id of the one object this particular record is associated with on dependent mechanism. That is, whenever a new object is created in MsPASS using the history feature one of these records will be created for each data object that is defined as atomic. This string defines unique key for the object it could be connected to with the this pointer. The parents of the current object are defined by the inputs data structure below.</p>
<p>In the current implementation id is string representation of a uuid maintained by each atomic object. We use a string to maximize flexibility at a minor cost for storage.</p>
<p>Names used imply the following concepts: raw - means the data is new input to mspass (raw data from data center, field experiment, or simulation). That tag means no prior history can be reconstructed. origin - top-level ancestor of current data. The top of a processing chain is always tagged as an origin. A top level can also be "raw" but not necessarily. In particular, readers that load partially processed data should mark the data read as an origin, but not raw. stage - all processed data objects that are volatile elements within a workflow are defined as a stage. They are presumed to leave their existence known only through ancestory preserved in the processing chain. A stage becomes a potential root only when it is saved by a writer where the writer will mark that position as a save. Considered calling this a branch, but that doesn't capture the concept right since we require this mechanism to correctly perserve splits into multiple outputs. We preserve that cleanly for each data object. That is, the implementation make it easy to reconstruct the history of a single final data object, but reconstructing interlinks between objects in an overall processing flow will be a challenge. That was a necessary compomise to avoid memory bloat. The history is properly viewed as a tree branching from a single root (the final output) to leaves that define all it's parents.</p>
<p>The concepts of raw, origin, and stage are implemented with the enum class defined above called ProcessingStatus. Each history record has that as an attribute, but each call to new_stage updates a copy kept inside this object to simplify the python wrappers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a78c4def2e3503ba2fbdadf3c02b733a7" name="a78c4def2e3503ba2fbdadf3c02b733a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c4def2e3503ba2fbdadf3c02b733a7">&#9670;&#160;</a></span>ProcessingHistory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::ProcessingHistory::ProcessingHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>
<div class="fragment"><div class="line"><span class="lineno">   86</span>                                    :elog()</div>
<div class="line"><span class="lineno">   87</span>{</div>
<div class="line"><span class="lineno">   88</span>  current_status=ProcessingStatus::UNDEFINED;</div>
<div class="line"><span class="lineno">   89</span>  current_id=<span class="stringliteral">&quot;UNDEFINED&quot;</span>;</div>
<div class="line"><span class="lineno">   90</span>  current_stage=-1;  <span class="comment">//illegal value that could be used as signal for uninitalized</span></div>
<div class="line"><span class="lineno">   91</span>  mytype=AtomicType::UNDEFINED;</div>
<div class="line"><span class="lineno">   92</span>  algorithm=<span class="stringliteral">&quot;UNDEFINED&quot;</span>;</div>
<div class="line"><span class="lineno">   93</span>  algid=<span class="stringliteral">&quot;UNDEFINED&quot;</span>;</div>
<div class="line"><span class="lineno">   94</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a225e2e1941f342f3764c2c27854ad2f6" name="a225e2e1941f342f3764c2c27854ad2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e2e1941f342f3764c2c27854ad2f6">&#9670;&#160;</a></span>ProcessingHistory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::ProcessingHistory::ProcessingHistory </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>jobnm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>jid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct and fill in <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html">BasicProcessingHistory</a> job attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobnm</td><td>- set as jobname </td></tr>
    <tr><td class="paramname">jid</td><td>- set as jobid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80dc3ba4e28743d0b13c105dc62428aa" name="a80dc3ba4e28743d0b13c105dc62428aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dc3ba4e28743d0b13c105dc62428aa">&#9670;&#160;</a></span>ProcessingHistory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::utility::ProcessingHistory::ProcessingHistory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard copy constructor. </p>
<div class="fragment"><div class="line"><span class="lineno">  106</span>  : BasicProcessingHistory(parent),elog(parent.elog),nodes(parent.nodes),</div>
<div class="line"><span class="lineno">  107</span>      algorithm(parent.algorithm),algid(parent.algid)</div>
<div class="line"><span class="lineno">  108</span>{</div>
<div class="line"><span class="lineno">  109</span>  current_status=parent.current_status;</div>
<div class="line"><span class="lineno">  110</span>  current_id=parent.current_id;</div>
<div class="line"><span class="lineno">  111</span>  current_stage=parent.current_stage;</div>
<div class="line"><span class="lineno">  112</span>  mytype=parent.mytype;</div>
<div class="line"><span class="lineno">  113</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc16a9d2c81e0fce08669573ffa8d741" name="afc16a9d2c81e0fce08669573ffa8d741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc16a9d2c81e0fce08669573ffa8d741">&#9670;&#160;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::accumulate </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to use with a spark reduce algorithm. </p>
<p>A reduce operator in spark utilizes a binary function where two inputs are used to generate a single output object. Because the inputs could be scattered on multiple processor nodes this operation must be associative. The new_ensemble_process method does not satisfy that constraint so this method was necessary to handle that type of algorithm correctly.</p>
<p>The way this algorithm works is it fundamentally branches on two different cases: (1) initialization, which is detected by testing if the node data map is empty or (2) secondary calls. This should work even if multiple inputs are combined at the end of the reduce operation because the copies being merged will not be empty. Note an empty input will create a complaint entry in the error log. </p>
<div class="fragment"><div class="line"><span class="lineno">  511</span>{</div>
<div class="line"><span class="lineno">  512</span>  <a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a78c4def2e3503ba2fbdadf3c02b733a7">ProcessingHistory</a> newinput(ni);</div>
<div class="line"><span class="lineno">  513</span>  <span class="keywordflow">if</span>((newinput.algorithm != algin) || (newinput.algid != algidin)</div>
<div class="line"><span class="lineno">  514</span>    || (newinput.jid  != newinput.jobid()) || (newinput.jnm != newinput.jobname()))</div>
<div class="line"><span class="lineno">  515</span>  {</div>
<div class="line"><span class="lineno">  516</span>    NodeData nd;</div>
<div class="line"><span class="lineno">  517</span>    nd=newinput.current_nodedata();</div>
<div class="line"><span class="lineno">  518</span>    newinput.newid();</div>
<div class="line"><span class="lineno">  519</span>    pair&lt;string,NodeData&gt; pn(newinput.current_id,nd);</div>
<div class="line"><span class="lineno">  520</span>    newinput.nodes.insert(pn);</div>
<div class="line"><span class="lineno">  521</span>    newinput.jid=newinput.jobid();</div>
<div class="line"><span class="lineno">  522</span>    newinput.jnm=newinput.jobname();</div>
<div class="line"><span class="lineno">  523</span>    newinput.algorithm=algin;</div>
<div class="line"><span class="lineno">  524</span>    newinput.algid=algidin;</div>
<div class="line"><span class="lineno">  525</span>    newinput.current_status=ProcessingStatus::VOLATILE;</div>
<div class="line"><span class="lineno">  526</span>    newinput.current_stage=nd.stage+1;</div>
<div class="line"><span class="lineno">  527</span>    newinput.mytype=typ;</div>
<div class="line"><span class="lineno">  528</span>  }</div>
<div class="line"><span class="lineno">  529</span>  <span class="comment">/* We have to detect an initialization condition without losing the</span></div>
<div class="line"><span class="lineno">  530</span><span class="comment">  stored history.   There are two conditions we need to handle.  First,</span></div>
<div class="line"><span class="lineno">  531</span><span class="comment">  if we create an empty container to hold the accmulator and put it on the</span></div>
<div class="line"><span class="lineno">  532</span><span class="comment">  left hand side we will want to clear the history chain or we will</span></div>
<div class="line"><span class="lineno">  533</span><span class="comment">  accumulate random junk.   The second condition is if we accumulate in</span></div>
<div class="line"><span class="lineno">  534</span><span class="comment">  a way were the left hand side is some existing data where we do want to</span></div>
<div class="line"><span class="lineno">  535</span><span class="comment">  preserve the history.   For the is_empty logic:   we just copy the</span></div>
<div class="line"><span class="lineno">  536</span><span class="comment">  newinput&#39;s history and add make its current node data the connection</span></div>
<div class="line"><span class="lineno">  537</span><span class="comment">  backward - i.e. we have to make a new uuid and add an entry. */</span></div>
<div class="line"><span class="lineno">  538</span>  <span class="keywordflow">if</span>(this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a>())</div>
<div class="line"><span class="lineno">  539</span>  {</div>
<div class="line"><span class="lineno">  540</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a>();</div>
<div class="line"><span class="lineno">  541</span>    nodes=ni.get_nodes();</div>
<div class="line"><span class="lineno">  542</span>    NodeData nd;</div>
<div class="line"><span class="lineno">  543</span>    nd=ni.current_nodedata();</div>
<div class="line"><span class="lineno">  544</span>    pair&lt;string,NodeData&gt; pn(current_id,nd);</div>
<div class="line"><span class="lineno">  545</span>    this-&gt;nodes.insert(pn);</div>
<div class="line"><span class="lineno">  546</span>    this-&gt;set_jobid(ni.jobid());</div>
<div class="line"><span class="lineno">  547</span>    this-&gt;set_jobname(ni.jobname());</div>
<div class="line"><span class="lineno">  548</span>    algorithm=algin;</div>
<div class="line"><span class="lineno">  549</span>    algid=algidin;</div>
<div class="line"><span class="lineno">  550</span>    current_status=ProcessingStatus::VOLATILE;</div>
<div class="line"><span class="lineno">  551</span>    current_stage=nd.stage+1;</div>
<div class="line"><span class="lineno">  552</span>    mytype=typ;</div>
<div class="line"><span class="lineno">  553</span>  }</div>
<div class="line"><span class="lineno">  554</span>  <span class="comment">/* This is the condition for a left hand side that is not empty but not</span></div>
<div class="line"><span class="lineno">  555</span><span class="comment">  yet initialized.   We detect this condition by a mismatch in all the unique</span></div>
<div class="line"><span class="lineno">  556</span><span class="comment">  names and ids that mark the current process define this reduce operation*/</span></div>
<div class="line"><span class="lineno">  557</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span>((this-&gt;algorithm != algin) || (this-&gt;algid != algidin)</div>
<div class="line"><span class="lineno">  558</span>    || (this-&gt;jid  != newinput.jobid()) || (this-&gt;jnm != newinput.jobname()))</div>
<div class="line"><span class="lineno">  559</span>  {</div>
<div class="line"><span class="lineno">  560</span>    <span class="comment">/* This is similar to the block above, but the key difference here is we</span></div>
<div class="line"><span class="lineno">  561</span><span class="comment">    have to push this&#39;s history data to convert it&#39;s current data to define an input.</span></div>
<div class="line"><span class="lineno">  562</span><span class="comment">    That means getting a new uuid and pushing current node data to the nodes map</span></div>
<div class="line"><span class="lineno">  563</span><span class="comment">    as an input */</span></div>
<div class="line"><span class="lineno">  564</span>    NodeData nd;</div>
<div class="line"><span class="lineno">  565</span>    nd=this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata</a>();</div>
<div class="line"><span class="lineno">  566</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a>();</div>
<div class="line"><span class="lineno">  567</span>    pair&lt;string,NodeData&gt; pn(current_id,nd);</div>
<div class="line"><span class="lineno">  568</span>    this-&gt;nodes.insert(pn);</div>
<div class="line"><span class="lineno">  569</span>    this-&gt;jid=newinput.jobid();</div>
<div class="line"><span class="lineno">  570</span>    this-&gt;jnm=newinput.jobname();</div>
<div class="line"><span class="lineno">  571</span>    this-&gt;algorithm=algin;</div>
<div class="line"><span class="lineno">  572</span>    this-&gt;algid=algidin;</div>
<div class="line"><span class="lineno">  573</span>    this-&gt;current_status=ProcessingStatus::VOLATILE;</div>
<div class="line"><span class="lineno">  574</span>    this-&gt;current_stage=nd.stage+1;</div>
<div class="line"><span class="lineno">  575</span>    this-&gt;mytype=typ;</div>
<div class="line"><span class="lineno">  576</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a4f2cb1d5af0500a526fa8745aa52db36">merge</a>(newinput);</div>
<div class="line"><span class="lineno">  577</span>  }</div>
<div class="line"><span class="lineno">  578</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  579</span>  {</div>
<div class="line"><span class="lineno">  580</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a4f2cb1d5af0500a526fa8745aa52db36">merge</a>(newinput);</div>
<div class="line"><span class="lineno">  581</span>  }</div>
<div class="line"><span class="lineno">  582</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a110c300dfa2a6f5236a7d254fa7bf663"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">mspass::utility::ProcessingHistory::current_nodedata</a></div><div class="ttdeci">NodeData current_nodedata() const</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:712</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a4f2cb1d5af0500a526fa8745aa52db36"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a4f2cb1d5af0500a526fa8745aa52db36">mspass::utility::ProcessingHistory::merge</a></div><div class="ttdeci">void merge(const ProcessingHistory &amp;data_to_add)</div><div class="ttdoc">Merge the history nodes from another.</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:463</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a78c4def2e3503ba2fbdadf3c02b733a7"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a78c4def2e3503ba2fbdadf3c02b733a7">mspass::utility::ProcessingHistory::ProcessingHistory</a></div><div class="ttdeci">ProcessingHistory()</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:86</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a8e42309bb4dfb0c0ea38496a3235f069"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">mspass::utility::ProcessingHistory::is_empty</a></div><div class="ttdeci">bool is_empty() const</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:114</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a9a8bf8bc3632660c91fd9d82a79f8411"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">mspass::utility::ProcessingHistory::newid</a></div><div class="ttdeci">std::string newid()</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:700</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a4f2cb1d5af0500a526fa8745aa52db36">merge()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid()</a>, and <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a972bd00dc85cae2e490833225f53e282">mspass::utility::NodeData::stage</a>.</p>

</div>
</div>
<a id="a667e046c02eb06959c3632c9157161b6" name="a667e046c02eb06959c3632c9157161b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667e046c02eb06959c3632c9157161b6">&#9670;&#160;</a></span>add_many_inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::add_many_inputs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define several data objects as inputs. </p>
<p>This method acts like add_one_input in that it alters only the inputs chain. In fact it is nothing more than a loop over the components of the vector calling add_one_input for each component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is the vector of data to define as inputs </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  335</span>{</div>
<div class="line"><span class="lineno">  336</span>  vector&lt;ProcessingHistory*&gt;::const_iterator dptr;</div>
<div class="line"><span class="lineno">  337</span>  <span class="keywordflow">for</span>(dptr=d.begin();dptr!=d.end();++dptr)</div>
<div class="line"><span class="lineno">  338</span>  {</div>
<div class="line"><span class="lineno">  339</span>    <a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a78c4def2e3503ba2fbdadf3c02b733a7">ProcessingHistory</a> *ptr;</div>
<div class="line"><span class="lineno">  340</span>    ptr=(*dptr);</div>
<div class="line"><span class="lineno">  341</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#abf871538f6024bebc2b1512ba1e58ff7">add_one_input</a>(*ptr);</div>
<div class="line"><span class="lineno">  342</span>  }</div>
<div class="line"><span class="lineno">  343</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_abf871538f6024bebc2b1512ba1e58ff7"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#abf871538f6024bebc2b1512ba1e58ff7">mspass::utility::ProcessingHistory::add_one_input</a></div><div class="ttdeci">void add_one_input(const ProcessingHistory &amp;data_to_add)</div><div class="ttdoc">Add one datum as an input for current data.</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:285</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#abf871538f6024bebc2b1512ba1e58ff7">add_one_input()</a>.</p>

</div>
</div>
<a id="abf871538f6024bebc2b1512ba1e58ff7" name="abf871538f6024bebc2b1512ba1e58ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf871538f6024bebc2b1512ba1e58ff7">&#9670;&#160;</a></span>add_one_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::add_one_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>data_to_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add one datum as an input for current data. </p>
<p>This method MUST ONLY be called after a call to new_ensemble_process in the situation were additional inputs need to be defined that were not available at the time new_ensemble_process was called. An example might be a stack that was created within the scope of "algorithm" and then used in some way to create the output data. In any case it differs fundamentally from new_ensemble_process in that it does not touch attributes that define the current state of "this". It simply says this is another input to the data "this" contains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_to_add</td><td>is the <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> of the data object to be defined as input. Note the type of the data to which it is linked will be saved as the base of the input chain from data_to_add. It can be different from the type of "this". </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  286</span>{</div>
<div class="line"><span class="lineno">  287</span> </div>
<div class="line"><span class="lineno">  288</span>  <span class="keywordflow">if</span>(data_to_add.is_empty())</div>
<div class="line"><span class="lineno">  289</span>  {</div>
<div class="line"><span class="lineno">  290</span>    stringstream ss;</div>
<div class="line"><span class="lineno">  291</span>    ss&lt;&lt;<span class="stringliteral">&quot;Data with uuid=&quot;</span>&lt;&lt;data_to_add.id()&lt;&lt;<span class="stringliteral">&quot; has an empty history chain&quot;</span>&lt;&lt;endl</div>
<div class="line"><span class="lineno">  292</span>      &lt;&lt; <span class="stringliteral">&quot;At best this will leave ProcessingHistory incomplete&quot;</span>&lt;&lt;endl;</div>
<div class="line"><span class="lineno">  293</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::add_one_input&quot;</span>,ss.str(),</div>
<div class="line"><span class="lineno">  294</span>      ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  295</span>  }</div>
<div class="line"><span class="lineno">  296</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  297</span>  {</div>
<div class="line"><span class="lineno">  298</span>    multimap&lt;string,NodeData&gt;::iterator nptr;</div>
<div class="line"><span class="lineno">  299</span>    multimap&lt;string,NodeData&gt; newhistory = data_to_add.get_nodes();</div>
<div class="line"><span class="lineno">  300</span>    multimap&lt;string,NodeData&gt;::iterator nl,nu;</div>
<div class="line"><span class="lineno">  301</span>    <span class="comment">/* As above this one needs check for duplicates and only add</span></div>
<div class="line"><span class="lineno">  302</span><span class="comment">    a node if the data are unique.  This is simple compared to new_ensemble_process</span></div>
<div class="line"><span class="lineno">  303</span><span class="comment">    because we just have to check one object&#39;s history at a time. */</span></div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">for</span>(nptr=newhistory.begin();nptr!=newhistory.end();++nptr)</div>
<div class="line"><span class="lineno">  305</span>    {</div>
<div class="line"><span class="lineno">  306</span>      <span class="keywordtype">string</span> key(nptr-&gt;first);</div>
<div class="line"><span class="lineno">  307</span>      <span class="keywordflow">if</span>(this-&gt;nodes.count(key)&gt;0)</div>
<div class="line"><span class="lineno">  308</span>      {</div>
<div class="line"><span class="lineno">  309</span>        nl=this-&gt;nodes.lower_bound(key);</div>
<div class="line"><span class="lineno">  310</span>        nu=this-&gt;nodes.upper_bound(key);</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span> ptr=nl;ptr!=nu;++ptr)</div>
<div class="line"><span class="lineno">  312</span>        {</div>
<div class="line"><span class="lineno">  313</span>          NodeData ndtest(ptr-&gt;second);</div>
<div class="line"><span class="lineno">  314</span>          <span class="keywordflow">if</span>(ndtest != (nptr-&gt;second))</div>
<div class="line"><span class="lineno">  315</span>          {</div>
<div class="line"><span class="lineno">  316</span>            this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  317</span>          }</div>
<div class="line"><span class="lineno">  318</span>        }</div>
<div class="line"><span class="lineno">  319</span>      }</div>
<div class="line"><span class="lineno">  320</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  321</span>      {</div>
<div class="line"><span class="lineno">  322</span>        this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  323</span>      }</div>
<div class="line"><span class="lineno">  324</span>    }</div>
<div class="line"><span class="lineno">  325</span>    <span class="comment">/* Don&#39;t forget head node data*/</span></div>
<div class="line"><span class="lineno">  326</span>    NodeData nd=data_to_add.current_nodedata();</div>
<div class="line"><span class="lineno">  327</span>    NodeData ndhere=this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata</a>();</div>
<div class="line"><span class="lineno">  328</span>    pair&lt;string,NodeData&gt; pnd(current_id,nd);</div>
<div class="line"><span class="lineno">  329</span>    this-&gt;nodes.insert(pnd);</div>
<div class="line"><span class="lineno">  330</span>  }</div>
<div class="line"><span class="lineno">  331</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_error_logger_html_aa69873ba0aebf67e9ba24d01992c0bcf"><div class="ttname"><a href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error</a></div><div class="ttdeci">int log_error(const mspass::utility::MsPASSError &amp;merr)</div><div class="ttdef"><b>Definition</b> ErrorLogger.cc:81</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">id()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, and <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>.</p>

</div>
</div>
<a id="afbcd32c36bbabff34fb51e382da69d83" name="afbcd32c36bbabff34fb51e382da69d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcd32c36bbabff34fb51e382da69d83">&#9670;&#160;</a></span>clean_accumulate_uuids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::ProcessingHistory::clean_accumulate_uuids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up inconsistent uuids that can be produced by reduce. </p>
<p>In a spark reduce operation it is possible to create multiple uuid keys for inputs to the same algorithm instance. That happpens because the mechanism used by <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> to define the process history tree is not associative. When a reduce gets sprayed across multiple nodes multiple initializations can occur that make artifical inconsitent uuids. This method should normally be called after a reduce operator if history is being preserved or the history chain may be foobarred - no invalid just mess up with extra branches in the processing tree.</p>
<p>A VERY IMPORTANT limitation of the algorithm used by this method is that the combination of algorithm and algid in "this" MUST be unique for a given job run when a reduce is called. i.e. if an earlier workflow had used alg and algid but with a different jobid and jobname the distintion cannot be detected with this algorithm. This means our global history handling must guarantee algid is unique for each run.</p>
<dl class="section return"><dt>Returns</dt><dd>unique uuid for alg,algid match set in the history chain. Note if there are no duplicates it simply returns the only one it finds. If there are duplicates it returns the lexically smallest (first in alphabetic order) uuid. Most importantly if there is no match or if history is empty it returns the string UNDEFINED. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  585</span>{</div>
<div class="line"><span class="lineno">  586</span>  <span class="comment">/* Return undefined immediately if the history chain is empty */</span></div>
<div class="line"><span class="lineno">  587</span>  <span class="keywordflow">if</span>(this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a>()) <span class="keywordflow">return</span> string(<span class="stringliteral">&quot;UNDEFINED&quot;</span>);</div>
<div class="line"><span class="lineno">  588</span>  NodeData ndthis=this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata</a>();</div>
<div class="line"><span class="lineno">  589</span>  <span class="keywordtype">string</span> alg(ndthis.algorithm);</div>
<div class="line"><span class="lineno">  590</span>  <span class="keywordtype">string</span> algidtest(ndthis.algid);</div>
<div class="line"><span class="lineno">  591</span>  <span class="comment">/* The algorithm here finds all entries for which algorithm is alg and</span></div>
<div class="line"><span class="lineno">  592</span><span class="comment">  algid matches aldid.  We build a list of uuids (keys) linked to that unique</span></div>
<div class="line"><span class="lineno">  593</span><span class="comment">  algorithm.  We then use the id in ndthis as the master*/</span></div>
<div class="line"><span class="lineno">  594</span>  set&lt;string&gt; matching_ids;</div>
<div class="line"><span class="lineno">  595</span>  matching_ids.insert(ndthis.uuid);</div>
<div class="line"><span class="lineno">  596</span>  <span class="comment">/* this approach of pushing iterators to this list that match seemed to</span></div>
<div class="line"><span class="lineno">  597</span><span class="comment">  be the only way I could make this work correctly.   Not sure why, but</span></div>
<div class="line"><span class="lineno">  598</span><span class="comment">  the added cost over handling this correctly in the loops is small. */</span></div>
<div class="line"><span class="lineno">  599</span>  std::list&lt;multimap&lt;string,NodeData&gt;::iterator&gt; need_to_erase;</div>
<div class="line"><span class="lineno">  600</span>  <span class="keywordflow">for</span>(<span class="keyword">auto</span> nptr=this-&gt;nodes.begin();nptr!=this-&gt;nodes.end();++nptr)</div>
<div class="line"><span class="lineno">  601</span>  {</div>
<div class="line"><span class="lineno">  602</span>    <span class="comment">/* this copy operation is somewhat inefficient, but the cost is small</span></div>
<div class="line"><span class="lineno">  603</span><span class="comment">    compared to how obscure the code will look if we directly manipulate the</span></div>
<div class="line"><span class="lineno">  604</span><span class="comment">    second value */</span></div>
<div class="line"><span class="lineno">  605</span>    NodeData nd(nptr-&gt;second);</div>
<div class="line"><span class="lineno">  606</span>    <span class="comment">/* this depends upon the distinction between set and multiset.  i.e. an insert</span></div>
<div class="line"><span class="lineno">  607</span><span class="comment">    of a duplicate does nothing*/</span></div>
<div class="line"><span class="lineno">  608</span>    <span class="keywordflow">if</span>((alg==nd.algorithm) &amp;&amp; (algidtest==nd.algid))</div>
<div class="line"><span class="lineno">  609</span>    {</div>
<div class="line"><span class="lineno">  610</span>      matching_ids.insert(nd.uuid);</div>
<div class="line"><span class="lineno">  611</span>      need_to_erase.push_back(nptr);</div>
<div class="line"><span class="lineno">  612</span>    }</div>
<div class="line"><span class="lineno">  613</span>  }</div>
<div class="line"><span class="lineno">  614</span>  <span class="comment">// handle no match situation gracefully</span></div>
<div class="line"><span class="lineno">  615</span>  <span class="keywordflow">if</span>(matching_ids.empty())</div>
<div class="line"><span class="lineno">  616</span>    <span class="keywordflow">return</span> string(<span class="stringliteral">&quot;UNDEFINED&quot;</span>);</div>
<div class="line"><span class="lineno">  617</span>  <span class="comment">/* Nothing more to do but return the uuid if there is only one*/</span></div>
<div class="line"><span class="lineno">  618</span>  <span class="keywordflow">if</span>(matching_ids.size()==1)</div>
<div class="line"><span class="lineno">  619</span>    <span class="keywordflow">return</span> *(matching_ids.begin());</div>
<div class="line"><span class="lineno">  620</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  621</span>  {</div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">for</span>(<span class="keyword">auto</span> sptr=need_to_erase.begin();sptr!=need_to_erase.end();++sptr)</div>
<div class="line"><span class="lineno">  623</span>    {</div>
<div class="line"><span class="lineno">  624</span>      nodes.erase(*sptr);</div>
<div class="line"><span class="lineno">  625</span>    }</div>
<div class="line"><span class="lineno">  626</span>    need_to_erase.clear();</div>
<div class="line"><span class="lineno">  627</span>  }</div>
<div class="line"><span class="lineno">  628</span>  <span class="comment">/* Here is the complicated case.  We use the uuid from ndthis as the master</span></div>
<div class="line"><span class="lineno">  629</span><span class="comment">  and change all the others.   This operation works ONLY because in a multimap</span></div>
<div class="line"><span class="lineno">  630</span><span class="comment">  erase only invalidates the iterator it points to and others remain valid.</span></div>
<div class="line"><span class="lineno">  631</span><span class="comment">  */</span></div>
<div class="line"><span class="lineno">  632</span>  <span class="keywordtype">string</span> master_uuid=ndthis.uuid;</div>
<div class="line"><span class="lineno">  633</span>  <span class="keywordflow">for</span>(<span class="keyword">auto</span> sptr=matching_ids.begin();sptr!=matching_ids.end();++sptr)</div>
<div class="line"><span class="lineno">  634</span>  {</div>
<div class="line"><span class="lineno">  635</span>    <span class="comment">/* Note this test is necessary to stip the master_uuid - no else needed*/</span></div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">if</span>((*sptr)!=master_uuid)</div>
<div class="line"><span class="lineno">  637</span>    {</div>
<div class="line"><span class="lineno">  638</span>      multimap&lt;string,NodeData&gt;::iterator nl,nu;</div>
<div class="line"><span class="lineno">  639</span>      nl=this-&gt;nodes.lower_bound(*sptr);</div>
<div class="line"><span class="lineno">  640</span>      nu=this-&gt;nodes.upper_bound(*sptr);</div>
<div class="line"><span class="lineno">  641</span>      <span class="keywordflow">for</span>(<span class="keyword">auto</span> nptr=nl;nptr!=nu;++nptr)</div>
<div class="line"><span class="lineno">  642</span>      {</div>
<div class="line"><span class="lineno">  643</span>        NodeData nd;</div>
<div class="line"><span class="lineno">  644</span>        nd=(nptr-&gt;second);</div>
<div class="line"><span class="lineno">  645</span>        need_to_erase.push_back(nptr);</div>
<div class="line"><span class="lineno">  646</span>        nodes.insert(pair&lt;string,NodeData&gt;(master_uuid,nd));</div>
<div class="line"><span class="lineno">  647</span>      }</div>
<div class="line"><span class="lineno">  648</span>    }</div>
<div class="line"><span class="lineno">  649</span>  }</div>
<div class="line"><span class="lineno">  650</span>  <span class="keywordflow">for</span>(<span class="keyword">auto</span> sptr=need_to_erase.begin();sptr!=need_to_erase.end();++sptr)</div>
<div class="line"><span class="lineno">  651</span>  {</div>
<div class="line"><span class="lineno">  652</span>    nodes.erase(*sptr);</div>
<div class="line"><span class="lineno">  653</span>  }</div>
<div class="line"><span class="lineno">  654</span> </div>
<div class="line"><span class="lineno">  655</span>  <span class="keywordflow">return</span> master_uuid;</div>
<div class="line"><span class="lineno">  656</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_node_data.html#aa51f302e3e070fd072255e1d1af9073f">mspass::utility::NodeData::algid</a>, <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a040189091bc8458cc84b7a3781856643">mspass::utility::NodeData::algorithm</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, and <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a0f0df95910b9712e36d3a8389c0c9f38">mspass::utility::NodeData::uuid</a>.</p>

</div>
</div>
<a id="a42865512c68a26b85b394825a1629729" name="a42865512c68a26b85b394825a1629729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42865512c68a26b85b394825a1629729">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear this history chain - use with caution. </p>
<div class="fragment"><div class="line"><span class="lineno">  678</span>{</div>
<div class="line"><span class="lineno">  679</span>  nodes.clear();</div>
<div class="line"><span class="lineno">  680</span>  current_status=ProcessingStatus::UNDEFINED;</div>
<div class="line"><span class="lineno">  681</span>  current_stage=0;</div>
<div class="line"><span class="lineno">  682</span>  mytype=AtomicType::UNDEFINED;</div>
<div class="line"><span class="lineno">  683</span>  algorithm=<span class="stringliteral">&quot;UNDEFINED&quot;</span>;</div>
<div class="line"><span class="lineno">  684</span>  algid=<span class="stringliteral">&quot;UNDEFINED&quot;</span>;</div>
<div class="line"><span class="lineno">  685</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a89df41edb1ff1e92abd5a4f864c36673" name="a89df41edb1ff1e92abd5a4f864c36673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89df41edb1ff1e92abd5a4f864c36673">&#9670;&#160;</a></span>created_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; mspass::utility::ProcessingHistory::created_by </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the algorithm name and id that created current node. </p>
<div class="fragment"><div class="line"><span class="lineno">  615</span>  {</div>
<div class="line"><span class="lineno">  616</span>    std::pair&lt;std::string,std::string&gt; result(algorithm,algid);</div>
<div class="line"><span class="lineno">  617</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  618</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a110c300dfa2a6f5236a7d254fa7bf663" name="a110c300dfa2a6f5236a7d254fa7bf663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110c300dfa2a6f5236a7d254fa7bf663">&#9670;&#160;</a></span>current_nodedata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_node_data.html">NodeData</a> mspass::utility::ProcessingHistory::current_nodedata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return all the attributes of current.</p>
<p>This is a convenience method strictly for the C++ interface (it too nonpythonic to be useful to wrap for python). It returns a <a class="el" href="classmspass_1_1utility_1_1_node_data.html" title="Holds properties of data used as input to algorithm that created this object.">NodeData</a> class containing the attributes of the head of the chain. Like the getters above that is needed to save that data. </p>
<div class="fragment"><div class="line"><span class="lineno">  713</span>{</div>
<div class="line"><span class="lineno">  714</span>  NodeData nd;</div>
<div class="line"><span class="lineno">  715</span>  nd.status=current_status;</div>
<div class="line"><span class="lineno">  716</span>  nd.uuid=current_id;</div>
<div class="line"><span class="lineno">  717</span>  nd.type=mytype;</div>
<div class="line"><span class="lineno">  718</span>  nd.stage=current_stage;</div>
<div class="line"><span class="lineno">  719</span>  nd.algorithm=algorithm;</div>
<div class="line"><span class="lineno">  720</span>  nd.algid=algid;</div>
<div class="line"><span class="lineno">  721</span>  <span class="keywordflow">return</span> nd;</div>
<div class="line"><span class="lineno">  722</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_node_data.html#aa51f302e3e070fd072255e1d1af9073f">mspass::utility::NodeData::algid</a>, <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a040189091bc8458cc84b7a3781856643">mspass::utility::NodeData::algorithm</a>, <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a972bd00dc85cae2e490833225f53e282">mspass::utility::NodeData::stage</a>, <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a3dab2773c306f1d9977dccb455beec59">mspass::utility::NodeData::status</a>, <a class="el" href="classmspass_1_1utility_1_1_node_data.html#aa7c6f56ceca095d0af31f456d75954a4">mspass::utility::NodeData::type</a>, and <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a0f0df95910b9712e36d3a8389c0c9f38">mspass::utility::NodeData::uuid</a>.</p>

</div>
</div>
<a id="a52b0394b444f6db307945284ac6e5f8a" name="a52b0394b444f6db307945284ac6e5f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b0394b444f6db307945284ac6e5f8a">&#9670;&#160;</a></span>get_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">multimap&lt; string, <a class="el" href="classmspass_1_1utility_1_1_node_data.html">NodeData</a> &gt; mspass::utility::ProcessingHistory::get_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the nodes multimap that defines the tree stucture branches.</p>
<p>This method does more than just get the protected multimap called nodes. It copies the map and then pushes the "current" contents to the map before returning the copy. This allows the data defines as current to not be pushed into the tree until they are needed. <br  />
 </p>
<div class="fragment"><div class="line"><span class="lineno">  658</span>{</div>
<div class="line"><span class="lineno">  659</span>  <span class="comment">/* Return empty map if it has no data - necessary or the logic</span></div>
<div class="line"><span class="lineno">  660</span><span class="comment">  below will insert an empty head to the chain. */</span></div>
<div class="line"><span class="lineno">  661</span>  <span class="keywordflow">if</span>(this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a>())</div>
<div class="line"><span class="lineno">  662</span>      <span class="keywordflow">return</span> nodes;  <span class="comment">// a way to return an empty container</span></div>
<div class="line"><span class="lineno">  663</span>  <span class="comment">/* This is wrong, I think, but retained to test before removing.</span></div>
<div class="line"><span class="lineno">  664</span><span class="comment">  remove this once current idea is confirmed. Note if that</span></div>
<div class="line"><span class="lineno">  665</span><span class="comment">  proves true we can also remove the two lines above as they do</span></div>
<div class="line"><span class="lineno">  666</span><span class="comment">  nothing useful*/</span></div>
<div class="line"><span class="lineno">  667</span>  <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  668</span><span class="comment">  NodeData nd;</span></div>
<div class="line"><span class="lineno">  669</span><span class="comment">  nd=this-&gt;current_nodedata();</span></div>
<div class="line"><span class="lineno">  670</span><span class="comment">  pair&lt;string,NodeData&gt; pn(current_id,nd);</span></div>
<div class="line"><span class="lineno">  671</span><span class="comment">  multimap&lt;string,NodeData&gt; result(this-&gt;nodes);</span></div>
<div class="line"><span class="lineno">  672</span><span class="comment">  result.insert(pn);</span></div>
<div class="line"><span class="lineno">  673</span><span class="comment">  return result;</span></div>
<div class="line"><span class="lineno">  674</span><span class="comment">  */</span></div>
<div class="line"><span class="lineno">  675</span>  <span class="keywordflow">return</span> nodes;</div>
<div class="line"><span class="lineno">  676</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>.</p>

</div>
</div>
<a id="adf60368ca5c699cc9186fa145d04376d" name="adf60368ca5c699cc9186fa145d04376d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf60368ca5c699cc9186fa145d04376d">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mspass::utility::ProcessingHistory::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the id of this object set for this history chain.</p>
<p>We maintain the uuid for a data object inside this class. This method fetches the string representation of the uuid of this data object. </p>
<div class="fragment"><div class="line"><span class="lineno">  610</span>  {</div>
<div class="line"><span class="lineno">  611</span>    <span class="keywordflow">return</span> current_id;</div>
<div class="line"><span class="lineno">  612</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec695e46a390b9cf55f1919af803fb33" name="aec695e46a390b9cf55f1919af803fb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec695e46a390b9cf55f1919af803fb33">&#9670;&#160;</a></span>inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; <a class="el" href="classmspass_1_1utility_1_1_node_data.html">NodeData</a> &gt; mspass::utility::ProcessingHistory::inputs </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>id_to_find</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of data that define the inputs to a give uuids. </p>
<p>This low level getter returns the <a class="el" href="classmspass_1_1utility_1_1_node_data.html" title="Holds properties of data used as input to algorithm that created this object.">NodeData</a> objects that define the inputs to the uuid of some piece of data that was used as input at some stage for the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_to_find</td><td>is the uuid for which input data is desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of <a class="el" href="classmspass_1_1utility_1_1_node_data.html" title="Holds properties of data used as input to algorithm that created this object.">NodeData</a> that define the inputs. Will silently return empty list if the key is not found. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  725</span>{</div>
<div class="line"><span class="lineno">  726</span>  list&lt;NodeData&gt; result;</div>
<div class="line"><span class="lineno">  727</span>  <span class="comment">// Return empty list immediately if key not found</span></div>
<div class="line"><span class="lineno">  728</span>  <span class="keywordflow">if</span>(nodes.count(id_to_find)&lt;=0) <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  729</span>  <span class="comment">/* Note these have to be const_iterators because method is tagged const*/</span></div>
<div class="line"><span class="lineno">  730</span>  multimap&lt;string,NodeData&gt;::const_iterator upper,lower;</div>
<div class="line"><span class="lineno">  731</span>  lower=nodes.lower_bound(id_to_find);</div>
<div class="line"><span class="lineno">  732</span>  upper=nodes.upper_bound(id_to_find);</div>
<div class="line"><span class="lineno">  733</span>  multimap&lt;string,NodeData&gt;::const_iterator mptr;</div>
<div class="line"><span class="lineno">  734</span>  <span class="keywordflow">for</span>(mptr=lower;mptr!=upper;++mptr)</div>
<div class="line"><span class="lineno">  735</span>  {</div>
<div class="line"><span class="lineno">  736</span>    result.push_back(mptr-&gt;second);</div>
<div class="line"><span class="lineno">  737</span>  }</div>
<div class="line"><span class="lineno">  738</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  739</span>};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e42309bb4dfb0c0ea38496a3235f069" name="a8e42309bb4dfb0c0ea38496a3235f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e42309bb4dfb0c0ea38496a3235f069">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::ProcessingHistory::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the processing chain is empty.</p>
<p>This method provides a standard test for an invalid, empty processing chain. Constructors except the copy constructor will all put this object in an invalid state that will cause this method to return true. Only if the chain is initialized properly with a call to set_as_origin will this method return a false. </p>
<div class="fragment"><div class="line"><span class="lineno">  115</span>{</div>
<div class="line"><span class="lineno">  116</span>  <span class="keywordflow">if</span>( (current_status==ProcessingStatus::UNDEFINED)</div>
<div class="line"><span class="lineno">  117</span>     &amp;&amp; (nodes.empty()) )<span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  118</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  119</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a477b2020ad7e3c753999e3906cd8eb58" name="a477b2020ad7e3c753999e3906cd8eb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477b2020ad7e3c753999e3906cd8eb58">&#9670;&#160;</a></span>is_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::ProcessingHistory::is_origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current data is in state defined as "origin" - see class description </p>
<div class="fragment"><div class="line"><span class="lineno">  128</span>{</div>
<div class="line"><span class="lineno">  129</span>  <span class="keywordflow">if</span>(current_status==ProcessingStatus::RAW || current_status==ProcessingStatus::ORIGIN)</div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  131</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  133</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a440cedfda00fd0b7211ed4673f09426e" name="a440cedfda00fd0b7211ed4673f09426e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440cedfda00fd0b7211ed4673f09426e">&#9670;&#160;</a></span>is_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::ProcessingHistory::is_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current data is in state defined as "raw" - see class description </p>
<div class="fragment"><div class="line"><span class="lineno">  121</span>{</div>
<div class="line"><span class="lineno">  122</span>  <span class="keywordflow">if</span>(current_status==ProcessingStatus::RAW)</div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  124</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  126</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35cd2643171f354ded06e1a34681961d" name="a35cd2643171f354ded06e1a34681961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cd2643171f354ded06e1a34681961d">&#9670;&#160;</a></span>is_saved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::ProcessingHistory::is_saved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current data is in state defined as "saved" - see class description </p>
<div class="fragment"><div class="line"><span class="lineno">  142</span>{</div>
<div class="line"><span class="lineno">  143</span>  <span class="keywordflow">if</span>(current_status==ProcessingStatus::SAVED)</div>
<div class="line"><span class="lineno">  144</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  145</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  147</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cfd15514483fc2701e53ba1be8412e9" name="a8cfd15514483fc2701e53ba1be8412e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd15514483fc2701e53ba1be8412e9">&#9670;&#160;</a></span>is_volatile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::utility::ProcessingHistory::is_volatile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current data is in state defined as "volatile" - see class description </p>
<div class="fragment"><div class="line"><span class="lineno">  135</span>{</div>
<div class="line"><span class="lineno">  136</span>  <span class="keywordflow">if</span>(current_status==ProcessingStatus::VOLATILE)</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  138</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  140</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5152d2f6a4706e635d6ca16e68b9bcc" name="ab5152d2f6a4706e635d6ca16e68b9bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5152d2f6a4706e635d6ca16e68b9bcc">&#9670;&#160;</a></span>map_as_saved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::ProcessingHistory::map_as_saved </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the current data for saving. </p>
<p>Saving data is treated as a special form of map operation. That is because a save by our definition is always a one-to-one operation with an index entry for each atomic object. This method pushes a new entry in the history chain tagged by the algorithm/algid field for the writer. It differs from new_map in the important sense that the uuid is not changed. The record this sets in the nodes multimap will then have the same uuid for the key as the that in <a class="el" href="classmspass_1_1utility_1_1_node_data.html" title="Holds properties of data used as input to algorithm that created this object.">NodeData</a>. That along with the status set SAVED can be used downstream to recognize save records.</p>
<p>It is VERY IMPORTANT for use of this method to realize this method saves nothing. It only preps the history chain data so calls that follow will retrieve the right information to reconstruct the full history chain. Writers should follow this sequence:</p><ol type="1">
<li>call map_as_saved with the writer name for algorithm definition</li>
<li>save the data and history chain to MongoDB.</li>
<li>be sure you have a copy of the uuid string of the data just saved and call the clear method.</li>
<li>call the set_as_origin method using the uuid saved with the algorithm/id the same as used for earlier call to map_as_saved. This makes the put <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> in a state identical to that produced by a reader.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>is the algorithm names to assign to the ouput. This would normally be name defining the writer. </td></tr>
    <tr><td class="paramname">algid</td><td>is an id designator to uniquely define an instance of algorithm. Note that algid must itself be a unique keyword or the history chains will get scrambled. alg is mostly carried as baggage to make output more easily comprehended without additional lookups. Note one model to distinguish records of actual save and redefinition of the data as an origin (see above) is to use a different id for the call to map_as_saved and later call to set_as_origin. This code doesn't care, but that is an implementation detail in how this will work with MongoDB. </td></tr>
    <tr><td class="paramname">typ</td><td>defines the data type (C++ class) that was just saved. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  422</span>{</div>
<div class="line"><span class="lineno">  423</span>  <span class="keywordflow">if</span>(this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a>())</div>
<div class="line"><span class="lineno">  424</span>  {</div>
<div class="line"><span class="lineno">  425</span>    stringstream ss;</div>
<div class="line"><span class="lineno">  426</span>    ss &lt;&lt; <span class="stringliteral">&quot;Attempt to call this method on an empty history chain for uuid=&quot;</span></div>
<div class="line"><span class="lineno">  427</span>       &lt;&lt; this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">id</a>()&lt;&lt;endl</div>
<div class="line"><span class="lineno">  428</span>       &lt;&lt; <span class="stringliteral">&quot;Cannot preserve history for writer=&quot;</span>&lt;&lt;alg&lt;&lt;<span class="stringliteral">&quot; with id=&quot;</span>&lt;&lt;algid&lt;&lt;endl;</div>
<div class="line"><span class="lineno">  429</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::map_as_saved&quot;</span>,ss.str(),ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  430</span>    <span class="keywordflow">return</span> current_id;</div>
<div class="line"><span class="lineno">  431</span>  }</div>
<div class="line"><span class="lineno">  432</span>  <span class="comment">/* This is essentially pushing current data to the end of the history chain</span></div>
<div class="line"><span class="lineno">  433</span><span class="comment">  but using a special id that may or may not be saved by the caller.</span></div>
<div class="line"><span class="lineno">  434</span><span class="comment">  We use a fixed keyword defined in ProcessingHistory.h assuming saves</span></div>
<div class="line"><span class="lineno">  435</span><span class="comment">  are always a one-to-one operation (definition of atomic really)*/</span></div>
<div class="line"><span class="lineno">  436</span>  NodeData nd(this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata</a>());</div>
<div class="line"><span class="lineno">  437</span>  pair&lt;string,NodeData&gt; pn(SAVED_ID_KEY,nd);</div>
<div class="line"><span class="lineno">  438</span>  this-&gt;nodes.insert(pn);</div>
<div class="line"><span class="lineno">  439</span>  <span class="comment">/* Now we reset current to define it as the saver.  Then calls to the</span></div>
<div class="line"><span class="lineno">  440</span><span class="comment">  getters for the multimap will properly insert this data as the end of the</span></div>
<div class="line"><span class="lineno">  441</span><span class="comment">  chain.  Note a key difference from new_map is we don&#39;t create a new uuid.</span></div>
<div class="line"><span class="lineno">  442</span><span class="comment">  I don&#39;t think that will cause an ambiguity, but it might be better to</span></div>
<div class="line"><span class="lineno">  443</span><span class="comment">  just create a new one here - will do it this way unless that proves a problem</span></div>
<div class="line"><span class="lineno">  444</span><span class="comment">  as the equality of the two might be a useful test for other purposes */</span></div>
<div class="line"><span class="lineno">  445</span>  algorithm=alg;</div>
<div class="line"><span class="lineno">  446</span>  algid=algid_in;</div>
<div class="line"><span class="lineno">  447</span>  current_status=ProcessingStatus::SAVED;</div>
<div class="line"><span class="lineno">  448</span>  current_id=SAVED_ID_KEY;</div>
<div class="line"><span class="lineno">  449</span>  <span class="keywordflow">if</span>(current_stage&gt;=0)</div>
<div class="line"><span class="lineno">  450</span>    ++current_stage;</div>
<div class="line"><span class="lineno">  451</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  452</span>  {</div>
<div class="line"><span class="lineno">  453</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::map_as_saved&quot;</span>,</div>
<div class="line"><span class="lineno">  454</span>      <span class="stringliteral">&quot;current_stage on entry had not been initialized\nImproper usage will create an invalid history chain that may cause downstream problems&quot;</span>,</div>
<div class="line"><span class="lineno">  455</span>       ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  456</span>    current_stage=0;</div>
<div class="line"><span class="lineno">  457</span>  }</div>
<div class="line"><span class="lineno">  458</span>  mytype=typ;</div>
<div class="line"><span class="lineno">  459</span>  <span class="keywordflow">return</span> current_id;</div>
<div class="line"><span class="lineno">  460</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_adf60368ca5c699cc9186fa145d04376d"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">mspass::utility::ProcessingHistory::id</a></div><div class="ttdeci">std::string id() const</div><div class="ttdef"><b>Definition</b> ProcessingHistory.h:609</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a110c300dfa2a6f5236a7d254fa7bf663">current_nodedata()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">id()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, and <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>.</p>

</div>
</div>
<a id="a4f2cb1d5af0500a526fa8745aa52db36" name="a4f2cb1d5af0500a526fa8745aa52db36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2cb1d5af0500a526fa8745aa52db36">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>data_to_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge the history nodes from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_to_add</td><td>is the <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> of the data object to be merged. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  464</span>{</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>  <span class="keywordflow">if</span>(data_to_add.is_empty())</div>
<div class="line"><span class="lineno">  467</span>  {</div>
<div class="line"><span class="lineno">  468</span>    stringstream ss;</div>
<div class="line"><span class="lineno">  469</span>    ss&lt;&lt;<span class="stringliteral">&quot;Data with uuid=&quot;</span>&lt;&lt;data_to_add.id()&lt;&lt;<span class="stringliteral">&quot; has an empty history chain&quot;</span>&lt;&lt;endl</div>
<div class="line"><span class="lineno">  470</span>      &lt;&lt; <span class="stringliteral">&quot;At best this will leave ProcessingHistory incomplete&quot;</span>&lt;&lt;endl;</div>
<div class="line"><span class="lineno">  471</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::merge&quot;</span>,ss.str(),</div>
<div class="line"><span class="lineno">  472</span>      ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  473</span>  }</div>
<div class="line"><span class="lineno">  474</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  475</span>  {</div>
<div class="line"><span class="lineno">  476</span>    multimap&lt;string,NodeData&gt;::iterator nptr;</div>
<div class="line"><span class="lineno">  477</span>    multimap&lt;string,NodeData&gt; newhistory = data_to_add.get_nodes();</div>
<div class="line"><span class="lineno">  478</span>    multimap&lt;string,NodeData&gt;::iterator nl,nu;</div>
<div class="line"><span class="lineno">  479</span>    <span class="keywordflow">for</span>(nptr=newhistory.begin();nptr!=newhistory.end();++nptr)</div>
<div class="line"><span class="lineno">  480</span>    {</div>
<div class="line"><span class="lineno">  481</span>      <span class="keywordtype">string</span> key(nptr-&gt;first);</div>
<div class="line"><span class="lineno">  482</span>      <span class="comment">/* if the data_to_add&#39;s key matches its current id,</span></div>
<div class="line"><span class="lineno">  483</span><span class="comment">      we merge all the nodes under the current id of *this. */</span></div>
<div class="line"><span class="lineno">  484</span>      <span class="keywordflow">if</span>(key == data_to_add.current_id)</div>
<div class="line"><span class="lineno">  485</span>      {</div>
<div class="line"><span class="lineno">  486</span>        this-&gt;nodes.insert(std::make_pair(this-&gt;current_id, nptr-&gt;second));</div>
<div class="line"><span class="lineno">  487</span>      }</div>
<div class="line"><span class="lineno">  488</span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span>(this-&gt;nodes.count(key)&gt;0)</div>
<div class="line"><span class="lineno">  489</span>      {</div>
<div class="line"><span class="lineno">  490</span>        nl=this-&gt;nodes.lower_bound(key);</div>
<div class="line"><span class="lineno">  491</span>        nu=this-&gt;nodes.upper_bound(key);</div>
<div class="line"><span class="lineno">  492</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span> ptr=nl;ptr!=nu;++ptr)</div>
<div class="line"><span class="lineno">  493</span>        {</div>
<div class="line"><span class="lineno">  494</span>          NodeData ndtest(ptr-&gt;second);</div>
<div class="line"><span class="lineno">  495</span>          <span class="keywordflow">if</span>(ndtest != (nptr-&gt;second))</div>
<div class="line"><span class="lineno">  496</span>          {</div>
<div class="line"><span class="lineno">  497</span>            this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  498</span>          }</div>
<div class="line"><span class="lineno">  499</span>        }</div>
<div class="line"><span class="lineno">  500</span>      }</div>
<div class="line"><span class="lineno">  501</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  502</span>      {</div>
<div class="line"><span class="lineno">  503</span>        this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  504</span>      }</div>
<div class="line"><span class="lineno">  505</span>    }</div>
<div class="line"><span class="lineno">  506</span>  }</div>
<div class="line"><span class="lineno">  507</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#adf60368ca5c699cc9186fa145d04376d">id()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, and <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>.</p>

</div>
</div>
<a id="a986da6a438099a371a0b0a9556f2c8b3" name="a986da6a438099a371a0b0a9556f2c8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986da6a438099a371a0b0a9556f2c8b3">&#9670;&#160;</a></span>new_ensemble_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::ProcessingHistory::new_ensemble_process </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> * &gt;&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>create_newid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define history chain for an algorithm with multiple inputs in an ensemble.</p>
<p>Use this method to define the history chain for an algorithm that has multiple inputs for each output. Each output needs to call this method to build the connections that define how all inputs link to the the new data being created by the algorithm that calls this method. Use this method for map operators that have an ensemble object as input and a single data object as output. This method should be called in creation of the output object. If the algorthm builds multiple outputs to build an output ensemble call this method for each output before pushing it to the output ensemble container.</p>
<p>This method should not be used for a reduce operation in spark. It does not satisfy the associative rule for reduce. Use accumulate for reduce operations.</p>
<p>Normally, it makes sense to have the boolean create_newid true so it is guaranteed the current_id is unique. There is little cost in creating a new one if there is any doubt the current_id is not a duplicate. The false option is there only for rare cases where the current id value needs to be preserved.</p>
<p>Note the vector of data passed is raw pointers for efficiency to avoid excessive copying. For normal use this should not create memory leaks but make sure you don't try to free what the pointers point to or problems are guaranteed. It is VERY IMPORTANT to realize that all the pointers are presumed to point to the <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> component of a set of larger data object (Seismogram or TimeSeries). The parents do not all have be a common type as if they have valid history data within them their current type will be defined.</p>
<p>This method ALWAYS marks the status as VOLATILE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>is the algorithm names to assign to the origin node. This would normally be name defining the algorithm that makes sense to a human. </td></tr>
    <tr><td class="paramname">algid</td><td>is an id designator to uniquely define an instance of algorithm. Note that algid must itself be a unique keyword or the history chains will get scrambled. alg is mostly carried as baggage to make output more easily comprehended without additional lookups. </td></tr>
    <tr><td class="paramname">typ</td><td>defines the data type (C++ class) the algorithm that is generating this data will create. </td></tr>
    <tr><td class="paramname">create_newid</td><td>is a boolean defining how the current id is handled. As described above, if true the method will call newid and set that as the current id of this data object. If false the current value is left intact. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of the uuid of the data to which this <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> is now attached. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  190</span>{</div>
<div class="line"><span class="lineno">  191</span>  <span class="keywordflow">if</span>(create_newid)</div>
<div class="line"><span class="lineno">  192</span>  {</div>
<div class="line"><span class="lineno">  193</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a>();</div>
<div class="line"><span class="lineno">  194</span>  }</div>
<div class="line"><span class="lineno">  195</span>  <span class="comment">/* We need to clear the tree contents because all the parents will</span></div>
<div class="line"><span class="lineno">  196</span><span class="comment">  branch from this.  Hence, we have to put the node data into an empty</span></div>
<div class="line"><span class="lineno">  197</span><span class="comment">  container */</span></div>
<div class="line"><span class="lineno">  198</span>  this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">clear</a>();</div>
<div class="line"><span class="lineno">  199</span>  algorithm=alg;</div>
<div class="line"><span class="lineno">  200</span>  algid=algid_in;</div>
<div class="line"><span class="lineno">  201</span>  mytype=typ;</div>
<div class="line"><span class="lineno">  202</span>  <span class="comment">/* Initialize current stage but assume it will be updated as max of</span></div>
<div class="line"><span class="lineno">  203</span><span class="comment">  parents below */</span></div>
<div class="line"><span class="lineno">  204</span>  current_stage=0;</div>
<div class="line"><span class="lineno">  205</span>  multimap&lt;string,NodeData&gt;::const_iterator nptr,nl,nu;</div>
<div class="line"><span class="lineno">  206</span>  <span class="keywordtype">size_t</span> i;</div>
<div class="line"><span class="lineno">  207</span>  <span class="comment">/* current_stage can be ambiguous from multiple inputs.  We define</span></div>
<div class="line"><span class="lineno">  208</span><span class="comment">  the current stage from a reduce as the largest stage value found</span></div>
<div class="line"><span class="lineno">  209</span><span class="comment">  in all inputs.  Note we only test the stage value at the head for</span></div>
<div class="line"><span class="lineno">  210</span><span class="comment">  each parent */</span></div>
<div class="line"><span class="lineno">  211</span>  <span class="keywordtype">int</span> max_stage(0);</div>
<div class="line"><span class="lineno">  212</span>  <span class="keywordflow">for</span>(i=0;i&lt;parents.size();++i)</div>
<div class="line"><span class="lineno">  213</span>  {</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">if</span>(parents[i]-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty</a>())</div>
<div class="line"><span class="lineno">  215</span>    {</div>
<div class="line"><span class="lineno">  216</span>      stringstream ss;</div>
<div class="line"><span class="lineno">  217</span>      ss &lt;&lt; <span class="stringliteral">&quot;Vector member number &quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; with uuid=&quot;</span>&lt;&lt;parents[i]-&gt;id()</div>
<div class="line"><span class="lineno">  218</span>         &lt;&lt; <span class="stringliteral">&quot; has an empty history chain&quot;</span>&lt;&lt;endl</div>
<div class="line"><span class="lineno">  219</span>         &lt;&lt; <span class="stringliteral">&quot;At best the processing history data will be incomplete&quot;</span>&lt;&lt;endl;</div>
<div class="line"><span class="lineno">  220</span>      elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::new_ensemble_process&quot;</span>,ss.str(),</div>
<div class="line"><span class="lineno">  221</span>        ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  222</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  223</span>    }</div>
<div class="line"><span class="lineno">  224</span>    multimap&lt;string,NodeData&gt; parent_node_data(parents[i]-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes</a>());</div>
<div class="line"><span class="lineno">  225</span>    <span class="comment">/* We also have to get the head data with this method now */</span></div>
<div class="line"><span class="lineno">  226</span>    NodeData nd=parents[i]-&gt;current_nodedata();</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">if</span>(nd.stage&gt;max_stage) max_stage=nd.stage;</div>
<div class="line"><span class="lineno">  228</span>    <span class="keywordflow">for</span>(nptr=parent_node_data.begin();nptr!=parent_node_data.end();++nptr)</div>
<div class="line"><span class="lineno">  229</span>    {</div>
<div class="line"><span class="lineno">  230</span>      <span class="comment">/*Adding to nodes multimap has a complication.  It is possible in</span></div>
<div class="line"><span class="lineno">  231</span><span class="comment">      some situations to have duplicate node data coming from different</span></div>
<div class="line"><span class="lineno">  232</span><span class="comment">      inputs.  The method we use to reconstruct the processing history tree</span></div>
<div class="line"><span class="lineno">  233</span><span class="comment">      will be confused by such duplicates so we need to test for pure</span></div>
<div class="line"><span class="lineno">  234</span><span class="comment">      duplicates in NodeData values. This algorithm would not scale well</span></div>
<div class="line"><span class="lineno">  235</span><span class="comment">      if the number of values with a common key is large for either</span></div>
<div class="line"><span class="lineno">  236</span><span class="comment">      this or parent[i]*/</span></div>
<div class="line"><span class="lineno">  237</span>      <span class="keywordtype">string</span> key(nptr-&gt;first);</div>
<div class="line"><span class="lineno">  238</span>      <span class="keywordflow">if</span>(this-&gt;nodes.count(key)&gt;0)</div>
<div class="line"><span class="lineno">  239</span>      {</div>
<div class="line"><span class="lineno">  240</span>        nl=this-&gt;nodes.lower_bound(key);</div>
<div class="line"><span class="lineno">  241</span>        nu=this-&gt;nodes.upper_bound(key);</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span> ptr=nl;ptr!=nu;++ptr)</div>
<div class="line"><span class="lineno">  243</span>        {</div>
<div class="line"><span class="lineno">  244</span>          NodeData ndtest(ptr-&gt;second);</div>
<div class="line"><span class="lineno">  245</span>          <span class="keywordflow">if</span>(ndtest != (nptr-&gt;second))</div>
<div class="line"><span class="lineno">  246</span>          {</div>
<div class="line"><span class="lineno">  247</span>            this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  248</span>          }</div>
<div class="line"><span class="lineno">  249</span>        }</div>
<div class="line"><span class="lineno">  250</span>      }</div>
<div class="line"><span class="lineno">  251</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  252</span>      {</div>
<div class="line"><span class="lineno">  253</span>        <span class="comment">/* No problem just inserting a node if there were no previous</span></div>
<div class="line"><span class="lineno">  254</span><span class="comment">        entries*/</span></div>
<div class="line"><span class="lineno">  255</span>        this-&gt;nodes.insert(*nptr);</div>
<div class="line"><span class="lineno">  256</span>      }</div>
<div class="line"><span class="lineno">  257</span>    }</div>
<div class="line"><span class="lineno">  258</span>    <span class="comment">/* Also insert the head data */</span></div>
<div class="line"><span class="lineno">  259</span>    pair&lt;string,NodeData&gt; pnd(current_id,nd);</div>
<div class="line"><span class="lineno">  260</span>    this-&gt;nodes.insert(pnd);</div>
<div class="line"><span class="lineno">  261</span>  }</div>
<div class="line"><span class="lineno">  262</span>  current_stage=max_stage;</div>
<div class="line"><span class="lineno">  263</span>  <span class="comment">/* Now reset the current contents to make it the base of the history tree.</span></div>
<div class="line"><span class="lineno">  264</span><span class="comment">  Be careful of uninitialized current_stage*/</span></div>
<div class="line"><span class="lineno">  265</span>  <span class="keywordflow">if</span>(current_stage&gt;=0)</div>
<div class="line"><span class="lineno">  266</span>    ++current_stage;</div>
<div class="line"><span class="lineno">  267</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  268</span>  {</div>
<div class="line"><span class="lineno">  269</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(<span class="stringliteral">&quot;ProcessingHistory::new_ensemble_process&quot;</span>,</div>
<div class="line"><span class="lineno">  270</span>      <span class="stringliteral">&quot;current_stage for none of the parents was initialized\nImproper usage will create an invalid history chain that may cause downstream problems&quot;</span>,</div>
<div class="line"><span class="lineno">  271</span>       ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  272</span>    current_stage=0;</div>
<div class="line"><span class="lineno">  273</span>  }</div>
<div class="line"><span class="lineno">  274</span>  algorithm=alg;</div>
<div class="line"><span class="lineno">  275</span>  algid=algid_in;</div>
<div class="line"><span class="lineno">  276</span>  <span class="comment">// note this is output type - inputs can be variable and defined by nodes</span></div>
<div class="line"><span class="lineno">  277</span>  mytype=typ;</div>
<div class="line"><span class="lineno">  278</span>  current_status=ProcessingStatus::VOLATILE;</div>
<div class="line"><span class="lineno">  279</span>  <span class="keywordflow">return</span> current_id;</div>
<div class="line"><span class="lineno">  280</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a42865512c68a26b85b394825a1629729"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">mspass::utility::ProcessingHistory::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:677</div></div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a52b0394b444f6db307945284ac6e5f8a"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">mspass::utility::ProcessingHistory::get_nodes</a></div><div class="ttdeci">std::multimap&lt; std::string, mspass::utility::NodeData &gt; get_nodes() const</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:657</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">clear()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a52b0394b444f6db307945284ac6e5f8a">get_nodes()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a8e42309bb4dfb0c0ea38496a3235f069">is_empty()</a>, <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>, <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid()</a>, and <a class="el" href="classmspass_1_1utility_1_1_node_data.html#a972bd00dc85cae2e490833225f53e282">mspass::utility::NodeData::stage</a>.</p>

</div>
</div>
<a id="ae0225ef6ba03dc64ebb711bb54b1554d" name="ae0225ef6ba03dc64ebb711bb54b1554d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0225ef6ba03dc64ebb711bb54b1554d">&#9670;&#160;</a></span>new_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mspass::utility::ProcessingHistory::new_map </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>data_to_clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProcessingStatus&#160;</td>
          <td class="paramname"><em>newstatus</em> = <code>ProcessingStatus::VOLATILE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define this algorithm as a one-to-one map. </p>
<p>Many algorithms define a one-to-one map where each one input data object creates one output data object. This class allows the input and output to be different data types requiring only that one input will map to one output. It differs from the overloaded method with fewer arguments in that it should be used if you need to clear and refresh the history chain for any reason. Known examples are creating simulation waveforms for testing within a workflow that have no prior history data loaded but which clone some properties of another piece of data. This method should be used in any situation where the history chain in the current data is wrong but the contents are the linked to some other process chain. It is supplied to cover odd cases, but use will likely be rare.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>is the algorithm names to assign to the origin node. This would normally be name defining the algorithm that makes sense to a human. </td></tr>
    <tr><td class="paramname">algid</td><td>is an id designator to uniquely define an instance of algorithm. Note that algid must itself be a unique keyword or the history chains will get scrambled. alg is mostly carried as baggage to make output more easily comprehended without additional lookups. </td></tr>
    <tr><td class="paramname">typ</td><td>defines the data type (C++ class) the algorithm that is generating this data will create. </td></tr>
    <tr><td class="paramname">data_to_clone</td><td>is reference to the <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> section of a parent data object that should be used to override the existing history chain. </td></tr>
    <tr><td class="paramname">newstatus</td><td>is how the status marking for the output. Normal (default) would be VOLATILE. This argument was included mainly for flexibility in case we wanted to extend the allowed entries in ProcessingStatus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75af2861c06a905968cc9c727b8cc877" name="a75af2861c06a905968cc9c727b8cc877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75af2861c06a905968cc9c727b8cc877">&#9670;&#160;</a></span>new_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mspass::utility::ProcessingHistory::new_map </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ProcessingStatus&#160;</td>
          <td class="paramname"><em>newstatus</em> = <code>ProcessingStatus::VOLATILE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define this algorithm as a one-to-one map of same type data. </p>
<p>Many algorithms define a one-to-one map where each one input data object creates one output data object. This (overloaded) version of this method is most appropriate when input and output are the same type and the history chain (<a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a>) is what the new algorithm will alter to make the result when it finishes. Use the overloaded version with a separate <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a> copy if the current object's data are not correct. In this algorithm the chain for this algorithm is simply appended with new definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>is the algorithm names to assign to the origin node. This would normally be name defining the algorithm that makes sense to a human. </td></tr>
    <tr><td class="paramname">algid</td><td>is an id designator to uniquely define an instance of algorithm. Note that algid must itself be a unique keyword or the history chains will get scrambled. alg is mostly carried as baggage to make output more easily comprehended without additional lookups. </td></tr>
    <tr><td class="paramname">typ</td><td>defines the data type (C++ class) the algorithm that is generating this data will create. </td></tr>
    <tr><td class="paramname">newstatus</td><td>is how the status marking for the output. Normal (default) would be VOLATILE. This argument was included mainly for flexibility in case we wanted to extend the allowed entries in ProcessingStatus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8bf8bc3632660c91fd9d82a79f8411" name="a9a8bf8bc3632660c91fd9d82a79f8411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8bf8bc3632660c91fd9d82a79f8411">&#9670;&#160;</a></span>newid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string mspass::utility::ProcessingHistory::newid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new id.</p>
<p>This creates a new uuid - how is an implementation detail but here we use boost's random number generator uuid generator that has some absurdly small probability of generating two equal ids. It returns the string representation of the id created. </p>
<div class="fragment"><div class="line"><span class="lineno">  701</span>{</div>
<div class="line"><span class="lineno">  702</span>  boost::uuids::random_generator gen;</div>
<div class="line"><span class="lineno">  703</span>  boost::uuids::uuid uuidval;</div>
<div class="line"><span class="lineno">  704</span>  uuidval=gen();</div>
<div class="line"><span class="lineno">  705</span>  this-&gt;current_id=boost::uuids::to_string(uuidval);</div>
<div class="line"><span class="lineno">  706</span>  <span class="keywordflow">return</span> current_id;</div>
<div class="line"><span class="lineno">  707</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82d681c60d2e64fab12b92e3244ce052" name="a82d681c60d2e64fab12b92e3244ce052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d681c60d2e64fab12b92e3244ce052">&#9670;&#160;</a></span>number_inputs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::utility::ProcessingHistory::number_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of inputs used to create current data.</p>
<p>In a number of contexts it can be useful to know the number of inputs defined for the current object. This returns that count. </p>
<div class="fragment"><div class="line"><span class="lineno">  697</span>{</div>
<div class="line"><span class="lineno">  698</span>  <span class="keywordflow">return</span> this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a82d681c60d2e64fab12b92e3244ce052">number_inputs</a>(current_id);</div>
<div class="line"><span class="lineno">  699</span>}</div>
<div class="ttc" id="aclassmspass_1_1utility_1_1_processing_history_html_a82d681c60d2e64fab12b92e3244ce052"><div class="ttname"><a href="classmspass_1_1utility_1_1_processing_history.html#a82d681c60d2e64fab12b92e3244ce052">mspass::utility::ProcessingHistory::number_inputs</a></div><div class="ttdeci">int number_inputs() const</div><div class="ttdef"><b>Definition</b> ProcessingHistory.cc:696</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a82d681c60d2e64fab12b92e3244ce052">number_inputs()</a>.</p>

</div>
</div>
<a id="a95006e7f8009c6d9a5c43d7e086c441b" name="a95006e7f8009c6d9a5c43d7e086c441b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95006e7f8009c6d9a5c43d7e086c441b">&#9670;&#160;</a></span>number_inputs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::utility::ProcessingHistory::number_inputs </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uuidstr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of inputs defined for any data in the process chain.</p>
<p>This overloaded version of number_inputs asks for the number of inputs defined for an arbitrary uuid. This is useful only if backtracing the ancestory of a child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uuidstr</td><td>is the uuid string to check in the ancestory record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04eaa592369744d85f54da21b8de9776" name="a04eaa592369744d85f54da21b8de9776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eaa592369744d85f54da21b8de9776">&#9670;&#160;</a></span>number_of_stages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mspass::utility::ProcessingHistory::number_of_stages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of processing stages that have been applied to this object. </p>
<p>One might want to know how many processing steps have been previously applied to produce the current data. For linear algorithms that would be useful only in debugging, but for an iterative algorithm it can be essential to avoid infinite loops with a loop limit parameter. This method returns how many times something has been done to alter the associated data. It returns 0 if the data are raw.</p>
<p>Important note is that the number return is the number of processing steps since the last save. Because a save operation is assumed to save the history chain then flush it there is not easy way at present to keep track of the total number of stages. If we really need this functionality it could be easily retrofitted with another private variable that is not reset when the clear method is called. </p>

<p>Reimplemented from <a class="el" href="classmspass_1_1utility_1_1_basic_processing_history.html#ac02ca16b83b616ade105d6694ffb6f7d">mspass::utility::BasicProcessingHistory</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  149</span>{</div>
<div class="line"><span class="lineno">  150</span>  <span class="keywordflow">return</span> current_stage;</div>
<div class="line"><span class="lineno">  151</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6203063df0564c57f28d76f8d5969ac" name="ab6203063df0564c57f28d76f8d5969ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6203063df0564c57f28d76f8d5969ac">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp; mspass::utility::ProcessingHistory::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_processing_history.html">ProcessingHistory</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. <br  />
 </p>
<div class="fragment"><div class="line"><span class="lineno">  742</span>{</div>
<div class="line"><span class="lineno">  743</span>  <span class="keywordflow">if</span>(<span class="keyword">this</span>!=(&amp;parent))</div>
<div class="line"><span class="lineno">  744</span>  {</div>
<div class="line"><span class="lineno">  745</span>    this-&gt;BasicProcessingHistory::operator=(parent);</div>
<div class="line"><span class="lineno">  746</span>    nodes=parent.nodes;</div>
<div class="line"><span class="lineno">  747</span>    current_status=parent.current_status;</div>
<div class="line"><span class="lineno">  748</span>    current_id=parent.current_id;</div>
<div class="line"><span class="lineno">  749</span>    current_stage=parent.current_stage;</div>
<div class="line"><span class="lineno">  750</span>    mytype=parent.mytype;</div>
<div class="line"><span class="lineno">  751</span>    algorithm=parent.algorithm;</div>
<div class="line"><span class="lineno">  752</span>    algid=parent.algid;</div>
<div class="line"><span class="lineno">  753</span>    elog=parent.elog;</div>
<div class="line"><span class="lineno">  754</span>  }</div>
<div class="line"><span class="lineno">  755</span>  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  756</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0621aa8adf8ebaab44a375a299c14fd8" name="a0621aa8adf8ebaab44a375a299c14fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0621aa8adf8ebaab44a375a299c14fd8">&#9670;&#160;</a></span>set_as_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::set_as_origin </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtomicType&#160;</td>
          <td class="paramname"><em>typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_as_raw</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set to define this as the top origin of a history chain.</p>
<p>This method should be called when a new object is created to initialize the history as an origin. Note again an origin may be raw but not all origins are define as raw. This interface controls that through the boolean define_as_raw (false by default). python wrappers should define an alternate set_as_raw method that calls this method with define_as_raw set true.</p>
<p>It is VERY IMPORTANT to realize that the uuid argument passed to this method is if fundamental importance. That string is assumed to be a uuid that can be linked to either a parent data object read from storage and/or linked to a history chain saved by a prior run. It becomes the current_id for the data to which this object is a parent. This method also always does two things that define how the contents can be used. current_stage is ALWAYS set 0. We distinguish a pure origin from an intermediate save ONLY by the status value saved in the history chain. That is, only uuids with status set to RAW are viewed as guaranteed to be stored. A record marked ORIGIN is assumed to passed through save operation. To retrieve the history chain from multiple runs the pieces have to be pieced together by history data stored in MongoDB.</p>
<p>The contents of the history data structures should be empty when this method is called. That would be the norm for any constructor except those that make a deep copy. If unsure the clear method should be called before this method is called. If it isn't empty it will be cleared anyway and a complaint message will be posted to elog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alg</td><td>is the algorithm names to assign to the origin node. This would normally be a reader name, but it could be a synthetic generator. </td></tr>
    <tr><td class="paramname">algid</td><td>is an id designator to uniquely define an instance of algorithm. Note that algid must itself be a unique keyword or the history chains will get scrambled. </td></tr>
    <tr><td class="paramname">uuid</td><td>unique if for this data object (see note above) </td></tr>
    <tr><td class="paramname">typ</td><td>defines the data type (C++ class) "this" points to. It might be possible to determine this dynamically, but a design choice was to only allow registered classes through this mechanism. i.e. the enum class typ implements has a finite number of C++ classes it accepts. The type must be a child <a class="el" href="classmspass_1_1utility_1_1_processing_history.html" title="Lightweight class to preserve procesing chain of atomic objects.">ProcessingHistory</a>. </td></tr>
    <tr><td class="paramname">define_as_raw</td><td>sets status as RAW if true and ORIGIN otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Never</td><td>throws an exception BUT this method will post a complaint to elog if the history data structures are not empty and it the clear method needs to be called internally. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  163</span>{</div>
<div class="line"><span class="lineno">  164</span>  <span class="keyword">const</span> <span class="keywordtype">string</span> base_error(<span class="stringliteral">&quot;ProcessingHistory::set_as_origin:  &quot;</span>);</div>
<div class="line"><span class="lineno">  165</span>  <span class="keywordflow">if</span>( nodes.size()&gt;0 )</div>
<div class="line"><span class="lineno">  166</span>  {</div>
<div class="line"><span class="lineno">  167</span>    elog.<a class="code hl_function" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">log_error</a>(alg+<span class="stringliteral">&quot;:&quot;</span>+algid_in,</div>
<div class="line"><span class="lineno">  168</span>      base_error + <span class="stringliteral">&quot;Illegal usage.  History chain was not empty.   Calling clear method and continuing&quot;</span>,</div>
<div class="line"><span class="lineno">  169</span>       ErrorSeverity::Complaint);</div>
<div class="line"><span class="lineno">  170</span>    this-&gt;<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">clear</a>();</div>
<div class="line"><span class="lineno">  171</span>  }</div>
<div class="line"><span class="lineno">  172</span>  <span class="keywordflow">if</span>(define_as_raw)</div>
<div class="line"><span class="lineno">  173</span>  {</div>
<div class="line"><span class="lineno">  174</span>    current_status=ProcessingStatus::RAW;</div>
<div class="line"><span class="lineno">  175</span>  }</div>
<div class="line"><span class="lineno">  176</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  177</span>  {</div>
<div class="line"><span class="lineno">  178</span>    current_status=ProcessingStatus::ORIGIN;</div>
<div class="line"><span class="lineno">  179</span>  }</div>
<div class="line"><span class="lineno">  180</span>  algorithm=alg;</div>
<div class="line"><span class="lineno">  181</span>  algid=algid_in;</div>
<div class="line"><span class="lineno">  182</span>  current_id=uuid;</div>
<div class="line"><span class="lineno">  183</span>  mytype=typ;</div>
<div class="line"><span class="lineno">  184</span>  <span class="comment">/* Origin/raw are always defined as stage 0 even after a save. */</span></div>
<div class="line"><span class="lineno">  185</span>  current_stage=0;</div>
<div class="line"><span class="lineno">  186</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a42865512c68a26b85b394825a1629729">clear()</a>, and <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>.</p>

</div>
</div>
<a id="aec67690fe76c0d6c41dc096bc2f400ae" name="aec67690fe76c0d6c41dc096bc2f400ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec67690fe76c0d6c41dc096bc2f400ae">&#9670;&#160;</a></span>set_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::utility::ProcessingHistory::set_id </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>newid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the uuid manually.</p>
<p>It may occasionally be necessary to create a uuid by some other mechanism. This allows that, but this method should be used with caution and only if you understand the consequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newid</td><td>is string definition to use for the id. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  709</span>{</div>
<div class="line"><span class="lineno">  710</span>  this-&gt;current_id=<a class="code hl_function" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid</a>;</div>
<div class="line"><span class="lineno">  711</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1utility_1_1_processing_history.html#a9a8bf8bc3632660c91fd9d82a79f8411">newid()</a>.</p>

</div>
</div>
<a id="afe65cff0547c9b75ea3ce9a7aa6b20f7" name="afe65cff0547c9b75ea3ce9a7aa6b20f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe65cff0547c9b75ea3ce9a7aa6b20f7">&#9670;&#160;</a></span>stage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::utility::ProcessingHistory::stage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current stage count for this object.</p>
<p>We maintain a counter of the number of processing steps that have been applied to produce this data object. This simple method returns that counter. With this implementation this is identical to number_of_stages. We retain it in the API in the event we want to implement an accumulating counter. </p>
<div class="fragment"><div class="line"><span class="lineno">  596</span>  {</div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">return</span> current_stage;</div>
<div class="line"><span class="lineno">  598</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ef35389afcd6d4305442a3720398a34" name="a1ef35389afcd6d4305442a3720398a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef35389afcd6d4305442a3720398a34">&#9670;&#160;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ProcessingStatus mspass::utility::ProcessingHistory::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current status definition (an enum). </p>
<div class="fragment"><div class="line"><span class="lineno">  601</span>  {</div>
<div class="line"><span class="lineno">  602</span>    <span class="keywordflow">return</span> current_status;</div>
<div class="line"><span class="lineno">  603</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/utility/<a class="el" href="_processing_history_8h_source.html">ProcessingHistory.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/utility/<b>ProcessingHistory.cc</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
