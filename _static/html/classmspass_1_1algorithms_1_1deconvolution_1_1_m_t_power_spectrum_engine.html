<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::algorithms::deconvolution::MTPowerSpectrumEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><b>deconvolution</b></li><li class="navelem"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mspass::algorithms::deconvolution::MTPowerSpectrumEngine Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Multittaper power spectral estimator.  
 <a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_t_power_spectrum_engine_8h_source.html">MTPowerSpectrumEngine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a509f3db8c91ae8e97b241bd5da67cd61" id="r_a509f3db8c91ae8e97b241bd5da67cd61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a509f3db8c91ae8e97b241bd5da67cd61">MTPowerSpectrumEngine</a> ()</td></tr>
<tr class="separator:a509f3db8c91ae8e97b241bd5da67cd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0ce9c1b2c9248d46ab794bf01d42b0" id="r_afa0ce9c1b2c9248d46ab794bf01d42b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#afa0ce9c1b2c9248d46ab794bf01d42b0">MTPowerSpectrumEngine</a> (const int winsize, const double tbp, const int ntapers, const int nfftin=-1, const double dtin=1.0)</td></tr>
<tr class="memdesc:afa0ce9c1b2c9248d46ab794bf01d42b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct with full definition.  <br /></td></tr>
<tr class="separator:afa0ce9c1b2c9248d46ab794bf01d42b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678a1167722867cfb20acc0c56932882" id="r_a678a1167722867cfb20acc0c56932882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a678a1167722867cfb20acc0c56932882">MTPowerSpectrumEngine</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp;parent)</td></tr>
<tr class="separator:a678a1167722867cfb20acc0c56932882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232d61152acbe74c6a890a662f89c63" id="r_a8232d61152acbe74c6a890a662f89c63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a8232d61152acbe74c6a890a662f89c63">~MTPowerSpectrumEngine</a> ()</td></tr>
<tr class="separator:a8232d61152acbe74c6a890a662f89c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51379e47b45995eb44c519c2672de77b" id="r_a51379e47b45995eb44c519c2672de77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a51379e47b45995eb44c519c2672de77b">operator=</a> (const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp;parent)</td></tr>
<tr class="separator:a51379e47b45995eb44c519c2672de77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c10c25ea2c6b82cf8bbe2991f16bfe" id="r_aa3c10c25ea2c6b82cf8bbe2991f16bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_power_spectrum.html">mspass::seismic::PowerSpectrum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#aa3c10c25ea2c6b82cf8bbe2991f16bfe">apply</a> (const <a class="el" href="classmspass_1_1seismic_1_1_time_series.html">mspass::seismic::TimeSeries</a> &amp;d)</td></tr>
<tr class="separator:aa3c10c25ea2c6b82cf8bbe2991f16bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab679e58c66c0c4a332350c7f4282e806" id="r_ab679e58c66c0c4a332350c7f4282e806"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#ab679e58c66c0c4a332350c7f4282e806">apply</a> (const std::vector&lt; double &gt; &amp;d)</td></tr>
<tr class="memdesc:ab679e58c66c0c4a332350c7f4282e806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level processing of vector of data.  <br /></td></tr>
<tr class="separator:ab679e58c66c0c4a332350c7f4282e806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada36c092fdc3aa128be8eb25d00349d6" id="r_ada36c092fdc3aa128be8eb25d00349d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#ada36c092fdc3aa128be8eb25d00349d6">df</a> () const</td></tr>
<tr class="separator:ada36c092fdc3aa128be8eb25d00349d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626438cc21ade06cfa7053c324ae58b4" id="r_a626438cc21ade06cfa7053c324ae58b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a626438cc21ade06cfa7053c324ae58b4">frequencies</a> ()</td></tr>
<tr class="separator:a626438cc21ade06cfa7053c324ae58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114db709279ea8ab275ba69fbdcbec13" id="r_a114db709279ea8ab275ba69fbdcbec13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a114db709279ea8ab275ba69fbdcbec13">taper_length</a> () const</td></tr>
<tr class="separator:a114db709279ea8ab275ba69fbdcbec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf94d6d1dff859884d9c0aa1719994a" id="r_accf94d6d1dff859884d9c0aa1719994a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#accf94d6d1dff859884d9c0aa1719994a">time_bandwidth_product</a> () const</td></tr>
<tr class="separator:accf94d6d1dff859884d9c0aa1719994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4b650fdedd815652c1e4e86a0e715" id="r_a10d4b650fdedd815652c1e4e86a0e715"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a10d4b650fdedd815652c1e4e86a0e715">number_tapers</a> () const</td></tr>
<tr class="separator:a10d4b650fdedd815652c1e4e86a0e715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaabbb574b28194bde51e45d1cfd2787" id="r_afaabbb574b28194bde51e45d1cfd2787"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#afaabbb574b28194bde51e45d1cfd2787">fftsize</a> () const</td></tr>
<tr class="separator:afaabbb574b28194bde51e45d1cfd2787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ea0259803f6cac1c5e8166541b2f51" id="r_af7ea0259803f6cac1c5e8166541b2f51"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">dt</a> ()</td></tr>
<tr class="separator:af7ea0259803f6cac1c5e8166541b2f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dadcf9ec587fa2d48d04066ba1d55b4" id="r_a1dadcf9ec587fa2d48d04066ba1d55b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a1dadcf9ec587fa2d48d04066ba1d55b4">set_df</a> (double <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">dt</a>)</td></tr>
<tr class="memdesc:a1dadcf9ec587fa2d48d04066ba1d55b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Putter equivalent of df.  <br /></td></tr>
<tr class="separator:a1dadcf9ec587fa2d48d04066ba1d55b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92db35500eda333738d2c650e0b6d82f" id="r_a92db35500eda333738d2c650e0b6d82f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">nf</a> ()</td></tr>
<tr class="separator:a92db35500eda333738d2c650e0b6d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Multittaper power spectral estimator. </p>
<p>The multitaper method uses averages of spectra windowed by Slepian functions. This class can be used to compute power spectra. For efficiency the design has constructors that build the Slepian functions and cache them in a private area. We use this model because computing spectra on a large data set in parallel will usually be done with a fixed time window. The expected use is that normally the engine is created once and passed as an argument to functions using it in a map operator.</p>
<p>This class uses the apply model for processing. It accepts raw vector or TimeSeries data. The former assumes the sample interval is 1 while the second scales the spectrum to have units of 1/Hz. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a509f3db8c91ae8e97b241bd5da67cd61" name="a509f3db8c91ae8e97b241bd5da67cd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509f3db8c91ae8e97b241bd5da67cd61">&#9670;&#160;</a></span>MTPowerSpectrumEngine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::MTPowerSpectrumEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Do not use as it produces a null object that is no functional. </p>
<div class="fragment"><div class="line"><span class="lineno">   17</span>                                             {</div>
<div class="line"><span class="lineno">   18</span>  taperlen = 0;</div>
<div class="line"><span class="lineno">   19</span>  ntapers = 0;</div>
<div class="line"><span class="lineno">   20</span>  nfft = 0;</div>
<div class="line"><span class="lineno">   21</span>  tbp = 0.0;</div>
<div class="line"><span class="lineno">   22</span>  deltaf = 1.0;</div>
<div class="line"><span class="lineno">   23</span>  operator_dt = 1.0;</div>
<div class="line"><span class="lineno">   24</span>  wavetable = NULL;</div>
<div class="line"><span class="lineno">   25</span>  workspace = NULL;</div>
<div class="line"><span class="lineno">   26</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afa0ce9c1b2c9248d46ab794bf01d42b0" name="afa0ce9c1b2c9248d46ab794bf01d42b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0ce9c1b2c9248d46ab794bf01d42b0">&#9670;&#160;</a></span>MTPowerSpectrumEngine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::MTPowerSpectrumEngine </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>winsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tbp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ntapers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nfftin</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dtin</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct with full definition. </p>
<p>This should be the normal constructor used to create this object. It creates and caches the Slepian tapers that are used on calls the apply method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">winsize</td><td>is the length of time windows in samples the operator will be designed to compute. </td></tr>
    <tr><td class="paramname">tbp</td><td>is the time bandwidth product to use for the operator. </td></tr>
    <tr><td class="paramname">ntapers</td><td>is the number of tapers to actually use for the operator. Note the maximum ntapers is always int(tbp*2). If ntapers is more than 2*tbp a mesage will be posted to cerr and ntapers set to tbp*2. </td></tr>
    <tr><td class="paramname">nfftin</td><td>is the size of the fft workspace to use for computation. When less than the winsize (the default forces this) set to 2*winsize+1. </td></tr>
    <tr><td class="paramname">dtin</td><td>sets the operator sample interval stored in the object and used to compute frequency bin size from fft length. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   30</span>                                                                {</div>
<div class="line"><span class="lineno">   31</span>  taperlen = winsize;</div>
<div class="line"><span class="lineno">   32</span>  tbp = tbpin;</div>
<div class="line"><span class="lineno">   33</span>  ntapers = ntpin;</div>
<div class="line"><span class="lineno">   34</span>  <span class="keywordflow">if</span> (nfftin &lt; winsize) {</div>
<div class="line"><span class="lineno">   35</span>    nfft = nextPowerOf2(winsize);</div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">if</span> (nfft == winsize)</div>
<div class="line"><span class="lineno">   37</span>      nfft = 2 * winsize;</div>
<div class="line"><span class="lineno">   38</span>  } <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   39</span>    nfft = nfftin;</div>
<div class="line"><span class="lineno">   40</span>  operator_dt = dtin;</div>
<div class="line"><span class="lineno">   41</span>  this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a1dadcf9ec587fa2d48d04066ba1d55b4">set_df</a>(dtin);</div>
<div class="line"><span class="lineno">   42</span>  <span class="keywordtype">int</span> nseq = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(2.0 * tbp);</div>
<div class="line"><span class="lineno">   43</span>  <span class="keywordflow">if</span> (ntapers &gt; nseq) {</div>
<div class="line"><span class="lineno">   44</span>    cerr &lt;&lt; <span class="stringliteral">&quot;MTPowerSpectrumEngine (WARNING):  requested number of tapers=&quot;</span></div>
<div class="line"><span class="lineno">   45</span>         &lt;&lt; ntpin &lt;&lt; endl</div>
<div class="line"><span class="lineno">   46</span>         &lt;&lt; <span class="stringliteral">&quot;is inconsistent with requested time time bandwidth product =&quot;</span></div>
<div class="line"><span class="lineno">   47</span>         &lt;&lt; tbp &lt;&lt; endl</div>
<div class="line"><span class="lineno">   48</span>         &lt;&lt; <span class="stringliteral">&quot;Automatically reset number tapers to max allowed=&quot;</span> &lt;&lt; nseq &lt;&lt; endl;</div>
<div class="line"><span class="lineno">   49</span>    ntapers = nseq;</div>
<div class="line"><span class="lineno">   50</span>  }</div>
<div class="line"><span class="lineno">   51</span>  <span class="keywordtype">int</span> seql(0);</div>
<div class="line"><span class="lineno">   52</span>  <span class="keywordtype">int</span> sequ = ntapers - 1;</div>
<div class="line"><span class="lineno">   53</span>  <span class="keywordtype">double</span> *work = <span class="keyword">new</span> <span class="keywordtype">double</span>[ntapers * taperlen];</div>
<div class="line"><span class="lineno">   54</span>  dpss_calc(taperlen, tbp, seql, sequ, work);</div>
<div class="line"><span class="lineno">   55</span>  tapers = dmatrix(ntapers, taperlen);</div>
<div class="line"><span class="lineno">   56</span>  <span class="keywordtype">int</span> i, ii, j;</div>
<div class="line"><span class="lineno">   57</span>  <span class="keywordflow">for</span> (i = 0, ii = 0; i &lt; ntapers; ++i) {</div>
<div class="line"><span class="lineno">   58</span>    <span class="keywordflow">for</span> (j = 0; j &lt; taperlen; ++j) {</div>
<div class="line"><span class="lineno">   59</span>      tapers(i, j) = work[ii];</div>
<div class="line"><span class="lineno">   60</span>      ++ii;</div>
<div class="line"><span class="lineno">   61</span>    }</div>
<div class="line"><span class="lineno">   62</span>  }</div>
<div class="line"><span class="lineno">   63</span>  <span class="keyword">delete</span>[] work;</div>
<div class="line"><span class="lineno">   64</span>  <span class="comment">/* To be consistent with Prieto we use this algorithm to convert to</span></div>
<div class="line"><span class="lineno">   65</span><span class="comment">  what he calls the &quot;positive standard&quot;.   That means we assure the</span></div>
<div class="line"><span class="lineno">   66</span><span class="comment">  center point is positive.</span></div>
<div class="line"><span class="lineno">   67</span><span class="comment">  */</span></div>
<div class="line"><span class="lineno">   68</span>  <span class="keywordflow">for</span> (i = 0; i &lt; ntapers; ++i) {</div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordtype">int</span> lh; <span class="comment">// matches Prieto algorithm name - see multitaper module</span></div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">if</span> (taperlen % 2)</div>
<div class="line"><span class="lineno">   71</span>      lh = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>((taperlen + 1) / 2);</div>
<div class="line"><span class="lineno">   72</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   73</span>      lh = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(taperlen / 2);</div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">if</span> (tapers(i, lh) &lt; 0.0) {</div>
<div class="line"><span class="lineno">   75</span>      <span class="keywordflow">for</span> (j = 0; j &lt; taperlen; ++j)</div>
<div class="line"><span class="lineno">   76</span>        tapers(i, j) = -tapers(i, j);</div>
<div class="line"><span class="lineno">   77</span>    }</div>
<div class="line"><span class="lineno">   78</span>  }</div>
<div class="line"><span class="lineno">   79</span>  wavetable = gsl_fft_complex_wavetable_alloc(nfft);</div>
<div class="line"><span class="lineno">   80</span>  workspace = gsl_fft_complex_workspace_alloc(nfft);</div>
<div class="line"><span class="lineno">   81</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine_html_a1dadcf9ec587fa2d48d04066ba1d55b4"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a1dadcf9ec587fa2d48d04066ba1d55b4">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::set_df</a></div><div class="ttdeci">double set_df(double dt)</div><div class="ttdoc">Putter equivalent of df.</div><div class="ttdef"><b>Definition</b> MTPowerSpectrumEngine.h:126</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a1dadcf9ec587fa2d48d04066ba1d55b4">set_df()</a>.</p>

</div>
</div>
<a id="a678a1167722867cfb20acc0c56932882" name="a678a1167722867cfb20acc0c56932882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678a1167722867cfb20acc0c56932882">&#9670;&#160;</a></span>MTPowerSpectrumEngine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::MTPowerSpectrumEngine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard copy constructor </p>
<div class="fragment"><div class="line"><span class="lineno">   84</span>    : tapers(parent.tapers) {</div>
<div class="line"><span class="lineno">   85</span>  taperlen = parent.taperlen;</div>
<div class="line"><span class="lineno">   86</span>  ntapers = parent.ntapers;</div>
<div class="line"><span class="lineno">   87</span>  nfft = parent.nfft;</div>
<div class="line"><span class="lineno">   88</span>  tbp = parent.tbp;</div>
<div class="line"><span class="lineno">   89</span>  operator_dt = parent.operator_dt;</div>
<div class="line"><span class="lineno">   90</span>  deltaf = parent.deltaf;</div>
<div class="line"><span class="lineno">   91</span>  wavetable = gsl_fft_complex_wavetable_alloc(nfft);</div>
<div class="line"><span class="lineno">   92</span>  workspace = gsl_fft_complex_workspace_alloc(nfft);</div>
<div class="line"><span class="lineno">   93</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8232d61152acbe74c6a890a662f89c63" name="a8232d61152acbe74c6a890a662f89c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232d61152acbe74c6a890a662f89c63">&#9670;&#160;</a></span>~MTPowerSpectrumEngine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::~MTPowerSpectrumEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Not trivial as it has to delete the fft workspace and cached tapers. </p>
<div class="fragment"><div class="line"><span class="lineno">   95</span>                                              {</div>
<div class="line"><span class="lineno">   96</span>  <span class="keywordflow">if</span> (wavetable != NULL)</div>
<div class="line"><span class="lineno">   97</span>    gsl_fft_complex_wavetable_free(wavetable);</div>
<div class="line"><span class="lineno">   98</span>  <span class="keywordflow">if</span> (workspace != NULL)</div>
<div class="line"><span class="lineno">   99</span>    gsl_fft_complex_workspace_free(workspace);</div>
<div class="line"><span class="lineno">  100</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3c10c25ea2c6b82cf8bbe2991f16bfe" name="aa3c10c25ea2c6b82cf8bbe2991f16bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c10c25ea2c6b82cf8bbe2991f16bfe">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1seismic_1_1_power_spectrum.html">PowerSpectrum</a> mspass::algorithms::deconvolution::MTPowerSpectrumEngine::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1seismic_1_1_time_series.html">mspass::seismic::TimeSeries</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\process a TimeSeries.</p>
<p>This is one of two methods for applying the multiaper algorithm to data. This one uses dt and data length to set the Rayleigh bin size (df). If the input data vector length is not the same as the operator length an elog complaint is posted to parent. Short data are processed but should be considered suspect unless the sizes differ by only a tiny fraction (e.g. and off by one error from rounding). Long data will be truncated on the right (i.e. sample 0 will be the start of the window used). The data return will be scaled to psd in units if 1/Hz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>is the data to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing estimated power spwecrum </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  116</span>                                                              {</div>
<div class="line"><span class="lineno">  117</span>  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  118</span>    <span class="keywordtype">int</span> k;</div>
<div class="line"><span class="lineno">  119</span>    <span class="comment">/* Used to test for operator sample interval against data sample interval.</span></div>
<div class="line"><span class="lineno">  120</span><span class="comment">    We don&#39;t use a epsilon comparison as slippery clock data sometime shave</span></div>
<div class="line"><span class="lineno">  121</span><span class="comment">    sample rates small percentage difference from nominal.*/</span></div>
<div class="line"><span class="lineno">  122</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> DT_FRACTION_TOLERANCE(0.001);</div>
<div class="line"><span class="lineno">  123</span>    <span class="keyword">const</span> <span class="keywordtype">string</span> algorithm(<span class="stringliteral">&quot;MTPowerSpectrumEngine&quot;</span>);</div>
<div class="line"><span class="lineno">  124</span>    <span class="comment">/* We need to define this here to allow posting problems to elog.*/</span></div>
<div class="line"><span class="lineno">  125</span>    PowerSpectrum result;</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordtype">int</span> dsize = d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">npts</a>();</div>
<div class="line"><span class="lineno">  127</span>    vector&lt;double&gt; work;</div>
<div class="line"><span class="lineno">  128</span>    work.reserve(this-&gt;nfft);</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordtype">double</span> dtfrac = fabs(d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#af31c96c0e2173d7581e1c3a3f8bcfde8">dt</a>() - this-&gt;operator_dt) / this-&gt;operator_dt;</div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">if</span> (dtfrac &gt; DT_FRACTION_TOLERANCE) {</div>
<div class="line"><span class="lineno">  131</span>      stringstream ss;</div>
<div class="line"><span class="lineno">  132</span>      ss &lt;&lt; <span class="stringliteral">&quot;Date sample interval=&quot;</span> &lt;&lt; d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#af31c96c0e2173d7581e1c3a3f8bcfde8">dt</a>()</div>
<div class="line"><span class="lineno">  133</span>         &lt;&lt; <span class="stringliteral">&quot; does not match operator sample interval=&quot;</span> &lt;&lt; this-&gt;operator_dt</div>
<div class="line"><span class="lineno">  134</span>         &lt;&lt; endl</div>
<div class="line"><span class="lineno">  135</span>         &lt;&lt; <span class="stringliteral">&quot;Cannot proceed.  Returning a null result&quot;</span>;</div>
<div class="line"><span class="lineno">  136</span>      result.elog.log_error(<span class="stringliteral">&quot;MTPowerSpectrumEngine::apply&quot;</span>, ss.str(),</div>
<div class="line"><span class="lineno">  137</span>                            ErrorSeverity::Invalid);</div>
<div class="line"><span class="lineno">  138</span>      result.kill();</div>
<div class="line"><span class="lineno">  139</span>      <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  140</span>    }</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">if</span> (dsize &lt; taperlen) {</div>
<div class="line"><span class="lineno">  143</span>      stringstream ss;</div>
<div class="line"><span class="lineno">  144</span>      ss &lt;&lt; <span class="stringliteral">&quot;Received data window of length=&quot;</span> &lt;&lt; d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">npts</a>() &lt;&lt; <span class="stringliteral">&quot; samples&quot;</span> &lt;&lt; endl</div>
<div class="line"><span class="lineno">  145</span>         &lt;&lt; <span class="stringliteral">&quot;Operator length=&quot;</span> &lt;&lt; taperlen &lt;&lt; endl</div>
<div class="line"><span class="lineno">  146</span>         &lt;&lt; <span class="stringliteral">&quot;Results may be unreliable&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  147</span>      result.elog.log_error(algorithm, <span class="keywordtype">string</span>(ss.str()),</div>
<div class="line"><span class="lineno">  148</span>                            ErrorSeverity::Suspect);</div>
<div class="line"><span class="lineno">  149</span>      <span class="keywordflow">for</span> (k = 0; k &lt; taperlen; ++k)</div>
<div class="line"><span class="lineno">  150</span>        work.push_back(0.0);</div>
<div class="line"><span class="lineno">  151</span>      <span class="keywordflow">for</span> (k = 0; k &lt; dsize; ++k)</div>
<div class="line"><span class="lineno">  152</span>        work[k] = d.<a class="code hl_variable" href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">s</a>[k];</div>
<div class="line"><span class="lineno">  153</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  154</span>      <span class="keywordflow">if</span> (dsize &gt; taperlen) {</div>
<div class="line"><span class="lineno">  155</span>        stringstream ss;</div>
<div class="line"><span class="lineno">  156</span>        ss &lt;&lt; <span class="stringliteral">&quot;Received data window of length=&quot;</span> &lt;&lt; d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">npts</a>() &lt;&lt; <span class="stringliteral">&quot; samples&quot;</span></div>
<div class="line"><span class="lineno">  157</span>           &lt;&lt; endl</div>
<div class="line"><span class="lineno">  158</span>           &lt;&lt; <span class="stringliteral">&quot;Operator length=&quot;</span> &lt;&lt; taperlen &lt;&lt; endl</div>
<div class="line"><span class="lineno">  159</span>           &lt;&lt; <span class="stringliteral">&quot;Results may be unreliable because data will be truncated to &quot;</span></div>
<div class="line"><span class="lineno">  160</span>              <span class="stringliteral">&quot;taper length&quot;</span></div>
<div class="line"><span class="lineno">  161</span>           &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  162</span>        result.elog.log_error(algorithm, ss.str(), ErrorSeverity::Suspect);</div>
<div class="line"><span class="lineno">  163</span>      }</div>
<div class="line"><span class="lineno">  164</span>      <span class="keywordflow">for</span> (k = 0; k &lt; taperlen; ++k)</div>
<div class="line"><span class="lineno">  165</span>        work.push_back(d.<a class="code hl_variable" href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">s</a>[k]);</div>
<div class="line"><span class="lineno">  166</span>    }</div>
<div class="line"><span class="lineno">  167</span>    <span class="comment">/* intentionally omit try catch here because the above logic assures Sizes</span></div>
<div class="line"><span class="lineno">  168</span><span class="comment">    must match here. This overloaded method will throw an exception in that</span></div>
<div class="line"><span class="lineno">  169</span><span class="comment">    case. Note in this implementation the result returned by apply is scaled to</span></div>
<div class="line"><span class="lineno">  170</span><span class="comment">    assumed properly scaled to power spectrum and normalized for multitapers.*/</span></div>
<div class="line"><span class="lineno">  171</span>    vector&lt;double&gt; spec(this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#aa3c10c25ea2c6b82cf8bbe2991f16bfe">apply</a>(work));</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>    result = PowerSpectrum(<span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span>Metadata &amp;<span class="keyword">&gt;</span>(d), spec, deltaf,</div>
<div class="line"><span class="lineno">  174</span>                           <span class="keywordtype">string</span>(<span class="stringliteral">&quot;Multitaper&quot;</span>), 0.0, d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#af31c96c0e2173d7581e1c3a3f8bcfde8">dt</a>(), d.<a class="code hl_function" href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">npts</a>());</div>
<div class="line"><span class="lineno">  175</span>    <span class="comment">/* We post these to metadata for the generic PowerSpectrum object. */</span></div>
<div class="line"><span class="lineno">  176</span>    result.put&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;time_bandwidth_product&quot;</span>, tbp);</div>
<div class="line"><span class="lineno">  177</span>    result.put&lt;<span class="keywordtype">long</span>&gt;(<span class="stringliteral">&quot;number_tapers&quot;</span>, ntapers);</div>
<div class="line"><span class="lineno">  178</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  179</span>  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">  181</span>  };</div>
<div class="line"><span class="lineno">  182</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine_html_aa3c10c25ea2c6b82cf8bbe2991f16bfe"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#aa3c10c25ea2c6b82cf8bbe2991f16bfe">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::apply</a></div><div class="ttdeci">mspass::seismic::PowerSpectrum apply(const mspass::seismic::TimeSeries &amp;d)</div><div class="ttdef"><b>Definition</b> MTPowerSpectrumEngine.cc:116</div></div>
<div class="ttc" id="aclassmspass_1_1seismic_1_1_basic_time_series_html_a347b349bb4e1f0e65978dfcd45ae3472"><div class="ttname"><a href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">mspass::seismic::BasicTimeSeries::npts</a></div><div class="ttdeci">size_t npts() const</div><div class="ttdef"><b>Definition</b> BasicTimeSeries.h:171</div></div>
<div class="ttc" id="aclassmspass_1_1seismic_1_1_basic_time_series_html_af31c96c0e2173d7581e1c3a3f8bcfde8"><div class="ttname"><a href="classmspass_1_1seismic_1_1_basic_time_series.html#af31c96c0e2173d7581e1c3a3f8bcfde8">mspass::seismic::BasicTimeSeries::dt</a></div><div class="ttdeci">double dt() const</div><div class="ttdef"><b>Definition</b> BasicTimeSeries.h:153</div></div>
<div class="ttc" id="aclassmspass_1_1seismic_1_1_core_time_series_html_ab044edb3fe5fe734cb577a4434f390a2"><div class="ttname"><a href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">mspass::seismic::CoreTimeSeries::s</a></div><div class="ttdeci">std::vector&lt; double &gt; s</div><div class="ttdef"><b>Definition</b> CoreTimeSeries.h:27</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#aa3c10c25ea2c6b82cf8bbe2991f16bfe">apply()</a>, <a class="el" href="classmspass_1_1seismic_1_1_basic_time_series.html#af31c96c0e2173d7581e1c3a3f8bcfde8">mspass::seismic::BasicTimeSeries::dt()</a>, <a class="el" href="classmspass_1_1seismic_1_1_power_spectrum.html#a920cd0761252df4312168f4571165f2b">mspass::seismic::PowerSpectrum::elog</a>, <a class="el" href="classmspass_1_1seismic_1_1_basic_spectrum.html#a7400b002f21460fece1d5519dfbc26c7">mspass::seismic::BasicSpectrum::kill()</a>, <a class="el" href="classmspass_1_1utility_1_1_error_logger.html#aa69873ba0aebf67e9ba24d01992c0bcf">mspass::utility::ErrorLogger::log_error()</a>, <a class="el" href="classmspass_1_1seismic_1_1_basic_time_series.html#a347b349bb4e1f0e65978dfcd45ae3472">mspass::seismic::BasicTimeSeries::npts()</a>, and <a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html#ab044edb3fe5fe734cb577a4434f390a2">mspass::seismic::CoreTimeSeries::s</a>.</p>

</div>
</div>
<a id="ab679e58c66c0c4a332350c7f4282e806" name="ab679e58c66c0c4a332350c7f4282e806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab679e58c66c0c4a332350c7f4282e806">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; mspass::algorithms::deconvolution::MTPowerSpectrumEngine::apply </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level processing of vector of data. </p>
<p>This is lower level function that processes a raw vector of data. Since it does not know the sample interval it cannot compute the rayleigh bin size so if callers need that feature they must do that (simple) calculation themselves. Unlike the TimeSeries method this one will throw an exception if the input data size does not match the operator size. It returns power spectral density assuming a sample rate of 1. i.e. it scales to correct for the gsl fft scaling by of the forward transform by N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is the vector of data to process. d.size() must this-&gt;taperlen() value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing estimated power spectrum (usual convention with 0 containing 0 frequency value) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throw</td><td>a MsPASSError if the size of d does not match operator length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada36c092fdc3aa128be8eb25d00349d6" name="ada36c092fdc3aa128be8eb25d00349d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada36c092fdc3aa128be8eb25d00349d6">&#9670;&#160;</a></span>df()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::deconvolution::MTPowerSpectrumEngine::df </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the frquency bin size defined for this operator. </p>
<div class="fragment"><div class="line"><span class="lineno">   92</span>{ <span class="keywordflow">return</span> deltaf; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="af7ea0259803f6cac1c5e8166541b2f51" name="af7ea0259803f6cac1c5e8166541b2f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ea0259803f6cac1c5e8166541b2f51">&#9670;&#160;</a></span>dt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::deconvolution::MTPowerSpectrumEngine::dt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the internally cached required data sample interval. </p>
<div class="fragment"><div class="line"><span class="lineno">  106</span>{ <span class="keywordflow">return</span> operator_dt; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="afaabbb574b28194bde51e45d1cfd2787" name="afaabbb574b28194bde51e45d1cfd2787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaabbb574b28194bde51e45d1cfd2787">&#9670;&#160;</a></span>fftsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MTPowerSpectrumEngine::fftsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return size of fft used by this operator - usually not the same as taper length. </p>
<div class="fragment"><div class="line"><span class="lineno">  104</span>{ <span class="keywordflow">return</span> nfft; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a626438cc21ade06cfa7053c324ae58b4" name="a626438cc21ade06cfa7053c324ae58b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626438cc21ade06cfa7053c324ae58b4">&#9670;&#160;</a></span>frequencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; mspass::algorithms::deconvolution::MTPowerSpectrumEngine::frequencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return and std::vector of all frequencies for spectral estimates this operator computes. </p>
<div class="fragment"><div class="line"><span class="lineno">  256</span>                                                  {</div>
<div class="line"><span class="lineno">  257</span>  vector&lt;double&gt; f;</div>
<div class="line"><span class="lineno">  258</span>  <span class="comment">/* If taperlen is odd this still works according to gsl documentation.*/</span></div>
<div class="line"><span class="lineno">  259</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">nf</a>(); ++i) {</div>
<div class="line"><span class="lineno">  260</span>    <span class="comment">/* Here we assume i=0 frequency is 0 */</span></div>
<div class="line"><span class="lineno">  261</span>    f.push_back(deltaf * ((<span class="keywordtype">double</span>)i));</div>
<div class="line"><span class="lineno">  262</span>  }</div>
<div class="line"><span class="lineno">  263</span>  <span class="keywordflow">return</span> f;</div>
<div class="line"><span class="lineno">  264</span>}</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine_html_a92db35500eda333738d2c650e0b6d82f"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::nf</a></div><div class="ttdeci">int nf()</div><div class="ttdef"><b>Definition</b> MTPowerSpectrumEngine.h:135</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">nf()</a>.</p>

</div>
</div>
<a id="a92db35500eda333738d2c650e0b6d82f" name="a92db35500eda333738d2c650e0b6d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92db35500eda333738d2c650e0b6d82f">&#9670;&#160;</a></span>nf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MTPowerSpectrumEngine::nf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return tne number of frequency bins in estimates the operator will compute. </p>
<div class="fragment"><div class="line"><span class="lineno">  135</span>           {</div>
<div class="line"><span class="lineno">  136</span>    <span class="comment">/* this simple formula depends upon integer truncation when used with</span></div>
<div class="line"><span class="lineno">  137</span><span class="comment">    nfft as an odd number.   For reference, this is what prieto uses in</span></div>
<div class="line"><span class="lineno">  138</span><span class="comment">    the python multitaper package:</span></div>
<div class="line"><span class="lineno">  139</span><span class="comment">    if (nfft%2 == 0):</span></div>
<div class="line"><span class="lineno">  140</span><span class="comment">        nf = int(nfft/2 + 1)</span></div>
<div class="line"><span class="lineno">  141</span><span class="comment">    else:</span></div>
<div class="line"><span class="lineno">  142</span><span class="comment">        nf = int((nfft+1)/2)</span></div>
<div class="line"><span class="lineno">  143</span><span class="comment">    they will yield the same result but this is simpler and faster</span></div>
<div class="line"><span class="lineno">  144</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  145</span>    <span class="keywordflow">return</span> (this-&gt;nfft) / 2 + 1;</div>
<div class="line"><span class="lineno">  146</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10d4b650fdedd815652c1e4e86a0e715" name="a10d4b650fdedd815652c1e4e86a0e715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d4b650fdedd815652c1e4e86a0e715">&#9670;&#160;</a></span>number_tapers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MTPowerSpectrumEngine::number_tapers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of tapers used by this engine. </p>
<div class="fragment"><div class="line"><span class="lineno">  101</span>{ <span class="keywordflow">return</span> ntapers; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51379e47b45995eb44c519c2672de77b" name="a51379e47b45995eb44c519c2672de77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51379e47b45995eb44c519c2672de77b">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp; mspass::algorithms::deconvolution::MTPowerSpectrumEngine::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html">MTPowerSpectrumEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard assignment operator. </p>
<div class="fragment"><div class="line"><span class="lineno">  102</span>                                                                    {</div>
<div class="line"><span class="lineno">  103</span>  <span class="keywordflow">if</span> (&amp;parent != <span class="keyword">this</span>) {</div>
<div class="line"><span class="lineno">  104</span>    taperlen = parent.taperlen;</div>
<div class="line"><span class="lineno">  105</span>    ntapers = parent.ntapers;</div>
<div class="line"><span class="lineno">  106</span>    nfft = parent.nfft;</div>
<div class="line"><span class="lineno">  107</span>    tbp = parent.tbp;</div>
<div class="line"><span class="lineno">  108</span>    operator_dt = parent.operator_dt;</div>
<div class="line"><span class="lineno">  109</span>    deltaf = parent.deltaf;</div>
<div class="line"><span class="lineno">  110</span>    tapers = parent.tapers;</div>
<div class="line"><span class="lineno">  111</span>    wavetable = gsl_fft_complex_wavetable_alloc(nfft);</div>
<div class="line"><span class="lineno">  112</span>    workspace = gsl_fft_complex_workspace_alloc(nfft);</div>
<div class="line"><span class="lineno">  113</span>  }</div>
<div class="line"><span class="lineno">  114</span>  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  115</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1dadcf9ec587fa2d48d04066ba1d55b4" name="a1dadcf9ec587fa2d48d04066ba1d55b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dadcf9ec587fa2d48d04066ba1d55b4">&#9670;&#160;</a></span>set_df()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::deconvolution::MTPowerSpectrumEngine::set_df </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Putter equivalent of df. </p>
<p>The computation of the Rayleigh bin size is complicated a bit by the folding properties of fft algorithms that have to handle odd and even length inputs differently. This algorithm uses the internally set nfft value to set the frequency bin size for even or odd nfft and the input sample interval. NOTE POSSIBLE CONFUSION that input is time sample interval NOT the actual frquency bin size. The reason is that the odd/even issue makes df dependent on if the fft size is even or odd. We include this method as a convenience as that is an implementation detail for the fft algorithm.</p>
<p>Note also this method sets not just df but the internally stored sample interval (symbol operator_dt in the source code.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>is the data sample interval (time domain)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computed df </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  126</span>                           {</div>
<div class="line"><span class="lineno">  127</span>    this-&gt;operator_dt = <a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">dt</a>;</div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordtype">int</span> this_nf = this-&gt;<a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">nf</a>();</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordtype">double</span> fny = 1.0 / (2.0 * <a class="code hl_function" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">dt</a>);</div>
<div class="line"><span class="lineno">  130</span>    this-&gt;deltaf = fny / <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(this_nf - 1);</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">return</span> deltaf;</div>
<div class="line"><span class="lineno">  132</span>  };</div>
<div class="ttc" id="aclassmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine_html_af7ea0259803f6cac1c5e8166541b2f51"><div class="ttname"><a href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">mspass::algorithms::deconvolution::MTPowerSpectrumEngine::dt</a></div><div class="ttdeci">double dt()</div><div class="ttdef"><b>Definition</b> MTPowerSpectrumEngine.h:106</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#af7ea0259803f6cac1c5e8166541b2f51">dt()</a>, and <a class="el" href="classmspass_1_1algorithms_1_1deconvolution_1_1_m_t_power_spectrum_engine.html#a92db35500eda333738d2c650e0b6d82f">nf()</a>.</p>

</div>
</div>
<a id="a114db709279ea8ab275ba69fbdcbec13" name="a114db709279ea8ab275ba69fbdcbec13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114db709279ea8ab275ba69fbdcbec13">&#9670;&#160;</a></span>taper_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::deconvolution::MTPowerSpectrumEngine::taper_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the taper length. </p>
<div class="fragment"><div class="line"><span class="lineno">   97</span>{ <span class="keywordflow">return</span> taperlen; };</div>
</div><!-- fragment -->
</div>
</div>
<a id="accf94d6d1dff859884d9c0aa1719994a" name="accf94d6d1dff859884d9c0aa1719994a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf94d6d1dff859884d9c0aa1719994a">&#9670;&#160;</a></span>time_bandwidth_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::deconvolution::MTPowerSpectrumEngine::time_bandwidth_product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve time-bandwidth product. </p>
<div class="fragment"><div class="line"><span class="lineno">   99</span>{ <span class="keywordflow">return</span> tbp; };</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/algorithms/deconvolution/<a class="el" href="_m_t_power_spectrum_engine_8h_source.html">MTPowerSpectrumEngine.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/algorithms/deconvolution/<b>MTPowerSpectrumEngine.cc</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
