

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.db.database &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=f6245a2f"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/quick_start.html">Getting Started in a Nutshell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda.html">Deploy MsPASS with Conda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda.html#advanced-setup-considerations">Advanced Setup Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_on_HPC.html">Deploying MsPASS on an HPC cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda_and_coiled.html">Deploy MsPASS with Conda and Coiled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started_overview.html">MsPASS Virtual Cluster Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/mongodb_and_mspass.html">Using MongoDB with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_tabular_data.html">Importing Tabular Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Seismic Data Objects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/numpy_scipy_interface.html">Using numpy/scipy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/continuous_data.html">Continuous Data Handling with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/schema_choices.html">What database schema should I use?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Processing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/cleaning_metadata.html">Cleaning Inconsistent Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/signal_to_noise.html">Signal to Noise Ratio Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System Tuning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/memory_management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/io.html">I/O in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_io.html">Parallel IO in MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/FAQ.html">Frequency Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/development_strategies.html">How do I develop a new workflow from scratch?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../../../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mspasspy.db.database</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mspasspy.db.database</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># WARNING fcntl is unix specific.</span>
<span class="c1"># Will fail if run in windows.  Mspass uses docker container</span>
<span class="c1"># so this will not be an issue there but if anyone tries to use this</span>
<span class="c1"># module outside mspass beware.</span>
<span class="kn">import</span> <span class="nn">fcntl</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">daskdf</span>

    <span class="n">_mspasspy_has_dask</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">_mspasspy_has_dask</span> <span class="o">=</span> <span class="kc">False</span>


<span class="kn">import</span> <span class="nn">gridfs</span>
<span class="kn">import</span> <span class="nn">pymongo</span>
<span class="kn">import</span> <span class="nn">pymongo.errors</span>
<span class="kn">from</span> <span class="nn">bson</span> <span class="kn">import</span> <span class="n">ObjectId</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">from</span> <span class="nn">obspy.clients.fdsn</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">Inventory</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span>
<span class="kn">import</span> <span class="nn">boto3</span><span class="o">,</span> <span class="nn">botocore</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">mspasspy.ccore.io</span> <span class="kn">import</span> <span class="n">_mseed_file_indexer</span><span class="p">,</span> <span class="n">_fwrite_to_file</span><span class="p">,</span> <span class="n">_fread_from_file</span>

<span class="kn">from</span> <span class="nn">mspasspy.ccore.seismic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">Seismogram</span><span class="p">,</span>
    <span class="n">DoubleVector</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.utility</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Metadata</span><span class="p">,</span>
    <span class="n">MsPASSError</span><span class="p">,</span>
    <span class="n">AtomicType</span><span class="p">,</span>
    <span class="n">ErrorSeverity</span><span class="p">,</span>
    <span class="n">dmatrix</span><span class="p">,</span>
    <span class="n">ProcessingHistory</span><span class="p">,</span>
    <span class="n">ProcessingStatus</span><span class="p">,</span>
    <span class="n">ErrorLogger</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.db.collection</span> <span class="kn">import</span> <span class="n">Collection</span>
<span class="kn">from</span> <span class="nn">mspasspy.db.schema</span> <span class="kn">import</span> <span class="n">DatabaseSchema</span><span class="p">,</span> <span class="n">MetadataSchema</span>
<span class="kn">from</span> <span class="nn">mspasspy.util.converter</span> <span class="kn">import</span> <span class="n">Textfile2Dataframe</span>


<div class="viewcode-block" id="Database"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database">[docs]</a><span class="k">class</span> <span class="nc">Database</span><span class="p">(</span><span class="n">pymongo</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">Database</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MsPASS core database handle.  All MongoDB database operation in MsPASS</span>
<span class="sd">    should normally utilize this object.  This object is a subclass of the</span>
<span class="sd">    Database class of pymongo.  It extends the class in several ways</span>
<span class="sd">    fundamental to the MsPASS framework:</span>

<span class="sd">    1. It abstracts read and write operations for seismic data managed</span>
<span class="sd">       by the framework.   Note reads and writes are for atomic objects.</span>
<span class="sd">       Use the distributed read and write functions for parallel handling of</span>
<span class="sd">       complete data sets.</span>
<span class="sd">    2. It contains methods for managing the most common seismic Metadata</span>
<span class="sd">       (namely source and receiver geometry and receiver response data).</span>
<span class="sd">    3. It adds a schema that can (optionally) be used to enforce type</span>
<span class="sd">       requirements and/or provide aliasing.</span>
<span class="sd">    4. Manages error logging data.</span>
<span class="sd">    5. Manages (optional) processing history data</span>

<span class="sd">    The class currently has only one constructor normally called with</span>
<span class="sd">    a variant of the following:</span>
<span class="sd">      db=Database(dbclient,&#39;mydatabase&#39;)</span>
<span class="sd">    where dbclient is either a MongoDB database client instance or</span>
<span class="sd">    (recommended) the MsPASS DBClient wrapper (a subclass of the</span>
<span class="sd">    pymongo client).  The second argument is the database &quot;name&quot;</span>
<span class="sd">    passed to the MongoDB server that defines your working database.</span>

<span class="sd">    The constructor should normally be used only with serial workflows.</span>
<span class="sd">    In cluster environments the recommended way to obtain a</span>
<span class="sd">    Database handle is via the DBClient method called `get_database`.</span>
<span class="sd">    The typical construct is:</span>

<span class="sd">        dbclient = DBClient(&quot;dbhostname&quot;)</span>
<span class="sd">        db = dbclient.get_database(&quot;mydatabase&quot;)</span>

<span class="sd">    where `dbhostname` is the hostname of the node running the MongoDB</span>
<span class="sd">    server and `mydatabase` is the name you assign your database.</span>
<span class="sd">    Serial workflows can and should use a similar construct but can</span>
<span class="sd">    normally default construct DBClient.</span>

<span class="sd">    Optional parameters are:</span>

<span class="sd">    :param schema: a :class:`str` of the yaml file name that defines</span>
<span class="sd">      both the database schema and the metadata schema. If this parameter</span>
<span class="sd">      is set, it will override the following two.</span>
<span class="sd">    :param db_schema: Set the name for the database schema to use with this</span>
<span class="sd">      handle.  Default is the MsPASS schema. (See User&#39;s Manual for details)</span>
<span class="sd">    :param md_schema:  Set the name for the Metadata schema.   Default is</span>
<span class="sd">      the MsPASS definitions.  (see User&#39;s Manual for details)</span>

<span class="sd">    As a subclass of pymongo Database the constructor accepts any</span>
<span class="sd">    parameters defined for the base class (see pymongo documentation)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">db_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">md_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># super(Database, self).__init__(*args, **kwargs)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schema</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_schema</span><span class="p">,</span> <span class="n">DatabaseSchema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">db_schema</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">(</span><span class="n">db_schema</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md_schema</span><span class="p">,</span> <span class="n">MetadataSchema</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">md_schema</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md_schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">(</span><span class="n">md_schema</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">()</span>
        <span class="c1"># This import has to appear here to avoid a circular import problem</span>
        <span class="c1"># the name stedronsky is a programming joke - name of funeral director</span>
        <span class="c1"># in the home town of glp</span>
        <span class="kn">from</span> <span class="nn">mspasspy.util.Undertaker</span> <span class="kn">import</span> <span class="n">Undertaker</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span> <span class="o">=</span> <span class="n">Undertaker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;_BaseObject__codec_options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">codec_options</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># somewhat weird that this import is requiired here but it won&#39;t</span>
        <span class="c1"># work without it.  Not sure how the symbol MongoClient is required</span>
        <span class="c1"># here but it is - ignore if a lint like ide says MongoClient is not used</span>
        <span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span>
        <span class="kn">from</span> <span class="nn">mspasspy.db.client</span> <span class="kn">import</span> <span class="n">DBClient</span>

        <span class="c1"># The following is also needed for this object to be serialized correctly</span>
        <span class="c1"># with dask distributed. Otherwise, the deserialized codec_options</span>
        <span class="c1"># will become a different type unrecognized by pymongo. Not sure why...</span>

        <span class="kn">from</span> <span class="nn">bson.codec_options</span> <span class="kn">import</span> <span class="n">CodecOptions</span><span class="p">,</span> <span class="n">TypeRegistry</span><span class="p">,</span> <span class="n">DatetimeConversion</span>
        <span class="kn">from</span> <span class="nn">bson.binary</span> <span class="kn">import</span> <span class="n">UuidRepresentation</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_BaseObject__codec_options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;_BaseObject__codec_options&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a collection of this database by name.</span>
<span class="sd">        Raises InvalidName if an invalid collection name is used.</span>
<span class="sd">        :Parameters:</span>
<span class="sd">          - `name`: the name of the collection to get</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Database.get_collection"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_collection">[docs]</a>    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">codec_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_preference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">write_concern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_concern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a :class:`mspasspy.db.collection.Collection` with the given name</span>
<span class="sd">        and options.</span>

<span class="sd">        This method is</span>
<span class="sd">        useful for creating a :class:`mspasspy.db.collection.Collection` with</span>
<span class="sd">        different codec options, read preference, and/or write concern from</span>
<span class="sd">        this :class:`Database`.  Useful mainly for advanced users tuning</span>
<span class="sd">        a polished workflow.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">          :param name: The name of the collection - a string.</span>
<span class="sd">          :param codec_options: (optional): An instance of</span>
<span class="sd">            :class:`bson.codec_options.CodecOptions`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`codec_options` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">          :param read_preference: (optional): The read preference to use. If</span>
<span class="sd">            ``None`` (the default) the :attr:`read_preference` of this</span>
<span class="sd">            :class:`Database` is used. See :mod:`pymongo.read_preferences`</span>
<span class="sd">            for options.</span>
<span class="sd">          :param write_concern: (optional): An instance of</span>
<span class="sd">            :class:`pymongo.write_concern.WriteConcern`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`write_concern` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">          :param read_concern:  An (optional) instance of</span>
<span class="sd">            :class:`pymongo.read_concern.ReadConcern`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`read_concern` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Collection</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="n">codec_options</span><span class="p">,</span>
            <span class="n">read_preference</span><span class="p">,</span>
            <span class="n">write_concern</span><span class="p">,</span>
            <span class="n">read_concern</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Database.create_collection"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.create_collection">[docs]</a>    <span class="k">def</span> <span class="nf">create_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">codec_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_preference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">write_concern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_concern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">session</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new :class:`mspasspy.db.collection.Collection` in this</span>
<span class="sd">        database.</span>
<span class="sd">        Normally collection creation is automatic. This method should</span>
<span class="sd">        only be used to specify options on</span>
<span class="sd">        creation. :class:`~pymongo.errors.CollectionInvalid` will be</span>
<span class="sd">        raised if the collection already exists.   Useful mainly for advanced users tuning</span>
<span class="sd">        a polished workflow.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">          :param name: the name of the collection to create</span>
<span class="sd">          :param codec_options` (optional): An instance of</span>
<span class="sd">            :class:`~bson.codec_options.CodecOptions`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`codec_options` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">          :param read_preference: (optional): The read preference to use. If</span>
<span class="sd">            ``None`` (the default) the :attr:`read_preference` of this</span>
<span class="sd">            :class:`Database` is used.</span>
<span class="sd">          :param write_concern: (optional): An instance of</span>
<span class="sd">            :class:`~pymongo.write_concern.WriteConcern`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`write_concern` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">          :param read_concern: (optional): An instance of</span>
<span class="sd">            :class:`~pymongo.read_concern.ReadConcern`. If ``None`` (the</span>
<span class="sd">            default) the :attr:`read_concern` of this :class:`Database` is</span>
<span class="sd">            used.</span>
<span class="sd">          :param collation: (optional): An instance of</span>
<span class="sd">            :class:`~pymongo.collation.Collation`.</span>
<span class="sd">          :param session: (optional): a</span>
<span class="sd">            :class:`~pymongo.client_session.ClientSession`.</span>
<span class="sd">          :param **kwargs: (optional): additional keyword arguments will</span>
<span class="sd">            be passed as options for the `create collection command`_</span>

<span class="sd">        All optional `create collection command`_ parameters should be passed</span>
<span class="sd">        as keyword arguments to this method. Valid options include, but are not</span>
<span class="sd">        limited to:</span>
<span class="sd">          ``size``: desired initial size for the collection (in</span>
<span class="sd">            bytes). For capped collections this size is the max</span>
<span class="sd">            size of the collection.</span>
<span class="sd">          ``capped``: if True, this is a capped collection</span>
<span class="sd">          ``max``: maximum number of objects if capped (optional)</span>
<span class="sd">          ``timeseries``: a document specifying configuration options for</span>
<span class="sd">            timeseries collections</span>
<span class="sd">          ``expireAfterSeconds``: the number of seconds after which a</span>
<span class="sd">            document in a timeseries collection expires</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">_tmp_session</span><span class="p">(</span><span class="n">session</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="c1"># Skip this check in a transaction where listCollections is not</span>
            <span class="c1"># supported.</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">in_transaction</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_collection_names</span><span class="p">(</span>
                <span class="nb">filter</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">},</span> <span class="n">session</span><span class="o">=</span><span class="n">s</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">CollectionInvalid</span><span class="p">(</span>
                    <span class="s2">&quot;collection </span><span class="si">%s</span><span class="s2"> already exists&quot;</span> <span class="o">%</span> <span class="n">name</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">Collection</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="n">codec_options</span><span class="p">,</span>
                <span class="n">read_preference</span><span class="p">,</span>
                <span class="n">write_concern</span><span class="p">,</span>
                <span class="n">read_concern</span><span class="p">,</span>
                <span class="n">session</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Database.set_metadata_schema"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.set_metadata_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the metadata schema defined for this handle.</span>

<span class="sd">        Normal use sets the schema at the time handle is created.</span>
<span class="sd">        In rare instances it can be useful to change the schema on the</span>
<span class="sd">        fly.   Use this method to do that for the Metadata component.</span>
<span class="sd">        An alternative is to create</span>
<span class="sd">        a new instance of Database with the new schema, but that approach</span>
<span class="sd">        is much slower than using this method.  Whether that matters is</span>
<span class="sd">        dependent on the number of times that operation is required.</span>

<span class="sd">        :param schema: Specification of the schema to use.  Can be</span>
<span class="sd">          a string defining a path to a yaml file defining the schema or</span>
<span class="sd">          an instance of :class:`mspsspy.db.schema.MetadataSchema` that</span>
<span class="sd">          was previously created by reading such a file.</span>
<span class="sd">        :type schema:  :class:`mspsspy.db.schema.MetadataSchema` or a :class:`str`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">MetadataSchema</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Error: argument schema is of type </span><span class="si">{}</span><span class="s2">, which is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Database.set_database_schema"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.set_database_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_database_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the database schema defined for this handle.</span>

<span class="sd">        Normal use sets the schema at the time handle is created.</span>
<span class="sd">        In rare instances it can be useful to change the schema on the</span>
<span class="sd">        fly.   Use this method to do that for the database schema component.</span>
<span class="sd">        An alternative is to create</span>
<span class="sd">        a new instance of Database with the new schema, but that approach</span>
<span class="sd">        is much slower than using this method.  Whether that matters is</span>
<span class="sd">        dependent on the number of times that operation is required.</span>

<span class="sd">        :param schema: Specification of the schema to use.  Can be</span>
<span class="sd">          a string defining a path to a yaml file defining the schema or</span>
<span class="sd">          an instance of :class:`mspsspy.db.schema.MetadataSchema` that</span>
<span class="sd">          was previously created by reading such a file.</span>
<span class="sd">        :type schema:  :class:`mspsspy.db.schema.MetadataSchema` or a :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">DatabaseSchema</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Error: argument schema is of type </span><span class="si">{}</span><span class="s2">, which is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Database.set_schema"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.set_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method to change both the database and metadata schema defined for this</span>
<span class="sd">        instance of a database handle.  This method sets the database</span>
<span class="sd">        schema (namespace for attributes saved in MongoDB) and the metadata</span>
<span class="sd">        schema (interal namespace).</span>

<span class="sd">        :param schema: a :class:`str` of the yaml file name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span></div>

<div class="viewcode-block" id="Database.read_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_doc_or_cursor</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize_ensemble</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ensemble_metadata</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;read_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
        <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Top-level MsPASS reader for seismic waveform data objects.</span>

<span class="sd">        Most MsPASS processing scripts use this method directly</span>
<span class="sd">        or indirectly via the parallel version called</span>
<span class="sd">        `read_distributed_data`.  This function will return</span>
<span class="sd">        one of four seismic data objects defined in MsPASS:</span>
<span class="sd">        `TimeSeries`,`Seismogram`, `TimeSeriesEnsemble`, or `SeismogramEnsemble`.</span>
<span class="sd">        What is retrieved is driven by the type of arg0, which in the</span>
<span class="sd">        implementation has the symbol `id_doc_or_cursor`.  As the symbol</span>
<span class="sd">        name implies it can be one of three things.  Each of the three</span>
<span class="sd">        types have implied assumptions:</span>

<span class="sd">        1.  If arg0 is a MongoDB `ObjectId` it is presumed to be the ObjectId</span>
<span class="sd">            of a document in the collection defined by the `collection`</span>
<span class="sd">            argument (see below).  When used in this way a query is</span>
<span class="sd">            always required to retrieve the document needed to construct</span>
<span class="sd">            the desired datum.  This method always implies you want to</span>
<span class="sd">            construct one, atomic datum.  This functionality is not</span>
<span class="sd">            recommended as it is the slowest reader due to the implicit</span>
<span class="sd">            database query required to implement that approach.</span>
<span class="sd">        2.  If arg0 is a python dictionary (dict) it is assumed to be a</span>
<span class="sd">            MongoDB &quot;document&quot; retrieved previously through the pymongo</span>
<span class="sd">            interface.  This usage is the best use for serial jobs driven</span>
<span class="sd">            by a for loop over a MongoDB cursor returned following a find</span>
<span class="sd">            query.   (See User&#39;s manual and tutorials for specific examples)</span>
<span class="sd">            The reason is that a cursor is effectively a buffered interface</span>
<span class="sd">            into the MongoDB database.  That is a loop over a cursor</span>
<span class="sd">            requires communication with the MongoDB server only when the</span>
<span class="sd">            buffer drains to a low water mark.   Consequently, cursor</span>
<span class="sd">            loops using this interface are much faster than atomic</span>
<span class="sd">            reads with ObjectIds.</span>
<span class="sd">        3.  If arg0 is a pymongo `Cursor` object the reader assumes you are</span>
<span class="sd">            asking it to construct an ensemble object.  Whether that is a</span>
<span class="sd">            `TimeSeriesEnsemble` or `SeismogramEnsemble` is dependent upon the</span>
<span class="sd">            setting of the &quot;collection&quot; argument.  The entire content of the</span>
<span class="sd">            implied list of documents returned by iterating over the cursor</span>
<span class="sd">            are used to construct ensembles of the atomic members.  In fact,</span>
<span class="sd">            the basic algorithm is to call this method recursively by</span>
<span class="sd">            sequentially reading one document at a time, constructing the</span>
<span class="sd">            atomic datum, and posting it to the member vector of the ensemble.</span>

<span class="sd">        As noted above arg0 interacts with the &quot;collection&quot; argument.</span>
<span class="sd">        The default of &quot;wf_TimeSeries&quot; can be used where appropriate but</span>
<span class="sd">        good practice is to be explicit and specify a value for &quot;collection&quot;</span>
<span class="sd">        in all alls to this method.</span>

<span class="sd">        This reader accepts data in any mix of what are defined by</span>
<span class="sd">        the database attribute tags `storage_mode` and `format`.   If those</span>
<span class="sd">        attributes are not defined for a retrieved document they default to</span>
<span class="sd">        &quot;storage_mode&quot;==&quot;gridfs&quot; and &quot;format&quot;==&quot;binary&quot;.  The `storage_mode`</span>
<span class="sd">        attribute can currently be one of the following:</span>
<span class="sd">        - `gridfs` is taken to mean the data are stored in the MongoDB</span>
<span class="sd">           gridfs file system.</span>
<span class="sd">        - &#39;files&#39; implies the data are stored in conventional computer files</span>
<span class="sd">          stored with two attributes that are required with this storage</span>
<span class="sd">          mode:  &quot;dir&quot; and &quot;dfile&quot;.</span>
<span class="sd">        - `URL` implies the data can be retrieved by some form of web service</span>
<span class="sd">          request through a url defined by other attributes in the document.</span>
<span class="sd">          This mode is volatile and currently not recommended due to the very</span>
<span class="sd">          slow and unreliable response to FDSN data queries.  It is likely,</span>
<span class="sd">          however, to become a major component with FDSN services moving to</span>
<span class="sd">          cloud systems.</span>
<span class="sd">        - This reader has prototype support for reading SCEC data stored on</span>
<span class="sd">          AWS s3.   The two valid values for defining those &quot;storage_mode&quot;s</span>
<span class="sd">          are &quot;s3_continuous&quot; and &quot;s3_event&quot;, which map to two different</span>
<span class="sd">          areas of SCEC&#39;s storage on AWS.   We emphasize the readers for</span>
<span class="sd">          this storage mode are prototypes and subject to change.  A similar</span>
<span class="sd">          interface may evolve for handling FDSN cloud data storage depending</span>
<span class="sd">          on how that interface is actually implemented.  It was in development</span>
<span class="sd">          at the time this docstring was written.</span>

<span class="sd">        The reader can read data in multiple formats. The actual format</span>
<span class="sd">        expected is driven by the database attribute called &quot;format&quot;.</span>
<span class="sd">        As noted above it defaults to &quot;binary&quot;, which means the data are</span>
<span class="sd">        stored in contiguous binary blocks on files that can be read with</span>
<span class="sd">        the low-level C function fread.   That is the fastest reader</span>
<span class="sd">        currently available, but comes at storage cast as the data are</span>
<span class="sd">        uncompressed doubles.  If the data are in some nonnative format</span>
<span class="sd">        (seed is considered not native), the format is cracked using</span>
<span class="sd">        obspy.   The list of formats accepted match those defined for</span>
<span class="sd">        obspy&#39;s `read` function.   The format value stored in the database</span>
<span class="sd">        is passed as the format argument to that function.  The miniseed</span>
<span class="sd">        format reader has been heavily exercised.  Other formats will be</span>
<span class="sd">        an adventure.  Be aware there will most definitely be namespace</span>
<span class="sd">        collisions of Metadata attributes with non-native formats other than</span>
<span class="sd">        miniseed.</span>

<span class="sd">        There is a special case for working with ensemble data that can</span>
<span class="sd">        be expected to provide the highest performance with a conventional</span>
<span class="sd">        file system.  That is the case of ensembles with the format of</span>
<span class="sd">        &quot;binary&quot; and data saved in files where all the waveforms of each</span>
<span class="sd">        ensemble are in the same file.  That structure is the default for</span>
<span class="sd">        ensembles saved to files with the `save_data` method.  This method</span>
<span class="sd">        is fast because the sample data are read with a C++ function that</span>
<span class="sd">        uses the stock fread function that for conventional file input is</span>
<span class="sd">        about as fast a reader as possible.</span>

<span class="sd">        An additional critical parameter is &quot;mode&quot;.  It must be one of</span>
<span class="sd">        &quot;promiscuous&quot;, &quot;cautious&quot;, or &quot;pedantic&quot;.   Default is &quot;promiscuous&quot;</span>
<span class="sd">        which more-or-less ignores the schema and loads the entire content</span>
<span class="sd">        of the document(s) to Metadata containers.   For ensembles that</span>
<span class="sd">        means the Metadata for the ensemble and all members.  See the</span>
<span class="sd">        User Manual section on &quot;CRUD Operations&quot; for details.</span>

<span class="sd">        This reader also has an option to normalize with one or more sets of</span>
<span class="sd">        data during reading.  For backward compatibility with versions of</span>
<span class="sd">        MsPASS prior to 2.0 the &quot;normalize&quot; parameter will accept a list of</span>
<span class="sd">        strings that are assumed to be collection names containing</span>
<span class="sd">        Metadata that is to be &quot;normalized&quot;.    That case, however, invokes the</span>
<span class="sd">        slowest algorithm possible to do that operation.  Not only does it</span>
<span class="sd">        use a query-based matching algorithm that requires a MongoDB find_one</span>
<span class="sd">        query for each datum, but it requires construction of an instance of</span>
<span class="sd">        the python class used in MsPASS for each calls and each collection listed.</span>
<span class="sd">        Better performance is normally possible with the v2 approach where</span>
<span class="sd">        the list passed via &quot;normalize&quot; is a list of subclasses of the</span>
<span class="sd">        :class:`mspasspy.db.normalize.BasicMatcher` class.  That interface</span>
<span class="sd">        provides a generic matching functionality and is most useful for</span>
<span class="sd">        improving performance when using one of the cache algorithms.</span>
<span class="sd">        For more detail see the User Manual section on normalization.</span>

<span class="sd">        Finally, this reader has to handle a special case of errors that</span>
<span class="sd">        cause the result to be invalid.  We do NOT use the standard</span>
<span class="sd">        exception mechanism for this reader because as noted in our User</span>
<span class="sd">        Manual throwing exceptions can abort a large parallel job.  Hence,</span>
<span class="sd">        we must try to minimize the cases when a single read operation will</span>
<span class="sd">        kill a larger workflow.  (That is reserved for truly unrecoverable</span>
<span class="sd">        errors like a malloc error.)  Throughout MsPASS we handle this issue</span>
<span class="sd">        with the `live` attribute of data objects.   All data objects,</span>
<span class="sd">        including ensembles, can be killed (marked data or live==False) as</span>
<span class="sd">        a signal they can be moved around but should be ignored in any</span>
<span class="sd">        processing workflows.  Reading data in is a special case.  A</span>
<span class="sd">        single read may fail for a variety of reasons but killing the entire</span>
<span class="sd">        job for something like one document containing an invalid attribute</span>
<span class="sd">        is problematic.  For that reason, this reader defines the concept</span>
<span class="sd">        of a special type of dead datum it calls an &quot;abortion&quot;.   This</span>
<span class="sd">        concept is discussed in greater detail in the User&#39;s Manual section on</span>
<span class="sd">        &quot;CRUD Operations&quot;, but for this context there are three key points:</span>

<span class="sd">        -  Any return from this function that is marked dead (live==False)</span>
<span class="sd">           is by definition an abortion.</span>
<span class="sd">        -  This reader adds a boolean attribute not stored in the database</span>
<span class="sd">           with the key &quot;is_abortion&quot;.  That value will be True if the datum</span>
<span class="sd">           is returned dead but should be False if it is set live.</span>
<span class="sd">        -  An entire ensemble may be marked dead only if reading of all the</span>
<span class="sd">           members defined by a cursor input fail.   Note handling of</span>
<span class="sd">           failures when constructing ensembles is different than atomic</span>
<span class="sd">           data because partial success is assumed to be acceptable.</span>
<span class="sd">           Hence, when a given datum in an ensemble fails the body is not</span>
<span class="sd">           added to the ensemble but processed the body is buried in a</span>
<span class="sd">           special collection called &quot;abortions&quot;.   See User&#39;s Manual</span>
<span class="sd">           for details.</span>

<span class="sd">        :param id_doc_or_cursor: required key argument that drives</span>
<span class="sd">          what the reader will return.  The type of this argument is a</span>
<span class="sd">          top-level control on what is read.   See above for details.</span>
<span class="sd">        :type id_doc_or_cursor:  As the name implies should be one of</span>
<span class="sd">          the following:  (1) MongoDB `ObjectId` of wf document to be</span>
<span class="sd">          retrieved to define this read, (2) MongoDB document (python dict)</span>
<span class="sd">          of data defining the datum to be constructed, or (3) a pymongo</span>
<span class="sd">          `Cursor` object that can be iterated to load an enemble.  Note</span>
<span class="sd">          the &quot;doc&quot; can also be a Metadata subclass.  That means you can</span>
<span class="sd">          use a seismic data object as input and it will be accepted.</span>
<span class="sd">          The read will work, however, only if the contents of the Metadata</span>
<span class="sd">          container are sufficient.  Use of explicit or implicit</span>
<span class="sd">          Metadata container input is not advised even it it might work as it</span>
<span class="sd">          violates an implicit assumption of the function that the input is</span>
<span class="sd">          closely linked to MongoDB.  A doc from a cursor or one retrieved</span>
<span class="sd">          through an ObjectId match that assump0tion but an Metadata</span>
<span class="sd">          container does not.</span>

<span class="sd">        :param mode: read mode that controls how the function interacts with</span>
<span class="sd">          the schema definition.   Must be one of</span>
<span class="sd">          [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;].   See user&#39;s manual for a</span>
<span class="sd">          detailed description of what the modes mean.  Default is &#39;promiscuous&#39;</span>
<span class="sd">          which turns off all schema checks and loads all attributes defined for</span>
<span class="sd">          each object read.</span>
<span class="sd">        :type mode: :class:`str`</span>

<span class="sd">        :param normalize: Use this parameter to do normalization during read.</span>
<span class="sd">          From version 2 onward the preferred input is a list of</span>
<span class="sd">          concrete instances of the base class :class:`BasicMatcher`.</span>
<span class="sd">          For backward compatibility this parameter may also defined a</span>
<span class="sd">          list of collection names defined by a list of strings.</span>
<span class="sd">          Note all normalizers will, by default,</span>
<span class="sd">          normally kill any datum for which matching fails.  Note for</span>
<span class="sd">          ensembles this parameter defines matching to be applied to all</span>
<span class="sd">          enemble members.  Use `normalize_ensemble` to normalize the enemble&#39;s</span>
<span class="sd">          `Metadata` container.  Member ensemble normalziation can be different</span>
<span class="sd">          for each member while ensemble Metadata is assume  the same for</span>
<span class="sd">          all members.</span>
<span class="sd">        :type normalize: a :class:`list` of :class:`BasicMatcher` or :class:`str`.</span>
<span class="sd">          :class:`BasicMatchers` are applied sequentialy with the</span>
<span class="sd">          `normalize` function using this matcher.   When a list of strings is given each</span>
<span class="sd">          call to this function initiates construction of a database Id</span>
<span class="sd">          matcher using the collection name.   e.g. if the list has &quot;source&quot;</span>
<span class="sd">          the wf read is expected to contain the attribute &quot;source_id&quot;</span>
<span class="sd">          that resolves to an id in the source collection.  With string</span>
<span class="sd">          input that always happens only through database transactions.</span>

<span class="sd">        :param normalize_ensemble:  This parameter should be used to</span>
<span class="sd">          apply normalization to ensemble Metadata (attributes common to</span>
<span class="sd">          all ensemble &quot;members&quot;. )  It will be ignored if reading</span>
<span class="sd">          atomic data.  Otherwise it behaves like normalize</span>
<span class="sd">        :type normalize_ensemble:  a :class:`list` of :class:`BasicMatcher` or :class:`str`.</span>
<span class="sd">          :class:`BasicMatchers` are applied sequentialy with the</span>
<span class="sd">          `normalize` function.   When a list of strings is given each</span>
<span class="sd">          call to this function initiates construction of an database Id</span>
<span class="sd">          matcher using the collection name.   e.g. if the list has &quot;source&quot;</span>
<span class="sd">          the wf read is expected to contain the attribute &quot;source_id&quot;</span>
<span class="sd">          that resolves to an id in the source collection.  With string</span>
<span class="sd">          input that always happens only through database transactions.</span>

<span class="sd">        :param load_history: boolean switch controlling handling of the</span>
<span class="sd">          object-level history mechanism.  When True if the data were</span>
<span class="sd">          saved previously with a comparable switch to save the</span>
<span class="sd">          history, this reader will load the history data.   This feature allows</span>
<span class="sd">          preserving a complete object-level history tree in a workflow</span>
<span class="sd">          with an intermediate save.   If no history data are found the</span>
<span class="sd">          history tree is initialized. When this parameter is set False</span>
<span class="sd">          the history tree will be left null.</span>

<span class="sd">        :param exclude_keys: Sometimes it is helpful to remove one or more</span>
<span class="sd">          attributes stored in the database from the data&#39;s Metadata (header)</span>
<span class="sd">          so they will not cause problems in downstream processing.  Use this</span>
<span class="sd">          argument to supply a list of keys that should be deleted from</span>
<span class="sd">          the datum before it is returned.  With ensembles the editing</span>
<span class="sd">          is applied to all members.   Note this same functionality</span>
<span class="sd">          can be accomplished within a workflow with the trace editing</span>
<span class="sd">          module.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str` defining</span>
<span class="sd">          the keys to be cleared.</span>

<span class="sd">        :param collection:  Specify the collection name for this read.</span>
<span class="sd">           In MsPASS the equivalent of header attributes are stored in</span>
<span class="sd">           MongoDB documents contained in a &quot;collection&quot;.   The assumption</span>
<span class="sd">           is a given collection only contains documents for one of the</span>
<span class="sd">           two atomic types defined in MsPASS:  `TimeSeries` or `Seismogram`.</span>
<span class="sd">           The data type for collections defined by the schema is an</span>
<span class="sd">           attribute that the reader tests to define the type of atomic</span>
<span class="sd">           objects to be constructed (Note ensembles are assembled from</span>
<span class="sd">           atomic objects by recursive calls the this same read method.)</span>
<span class="sd">           The default is &quot;wf_TimeSeries&quot;, but we recommend always defining</span>
<span class="sd">           this argument for clarity and stability in the event the default</span>
<span class="sd">           would change.</span>
<span class="sd">         :type collection:   :class:`str` defining a collection that must be</span>
<span class="sd">           defined in the schema.  If not, the function will abort the job.</span>

<span class="sd">        :param data_tag:  The definition of a dataset can become ambiguous</span>
<span class="sd">          when partially processed data are saved within a workflow.   A common</span>
<span class="sd">          example would be windowing long time blocks of data to shorter time</span>
<span class="sd">          windows around a particular seismic phase and saving the windowed data.</span>
<span class="sd">          The windowed data can be difficult to distinguish from the original</span>
<span class="sd">          with standard queries.  For this reason we make extensive use of &quot;tags&quot;</span>
<span class="sd">          for save operations to avoid such ambiguities.   Reads present</span>
<span class="sd">          a different problem as selection for such a tag is best done with</span>
<span class="sd">          MongoDB queries.   If set this argument provides a cross validation</span>
<span class="sd">          that the data are consistent with a particular tag.  In particular,</span>
<span class="sd">          if a datum does not have the attribute &quot;data_tag&quot; set to the value</span>
<span class="sd">          defined by the argument a null, dead datum will be returned.</span>
<span class="sd">          For ensembles any document defined by the cursor input for which</span>
<span class="sd">          the &quot;data_tag&quot; attribute does not match will be silenetly dropped.</span>
<span class="sd">          The default is None which disables the cross-checking.</span>
<span class="sd">        :type data_tag: :class:`str` used for the filter.  Can be None</span>
<span class="sd">          in which case the cross-check test is disable.</span>

<span class="sd">        :param ensemble_metadata:  Optional constant attributes to</span>
<span class="sd">          assign to ensemble Metadata.  Ignored for atomic data.</span>
<span class="sd">          It is important to stress that the contents of this dict are</span>
<span class="sd">          applied last.  Use with caution, particularly when using</span>
<span class="sd">          normalizatoin, to avoid accidentally overwriting some</span>
<span class="sd">          attribute loaded from the database.</span>
<span class="sd">        :type ensemble_metadata:  python dict.   The contents are copied</span>
<span class="sd">          verbatim to the ensemble Metadata container with a loop over the</span>
<span class="sd">          dict keys.</span>

<span class="sd">        :param alg_name: optional alternative name to assign for this algorithm</span>
<span class="sd">          as a tag for the origin node of the history tree.   Default is the</span>
<span class="sd">          function&#39;s name (&quot;read_data&quot;) and should rarely if ever be changed.</span>
<span class="sd">          Ignored unless `load_history` is set True.</span>
<span class="sd">        :type alg_name: :class:`str`</span>

<span class="sd">        :param alg_id: The object-level history mechanism uses a string to</span>
<span class="sd">          tag a specific instance of running a particular function in a workflow.</span>
<span class="sd">          If a workflow has multiple instances of read_data with different</span>
<span class="sd">          parameters, for example, one might specify a value of this argument.</span>
<span class="sd">          Ignored unless `load_history` is set True.</span>
<span class="sd">        :type alg_id: :class:`str`</span>

<span class="sd">        :param define_as_raw: boolean to control a detail of the object-level</span>
<span class="sd">          history definition of the tree node created for this process.</span>
<span class="sd">          The functions by definition an &quot;origin&quot; but a special case is a</span>
<span class="sd">          &quot;raw&quot; origin meaning the sample data are unaltered (other than type)</span>
<span class="sd">          from the field data.  Most miniseed data, for example, would</span>
<span class="sd">          want to set this argument True.   Ignored unless `load_history` is set True.</span>

<span class="sd">        :param merge_method:  when reading miniseed data implied gaps can</span>
<span class="sd">          be present when packets are missing from a sequence of packets</span>
<span class="sd">          having a common net:sta:chan:loc codes.  We use obspy&#39;s</span>
<span class="sd">          miniseed reader to crack miniseed data.  It breaks such data into</span>
<span class="sd">          multiple &quot;segments&quot;.  We then use their</span>
<span class="sd">          `merge&lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.merge.html&gt;`__</span>
<span class="sd">          method of the &quot;Stream&quot; object to glue any such segments together.</span>
<span class="sd">          This parameter is passed as the &quot;method&quot; argument to that function.</span>
<span class="sd">          For detail see</span>
<span class="sd">          `__add__ &lt;https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.__add__.html#obspy.core.trace.Trace.__add__&gt;`</span>
<span class="sd">          for details on methods 0 and 1,</span>
<span class="sd">          See `_cleanup &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream._cleanup.html#obspy.core.stream.Stream._cleanup&gt;`</span>
<span class="sd">          for details on method -1.  Note this argument is ignored unless</span>
<span class="sd">          the reader is trying to read miniseed data.</span>
<span class="sd">        :type method: :class:`int` with one of three values: -1, 0, or 1</span>

<span class="sd">        :param merge_fill_value: Fill value for gap processing when obspy&#39;s merge</span>
<span class="sd">          method is invoked.  (see description for &quot;merge_method&quot; above).</span>
<span class="sd">          The value given here is passed used as the &quot;fill&quot; argument to</span>
<span class="sd">          the obspy merge method.  As with merge_method this argument is</span>
<span class="sd">          relevant only when reading miniseed data.</span>
<span class="sd">        :type merge_fill_value: :class:`int`, :class:`float` or None (default)</span>

<span class="sd">        :param merge_interpolation_samples: when merge_method is set to</span>
<span class="sd">          -1 the obspy merge function requires a value for an</span>
<span class="sd">          argument they call &quot;interpolate_samples&quot;.  See their documentation</span>
<span class="sd">          for details, but this argument controls how &quot;overlaps&quot;, as opposed</span>
<span class="sd">          to gaps, are handled by merge.  See the function documentation</span>
<span class="sd">          `here&lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.merge.html&gt;`__</span>
<span class="sd">          for details.</span>
<span class="sd">        :type interpolation_samples: :class:`int`</span>

<span class="sd">        :return: for ObjectId python dictionary values of arg0 will return</span>
<span class="sd">          either a :class:`mspasspy.ccore.seismic.TimeSeries`</span>
<span class="sd">          or :class:`mspasspy.ccore.seismic.Seismogram` object.</span>
<span class="sd">          If arg0 is a pymongo Cursor the function will return a</span>
<span class="sd">          :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">          :class:`mspasspy.ccore.seismic.SeismogramEnsemble` object.</span>
<span class="sd">          As noted above failures in reading atomic data will result in</span>
<span class="sd">          an object be marked dead and the Metadata attribute &quot;is_abortion&quot;</span>
<span class="sd">          to be set True.  When reading ensembles any problem members will</span>
<span class="sd">          be excluded from the output and the bodies buried in a special</span>
<span class="sd">          collection called &quot;abortions&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> is not defined in database schema&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection</span><span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported, but </span><span class="si">{}</span><span class="s2"> is requested. Please check the data_type of </span><span class="si">{}</span><span class="s2"> collection.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">object_type</span><span class="p">,</span> <span class="n">wf_collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only promiscuous, cautious and pedantic are supported, but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">normalizer_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">normalize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normalizer_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalizer_list</span> <span class="o">=</span> <span class="n">parse_normlist</span><span class="p">(</span><span class="n">normalize</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># same for ensemble</span>
        <span class="k">if</span> <span class="n">normalize_ensemble</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">normalize_ensemble_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">normalizer_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normalize_ensemble_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalize_ensemble_list</span> <span class="o">=</span> <span class="n">parse_normlist</span><span class="p">(</span><span class="n">normalize_ensemble</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># This assumes the name of a metadata schema matches the data type it defines.</span>
        <span class="n">read_metadata_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">database_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span>

        <span class="c1"># We temporarily swap the main collection defined by the metadata schema by</span>
        <span class="c1"># the wf_collection. This ensures the method works consistently for any</span>
        <span class="c1"># user-specified collection argument.</span>
        <span class="n">metadata_schema_collection</span> <span class="o">=</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metadata_schema_collection</span> <span class="o">!=</span> <span class="n">wf_collection</span><span class="p">:</span>
            <span class="n">temp_metadata_schema</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">)</span>
            <span class="n">temp_metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="n">swap_collection</span><span class="p">(</span>
                <span class="n">metadata_schema_collection</span><span class="p">,</span> <span class="n">wf_collection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
            <span class="p">)</span>
            <span class="n">read_metadata_schema</span> <span class="o">=</span> <span class="n">temp_metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">doclist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># We could use a zero length doclist as switch to define</span>
        <span class="c1"># atomic reads, but this boolean will make that logic</span>
        <span class="c1"># clearer below</span>
        <span class="n">reading_atomic_data</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span>
        <span class="c1"># This logic allows object_id to be either a document or</span>
        <span class="c1"># an object id</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Metadata</span><span class="p">)):</span>
            <span class="c1"># note because all seismic data objects inherit Metadata</span>
            <span class="c1"># this block will be entered if passed a seismic data object.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">,</span> <span class="n">Metadata</span><span class="p">):</span>
                <span class="n">object_doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">object_doc</span> <span class="o">=</span> <span class="n">id_doc_or_cursor</span>
            <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;data_tag&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">object_doc</span> <span class="ow">or</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">data_tag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Seismogram</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">,</span> <span class="n">ObjectId</span><span class="p">):</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">id_doc_or_cursor</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
                <span class="n">query</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_tag</span>
            <span class="n">object_doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">()</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No matching document for the followng query:  </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">query</span>
                <span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Returning default constructed datum&quot;</span>
                <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Database.read_data&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">d</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">,</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">Cursor</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">id_doc_or_cursor</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
                    <span class="c1"># silently drop any documents that do not have data tag</span>
                    <span class="c1"># and match input value</span>
                    <span class="k">if</span> <span class="n">data_tag</span> <span class="ow">in</span> <span class="n">object_doc</span> <span class="ow">and</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">data_tag</span><span class="p">:</span>
                        <span class="n">doclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">doclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="n">reading_atomic_data</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># return default constructed ensemble with a error message if</span>
            <span class="c1"># editing for data tag above threw out all data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doclist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Found no data matching data_tag=</span><span class="si">{}</span><span class="s2"> in list created from cursor</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">data_tag</span>
                <span class="p">)</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Returning an empty ensemble marked dead&quot;</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">SeismogramEnsemble</span><span class="p">()</span>
                <span class="n">val</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;Database.read_data&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database.read_data:  arg0 has unsupported type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">id_doc_or_cursor</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a dict (document), ObjectId, or pymongo cursor</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reading_atomic_data</span><span class="p">:</span>
            <span class="n">md</span><span class="p">,</span> <span class="n">live</span><span class="p">,</span> <span class="n">elog</span> <span class="o">=</span> <span class="n">doc2md</span><span class="p">(</span>
                <span class="n">object_doc</span><span class="p">,</span>
                <span class="n">database_schema</span><span class="p">,</span>
                <span class="n">read_metadata_schema</span><span class="p">,</span>
                <span class="n">wf_collection</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">mode</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">live</span><span class="p">:</span>
                <span class="c1"># Default construct datum and add Metadata afterward.</span>
                <span class="c1"># Metadata needs to be added to body bag to allow idenficiation</span>
                <span class="c1"># of the body downstream</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">d</span><span class="o">.</span><span class="n">elog</span> <span class="o">+=</span> <span class="n">elog</span>
                <span class="c1"># A simple way to signal this is an abortion downstream</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># not necessary because default constructor seets</span>
                <span class="c1"># live false but safer to be explicit this is most sincerely dead</span>
                <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">d</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_atomic_object</span><span class="p">(</span>
                <span class="n">md</span><span class="p">,</span>
                <span class="n">object_type</span><span class="p">,</span>
                <span class="n">merge_method</span><span class="p">,</span>
                <span class="n">merge_fill_value</span><span class="p">,</span>
                <span class="n">merge_interpolation_samples</span><span class="p">,</span>
                <span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Any messages posted here will be out of order if there are</span>
                <span class="c1"># also messages posted by _construct_atomic_object but</span>
                <span class="c1"># that is a minor blemish compared to the hassle required</span>
                <span class="c1"># to fix it</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span> <span class="o">+=</span> <span class="n">elog</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># We normalize after construction to allow use of normalize</span>
                <span class="c1"># function feature of kill and error logging</span>
                <span class="c1"># this obnoxious import is necessary because of a name</span>
                <span class="c1"># collsion of the function normalize and the argument</span>
                <span class="c1"># normalize in this method</span>
                <span class="kn">import</span> <span class="nn">mspasspy.db.normalize</span> <span class="k">as</span> <span class="nn">normalize_module</span>

                <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">normalizer_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                        <span class="c1"># scope qualifier needed to avoid name collsion with normalize argument</span>
                        <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">normalize_module</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span>
                            <span class="n">mspass_object</span><span class="p">,</span> <span class="n">matcher</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="c1"># normalizers can kil</span>
                <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">clear_modified</span><span class="p">()</span>
                <span class="c1"># Since the above can do a kill, we don&#39;t bother with the</span>
                <span class="c1"># history if the datum was killed during normalization</span>
                <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">load_history</span><span class="p">:</span>
                    <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">history_obj_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                        <span class="n">history_id</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># None is used as a signal this is the</span>
                        <span class="c1"># initialization of a workflow so the</span>
                        <span class="c1"># result will be marked such that the</span>
                        <span class="c1"># is_origin method returns True</span>
                        <span class="n">history_id</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_history</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">,</span>
                        <span class="n">history_id</span><span class="p">,</span>
                        <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                        <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                        <span class="n">define_as_raw</span><span class="o">=</span><span class="n">define_as_raw</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">mdlist</span><span class="p">,</span> <span class="n">live</span><span class="p">,</span> <span class="n">elog</span><span class="p">,</span> <span class="n">abortions</span> <span class="o">=</span> <span class="n">doclist2mdlist</span><span class="p">(</span>
                <span class="n">doclist</span><span class="p">,</span>
                <span class="n">database_schema</span><span class="p">,</span>
                <span class="n">read_metadata_schema</span><span class="p">,</span>
                <span class="n">wf_collection</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">mode</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># This is a special method of Undertaker to handle the</span>
            <span class="c1"># kind of data returned in the &quot;abortions&quot; list.</span>
            <span class="c1"># See Undertaker docstring or User Manual for concepts</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abortions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">abortions</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">handle_abortion</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">live</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># note this function returns a clean ensemble with</span>
                <span class="c1"># no dead data.  It will be considered bad only if is empty</span>
                <span class="c1"># note it send any datum that failed during construction</span>
                <span class="c1"># to abortions using the Undertaker method &quot;handle_abortions&quot;</span>
                <span class="c1"># as done immediatley above.  Also set ensemble dead if</span>
                <span class="c1"># there are no live mebmers</span>
                <span class="n">ensemble</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_ensemble</span><span class="p">(</span>
                    <span class="n">mdlist</span><span class="p">,</span>
                    <span class="n">object_type</span><span class="p">,</span>
                    <span class="n">merge_method</span><span class="p">,</span>
                    <span class="n">merge_fill_value</span><span class="p">,</span>
                    <span class="n">merge_interpolation_samples</span><span class="p">,</span>
                    <span class="n">aws_access_key_id</span><span class="p">,</span>
                    <span class="n">aws_secret_access_key</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">normalize</span> <span class="ow">or</span> <span class="n">normalize_ensemble</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">mspasspy.db.normalize</span> <span class="k">as</span> <span class="nn">normalize_module</span>

                    <span class="c1"># first handle enemble Metadata</span>
                    <span class="k">if</span> <span class="n">normalize_ensemble</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">normalize_ensemble_list</span><span class="p">:</span>
                            <span class="c1"># use this conditional because normalizers can kill</span>
                            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                                <span class="c1"># scope qualifier needed to avoid name collsion with normalize argument</span>
                                <span class="n">ensemble</span> <span class="o">=</span> <span class="n">normalize_module</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">matcher</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">break</span>
                    <span class="c1"># these are applied to all live members</span>
                    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                            <span class="c1"># note this silently skipss dead data</span>
                            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">normalizer_list</span><span class="p">:</span>
                                    <span class="n">d</span> <span class="o">=</span> <span class="n">normalize_module</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">matcher</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">load_history</span><span class="p">:</span>
                        <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">history_obj_id_name</span><span class="p">):</span>
                                    <span class="n">history_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">history_id</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_load_history</span><span class="p">(</span>
                                    <span class="n">mspass_object</span><span class="p">,</span>
                                    <span class="n">history_id</span><span class="p">,</span>
                                    <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                                    <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                                    <span class="n">define_as_raw</span><span class="o">=</span><span class="n">define_as_raw</span><span class="p">,</span>
                                <span class="p">)</span>
                    <span class="c1"># make sure we didn&#39;t kill all members</span>
                    <span class="n">kill_me</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                            <span class="n">kill_me</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">kill_me</span><span class="p">:</span>
                        <span class="n">ensemble</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default constructed container assumed marked dead</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">ensemble</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ensemble</span> <span class="o">=</span> <span class="n">SeismogramEnsemble</span><span class="p">()</span>
            <span class="c1"># elog referenced here comes from doclist2mdlist - a bit confusing</span>
            <span class="c1"># but delayed to here to construct ensemble first</span>
            <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span> <span class="o">+=</span> <span class="n">elog</span>

            <span class="c1"># We post this even to dead ensmebles</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble_metadata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ensmd</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">ensemble_metadata</span><span class="p">)</span>
                <span class="n">ensemble</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span><span class="n">ensmd</span><span class="p">)</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">ensemble</span>  <span class="c1"># ths just creates an alias not a copy</span>

        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.save_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">return_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;gridfs&quot;</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cremate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">normalizing_collections</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">],</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard method to save all seismic data objects to be managed by</span>
<span class="sd">        MongoDB.</span>

<span class="sd">        This method provides a unified interface for saving all seismic</span>
<span class="sd">        data objects in MsPASS.   That is, what we call atomic data</span>
<span class="sd">        (:class:`mspasspy.ccore.seismic.TimeSeries` and</span>
<span class="sd">        :class:`mspasspy.ccore.seismic.Seismogram`) and ensembles of the</span>
<span class="sd">        two atomic types ():class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` and</span>
<span class="sd">        :class:`mspasspy.ccore.seismic.SeismogramEnsemble`).  Handling</span>
<span class="sd">        multiple types while simultaneously supporting multiple abstractions</span>
<span class="sd">        of how the data are stored externally has some complexities.</span>
<span class="sd">        1.  All MsPASS data have multiple containers used internally</span>
<span class="sd">            to define different concepts.   In particular atomic data</span>
<span class="sd">            have a Metadata container we map to MongoDB documents directly,</span>
<span class="sd">            sample data that is the largest data component that we handle</span>
<span class="sd">            multiple ways, error log data, and (optional) object-level</span>
<span class="sd">            history data.  Ensembles are groups of atomic data but they also</span>
<span class="sd">            contain a Metadata and error log container common with content</span>
<span class="sd">            common to the group.</span>
<span class="sd">        2.  With seismic data the size is normally dominated by the</span>
<span class="sd">            sample data that are stored internally as a vector container</span>
<span class="sd">            for `TimeSeries` objects and a matrix for `Seismogram` objects.</span>
<span class="sd">            Handling moving that data to storage as fast as possible is thus the</span>
<span class="sd">            key to optimize write performance.  The write process is further</span>
<span class="sd">            complicated, however, by the fact that &quot;write/save&quot; is itself</span>
<span class="sd">            an abstraction that even in FORTRAN days hid a lot of complexity.</span>
<span class="sd">            A call to this function supports multiple save mechanisms we</span>
<span class="sd">            define through the `storage_mode` keyword. At present</span>
<span class="sd">            &quot;storage_mode&quot; can be only one of two options:  &quot;file&quot; and</span>
<span class="sd">            &quot;gridfs&quot;.  Note this class has prototype code for reading data</span>
<span class="sd">            in AWS s3 cloud storage that is not yet part of this interface.</span>
<span class="sd">            The API, however, was designed to allow adding one or more</span>
<span class="sd">            &quot;storage_mode&quot; options that allow other mechanisms to save</span>
<span class="sd">            sample data.  The top priority for a new &quot;storage_mode&quot; when</span>
<span class="sd">            the details are finalized is cloud storage of FDSN data by</span>
<span class="sd">            Earthscope and other data centers.  We have also experimented</span>
<span class="sd">            with parallel file containers like HDF5 for improved IO performance</span>
<span class="sd">            but have not yet produced a stable implementation.   In the</span>
<span class="sd">            future look for all such improvements.  What is clear is the</span>
<span class="sd">            API will define these alternatives through the &quot;storage_mode&quot;</span>
<span class="sd">            concept.</span>
<span class="sd">        3.  In MsPASS we make extensive use of the idea from seismic reflection</span>
<span class="sd">            processing of marking problem data &quot;dead&quot;.   This method</span>
<span class="sd">            handles all dead data through a standard interface with the</span>
<span class="sd">            memorable/colorful name :py:class:`mspasspy.util.Undertaker`.</span>
<span class="sd">            The default save calls the &quot;bury&quot; method of that class, but</span>
<span class="sd">            there is an optional &quot;cremate&quot; argument that calls that</span>
<span class="sd">            method instead.  The default of &quot;bury&quot; writes error log data</span>
<span class="sd">            to a special collection (&quot;cemetery&quot;) while the &quot;cremate&quot; method</span>
<span class="sd">            causes dead data to vanish without a trace on save.</span>
<span class="sd">        4.  There are two types of save concepts this method has to support.</span>
<span class="sd">            That is, sometimes one needs to save intermediate results of</span>
<span class="sd">            a workflow and continue on doing more work on the same data.</span>
<span class="sd">            The more common situation is to terminate a workflow with</span>
<span class="sd">            a call to this method.  The method argument `return_data`</span>
<span class="sd">            is an implicit switch for these two concepts.  When</span>
<span class="sd">            `return_data` is False, which is the default, only the</span>
<span class="sd">            ObjectId(s) of thw wf document(s) are returned by the function.</span>
<span class="sd">            We use that as the default to avoid memory overflow in a</span>
<span class="sd">            final save when the `compute` method is called in dask or the</span>
<span class="sd">            `collect` method is called in pyspark.  Set the `return_data`</span>
<span class="sd">            argument True if you are doing an intermediate save and want</span>
<span class="sd">            to reuse the content of what is returned.</span>
<span class="sd">        5.  There is a long history in seismology of debate on data formats.</span>
<span class="sd">            The fundamental reason for much of the debate has to do with</span>
<span class="sd">            the namespace and concepts captured in data &quot;headers&quot; for</span>
<span class="sd">            different formats seismologists have invented over several</span>
<span class="sd">            decades.   A type example is that two &quot;standard&quot; formats</span>
<span class="sd">            are SEGY that is the universal standard in seismic reflection</span>
<span class="sd">            data exchange and SEED which is now the standard earthquakek</span>
<span class="sd">            data format (Technically most data is now &quot;miniseed&quot; which</span>
<span class="sd">            differs from SEED by defining only minimal header attributes</span>
<span class="sd">            compared to the abomination of SEED that allows pretty much</span>
<span class="sd">            anything stored in an excessively complex data structure.)</span>
<span class="sd">            Further debate occurs regarding how data sets are stored in</span>
<span class="sd">            a particular format.   These range from the atomic level file</span>
<span class="sd">            model of SAC to the opposite extreme of an entire data set</span>
<span class="sd">            stored in one file, which is common for SEGY.   Because of the</span>
<span class="sd">            complexity of multiple formats seismologists have used for</span>
<span class="sd">            the external representation of data, this writer has limits</span>
<span class="sd">            on what it can and cannot do.  Key points about how formatting</span>
<span class="sd">            is handled are:</span>
<span class="sd">            -  The default save is a native format that is fast and efficient.</span>
<span class="sd">               You can select alternative formats for data by setting a valid</span>
<span class="sd">               value (string) for the &quot;format&quot; argument to this method.</span>
<span class="sd">               What is &quot;valid&quot; for the format argument is currently simple</span>
<span class="sd">               to state:   the value received for format is passed directly</span>
<span class="sd">               to obspy&#39;s  Stream write method&#39;s format argument.  That is,</span>
<span class="sd">               realize that when saving to a nonnative format the first thing</span>
<span class="sd">               this method does is convert the data to a Stream.  It then</span>
<span class="sd">               calls obspy&#39;s write method with the format specified.</span>
<span class="sd">            -  Given the above, it follows that if you are writing data to</span>
<span class="sd">               any nonnative format before calling this function you will</span>
<span class="sd">               almost certainly have to edit the Metadata of each datum to</span>
<span class="sd">               match the namespace for the format you want to write.</span>
<span class="sd">               If not, obspy&#39;s writer will almost certainly fail.  The only</span>
<span class="sd">               exception is miniseed where if the data being processed originate</span>
<span class="sd">               as miniseed they can often be saved as miniseed without edits.</span>
<span class="sd">            -  This writer only saves atomic data on single ensembles and</span>
<span class="sd">               knows nothing about assumptions a format makes about the</span>
<span class="sd">               larger scale layout of a dataset.  e.g. you could theoretically</span>
<span class="sd">               write an ensemble in SAC format, but the output will be</span>
<span class="sd">               unreadable by SAC because multiple records could easily be written</span>
<span class="sd">               in a single file.  Our perspective is that MsPASS is a framework</span>
<span class="sd">               and we do not have resources to sort out all the complexities of</span>
<span class="sd">               all the formats out there.   We request the user community to</span>
<span class="sd">               share an development for nonstandard formats.   Current the</span>
<span class="sd">               only format options that are not &quot;use at your own risk&quot; are</span>
<span class="sd">               the native &quot;binary&quot; format and miniseed.</span>

<span class="sd">        Given the complexity just described, users should not be surprised</span>
<span class="sd">        that there are limits to what this single method can do and that</span>
<span class="sd">        evolution of its capabilities is inevitable as the IT world evolves.</span>
<span class="sd">        We reiterate the entire point of this method (also the related</span>
<span class="sd">        read_data method) is to abstract the save process to make it</span>
<span class="sd">        as simple as possible while providing mechanisms to make it work</span>
<span class="sd">        as efficiently as possible.</span>

<span class="sd">        There are some important implementation details related to</span>
<span class="sd">        the points above that are important to understand if you encounter</span>
<span class="sd">        issues using this algorithm.</span>
<span class="sd">        1.  Writing is always atomic.  Saving ensemble data is little more</span>
<span class="sd">            than an enhanced loop over data members.  By &quot;enhanced&quot; we mean</span>
<span class="sd">            two things:  (a)  any ensemble Metadata attributes are copied</span>
<span class="sd">            to the documents saved for each member, and (b) dead data have</span>
<span class="sd">            to be handled differently but the handling is a simple conditional</span>
<span class="sd">            of &quot;if live&quot; with dead data handled the same as atomic bodies.</span>
<span class="sd">        2.  Atomic saves handle four components of the MsPASS data objects</span>
<span class="sd">            differently.   The first thing saved is always the sample data.</span>
<span class="sd">            How that is done depends upon the storage mode and format</span>
<span class="sd">            discussed in more detail below.  The writer then saves the</span>
<span class="sd">            content of the datum&#39;s Metadata container returning a copy of</span>
<span class="sd">            the value of the ObjectId of the document saved.   That ObjectID</span>
<span class="sd">            is used as a cross reference for saving the final two fundamentally</span>
<span class="sd">            different components:  (a) any error log entries and (b) object-level</span>
<span class="sd">            history data (optional).</span>
<span class="sd">        3.  As noted above how the sample data is stored is driven by the</span>
<span class="sd">            &quot;storage_mode&quot; argument.  Currently two values are accepted.</span>
<span class="sd">            &quot;gridfs&quot;, which is the default, pushes the sample data to a</span>
<span class="sd">            MongoDB managed internal file space the documents refer to with</span>
<span class="sd">            that name.  There are two important caveats about gridfs storage.</span>
<span class="sd">            First, the data saved will use the same file system as that used</span>
<span class="sd">            by the database server.  That can easily cause a file-system full</span>
<span class="sd">            error or a quota error if used naively.   Second, gridfs IO is</span>
<span class="sd">            prone to a serious preformance issue in a parallel workflow as</span>
<span class="sd">            all workers can be shouting at the database server simultaneously</span>
<span class="sd">            filling the network connection and/or overloading the server.</span>
<span class="sd">            For those reasons, &quot;file&quot; should be used for the storage</span>
<span class="sd">            mode for most applications.   It is not the default because</span>
<span class="sd">            storing data in files always requires the user to implement some</span>
<span class="sd">            organizational scheme through the &quot;dir&quot; and &quot;dfile&quot; arguments.</span>
<span class="sd">            There is no one-size-fits-all solution for organizing how a</span>
<span class="sd">            particular project needs to organize the files it produces.</span>
<span class="sd">            Note, however, that one can set storage_mode to &quot;file&quot; and this</span>
<span class="sd">            writer will work.  By default is sets &quot;dir&quot; to the current directory</span>
<span class="sd">            and &quot;dfile&quot; to a random string created with a uuid generator.</span>
<span class="sd">            (For ensembles the default is to write all member data to</span>
<span class="sd">            the file defined explicitly or implicitly by the &quot;dir&quot; and &quot;dfile&quot;</span>
<span class="sd">            arguments.)   An final implementation detail is that if &quot;dir&quot;</span>
<span class="sd">            and &quot;dfile&quot; are left at the default None, the algorithm will</span>
<span class="sd">            attempt to extract the value of &quot;dir&quot; and &quot;dfile&quot; from the</span>
<span class="sd">            Metadata of an atomic datum referenced in the save (i.e. for</span>
<span class="sd">            ensembles each datum will be treated independently.).  That</span>
<span class="sd">            feature allows more complex data organization schemes managed</span>
<span class="sd">            externally from the writer for ensembles.  All of that was</span>
<span class="sd">            designed to make this method as bombproof as possible, but</span>
<span class="sd">            users need to be aware naive usage can create a huge mess.</span>
<span class="sd">            e.g. with &quot;file&quot; and null &quot;dir&quot; and &quot;dfile&quot; saving a million</span>
<span class="sd">            atomic data will create a million files with random names in</span>
<span class="sd">            your current directory.  Good luck cleaning that mess up.</span>
<span class="sd">            Finally, we reiterate that when Earthscope finishes their</span>
<span class="sd">            design work for cloud storage access there will probably be</span>
<span class="sd">            a new storage mode added to support that access.  The &quot;s3&quot;</span>
<span class="sd">            methods in `Database` should be viewed only as prototypes.</span>
<span class="sd">        4.  If any datum has an error log entry it is always saved by</span>
<span class="sd">            this method is a collection called &quot;elog&quot;.  That save is not</span>
<span class="sd">            optional as we view all error log entries as significant.</span>
<span class="sd">            Each elog document contains an ObjectId of the wf document</span>
<span class="sd">            with which it is associated.</span>
<span class="sd">        5.  Handling of the bodies of dead data has some complexity.</span>
<span class="sd">            Since v2 of `Database` all dead data are passed through an</span>
<span class="sd">            instance of :py:class:`mspasspy.util.Undertaker`.  By default</span>
<span class="sd">            atomic dead data are passed through the</span>
<span class="sd">            :py:meth:`mspasspy.util.Undertaker.bury` method.</span>
<span class="sd">            If the &quot;cremate&quot; argument is set True the</span>
<span class="sd">            :py:meth:`mspasspy.util.Undertaker.cremate` method will be called.</span>
<span class="sd">            For ensembles the writer calls the</span>
<span class="sd">            :py:meth:`mspasspy.util.Undertaker.bring_out_your_dead`.</span>
<span class="sd">            If cremate is set True the bodies are discarded. Otherwise</span>
<span class="sd">            the `bury` method is called in a loop over all bodies.</span>
<span class="sd">            Note the default `bury` method creates</span>
<span class="sd">            a document for each dead datum in one of two</span>
<span class="sd">            special collections:  (a) data killed by a processing algorithm</span>
<span class="sd">            are saved to the &quot;cemetery&quot; collection, and (b) data killed by</span>
<span class="sd">            a reader are saved to &quot;abortions&quot; (An abortion is a datum</span>
<span class="sd">            that was never successfully constructed - born.)  The documents</span>
<span class="sd">            for the two collections contain the same name-value pairs but</span>
<span class="sd">            we split them because action required by an abortion is</span>
<span class="sd">            very different from a normal kill.   See the User Manual</span>
<span class="sd">            section on &quot;CRUD Operations&quot; for information on this topic.</span>
<span class="sd">        6.  Object-level history is not saved unless the argument</span>
<span class="sd">            &quot;save_history&quot; is set True (default is False).   When enabled</span>
<span class="sd">            the history data (if defined) is saved to a collection called</span>
<span class="sd">            &quot;history&quot;.   The document saved, like elog, has the ObjectId of</span>
<span class="sd">            the wf document with which it is associated.  Be aware that there</span>
<span class="sd">            is a signficant added cost to creating a history document entry.</span>
<span class="sd">            Because calling this method is part of the history chain one</span>
<span class="sd">            would want to preserve, an atomic database operation is</span>
<span class="sd">            required for each datum saved.   That is, the algorithm</span>
<span class="sd">            does an update of the wf document with which it it is associated</span>
<span class="sd">            containing the ObjectId of the history document it saved.</span>
<span class="sd">        7.  As noted above saving data with &quot;format&quot; set to anything but</span>
<span class="sd">            the default &quot;binary&quot; or &quot;MSEED&quot; is adventure land.</span>
<span class="sd">            We reiterate saving other formats is a development frontier we</span>
<span class="sd">            hope to come as contributions from users who need writers for a particular</span>
<span class="sd">            format and are intimately familiar with that format&#39;s idiosyncracies.</span>
<span class="sd">        8.  The &quot;mode&quot; argument has a number of subtle idiosyncracies</span>
<span class="sd">            that need to be recognized.  In general we recommend always</span>
<span class="sd">            writing data (i.e. calling this method) with the default</span>
<span class="sd">            mode of &quot;promiscuous&quot;.  That guarantees you won&#39;t mysteriously</span>
<span class="sd">            lose data being saved or abort the workflow when it is finished.</span>
<span class="sd">            In general it is better to use one of the verify methods or the</span>
<span class="sd">            dbverify command line tool to look for problem attributes in</span>
<span class="sd">            any saved documents than try to enforce rules setting</span>
<span class="sd">            mode to &quot;cautious&quot; or &quot;pedantic&quot;.   On the other hand, even</span>
<span class="sd">            if running in &quot;promiscuous&quot; mode certain rules are enforced:</span>
<span class="sd">             -  Any aliases defined in the schema are always reset to the</span>
<span class="sd">                key defined for the schema.  e.g. if you used the alias</span>
<span class="sd">                &quot;dt&quot; for the data sample interval this writer will always</span>
<span class="sd">                change it to &quot;delta&quot; (with the standard schema anyway)</span>
<span class="sd">                before saving the document created from that datum.</span>
<span class="sd">             -  All modes enforce a schema constraint for &quot;readonly&quot;</span>
<span class="sd">                attributes.   An immutable (readonly) attribute by definition</span>
<span class="sd">                should not be changed during processing.   During a save</span>
<span class="sd">                all attributes with a key defined as readonly are tested</span>
<span class="sd">                with a method in the Metadata container that keeps track of</span>
<span class="sd">                any Metadata changes.  If a readonly attribute is found to</span>
<span class="sd">                have been changed it will be renamed with the prefix</span>
<span class="sd">                &quot;READONLYERROR_&quot;, saved, and an error posted (e.g. if you try</span>
<span class="sd">                to alter site_lat (a readonly attribute) in a workflow when</span>
<span class="sd">                you save the waveform you will find an entry with the key</span>
<span class="sd">                READONERROR_site_lat.)  We emphasize the issue happens if</span>
<span class="sd">                the value associated with such a key was altered after the</span>
<span class="sd">                datum was constructed.  If the attribute does not</span>
<span class="sd">                change it is ERASED and will not appear in the document.</span>
<span class="sd">                The reason for that is this feature exists to handle</span>
<span class="sd">                attributes loaded in normalization.   Be aware this</span>
<span class="sd">                feature can bloat the elog collection if an entire dataset</span>
<span class="sd">                share a problem this algorithm flags as a readonly error.</span>

<span class="sd">        This method can throw an exception but only for errors in</span>
<span class="sd">        usage (i.e. arguments defined incorrectly)</span>

<span class="sd">        :param mspass_object: the seismic object you want to save.</span>
<span class="sd">        :type mspass_object: :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">          :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">          :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble`, or</span>
<span class="sd">          :class:`mspasspy.ccore.seismic.SeismogramEnsemble`</span>
<span class="sd">        :param return_data: When True return a (usually edited) copy</span>
<span class="sd">        of the data received.   When False, the default, return only</span>
<span class="sd">        a requested subset of the attributes in the wf document saved</span>
<span class="sd">        for this datum.s</span>
<span class="sd">        :param return_list:  list of keys for attributes to extract</span>
<span class="sd">          and set for return python dictionary when return_data is False.</span>
<span class="sd">          Ignored if return_data is True.   Be warned for ensembles the</span>
<span class="sd">          attributes are expected to be in the ensemble Metadata container.</span>
<span class="sd">          Missing attributes will be silentely ignored so an empty dict</span>
<span class="sd">          will be returned if none of the attributes is this list are defined.</span>
<span class="sd">        :param mode: This parameter defines how attributes defined with</span>
<span class="sd">          key-value pairs in MongoDB documents are to be handled on reading.</span>
<span class="sd">          By &quot;to be handled&quot; we mean how strongly to enforce name and type</span>
<span class="sd">          specification in the schema for the type of object being constructed.</span>
<span class="sd">          Options are [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;] with &#39;promiscuous&#39;</span>
<span class="sd">          being the default.  See the User&#39;s manual for more details on</span>
<span class="sd">          the concepts and how to use this option.</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param storage_mode: Current must be either &quot;gridfs&quot; or &quot;file.  When set to</span>
<span class="sd">          &quot;gridfs&quot; the waveform data are stored internally and managed by</span>
<span class="sd">          MongoDB.  If set to &quot;file&quot; the data will be stored in a file system</span>
<span class="sd">          with the dir and dfile arguments defining a file name.   The</span>
<span class="sd">          default is &quot;gridfs&quot;.  See above for more details.</span>
<span class="sd">        :type storage_mode: :class:`str`</span>
<span class="sd">        :param dir: file directory for storage.  This argument is ignored if</span>
<span class="sd">          storage_mode is set to &quot;gridfs&quot;.  When storage_mode is &quot;file&quot; it</span>
<span class="sd">          sets the directory in a file system where the data should be saved.</span>
<span class="sd">          Note this can be an absolute or relative path.  If the path is</span>
<span class="sd">          relative it will be expanded with the standard python library</span>
<span class="sd">          path functions to a full path name for storage in the database</span>
<span class="sd">          document with the attribute &quot;dir&quot;.  As for any io we remind the</span>
<span class="sd">          user that you much have write permission in this directory.</span>
<span class="sd">          Note if this argument is None (default) and storage_mode is &quot;file&quot;</span>
<span class="sd">          the algorithm will first attempt to extract &quot;dir&quot; from the</span>
<span class="sd">          Metadata of mspass_object.  If that is defined it will be used</span>
<span class="sd">          as the write directory. If it is not defined it will default to</span>
<span class="sd">          the current directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name for storage of waveform data.  As with dir</span>
<span class="sd">          this parameter is ignored if storage_mode is &quot;gridfs&quot; and is</span>
<span class="sd">          required only if storage_mode is &quot;file&quot;.   Note that this file</span>
<span class="sd">          name does not have to be unique.  The writer always positions</span>
<span class="sd">          the write pointer to the end of the file referenced and sets the</span>
<span class="sd">          attribute &quot;foff&quot; to that position. That allows automatic appends to</span>
<span class="sd">          files without concerns about unique names.  Like the dir argument</span>
<span class="sd">          if this argument is None (default) and storage_mode is &quot;file&quot;</span>
<span class="sd">          the algorithm will first attempt to extract &quot;dfile&quot; from the</span>
<span class="sd">          Metadata of mspass_object.  If that is defined it will be used</span>
<span class="sd">          as the output filename. If it is not defined a uuid generator</span>
<span class="sd">          is used to create a file name with a random string of characters.</span>
<span class="sd">          That usage is never a good idea, but is a feature added to make</span>
<span class="sd">          this method more bombproof.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param format: the format of the file. This can be one of the</span>
<span class="sd">          `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.write.html#supported-formats&gt;`__</span>
<span class="sd">          of ObsPy writer. The default the python None which the method</span>
<span class="sd">          assumes means to store the data in its raw binary form.  The default</span>
<span class="sd">          should normally be used for efficiency.  Alternate formats are</span>
<span class="sd">          primarily a simple export mechanism.  See the User&#39;s manual for</span>
<span class="sd">          more details on data export.  Used only for &quot;file&quot; storage mode.</span>
<span class="sd">          A discussion of format caveats can be found above.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        :param overwrite:  If true gridfs data linked to the original</span>
<span class="sd">          waveform will be replaced by the sample data from this save.</span>
<span class="sd">          Default is false, and should be the normal use.  This option</span>
<span class="sd">          should never be used after a reduce operator as the parents</span>
<span class="sd">          are not tracked and the space advantage is likely minimal for</span>
<span class="sd">          the confusion it would cause.   This is most useful for light, stable</span>
<span class="sd">          preprocessing with a set of map operators to regularize a data</span>
<span class="sd">          set before more extensive processing.  It can only be used when</span>
<span class="sd">          storage_mode is set to gridfs.</span>
<span class="sd">        :type overwrite:  boolean</span>

<span class="sd">        :param exclude_keys: Metadata can often become contaminated with</span>
<span class="sd">          attributes that are no longer needed or a mismatch with the data.</span>
<span class="sd">          A type example is the bundle algorithm takes three TimeSeries</span>
<span class="sd">          objects and produces a single Seismogram from them.  That process</span>
<span class="sd">          can, and usually does, leave things like seed channel names and</span>
<span class="sd">          orientation attributes (hang and vang) from one of the components</span>
<span class="sd">          as extraneous baggage.   Use this of keys to prevent such attributes</span>
<span class="sd">          from being written to the output documents.  Note if the data being</span>
<span class="sd">          saved lack these keys nothing happens so it is safer, albeit slower,</span>
<span class="sd">          to have the list be as large as necessary to eliminate any potential</span>
<span class="sd">          debris.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: The default for this parameter is the python</span>
<span class="sd">          None.  The default should be used for all but data export functions.</span>
<span class="sd">          The normal behavior is for this writer to use the object</span>
<span class="sd">          data type to determine the schema is should use for any type or</span>
<span class="sd">          name enforcement.  This parameter allows an alernate collection to</span>
<span class="sd">          be used with or without some different name and type restrictions.</span>
<span class="sd">          The most common use of anything other than the default is an</span>
<span class="sd">          export to a diffrent format.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key.  See above and</span>
<span class="sd">          User&#39;s manual for guidance on how the use of this option.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        :param cremate:  boolean controlling how dead data are handled.</span>
<span class="sd">          When True a datum marked dead is ignored and the body or a</span>
<span class="sd">          shell of the body (what depends on the return_list value) is</span>
<span class="sd">          returned.  If False (default) the</span>
<span class="sd">          :py:meth:`mspasspy.util.Undertaker.bury` method is called</span>
<span class="sd">          with body as input.  That creates a document for each dead</span>
<span class="sd">          datum either in the &quot;cemetery&quot; or &quot;abortions&quot; collection.</span>
<span class="sd">          See above for more deails.</span>
<span class="sd">        :param normalizing_collections:  list of collection names dogmatically treated</span>
<span class="sd">          as normalizing collection names.  The keywords in the list are used</span>
<span class="sd">          to always (i.e. for all modes) erase any attribute with a key name</span>
<span class="sd">          of the form `collection_attribute where `collection` is one of the collection</span>
<span class="sd">          names in this list and attribute is any string.  Attribute names with the &quot;_&quot;</span>
<span class="sd">          separator are saved unless the collection field matches one one of the</span>
<span class="sd">          strings (e.g. &quot;channel_vang&quot; will be erased before saving to the</span>
<span class="sd">          wf collection while &quot;foo_bar&quot; will not be erased.)  This list should</span>
<span class="sd">          ONLY be changed if a different schema than the default mspass schema</span>
<span class="sd">          is used and different names are used for normalizing collections.</span>
<span class="sd">          (e.g. if one added a &quot;shot&quot; collection to the schema the list would need</span>
<span class="sd">          to be changed to at least add &quot;shot&quot;.)</span>
<span class="sd">        :type normalizing_collection:  list if strings defining collection names.</span>
<span class="sd">        :param save_history:   When True the optional history data will</span>
<span class="sd">          be saved to the database if it was actually enabled in the workflow.</span>
<span class="sd">          If the history container is empty will silently do nothing.</span>
<span class="sd">          Default is False meaning history data is ignored.</span>
<span class="sd">        :return: python dict of requested attributes by default.  Edited</span>
<span class="sd">          copy of input when return_data is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">mspass_object</span><span class="p">,</span>
            <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database.save_data:  arg0 is illegal type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a MsPASS seismic data object&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="c1"># WARNING - if we add a storage_mode this will need to change</span>
        <span class="k">if</span> <span class="n">storage_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Database.save_data:  Unsupported storage_mode=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_mode</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database.save_data:  Illegal value of mode=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;Must be one one of the following:  promiscuous, cautious, or pedantic&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="c1"># We remove dead bodies from ensembles to simplify saving</span>
            <span class="c1"># data below.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">bodies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">bring_out_your_dead</span><span class="p">(</span>
                    <span class="n">mspass_object</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cremate</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bodies</span><span class="o">.</span><span class="n">member</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">bury</span><span class="p">(</span><span class="n">bodies</span><span class="p">)</span>
            <span class="c1"># schema isn&#39;t needed for handling the dead, but we do need it</span>
            <span class="c1"># for creating wf documents</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">)):</span>
                <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># careful - above test for all alllowed data currently makes</span>
                <span class="c1"># this only an else.  If more data types are added this will</span>
                <span class="c1"># break</span>
                <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>

            <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
                <span class="c1"># A weird construct</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>
            <span class="c1"># We need to make sure storage_mode is set in all live data</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># only atomic data can land here</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>

            <span class="c1"># Extend this method to add new storge modes</span>
            <span class="c1"># Note this implementation alters metadata in mspass_object</span>
            <span class="c1"># and all members of ensembles</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span>
                <span class="n">storage_mode</span><span class="o">=</span><span class="n">storage_mode</span><span class="p">,</span>
                <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">,</span>
                <span class="n">dfile</span><span class="o">=</span><span class="n">dfile</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
                <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># ensembles need to loop over members to do the atomic operations</span>
            <span class="c1"># remaining.  Hence, this conditional</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_save_all_documents</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="n">save_schema</span><span class="p">,</span>
                    <span class="n">exclude_keys</span><span class="p">,</span>
                    <span class="n">mode</span><span class="p">,</span>
                    <span class="n">wf_collection</span><span class="p">,</span>
                    <span class="n">save_history</span><span class="p">,</span>
                    <span class="n">data_tag</span><span class="p">,</span>
                    <span class="n">storage_mode</span><span class="p">,</span>
                    <span class="n">normalizing_collections</span><span class="p">,</span>
                    <span class="n">alg_name</span><span class="p">,</span>
                    <span class="n">alg_id</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># note else not elif because above guarantees only ensembles land here</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">sync_metadata</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atomic_save_all_documents</span><span class="p">(</span>
                        <span class="n">d</span><span class="p">,</span>
                        <span class="n">save_schema</span><span class="p">,</span>
                        <span class="n">exclude_keys</span><span class="p">,</span>
                        <span class="n">mode</span><span class="p">,</span>
                        <span class="n">wf_collection</span><span class="p">,</span>
                        <span class="n">save_history</span><span class="p">,</span>
                        <span class="n">data_tag</span><span class="p">,</span>
                        <span class="n">storage_mode</span><span class="p">,</span>
                        <span class="n">normalizing_collections</span><span class="p">,</span>
                        <span class="n">alg_name</span><span class="p">,</span>
                        <span class="n">alg_id</span><span class="p">,</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># may need to clean Metadata before calling this method</span>
            <span class="c1"># to assure there are not values that will cause MongoDB</span>
            <span class="c1"># to throw an exception when the tombstone subdocument</span>
            <span class="c1"># is written.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cremate</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">bury</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">save_history</span><span class="o">=</span><span class="n">save_history</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mspass_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># mpte emsembles with default only return &quot;is_live&quot; because</span>
            <span class="c1"># ids are only set in members.</span>
            <span class="n">retdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s2">&quot;is_live&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">retdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s2">&quot;is_live&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># note this returns an empty dict for dead data</span>
            <span class="k">return</span> <span class="n">retdict</span></div>

<div class="viewcode-block" id="Database.clean_collection"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.clean_collection">[docs]</a>    <span class="k">def</span> <span class="nf">clean_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_undefined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">required_xref_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_missing_xref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delete_missing_required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method can be used to fix a subset of common database problems</span>
<span class="sd">        created during processing that can cause problems if the user tries to</span>
<span class="sd">        read data saved with such blemishes.   The subset of problems</span>
<span class="sd">        are defined as those that are identified by the &quot;dbverify&quot; command</span>
<span class="sd">        line tool or it&#39;s Database equivalent (the verify method of this class).</span>
<span class="sd">        This method is an alternative to the command line tool dbclean.  Use</span>
<span class="sd">        this method for fixes applied as part of a python script.</span>

<span class="sd">        :param collection: the collection you would like to clean. If not specified, use the default wf collection</span>
<span class="sd">        :type collection: :class:`str`</span>
<span class="sd">        :param query: this is a python dict that is assumed to be a query</span>
<span class="sd">         to MongoDB to limit suite of documents to which the requested cleanup</span>
<span class="sd">         methods are applied.  The default will process the entire database</span>
<span class="sd">         collection specified.</span>
<span class="sd">        :type query: :class:`dict`</span>
<span class="sd">        :param rename_undefined: when set the options is assumed to contain</span>
<span class="sd">          a python dict defining how to rename a set of attributes. Each member</span>
<span class="sd">          of the dict is assumed to be of the form ``{original_key:new_key}``</span>
<span class="sd">          Each document handled will change the key from &quot;original_key&quot; to</span>
<span class="sd">          &quot;new_key&quot;.</span>
<span class="sd">        :type rename_undefined: :class:`dict`</span>
<span class="sd">        :param delete_undefined: attributes undefined in the schema can</span>
<span class="sd">          be problematic.  As a minimum they waste storage and memory if they</span>
<span class="sd">          are baggage.  At worst they may cause a downstream process to abort</span>
<span class="sd">          or mark some or all data dead.  On the other hand, undefined data may</span>
<span class="sd">          contain important information you need that for some reason is</span>
<span class="sd">          not defined in the schema.  In that case do not run this method to</span>
<span class="sd">          clear these.  When set true all attributes matching the query will</span>
<span class="sd">          have undefined attributes cleared.</span>
<span class="sd">        :param required_xref_list: in MsPASS we use &quot;normalization&quot; of some common</span>
<span class="sd">          attributes for efficiency.  The stock ones currently are &quot;source&quot;, &quot;site&quot;,</span>
<span class="sd">          and &quot;channel&quot;.  This list is a intimately linked to the</span>
<span class="sd">          delete_missing_xref option.  When that is true this list is</span>
<span class="sd">          enforced to clean debris.  Typical examples are [&#39;site_id&#39;,&#39;source_id&#39;]</span>
<span class="sd">          to require source and receiver geometry.</span>
<span class="sd">        :type required_xref_list: :class:`list`</span>
<span class="sd">        :param delete_missing_xref: Turn this option on to impose a brutal</span>
<span class="sd">          fix for data with missing (required) cross referencing data.  This</span>
<span class="sd">          clean operation, for example, might be necessary to clean up a</span>
<span class="sd">          data set with some channels that defy all attempts to find valid</span>
<span class="sd">          receiver metadata (stationxml stuff for passive data, survey data for</span>
<span class="sd">          active source data).  This clean method is a blunt instrument that</span>
<span class="sd">          should be used as a last resort.  When true the is list of xref</span>
<span class="sd">          keys defined by required_xref_list are tested any document that lacks</span>
<span class="sd">          of the keys will be deleted from the database.</span>
<span class="sd">        :param delete_missing_required: Set to ``True`` to delete this document if any required keys in the database schema is missing. Default is ``False``.</span>
<span class="sd">        :param verbose: Set to ``True`` to print all the operations. Default is ``False``.</span>
<span class="sd">        :param verbose_keys: a list of keys you want to added to better identify problems when error happens. It&#39;s used in the print messages.</span>
<span class="sd">        :type verbose_keys: :class:`list` of :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">verbose_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">verbose_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">required_xref_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">required_xref_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">rename_undefined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename_undefined</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">fixed_cnt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># fix the queried documents in the collection</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)]</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="c1"># no match documents return</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fixed_cnt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">fixed_attr_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span>
                        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span>
                        <span class="n">collection</span><span class="p">,</span>
                        <span class="n">rename_undefined</span><span class="p">,</span>
                        <span class="n">delete_undefined</span><span class="p">,</span>
                        <span class="n">required_xref_list</span><span class="p">,</span>
                        <span class="n">delete_missing_xref</span><span class="p">,</span>
                        <span class="n">delete_missing_required</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="p">,</span>
                        <span class="n">verbose_keys</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_attr_cnt</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_cnt</span><span class="p">:</span>
                            <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">fixed_cnt</span></div>

    <span class="c1"># clean a single document in the given collection atomically</span>
<div class="viewcode-block" id="Database.clean"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">document_id</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">rename_undefined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">required_xref_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_missing_xref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delete_missing_required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the atomic level operation for cleaning a single database</span>
<span class="sd">        document with one or more common fixes.  The clean_collection method</span>
<span class="sd">        is mainly a loop that calls this method for each document it is asked to</span>
<span class="sd">        handle.  Most users will likely not need or want to call this method</span>
<span class="sd">        directly but use the clean_collection method instead.  See the docstring</span>
<span class="sd">        for clean_collection for a less cyptic description of the options as</span>
<span class="sd">        the options are identical.</span>

<span class="sd">        :param document_id: the value of the _id field in the document you want to clean</span>
<span class="sd">        :type document_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :param collection: the name of collection saving the document. If not specified, use the default wf collection</span>
<span class="sd">        :param rename_undefined: Specify a :class:`dict` of ``{original_key:new_key}`` to rename the undefined keys in the document.</span>
<span class="sd">        :type rename_undefined: :class:`dict`</span>
<span class="sd">        :param delete_undefined: Set to ``True`` to delete undefined keys in the doc. ``rename_undefined`` will not work if this is ``True``. Default is ``False``.</span>
<span class="sd">        :param required_xref_list: a :class:`list` of xref keys to be checked.</span>
<span class="sd">        :type required_xref_list: :class:`list`</span>
<span class="sd">        :param delete_missing_xref: Set to ``True`` to delete this document if any keys specified in ``required_xref_list`` is missing. Default is ``False``.</span>
<span class="sd">        :param delete_missing_required: Set to ``True`` to delete this document if any required keys in the database schema is missing. Default is ``False``.</span>
<span class="sd">        :param verbose: Set to ``True`` to print all the operations. Default is ``False``.</span>
<span class="sd">        :param verbose_keys: a list of keys you want to added to better identify problems when error happens. It&#39;s used in the print messages.</span>
<span class="sd">        :type verbose_keys: :class:`list` of :class:`str`</span>

<span class="sd">        :return: number of fixes applied to each key</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">verbose_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">required_xref_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">required_xref_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">rename_undefined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename_undefined</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># validate parameters</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">verbose_keys</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;verbose_keys should be a list , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">verbose_keys</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">rename_undefined</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;rename_undefined should be a dict , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rename_undefined</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">required_xref_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;required_xref_list should be a list , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">required_xref_list</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">print_messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fixed_cnt</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># if the document does not exist in the db collection, return</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">document_id</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> document _id: </span><span class="si">{}</span><span class="s2">, is not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">collection</span><span class="p">,</span> <span class="n">document_id</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fixed_cnt</span>

        <span class="c1"># access each key</span>
        <span class="n">log_id_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># get all the values of the verbose_keys</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">verbose_keys</span><span class="p">:</span>
                <span class="n">log_id_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">log_helper</span> <span class="o">=</span> <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> document _id: </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">log_id_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">log_helper</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># 1. check if the document has all the required fields</span>
        <span class="n">missing_required_attr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">has_alias</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="c1"># get the aliases list of the key</span>
                    <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">aliases</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">keys_for_checking</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># check if any key appear in the doc</span>
                <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_for_checking</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                        <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key_in_doc</span><span class="p">:</span>
                    <span class="n">missing_required_attr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_required_attr_list</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;required attribute: &quot;</span>
            <span class="k">for</span> <span class="n">missing_attr</span> <span class="ow">in</span> <span class="n">missing_required_attr_list</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_attr</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;are missing.&quot;</span>

            <span class="c1"># delete this document</span>
            <span class="k">if</span> <span class="n">delete_missing_required</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_data</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span> <span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> the document is deleted.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">fixed_cnt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>

        <span class="c1"># 2. check if the document has all xref keys in the required_xref_list list provided by user</span>
        <span class="n">missing_xref_key_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xref_k</span> <span class="ow">in</span> <span class="n">required_xref_list</span><span class="p">:</span>
            <span class="c1"># xref_k in required_xref_list list should be defined in schema first</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">xref_k</span><span class="p">):</span>
                <span class="n">unique_xref_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_k</span><span class="p">)</span>
                <span class="c1"># xref_k should be a reference key as well</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_xref_key</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">):</span>
                    <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">has_alias</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">):</span>
                        <span class="c1"># get the aliases list of the key</span>
                        <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">aliases</span><span class="p">(</span>
                            <span class="n">unique_xref_k</span>
                        <span class="p">)</span>
                    <span class="n">keys_for_checking</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">)</span>
                    <span class="c1"># check if any key appear in the doc</span>
                    <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_for_checking</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                            <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">key_in_doc</span><span class="p">:</span>
                        <span class="n">missing_xref_key_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">)</span>
        <span class="c1"># missing required xref keys, should be deleted</span>
        <span class="k">if</span> <span class="n">missing_xref_key_list</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;required xref keys: &quot;</span>
            <span class="k">for</span> <span class="n">missing_key</span> <span class="ow">in</span> <span class="n">missing_xref_key_list</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_key</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;are missing.&quot;</span>

            <span class="c1"># delete this document</span>
            <span class="k">if</span> <span class="n">delete_missing_xref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_data</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span> <span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> the document is deleted.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">fixed_cnt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>

        <span class="c1"># 3. try to fix the mismtach errors in the doc</span>
        <span class="n">update_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># if not the schema keys, ignore schema type check enforcement</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="c1"># delete undefined attributes in the doc if delete_undefined is True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">delete_undefined</span><span class="p">:</span>
                    <span class="c1"># try to rename the user specified keys</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_undefined</span><span class="p">:</span>
                        <span class="n">update_dict</span><span class="p">[</span><span class="n">rename_undefined</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">update_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="c1"># to remove aliases, get the unique key name defined in the schema</span>
            <span class="n">unique_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">update_dict</span><span class="p">[</span><span class="n">unique_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span>
                        <span class="n">unique_k</span>
                    <span class="p">)(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">attribute </span><span class="si">{}</span><span class="s2"> conversion from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> is done.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">log_helper</span><span class="p">,</span>
                            <span class="n">unique_k</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fixed_cnt</span><span class="p">:</span>
                        <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">attribute </span><span class="si">{}</span><span class="s2"> conversion from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> cannot be done.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">log_helper</span><span class="p">,</span>
                            <span class="n">unique_k</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># attribute values remain the same</span>
                <span class="n">update_dict</span><span class="p">[</span><span class="n">unique_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># 4. update the fixed attributes in the document in the collection</span>
        <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}</span>
        <span class="c1"># use replace_one here because there may be some aliases in the document</span>
        <span class="n">col</span><span class="o">.</span><span class="n">replace_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="n">update_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">print_messages</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fixed_cnt</span></div>

<div class="viewcode-block" id="Database.verify"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document_id</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span> <span class="n">tests</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;xref&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;undefined&quot;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an atomic-level operation to search for known issues in</span>
<span class="sd">        Metadata stored in a database and needed to construct a valid</span>
<span class="sd">        data set for starting a workflow.  By &quot;atomic&quot; we main the operation</span>
<span class="sd">        is for a single document in MongoDB linked to an atomic data</span>
<span class="sd">        object (currently that means TimeSeries or Seismogram objects).</span>
<span class="sd">        The tests are the same as those available through the command</span>
<span class="sd">        line tool dbverify.  See the man page for that tool and the</span>
<span class="sd">        user&#39;s manual for more details about the tests this method</span>
<span class="sd">        enables.</span>

<span class="sd">        :param document_id: the value of the _id field in the document you want to verify</span>
<span class="sd">        :type document_id: :class:`bson.ObjectId.ObjectId` of document to be tested</span>
<span class="sd">        :param collection: the name of collection to which document_id is</span>
<span class="sd">         expected to provide a unique match.  If not specified, uses the default wf collection</span>
<span class="sd">        :param tests: this should be a python list of test to apply by</span>
<span class="sd">         name keywords.  Test nams allowed are &#39;xref&#39;, &#39;type&#39;,</span>
<span class="sd">         and &#39;undefined&#39;.   Default runs all tests.   Specify a subset of those</span>
<span class="sd">         keywords to be more restrictive.</span>
<span class="sd">        :type tests: :class:`list` of :class:`str`</span>

<span class="sd">        :return: a python dict keyed by a problematic key.  The value in each</span>
<span class="sd">          entry is the name of the failed test (i.e. &#39;xref&#39;, &#39;type&#39;, or &#39;undefined&#39;)</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        :excpetion: This method will throw a fatal error exception if the</span>
<span class="sd">          id received does no match any document in the database.  That is</span>
<span class="sd">          intentional as the method should normally appear in a loop over</span>
<span class="sd">          ids found after query and the ids should then always be valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check tests</span>
        <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xref&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;undefined&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;only xref, type and undefined are supported, but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">test</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># remove redundant if happens</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tests</span><span class="p">))</span>

        <span class="n">problematic_keys</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">document_id</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Database.verify:  ObjectId=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">document_id</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; has no matching document in &quot;</span>
                <span class="o">+</span> <span class="n">collection</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># run the tests</span>
        <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;xref&quot;</span><span class="p">:</span>
                <span class="c1"># test every possible xref keys in the doc</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xref_key</span><span class="p">(</span>
                        <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_bad_xref_key</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                            <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;undefined&quot;</span><span class="p">:</span>
                <span class="n">undefined_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_undefined_keys</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">undefined_keys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                <span class="c1"># check if there are type mismatch between keys in doc and keys in schema</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_mismatch_key</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                            <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">problematic_keys</span></div>

    <span class="k">def</span> <span class="nf">_check_xref_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">xref_key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atomic function checks for a single xref_key in a single document.</span>
<span class="sd">        It used by the verify method.</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>
<span class="sd">        :param xref_key:  the xref key we need to check in the document</span>

<span class="sd">        :return: (is_bad_xref_key, is_bad_wf)</span>
<span class="sd">        :rtype: a :class:`tuple` of two :class:`bool`s</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># if xref_key is not defind -&gt; not checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">xref_key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="c1"># if xref_key is not a xref_key -&gt; not checking</span>
        <span class="n">unique_xref_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_xref_key</span><span class="p">(</span><span class="n">unique_xref_key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="c1"># if the xref_key is not in the doc -&gt; bad_wf</span>
        <span class="k">if</span> <span class="n">xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span> <span class="ow">and</span> <span class="n">unique_xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="k">if</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">xref_key_val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">xref_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xref_key_val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">unique_xref_key</span><span class="p">]</span>

        <span class="c1"># if we can&#39;t find document in the normalized collection/invalid xref_key naming -&gt; bad_xref_key</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">unique_xref_key</span> <span class="ow">and</span> <span class="n">unique_xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span>
            <span class="n">normalized_collection_name</span> <span class="o">=</span> <span class="n">unique_xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">normalized_collection_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span>
                <span class="n">normalized_collection_name</span>
            <span class="p">)</span>
            <span class="n">normalized_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">normalized_collection_name</span><span class="p">]</span>
            <span class="c1"># try to find the referenced docuement</span>
            <span class="n">normalized_doc</span> <span class="o">=</span> <span class="n">normalized_col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">xref_key_val</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">normalized_doc</span><span class="p">:</span>
                <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># invalid xref_key name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

    <span class="k">def</span> <span class="nf">_check_undefined_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atmoic function checks for if there are undefined required</span>
<span class="sd">        keys in a single document.  It is used by the verify method.</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>

<span class="sd">        :return: undefined_keys</span>
<span class="sd">        :rtype: :class:`list`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">undefined_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># check if doc has every required key in the collection schema</span>
        <span class="n">unique_doc_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># change possible aliases to unique keys</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">unique_doc_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_doc_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># check every required keys in the collection schema</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">required_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_doc_keys</span><span class="p">:</span>
                <span class="n">undefined_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">undefined_keys</span>

    <span class="k">def</span> <span class="nf">_check_mismatch_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atmoic function checks for if the key is mismatch with the schema</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>
<span class="sd">        :param key:  the key we need to check in the document</span>

<span class="sd">        :return: is_mismatch_key, if True, it means key is mismatch with the schema</span>
<span class="sd">        :rtype: :class:`bool`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_mismatch_key</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">unique_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span> <span class="k">else</span> <span class="n">doc</span><span class="p">[</span><span class="n">unique_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_key</span><span class="p">)):</span>
                <span class="n">is_mismatch_key</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_mismatch_key</span>

    <span class="k">def</span> <span class="nf">_delete_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">keylist</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes all occurrences of attributes linked to keys defined</span>
<span class="sd">        in a list of keywords passed as (required) keylist argument.</span>
<span class="sd">        If a key is not in a given document no action is taken.</span>

<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param keylist:  list of keys for elements of each document</span>
<span class="sd">        that are to be deleted.   key are not test against schema</span>
<span class="sd">        but all matches will be deleted.</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when ``True`` edit will produce a line of printed</span>
<span class="sd">        output describing what was deleted.  Use this option only if</span>
<span class="sd">        you know from dbverify the number of changes to be made are small.</span>

<span class="sd">        :return:  dict keyed by the keys of all deleted entries.  The value</span>
<span class="sd">        of each entry is the number of documents the key was deleted from.</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># preload counts to 0 so we get a return saying 0 when no changes</span>
        <span class="c1"># are made</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">todel</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">todel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Deleted &quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="s2">&quot; with key=&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot; from doc with id=&quot;</span><span class="p">,</span> <span class="nb">id</span>
                        <span class="p">)</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$unset&quot;</span><span class="p">:</span> <span class="n">todel</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_rename_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">rename_map</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames specified keys for all or a subset of documents in a</span>
<span class="sd">        MongoDB collection.   The updates are driven by an input python</span>
<span class="sd">        dict passed as the rename_map argument. The keys of rename_map define</span>
<span class="sd">        doc keys that should be changed.  The values of the key-value</span>
<span class="sd">        pairs in rename_map are the new keys assigned to each match.</span>


<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param rename_map:  remap definition dict used as described above.</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when true edit will produce a line of printed</span>
<span class="sd">        output describing what was deleted.  Use this option only if</span>
<span class="sd">        you know from dbverify the number of changes to be made are small.</span>
<span class="sd">        When false the function runs silently.</span>

<span class="sd">        :return:  dict keyed by the keys of all changed entries.  The value</span>
<span class="sd">        of each entry is the number of documents changed.  The keys are the</span>
<span class="sd">        original keys.  displays of result should old and new keys using</span>
<span class="sd">        the rename_map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># preload counts to 0 so we get a return saying 0 when no changes</span>
        <span class="c1"># are made</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">newkey</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Changed attribute with key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; to have new key=&quot;</span><span class="p">,</span>
                            <span class="n">newkey</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attribute value=&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">doc</span><span class="p">[</span><span class="n">newkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">replace_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="n">doc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_fix_attribute_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function attempts to fix type collisions in the schema defined</span>
<span class="sd">        for the specified database and collection.  It tries to fix any</span>
<span class="sd">        type mismatch that can be repaired by the python equivalent of a</span>
<span class="sd">        type cast (an obscure syntax that can be seen in the actual code).</span>
<span class="sd">        Known examples are it can cleanly convert something like an int to</span>
<span class="sd">        a float or vice-versa, but it cannot do something like convert an</span>
<span class="sd">        alpha string to a number. Note, however, that python does cleanly</span>
<span class="sd">        convert simple number strings to number.  For example:  x=int(&#39;10&#39;)</span>
<span class="sd">        will yield an &quot;int&quot; class number of 10.  x=int(&#39;foo&#39;), however, will</span>
<span class="sd">        not work.   Impossible conversions will not abort the function but</span>
<span class="sd">        will generate an error message printed to stdout.  The function</span>
<span class="sd">        continues on so if there are a large number of such errors the</span>
<span class="sd">        output could become voluminous.  ALWAYS run dbverify before trying</span>
<span class="sd">        this function (directly or indirectly through the command line</span>
<span class="sd">        tool dbclean).</span>

<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when true edit will produce one or more lines of</span>
<span class="sd">        printed output for each change it makes.  The default is false.</span>
<span class="sd">        Needless verbose should be avoided unless you are certain the</span>
<span class="sd">        number of changes it will make are small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;////////Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;/////////&quot;</span><span class="p">)</span>
            <span class="n">up_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Warning:  in doc with id=&quot;</span><span class="p">,</span>
                            <span class="nb">id</span><span class="p">,</span>
                            <span class="s2">&quot;found key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; that is not defined in the schema&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Value of key-value pair=&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot check type for an unknown attribute name&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">newval</span> <span class="o">=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">val</span><span class="p">)</span>
                        <span class="n">up_d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">newval</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;Changed data for key=&quot;</span><span class="p">,</span>
                                <span class="n">k</span><span class="p">,</span>
                                <span class="s2">&quot; from &quot;</span><span class="p">,</span>
                                <span class="n">val</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">newval</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;////////Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;/////////&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;WARNING:  could not convert attribute with key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; and value=&quot;</span><span class="p">,</span>
                            <span class="n">val</span><span class="p">,</span>
                            <span class="s2">&quot; to required type=&quot;</span><span class="p">,</span>
                            <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This error was thrown and handled:  &quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">up_d</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_check_links</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xref_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">error_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks for missing cross-referencing ids in a</span>
<span class="sd">        specified wf collection (i.e. wf_TimeSeries or wf_Seismogram)</span>
<span class="sd">        It scans the wf collection to detect two potential errors:</span>
<span class="sd">        (1) documents with the normalization key completely missing</span>
<span class="sd">        and (2) documents where the key is present does not match any</span>
<span class="sd">        document in normalization collection.   By default this</span>
<span class="sd">        function operates silently assuming the caller will</span>
<span class="sd">        create a readable report from the return that defines</span>
<span class="sd">        the documents that had errors.  This function is used in the</span>
<span class="sd">        verify standalone program that acts as a front end to tests</span>
<span class="sd">        in this module.  The function can be run in independently</span>
<span class="sd">        so there is a verbose option to print errors as they are encountered.</span>

<span class="sd">        :param xref_key: the normalized key you would like to check</span>
<span class="sd">        :param collection:  mspass waveform collection on which the normalization</span>
<span class="sd">        check is to be performed.  default is wf_TimeSeries.</span>
<span class="sd">        Currently only accepted alternative is wf_Seismogram.</span>
<span class="sd">        :param wfquery:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire wf collection.</span>
<span class="sd">        :param verbose:  when True errors will be printed.  By default</span>
<span class="sd">        the function works silently and you should use the output to</span>
<span class="sd">        interact with any errors returned.</span>
<span class="sd">        :param error_limit: Is a sanity check on the number of errors logged.</span>
<span class="sd">        Errors of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  returns a tuple with two lists.  Both lists are ObjectIds</span>
<span class="sd">        of the scanned wf collection that have errors.  component 0</span>
<span class="sd">        of the tuple contains ids of wf entries that have the normalization</span>
<span class="sd">        id set but the id does not resolve with the normalization collection.</span>
<span class="sd">        component 1 contains the ids of documents in the wf collection that</span>
<span class="sd">        do not contain the normalization id key at all (a more common problem)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># schema doesn&#39;t currently have a way to list normalized</span>
        <span class="c1"># collection names.  For now we just freeze the names</span>
        <span class="c1"># and put them in this one place for maintainability</span>

        <span class="c1"># undefined collection name in the schema</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_links:  collection </span><span class="si">{}</span><span class="s2"> is not defined in database schema&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># get all the xref_keys in the collection by schema</span>
        <span class="n">xref_keys_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">xref_keys</span><span class="p">()</span>

        <span class="c1"># the list of xref_key that should be checked</span>
        <span class="n">xref_keys</span> <span class="o">=</span> <span class="n">xref_key</span>

        <span class="c1"># if xref_key is not defined, check all xref_keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xref_key</span><span class="p">:</span>
            <span class="n">xref_keys</span> <span class="o">=</span> <span class="n">xref_keys_list</span>

        <span class="c1"># if specified as a single key, wrap it as a list for better processing next</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">xref_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">xref_key</span><span class="p">]</span>

        <span class="c1"># check every key in the xref_key list if it is legal</span>
        <span class="k">for</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">xref_keys</span><span class="p">:</span>
            <span class="n">unique_xref_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unique_xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xref_keys_list</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_links:  illegal value for normalize arg=&quot;</span> <span class="o">+</span> <span class="n">xref_key</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span>

        <span class="c1"># We accumulate bad ids in this list that is returned</span>
        <span class="n">bad_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">missing_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># check for each xref_key in xref_keys</span>
        <span class="k">for</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">xref_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">xref_key</span> <span class="ow">and</span> <span class="n">xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span>
                <span class="n">normalize</span> <span class="o">=</span> <span class="n">xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">normalize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">normalize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_links:  illegal value for normalize arg=&quot;</span>
                    <span class="o">+</span> <span class="n">xref_key</span>
                    <span class="o">+</span> <span class="s2">&quot; should be in the form of xxx_id&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">dbwf</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">dbwf</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;checklinks:  &quot;</span>
                    <span class="o">+</span> <span class="n">wf_collection</span>
                    <span class="o">+</span> <span class="s2">&quot; collection has no data matching query=&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">wfquery</span><span class="p">),</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Starting cross reference link check for &quot;</span><span class="p">,</span>
                    <span class="n">wf_collection</span><span class="p">,</span>
                    <span class="s2">&quot; collection using id=&quot;</span><span class="p">,</span>
                    <span class="n">xref_key</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This should resolve links to &quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="s2">&quot; collection&quot;</span><span class="p">)</span>

            <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbwf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
                <span class="n">wfid</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
                <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xref_key</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span> <span class="n">wf_collection</span><span class="p">,</span> <span class="n">xref_key</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_bad_xref_key</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wfid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_id_list</span><span class="p">:</span>
                        <span class="n">bad_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">wfid</span><span class="p">),</span> <span class="s2">&quot; link with &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">xref_key</span><span class="p">),</span> <span class="s2">&quot; failed&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_id_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">error_limit</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;checklinks:  number of bad id errors exceeds internal limit&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_bad_wf</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wfid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_id_list</span><span class="p">:</span>
                        <span class="n">missing_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">wfid</span><span class="p">),</span> <span class="s2">&quot; is missing required key=&quot;</span><span class="p">,</span> <span class="n">xref_key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_id_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">error_limit</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;checklinks:  number of missing id errors exceeds internal limit&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">bad_id_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_id_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                <span class="p">):</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bad_id_list</span><span class="p">,</span> <span class="n">missing_id_list</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_check_attribute_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">error_limit</span><span class="o">=</span><span class="mi">1000</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the integrity of all attributes</span>
<span class="sd">        found in a specfied collection.  It is designed to detect two</span>
<span class="sd">        kinds of problems:  (1) type mismatches between what is stored</span>
<span class="sd">        in the database and what is defined for the schema, and (2)</span>
<span class="sd">        data with a key that is not recognized.  Both tests are necessary</span>
<span class="sd">        because unlike a relational database MongoDB is very promiscuous</span>
<span class="sd">        about type and exactly what goes into a document.  MongoDB pretty</span>
<span class="sd">        much allow type it knows about to be associated with any key</span>
<span class="sd">        you choose.   In MsPASS we need to enforce some type restrictions</span>
<span class="sd">        to prevent C++ wrapped algorithms from aborting with type mismatches.</span>
<span class="sd">        Hence, it is important to run this test on all collections needed</span>
<span class="sd">        by a workflow before starting a large job.</span>

<span class="sd">        :param collection:  MongoDB collection that is to be scanned</span>
<span class="sd">        for errors.  Note with normalized data this function should be</span>
<span class="sd">        run on the appropriate wf collection and all normalization</span>
<span class="sd">        collections the wf collection needs to link to.</span>
<span class="sd">        :param query:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire collection requested.</span>
<span class="sd">        :param verbose:  when True errors will be printed.   The default is</span>
<span class="sd">        False and the function will do it&#39;s work silently.   Verbose is</span>
<span class="sd">        most useful in an interactive python session where the function</span>
<span class="sd">        is called directly.  Most users will run this function</span>
<span class="sd">        as part of tests driven by the dbverify program.</span>
<span class="sd">        :param error_limit: Is a sanity check the number of errors logged</span>
<span class="sd">        The number of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  returns a tuple with two python dict containers.</span>
<span class="sd">        The component 0 python dict contains details of type mismatch errors.</span>
<span class="sd">        Component 1 contains details for data with undefined keys.</span>
<span class="sd">        Both python dict containers are keyed by the ObjectId of the</span>
<span class="sd">        document from which they were retrieved.  The values associated</span>
<span class="sd">        with each entry are like MongoDB subdocuments.  That is, the value</span>
<span class="sd">        return is itself a dict. The dict value contains key-value pairs</span>
<span class="sd">        that defined the error (type mismatch for 0 and undefined for 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># The following two can throw MsPASS errors but we let them</span>
        <span class="c1"># do so. Callers should have a handler for MsPASSError</span>
        <span class="n">dbschema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="c1"># This holds the schema for the collection to be scanned</span>
        <span class="c1"># dbschema is mostly an index to one of these</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">dbschema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_attribute_types:  query=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; yields zero matching documents&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">bad_type_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">undefined_key_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">bad_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">undefined_keys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">bad_types</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;doc with id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot; type mismatch for key=&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;value=&quot;</span><span class="p">,</span>
                                <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                <span class="s2">&quot; does not match expected type=&quot;</span><span class="p">,</span>
                                <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">undefined_keys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;doc with id=&quot;</span><span class="p">,</span>
                            <span class="nb">id</span><span class="p">,</span>
                            <span class="s2">&quot; has undefined key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; with value=&quot;</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bad_type_docs</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_types</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">undefined_key_docs</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">undefined_keys</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">undefined_key_docs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_type_docs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
            <span class="p">):</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bad_type_docs</span><span class="p">,</span> <span class="n">undefined_key_docs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_check_required</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">],</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">error_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies a test to assure a list of attributes</span>
<span class="sd">        are defined and of the right type.   This function is needed</span>
<span class="sd">        because certain attributes are essential in two different contexts.</span>
<span class="sd">        First, for waveform data there are some attributes that are</span>
<span class="sd">        required to construct the data object (e.g. sample interal or</span>
<span class="sd">        sample rate, start time, etc.).  Secondly, workflows generally</span>
<span class="sd">        require certain Metadata and what is required depends upon the</span>
<span class="sd">        workflow.  For example, any work with sources normally requires</span>
<span class="sd">        information about both station and instrument properties as well</span>
<span class="sd">        as source.  The opposite is noise correlation work where only</span>
<span class="sd">        station information is essential.</span>

<span class="sd">        :param collection:  MongoDB collection that is to be scanned</span>
<span class="sd">        for errors.  Note with normalized data this function should be</span>
<span class="sd">        run on the appropriate wf collection and all normalization</span>
<span class="sd">        collections the wf collection needs to link to.</span>
<span class="sd">        :param keys:  is a list of strings that are to be checked</span>
<span class="sd">        against the contents of the collection.  Note one of the first</span>
<span class="sd">        things the function does is test for the validity of the keys.</span>
<span class="sd">        If they are not defined in the schema the function will throw</span>
<span class="sd">        a MsPASSError exception.</span>
<span class="sd">        :param query:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire collection requested.</span>
<span class="sd">        :param verbose:  when True errors will be printed.   The default is</span>
<span class="sd">        False and the function will do it&#39;s work silently.   Verbose is</span>
<span class="sd">        most useful in an interactive python session where the function</span>
<span class="sd">        is called directly.  Most users will run this function</span>
<span class="sd">        as part of tests driven by the dbverify program.</span>
<span class="sd">        :param error_limit: Is a sanity check the number of errors logged</span>
<span class="sd">        The number of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  tuple with two components. Both components contain a</span>
<span class="sd">        python dict container keyed by ObjectId of problem documents.</span>
<span class="sd">        The values in the component 0 dict are themselves python dict</span>
<span class="sd">        containers that are like MongoDB subdocuments).  The key-value</span>
<span class="sd">        pairs in that dict are required data with a type mismatch with the schema.</span>
<span class="sd">        The values in component 1 are python lists of keys that had</span>
<span class="sd">        no assigned value but were defined as required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_required:  list of required keys is empty &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;- nothing to test&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># The following two can throw MsPASS errors but we let them</span>
        <span class="c1"># do so. Callers should have a handler for MsPASSError</span>
        <span class="n">dbschema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="c1"># This holds the schema for the collection to be scanned</span>
        <span class="c1"># dbschema is mostly an index to one of these</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">dbschema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="c1"># We first make sure the user didn&#39;t make a mistake in giving an</span>
        <span class="c1"># invalid key for the required list</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_required:  schema has no definition for key=&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_required:  query=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; yields zero matching documents&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">undef</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">wrong_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
            <span class="n">undef_this</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">wrong_this</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">undef_this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">wrong_this</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undef_this</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">undef</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">undef_this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrong_this</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wrong_types</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrong_types</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">undef</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">wrong_types</span><span class="p">,</span> <span class="n">undef</span><span class="p">])</span>

<div class="viewcode-block" id="Database.update_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">update_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cautious&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizing_collections</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">],</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method if you want to save the output of a processing algorithm</span>
<span class="sd">        whose output is only posted to metadata.   That can be something as</span>
<span class="sd">        simple as a little python function that does some calculations on other</span>
<span class="sd">        metadata field, or as elaborate as a bound FORTRAN or C/C++ function</span>
<span class="sd">        that computes something, posts the results to Metadata, but doesn&#39;t</span>
<span class="sd">        actually alter the sample data.   A type example of the later is an amplitude</span>
<span class="sd">        calculation that posts the computed amplitude to some metadata key value.</span>

<span class="sd">        This method will ONLY attempt to update Metadata attributes stored in the</span>
<span class="sd">        data passed (mspass_object) that have been marked as having been</span>
<span class="sd">        changed since creation of the data object.  The default mode will</span>
<span class="sd">        check entries against the schema and attempt to fix any type</span>
<span class="sd">        mismatches (mode==&#39;cautious&#39; for this algorithm).  In cautious or</span>
<span class="sd">        pedantic mode this method can end up posting a lot of errors in</span>
<span class="sd">        elog for data object (mspass_object) being handled.  In</span>
<span class="sd">        promiscuous mode there are no safeties and the any values</span>
<span class="sd">        that are defined in Metadata as having been changed will be</span>
<span class="sd">        posted as an update to the parent wf document to the data object.</span>

<span class="sd">        A feature of the schema that is considered an unbreakable rule is</span>
<span class="sd">        that any attribute marked &quot;readonly&quot; in the schema cannot by</span>
<span class="sd">        definition be updated with this method.  It utilizes the same</span>
<span class="sd">        method for handling this as the save_data method.  That is,</span>
<span class="sd">        for all &quot;mode&quot; parameters if an key is defined in the schema as</span>
<span class="sd">        readonly and it is listed as having been modified, it will</span>
<span class="sd">        be save with a new key creating by adding the prefix</span>
<span class="sd">        &quot;READONLYERROR_&quot; .  e.g. if we had a site_sta read as</span>
<span class="sd">        &#39;AAK&#39; but we changed it to &#39;XYZ&#39; in a workflow, when we tried</span>
<span class="sd">        to save the data you will find an entry in the document</span>
<span class="sd">        of {&#39;READONLYERROR_site_sta&#39; : &#39;XYZ&#39;}</span>

<span class="sd">        :param mspass_object: the object you want to update.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param exclude_keys: a list of metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param force_keys: a list of metadata attributes you want to force</span>
<span class="sd">         to be updated.   Normally this method will only update attributes</span>
<span class="sd">         that have been marked as changed since creation of the parent data</span>
<span class="sd">         object.  If data with these keys is found in the mspass_object they</span>
<span class="sd">         will be added to the update record.</span>
<span class="sd">        :type force_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param mode: This parameter defines how attributes defines how</span>
<span class="sd">          strongly to enforce schema constraints. As described above</span>
<span class="sd">          &#39;promiscuous&#39; justs updates all changed values with no schema</span>
<span class="sd">          tests.  &#39;cautious&#39;, the default, enforces type constraints and</span>
<span class="sd">          tries to convert easily fixed type mismatches (e.g. int to floats</span>
<span class="sd">          of vice versa).  Both &#39;cautious&#39; and &#39;pedantic&#39; may leave one or</span>
<span class="sd">          more complaint message in the elog of mspass_object on how the</span>
<span class="sd">          method did or did not fix mismatches with the schema.  Both</span>
<span class="sd">          also will drop any key-value pairs where the value cannot be</span>
<span class="sd">          converted to the type defined in the schema.</span>

<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">        :type alg_name: :class:`str`</span>
<span class="sd">        :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">        :type alg_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :return: mspass_object data.  Normally this is an unaltered copy</span>
<span class="sd">          of the data passed through mspass_object.  If there are errors,</span>
<span class="sd">          however, the elog will contain new messages.  Note any such</span>
<span class="sd">          messages are volatile and will not be saved to the database</span>
<span class="sd">          until the save_data method is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;:  only TimeSeries and Seismogram are supported</span><span class="se">\n</span><span class="s2">Received data of type=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># Return a None immediately if the data is marked dead - signal it did nothing</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;: only promiscuous, cautious and pedantic are supported, but </span><span class="si">{}</span><span class="s2"> was requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">wfid</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;: input data object is missing required waveform object id value (_id) - update is not possible without it&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
            <span class="c1"># A weird construct</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>
        <span class="c1"># One last check.  Make sure a document with the _id in mspass_object</span>
        <span class="c1"># exists.  If it doesn&#39;t exist, post an elog about this</span>
        <span class="n">test_doc</span> <span class="o">=</span> <span class="n">wf_collection</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wfid</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_doc</span><span class="p">:</span>  <span class="c1"># find_one returns None if find fails</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cannot find the document in the wf collection by the _id field in the object&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># FIXME starttime will be automatically created in this function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

        <span class="c1"># This method of Metadata returns a list of all</span>
        <span class="c1"># attributes that were changed after creation of the</span>
        <span class="c1"># object to which they are attached.</span>
        <span class="n">changed_key_list</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">modified</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">force_keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">force_keys</span><span class="p">:</span>
                <span class="n">changed_key_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

        <span class="c1"># clear all the aliases</span>
        <span class="c1"># TODO  check for potential bug in handling clear_aliases</span>
        <span class="c1"># and modified method - i.e. keys returned by modified may be</span>
        <span class="c1"># aliases</span>
        <span class="n">save_schema</span><span class="o">.</span><span class="n">clear_aliases</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>

        <span class="c1"># remove any values with only spaces</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># always exclude normalization data defined by names like site_lat</span>
        <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">_erase_normalized</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">,</span> <span class="n">normalizing_collections</span><span class="p">)</span>
        <span class="c1"># Done editing, now we convert copied_metadata to a python dict</span>
        <span class="c1"># using this Metadata method or the long version when in cautious or pedantic mode</span>
        <span class="n">insertion_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
            <span class="c1"># In this case we blindly update all entries that show</span>
            <span class="c1"># as modified that aren&#39;t in the exclude list</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                    <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># first handle readonly constraints</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                            <span class="n">newkey</span> <span class="o">=</span> <span class="s2">&quot;READONLYERROR_&quot;</span> <span class="o">+</span> <span class="n">k</span>
                            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">change_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;readonly attribute with key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; was improperly modified.  Saved changed value with key=&quot;</span>
                                <span class="o">+</span> <span class="n">newkey</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># Other modes have to test every key and type of value</span>
            <span class="c1"># before continuing.  pedantic logs an error for all problems</span>
            <span class="c1"># Both attempt to fix type mismatches before update.  Cautious</span>
            <span class="c1"># is silent unless the type problem cannot be repaired.  In that</span>
            <span class="c1"># case both will not attempt to update the offending key-value</span>
            <span class="c1"># Note many errors can be posted - one for each problem key-value pair</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;pedantic mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="s2">&quot; type of stored value=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot; does not match schema expectation=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting to correct type mismatch&quot;</span>
                                <span class="p">)</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                <span class="p">)</span>
                            <span class="c1"># Note we land here for both pedantic and cautious but not promiscuous</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># The following convert the actual value in a dict to a required type.</span>
                                <span class="c1"># This is because the return of type() is the class reference.</span>
                                <span class="n">old_value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span>
                                    <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="p">)</span>
                                <span class="n">new_value</span> <span class="o">=</span> <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="s2">&quot;Had to convert type of data with key=&quot;</span>
                                    <span class="o">+</span> <span class="n">k</span>
                                    <span class="o">+</span> <span class="s2">&quot; from &quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">old_value</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot; to &quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new_value</span><span class="p">))</span>
                                <span class="p">)</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Cannot update data with key=&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                                    <span class="c1"># pedantic mode</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                    <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                        <span class="s2">&quot;pedantic mode error: key value could not be converted to required type=&quot;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                        <span class="o">+</span> <span class="s2">&quot; actual type=&quot;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                        <span class="o">+</span> <span class="s2">&quot;, the object is killed&quot;</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># cautious mode</span>
                                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot; Required key value could not be converted to required type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                            <span class="o">+</span> <span class="s2">&quot; actual type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                            <span class="o">+</span> <span class="s2">&quot;, the object is killed&quot;</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot; Value stored has type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                            <span class="o">+</span> <span class="s2">&quot; which cannot be converted to type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Data for this key will not be changed or set in the database&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Python error exception message caught:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                                <span class="c1"># post elog entry into the mspass_object</span>
                                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span> <span class="ow">or</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                        <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                        <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                    <span class="p">)</span>
                                <span class="c1"># The None arg2 cause pop to not throw</span>
                                <span class="c1"># an exception if k isn&#39;t defined - a bit ambigous in the try block</span>
                                <span class="n">insertion_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="n">alg_name</span><span class="p">,</span>
                                <span class="s2">&quot;cannot update data with key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; because it is not defined in the schema&quot;</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="n">alg_name</span><span class="p">,</span>
                                <span class="s2">&quot;key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; is not defined in the schema.  Updating record, but this may cause downstream problems&quot;</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># ugly python indentation with this logic.  We always land here in</span>
        <span class="c1"># any mode when we&#39;ve passed over the entire metadata dict</span>
        <span class="c1"># if it is dead, it&#39;s considered something really bad happens, we should not update the object</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">wf_collection</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wfid</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">insertion_dict</span><span class="p">},</span> <span class="n">upsert</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.update_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_data">[docs]</a>    <span class="k">def</span> <span class="nf">update_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cautious&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizing_collections</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">],</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;Database.update_data&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates both metadata and sample data corresponding to an input data</span>
<span class="sd">        object.</span>

<span class="sd">        Since storage of data objects in MsPASS is broken into multiple</span>
<span class="sd">        collections and storage methods, doing a full data update has some</span>
<span class="sd">        complexity.   This method handles the problem differently for the</span>
<span class="sd">        different pieces:</span>
<span class="sd">            1. An update is performed on the parent wf collection document.</span>
<span class="sd">               That update makes use of the related Database method</span>
<span class="sd">               called update_metadata.</span>
<span class="sd">            2. If the error log is not empty it is saved.</span>
<span class="sd">            3. If the history container has contents it is saved.</span>
<span class="sd">            4. The sample data is the thorniest problem. Currently this</span>
<span class="sd">               method will only do sample updates for data stored in</span>
<span class="sd">               the mongodb gridfs system.   With files containing multiple</span>
<span class="sd">               waveforms it would be necessary to append to the files and</span>
<span class="sd">               this could create a blaat problem with large data sets so</span>
<span class="sd">               we do not currently support that type of update.</span>

<span class="sd">        A VERY IMPORTANT implicit feature of this method is that</span>
<span class="sd">        if the magic key &quot;gridfs_id&quot; exists the sample data in the</span>
<span class="sd">        input to this method (mspass_object.data) will overwrite any</span>
<span class="sd">        the existing content of gridfs found at the matching id.   This</span>
<span class="sd">        is a somewhat hidden feature so beware.</span>

<span class="sd">        :param mspass_object: the object you want to update.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param exclude_keys: a list of metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param force_keys: a list of metadata attributes you want to force</span>
<span class="sd">         to be updated.   Normally this method will only update attributes</span>
<span class="sd">         that have been marked as changed since creation of the parent data</span>
<span class="sd">         object.  If data with these keys is found in the mspass_object they</span>
<span class="sd">         will be added to the update record.</span>
<span class="sd">        :type force_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param mode: This parameter defines how attributes defines how</span>
<span class="sd">          strongly to enforce schema constraints. As described above</span>
<span class="sd">          &#39;promiscuous&#39; justs updates all changed values with no schema</span>
<span class="sd">          tests.  &#39;cautious&#39;, the default, enforces type constraints and</span>
<span class="sd">          tries to convert easily fixed type mismatches (e.g. int to floats</span>
<span class="sd">          of vice versa).  Both &#39;cautious&#39; and &#39;pedantic&#39; may leave one or</span>
<span class="sd">          more complaint message in the elog of mspass_object on how the</span>
<span class="sd">          method did or did not fix mismatches with the schema.  Both</span>
<span class="sd">          also will drop any key-value pairs where the value cannot be</span>
<span class="sd">          converted to the type defined in the schema.</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param normalizing_collections:  list of collection names dogmatically treated</span>
<span class="sd">          as normalizing collection names.  The keywords in the list are used</span>
<span class="sd">          to always (i.e. for all modes) erase any attribute with a key name</span>
<span class="sd">          of the form `collection_attribute where `collection` is one of the collection</span>
<span class="sd">          names in this list and attribute is any string.  Attribute names with the &quot;_&quot;</span>
<span class="sd">          separator are saved unless the collection field matches one one of the</span>
<span class="sd">          strings (e.g. &quot;channel_vang&quot; will be erased before saving to the</span>
<span class="sd">          wf collection while &quot;foo_bar&quot; will not be erased.)  This list should</span>
<span class="sd">          ONLY be changed if a different schema than the default mspass schema</span>
<span class="sd">          is used and different names are used for normalizing collections.</span>
<span class="sd">          (e.g. if one added a &quot;shot&quot; collection to the schema the list would need</span>
<span class="sd">          to be changed to at least add &quot;shot&quot;.)</span>
<span class="sd">        :type normalizing_collection:  list if strings defining collection names.</span>
<span class="sd">        :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">          (defaults to &#39;Database.update_data&#39; and should not normally need to be changed)</span>
<span class="sd">        :type alg_name: :class:`str`</span>
<span class="sd">        :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">        :type alg_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :return: mspass_object data.  Normally this is an unaltered copy</span>
<span class="sd">          of the data passed through mspass_object.  If there are errors,</span>
<span class="sd">          however, the elog will contain new messages.  All such messages,</span>
<span class="sd">          howevever, should be saved in the elog collection because elog</span>
<span class="sd">          is the last collection updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="c1"># First update metadata.  update_metadata will throw an exception</span>
        <span class="c1"># only for usage errors.   We test the elog size to check if there</span>
        <span class="c1"># are other warning messages and add a summary if there were any</span>
        <span class="n">logsize0</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">force_keys</span><span class="o">=</span><span class="n">force_keys</span><span class="p">,</span>
                <span class="n">normalizing_collections</span><span class="o">=</span><span class="n">normalizing_collections</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="n">logsize</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="c1"># A bit verbose, but we post this warning to make it clear the</span>
        <span class="c1"># problem originated from update_data - probably not really needed</span>
        <span class="c1"># but better to be though I think</span>
        <span class="k">if</span> <span class="n">logsize</span> <span class="o">&gt;</span> <span class="n">logsize0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="n">alg_name</span><span class="p">,</span>
                <span class="s2">&quot;update_metadata posted </span><span class="si">{nerr}</span><span class="s2"> messages during update&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">nerr</span><span class="o">=</span><span class="p">(</span><span class="n">logsize</span> <span class="o">-</span> <span class="n">logsize0</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># optional handle history - we need to update the wf record later with this value</span>
        <span class="c1"># if it is set</span>
        <span class="n">update_record</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="p">)</span>
        <span class="n">history_object_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="n">history_object_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">)</span>
            <span class="n">update_record</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>

        <span class="c1"># Now handle update of sample data.  The gridfs method used here</span>
        <span class="c1"># handles that correctly based on the gridfs id.</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;storage_mode&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                        <span class="n">alg_name</span><span class="p">,</span>
                        <span class="s2">&quot;found storage_mode=&quot;</span>
                        <span class="o">+</span> <span class="n">storage_mode</span>
                        <span class="o">+</span> <span class="s2">&quot;  Only support update to gridfs.  Changing to gridfs storage for sample data update&quot;</span><span class="p">,</span>
                        <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">alg_name</span><span class="p">,</span>
                    <span class="s2">&quot;storage_mode attribute was not set in Metadata of this object - setting as gridfs for update&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
                <span class="n">update_record</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
            <span class="c1"># This logic overwrites the content if the magic key</span>
            <span class="c1"># &quot;gridfs_id&quot; exists in the input. In both cases gridfs_id is set</span>
            <span class="c1"># in returned</span>
            <span class="k">if</span> <span class="s2">&quot;gridfs_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data_to_gridfs</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data_to_gridfs</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

            <span class="c1"># There is a possible efficiency gain right here.  Not sure if</span>
            <span class="c1"># gridfs_id is altered when the sample data are updated in place.</span>
            <span class="c1"># if we can be sure the returned gridfs_id is the same as theresult</span>
            <span class="c1"># input in that case, we would omit gridfs_id from the update</span>
            <span class="c1"># record and most data would not require the final update</span>
            <span class="c1"># transaction below</span>
            <span class="n">update_record</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span>
            <span class="c1"># should define wf_collection here because if the mspass_object is dead</span>
            <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
                <span class="c1"># A weird construct</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>

            <span class="n">elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="c1"># FIXME I think here we should check if elog_id field exists in the mspass_object</span>
                <span class="c1"># and we should update the elog entry if mspass_object already had one</span>
                <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                    <span class="n">old_elog_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">old_elog_id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># elog ids will be updated in the wf col when saving metadata</span>
                <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="n">old_elog_id</span><span class="p">,</span> <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span>
                <span class="p">)</span>
                <span class="n">update_record</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>

                <span class="c1"># update elog collection</span>
                <span class="c1"># we have to do the xref to wf collection like this too</span>
                <span class="n">elog_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)]</span>
                <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">}</span>
                <span class="n">elog_col</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                    <span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}}</span>
                <span class="p">)</span>
            <span class="c1"># finally we need to update the wf document if we set anything</span>
            <span class="c1"># in update_record</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">update_record</span><span class="p">):</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}</span>
                <span class="n">wf_collection</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_record</span><span class="p">})</span>
                <span class="c1"># we may probably set the elog_id field in the mspass_object</span>
                <span class="k">if</span> <span class="n">elog_id</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>
                <span class="c1"># we may probably set the history_object_id field in the mspass_object</span>
                <span class="k">if</span> <span class="n">history_object_id</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dead data land here</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="n">old_elog_id</span><span class="p">,</span> <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.read_ensemble_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_ensemble_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_ensemble_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">,</span>
        <span class="n">ensemble_metadata</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;read_ensemble_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRICATED METHOD:   do not use except for backward compatility</span>
<span class="sd">        in short term.  Will go away in a later release</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEPRICATED METHOD (read_ensemble_data)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This method has been superceded by read_data method.  Use it instead.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Method is backward compatible provided normalize is restricted to channel, site, and/or source&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">Cursor</span><span class="p">):</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span>
                <span class="n">ensemble_metadata</span><span class="o">=</span><span class="n">ensemble_metadata</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">load_history</span><span class="o">=</span><span class="n">load_history</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database.read_ensemble_data:  illegal type=</span><span class="si">{}</span><span class="s2"> for arg0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;From version 2 foraward only a pymongo cursor is allowed for defining input</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Fix and use the now standard read_data method instead&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ensemble</span></div>

<div class="viewcode-block" id="Database.read_ensemble_data_group"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_ensemble_data_group">[docs]</a>    <span class="k">def</span> <span class="nf">read_ensemble_data_group</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cursor</span><span class="p">,</span>
        <span class="n">ensemble_metadata</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;read_ensemble_data_group&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRICATED METHOD:   do not use except for backward compatility</span>
<span class="sd">        in short term.  Will go away in a later release</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEPRICATED METHOD (read_ensemble_data_group)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This method has been superceded by read_data method.  Use it instead.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Method is backward compatible provided normalize is restricted to channel, site, and/or source&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">Cursor</span><span class="p">):</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span>
                <span class="n">cursor</span><span class="p">,</span>
                <span class="n">ensemble_metadata</span><span class="o">=</span><span class="n">ensemble_metadata</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">load_history</span><span class="o">=</span><span class="n">load_history</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Database.read_ensemble_data_group:  illegal type=</span><span class="si">{}</span><span class="s2"> for arg0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">cursor</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;From version 2 foraward only a pymongo cursor is allowed for defining input</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Fix and use the now standard read_data method instead&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ensemble</span></div>

<div class="viewcode-block" id="Database.save_ensemble_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_ensemble_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_ensemble_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;gridfs&quot;</span><span class="p">,</span>
        <span class="n">dir_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_ensemble_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save an Ensemble container of a group of data objecs to MongoDB.</span>

<span class="sd">        DEPRICATED METHOD:  use save_method instead.</span>

<span class="sd">        Ensembles are a core concept in MsPASS that are a generalization of</span>
<span class="sd">        fixed &quot;gather&quot; types frozen into every seismic reflection processing</span>
<span class="sd">        system we know of.   This is is a writer for data stored in such a</span>
<span class="sd">        container.  It is little more than a loop over each &quot;member&quot; of the</span>
<span class="sd">        ensemble calling the Database.save_data method for each member.</span>
<span class="sd">        For that reason most of the arguments are passed downstream directly</span>
<span class="sd">        to save_data.   See the save_data method and the User&#39;s manual for</span>
<span class="sd">        more verbose descriptions of their behavior and expected use.</span>

<span class="sd">        The only complexity in handling an ensemble is that our implementation</span>
<span class="sd">        has a separate Metadata container associated with the overall group</span>
<span class="sd">        that is assumed to be constant for every member of the ensemble.  For this</span>
<span class="sd">        reason before entering the loop calling save_data on each member</span>
<span class="sd">        the method calls the objects sync_metadata method that copies (overwrites if</span>
<span class="sd">        previously defined) the ensemble attributes to each member.  That assure</span>
<span class="sd">        atomic saves will not lose their association with a unique ensemble</span>
<span class="sd">        indexing scheme.</span>

<span class="sd">        A final feature of note is that an ensemble can be marked dead.</span>
<span class="sd">        If the entire ensemble is set dead this function returns</span>
<span class="sd">        immediately and does nothing.</span>


<span class="sd">        :param ensemble_object: the ensemble you want to save.</span>
<span class="sd">        :type ensemble_object: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param storage_mode: &quot;gridfs&quot; stores the object in the mongodb grid file system (recommended). &quot;file&quot; stores</span>
<span class="sd">            the object in a binary file, which requires ``dfile`` and ``dir``.</span>
<span class="sd">        :type storage_mode: :class:`str`</span>
<span class="sd">        :param dir_list: A :class:`list` of file directories if using &quot;file&quot; storage mode. File directory is ``str`` type.</span>
<span class="sd">        :param dfile_list: A :class:`list` of file names if using &quot;file&quot; storage mode. File name is ``str`` type.</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being stored.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param exclude_objects: A list of indexes, where each specifies a object in the ensemble you want to exclude from being saved. Starting from 0.</span>
<span class="sd">        :type exclude_objects: :class:`list`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to tag the saved wf document.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING:  save_ensemble_data has been depricated.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Use save_data method instead.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This method may disappear in future releases&quot;</span><span class="p">)</span>
        <span class="c1"># The new save_data uses dir and dfile from member metadata</span>
        <span class="c1"># when sent a None so we just post the list</span>
        <span class="k">if</span> <span class="n">dir_list</span><span class="p">:</span>
            <span class="n">num_dl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dir_list</span><span class="p">)</span>
            <span class="n">nmembers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
            <span class="n">last_valid</span> <span class="o">=</span> <span class="n">nmembers</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num_dl</span> <span class="o">!=</span> <span class="n">nmembers</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;Database.save_enemble_data&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistence sizes.  Number of ensemble members=</span><span class="si">{}</span><span class="s2"> but size of dir_list argument =</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">nmembers</span><span class="p">,</span> <span class="n">num_dl</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">num_dl</span> <span class="o">&lt;</span> <span class="n">nmembers</span><span class="p">:</span>
                    <span class="n">last_valid</span> <span class="o">=</span> <span class="n">num_dl</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Using dir=</span><span class="si">{}</span><span class="s2"> for all members in slots &gt;= </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dir_list</span><span class="p">[</span><span class="n">last_valid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">last_valid</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Extra dir entries will be ignored&quot;</span>
                <span class="n">ensemble_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last_valid</span><span class="p">:</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">,</span> <span class="n">dir_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">,</span> <span class="n">dir_list</span><span class="p">[</span><span class="n">last_valid</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">dfile_list</span><span class="p">:</span>
            <span class="n">num_dl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfile_list</span><span class="p">)</span>
            <span class="n">nmembers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
            <span class="n">last_valid</span> <span class="o">=</span> <span class="n">nmembers</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num_dl</span> <span class="o">!=</span> <span class="n">nmembers</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;Database.save_enemble_data&quot;</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistence sizes.  Number of ensemble members=</span><span class="si">{}</span><span class="s2"> but size of dfile_list argument =</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">nmembers</span><span class="p">,</span> <span class="n">num_dl</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">num_dl</span> <span class="o">&lt;</span> <span class="n">nmembers</span><span class="p">:</span>
                    <span class="n">last_valid</span> <span class="o">=</span> <span class="n">num_dl</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Using dfile=</span><span class="si">{}</span><span class="s2"> for all members in slots &gt;= </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dfile_list</span><span class="p">[</span><span class="n">last_valid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">last_valid</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Extra dfile entries will be ignored&quot;</span>
                <span class="n">ensemble_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last_valid</span><span class="p">:</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dfile&quot;</span><span class="p">,</span> <span class="n">dfile_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span>
                        <span class="s2">&quot;dfile&quot;</span><span class="p">,</span> <span class="n">dfile_list</span><span class="p">[</span><span class="n">last_valid</span><span class="p">]</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_objects</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Double WARNING:   save_ensemble_data exclude_objects option will disappear in future releases&quot;</span>
            <span class="p">)</span>
            <span class="c1"># we won&#39;t do this elegantly since it should not be used</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exclude_objects</span><span class="p">:</span>
                <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">ensemble_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="n">ensemble_object</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">storage_mode</span><span class="o">=</span><span class="n">storage_mode</span><span class="p">,</span>
            <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
            <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
            <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_ensemble_data&quot;</span><span class="p">,</span>
            <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
            <span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># original did not have a return_data argument so we always return</span>
        <span class="c1"># a copy of the data</span>
        <span class="k">return</span> <span class="n">ensemble_object</span></div>

<div class="viewcode-block" id="Database.save_ensemble_data_binary_file"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_ensemble_data_binary_file">[docs]</a>    <span class="k">def</span> <span class="nf">save_ensemble_data_binary_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_ensemble_data_binary_file&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save an Ensemble container of a group of data objecs to MongoDB.</span>

<span class="sd">        DEPRICATED METHOD:  use save_method instead.</span>

<span class="sd">        Ensembles are a core concept in MsPASS that are a generalization of</span>
<span class="sd">        fixed &quot;gather&quot; types frozen into every seismic reflection processing</span>
<span class="sd">        system we know of.   This is is a writer for data stored in such a</span>
<span class="sd">        container.  It saves all the objects in the ensemble to one file.</span>

<span class="sd">        Our implementation has a separate Metadata container associated with the overall</span>
<span class="sd">        group that is assumed to be constant for every member of the ensemble.  For this</span>
<span class="sd">        reason the method calls the objects sync_metadata method that copies (overwrites</span>
<span class="sd">        if previously defined) the ensemble attributes to each member.  That assure</span>
<span class="sd">        atomic saves will not lose their association with a unique ensemble indexing scheme.</span>

<span class="sd">        A final feature of note is that an ensemble can be marked dead.</span>
<span class="sd">        If the entire ensemble is set dead this function returns</span>
<span class="sd">        immediately and does nothing.</span>


<span class="sd">        :param ensemble_object: the ensemble you want to save.</span>
<span class="sd">        :type ensemble_object: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being stored.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param exclude_objects: A list of indexes, where each specifies a object in the ensemble you want to exclude from being saved. Starting from 0.</span>
<span class="sd">        :type exclude_objects: :class:`list`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to tag the saved wf document.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        :param kill_on_failure:  When true if an io error occurs the data object&#39;s</span>
<span class="sd">          kill method will be invoked.  When false (the default) io errors are</span>
<span class="sd">          logged and left set live.  (Note data already marked dead are return</span>
<span class="sd">          are ignored by this function. )</span>
<span class="sd">        :type kill_on_failure: boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING:  save_ensemble_data_binary_file has been deprecated.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Use save_data method instead.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This method may disappear in future releases&quot;</span><span class="p">)</span>
        <span class="c1"># This method is now indistinguishable from save_ensemble so</span>
        <span class="c1"># we just call it</span>

        <span class="k">if</span> <span class="n">exclude_objects</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Double WARNING:   save_ensemble_data_binary_file exclude_objects option will disappear in future releases&quot;</span>
            <span class="p">)</span>
            <span class="c1"># we won&#39;t do this elegantly since it should not be used</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exclude_objects</span><span class="p">:</span>
                <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">dir</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dir</span>
        <span class="k">if</span> <span class="n">dfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
        <span class="n">ensemble_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_ensemble_data</span><span class="p">(</span>
            <span class="n">ensemble_object</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;file&quot;</span><span class="p">,</span>
            <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
            <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
            <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_ensemble_data_binary_file&quot;</span><span class="p">,</span>
            <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># original did not have a return_data argument so we always return</span>
        <span class="c1"># a copy of the data</span>
        <span class="k">return</span> <span class="n">ensemble_object</span></div>

<div class="viewcode-block" id="Database.update_ensemble_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_ensemble_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">update_ensemble_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;update_ensemble_metadata&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates (or save if it&#39;s new) the mspasspy ensemble object, including saving the processing history, elogs</span>
<span class="sd">        and metadata attributes.</span>

<span class="sd">        DEPRICATED METHOD:  Do not use.</span>

<span class="sd">        This method is a companion to save_ensemble_data. The relationship is</span>
<span class="sd">        comparable to that between the save_data and update_metadata methods.</span>
<span class="sd">        In particular, this method is mostly for internal use to save the</span>
<span class="sd">        contents of the Metadata container in each ensemble member.  Like</span>
<span class="sd">        save_ensemble_data it is mainly a loop over ensemble members calling</span>
<span class="sd">        update_metadata on each member.  Also like update_metadata it is</span>
<span class="sd">        advanced usage to use this method directly.  Most users will apply</span>
<span class="sd">        it under the hood as part of calls to save_ensemble_data.</span>

<span class="sd">        :param ensemble_object: the ensemble you want to update.</span>
<span class="sd">        :type ensemble_object: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param exclude_objects: a list of indexes, where each specifies a object in the ensemble you want to</span>
<span class="sd">        exclude from being saved. The index starts at 0.</span>
<span class="sd">        :type exclude_objects: :class:`list`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata</span>
<span class="sd">        schema.</span>
<span class="sd">        :param ignore_metadata_changed_test: if specify as ``True``, we do not check the whether attributes we want to update are in the Metadata.modified() set. Default to be ``False``.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to tag the saved wf document.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;WARNING:  This function is depricated and may be removed from future releases&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">exclude_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_objects</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># Skip data listed for exclusion and those that are marked dead</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_objects</span> <span class="ow">and</span> <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                    <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                    <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.delete_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.delete_data">[docs]</a>    <span class="k">def</span> <span class="nf">delete_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">object_id</span><span class="p">,</span>
        <span class="n">object_type</span><span class="p">,</span>
        <span class="n">remove_unreferenced_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">clear_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">clear_elog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete method for handling mspass data objects (TimeSeries and Seismograms).</span>

<span class="sd">        Delete is one of the basic operations any database system should</span>
<span class="sd">        support (the last letter of the acronymn CRUD is delete).  Deletion is</span>
<span class="sd">        nontrivial with seismic data stored with the model used in MsPASS.</span>
<span class="sd">        The reason is that the content of the objects are spread between</span>
<span class="sd">        multiple collections and sometimes use storage in files completely</span>
<span class="sd">        outside MongoDB.   This method, however, is designed to handle that</span>
<span class="sd">        and when given the object id defining a document in one of the wf</span>
<span class="sd">        collections, it will delete the wf document entry and manage the</span>
<span class="sd">        waveform data.  If the data are stored in gridfs the deletion of</span>
<span class="sd">        the waveform data will be immediate.  If the data are stored in</span>
<span class="sd">        disk files the file will be deleted when there are no more references</span>
<span class="sd">        in the wf collection for the exact combination of dir and dfile associated</span>
<span class="sd">        an atomic deletion.  Error log and history data deletion linked to</span>
<span class="sd">        a datum is optional.  Note this is an expensive operation as it</span>
<span class="sd">        involves extensive database interactions.   It is best used for</span>
<span class="sd">        surgical solutions.   Deletion of large components of a data set</span>
<span class="sd">        (e.g. all data with a given data_tag value) are best done with</span>
<span class="sd">        custom scripts utilizing file naming conventions and unix shell</span>
<span class="sd">        commands to delete waveform files.</span>


<span class="sd">        :param object_id: the wf object id you want to delete.</span>
<span class="sd">        :type object_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :param object_type: the object type you want to delete, must be one of [&#39;TimeSeries&#39;, &#39;Seismogram&#39;]</span>
<span class="sd">        :type object_type: :class:`str`</span>
<span class="sd">        :param remove_unreferenced_files: if ``True``, we will try to remove the file that no wf data is referencing. Default to be ``False``</span>
<span class="sd">        :param clear_history: if ``True``, we will clear the processing history of the associated wf object, default to be ``True``</span>
<span class="sd">        :param clear_elog: if ``True``, we will clear the elog entries of the associated wf object, default to be ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="s2">&quot;Seismogram&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

        <span class="c1"># get the wf collection name in the schema</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
            <span class="n">detele_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detele_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">detele_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>

        <span class="c1"># user might pass a mspass object by mistake</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span>

        <span class="c1"># fetch the document by the given object id</span>
        <span class="n">object_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">object_doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find document in wf collection by _id: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oid</span><span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># delete the document just retrieved from the database</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span>

        <span class="c1"># delete gridfs/file depends on storage mode, and unreferenced files</span>
        <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
            <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]):</span>
                <span class="n">gfsh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">remove_unreferenced_files</span><span class="p">:</span>
            <span class="n">dir_name</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span>
            <span class="n">dfile_name</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
            <span class="c1"># find if there are any remaining matching documents with dir and dfile</span>
            <span class="n">match_doc_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;dir&quot;</span><span class="p">:</span> <span class="n">dir_name</span><span class="p">,</span> <span class="s2">&quot;dfile&quot;</span><span class="p">:</span> <span class="n">dfile_name</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="c1"># delete this file</span>
            <span class="k">if</span> <span class="n">match_doc_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">dfile_name</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c1"># clear history</span>
        <span class="k">if</span> <span class="n">clear_history</span><span class="p">:</span>
            <span class="n">history_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
            <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="n">history_collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="k">if</span> <span class="n">history_obj_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">history_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]}</span>
                <span class="p">)</span>

        <span class="c1"># clear elog</span>
        <span class="k">if</span> <span class="n">clear_elog</span><span class="p">:</span>
            <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="n">elog_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="n">elog_collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="c1"># delete the one by elog_id in mspass object</span>
            <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]})</span>
            <span class="c1"># delete the documents with the wf_id equals to obejct[&#39;_id&#39;]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_many</span><span class="p">({</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">_load_collection_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Master Private Method - DEPRICATED</span>

<span class="sd">        Reads metadata from a requested collection and loads standard attributes from collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the collection_id attribute set to link it to a unique document in source.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded. Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching document are loaded.</span>
<span class="sd">        :param collection: requested collection metadata should be loaded</span>
<span class="sd">        :type collection: :class:`str`</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only live mspass object can load metadata&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">Seismogram</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;channel data can not be loaded into Seismogram&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="c1"># 1. get the metadata schema based on the mspass object type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>

        <span class="n">wf_collection</span> <span class="o">=</span> <span class="n">metadata_def</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported, but </span><span class="si">{}</span><span class="s2"> is requested. Please check the data_type of </span><span class="si">{}</span><span class="s2"> collection.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">object_type</span><span class="p">,</span> <span class="n">wf_collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">wf_collection_metadata_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

        <span class="n">collection_id</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="c1"># 2. get the collection_id from the current mspass_object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">collection_id</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;no </span><span class="si">{}</span><span class="s2"> in the mspass object&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection_id</span><span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">object_doc_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">collection_id</span><span class="p">]</span>

        <span class="c1"># 3. find the unique document associated with this source id in the source collection</span>
        <span class="n">object_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc_id</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">object_doc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;no match found in </span><span class="si">{}</span><span class="s2"> collection for source_id = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">collection</span><span class="p">,</span> <span class="n">object_doc_id</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># 4. use this document to update the mspass object</span>
        <span class="n">key_dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wf_collection_metadata_schema</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">wf_collection_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="n">collection</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_keys</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_undefined</span><span class="p">:</span>
                    <span class="n">key_dict</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="p">)</span>

        <span class="c1"># 5. add extra keys if include_undefined is true</span>
        <span class="k">if</span> <span class="n">include_undefined</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_dict</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

<div class="viewcode-block" id="Database.load_source_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_source_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_source_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;serialized_event&quot;</span><span class="p">,</span> <span class="s2">&quot;magnitude_type&quot;</span><span class="p">],</span>
        <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the source collection and loads standard attributes in source collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the source_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class</span>
<span class="sd">        or an ensemble (TimeSeriesEnsemble or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the source data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a shot gather.</span>

<span class="sd">        This method is DEPRICATED.  It is an slow alternative for normalization</span>
<span class="sd">        and is effectively an alternative to normalization with the</span>
<span class="sd">        Database driven id matcher.   Each call to this function requires</span>
<span class="sd">        a query with find_ond.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default are attributes not normally need that are loaded from QuakeML.  Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching source document are loaded.</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.load_site_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_site_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_site_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the site collection and loads standard attributes in site collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the site_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class or an ensemble (TimeSeriesEnsemble</span>
<span class="sd">        or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the site data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a common-receiver gather.</span>

<span class="sd">        This method is DEPRICATED.  It is an slow alternative for normalization</span>
<span class="sd">        and is effectively an alternative to normalization with the</span>
<span class="sd">        Database driven id matcher.   Each call to this function requires</span>
<span class="sd">        a query with find_ond.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default is None.  Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching site document are loaded.</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.load_channel_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_channel_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_channel_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">],</span>
        <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the channel collection and loads standard attributes in channel collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the site_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class or an ensemble (TimeSeriesEnsemble</span>
<span class="sd">        or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the site data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a common-receiver gather of TimeSeries data for a common sensor component.</span>

<span class="sd">        This method is DEPRICATED.  It is an slow alternative for normalization</span>
<span class="sd">        and is effectively an alternative to normalization with the</span>
<span class="sd">        Database driven id matcher.   Each call to this function requires</span>
<span class="sd">        a query with find_ond.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default excludes the serialized obspy class that is used to store response data.   Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching channel document are loaded</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span>
                <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MsPASS data objects are designed to cleanly handle what we call relative</span>
<span class="sd">        and UTC time.  This small helper function assures the Metadata of</span>
<span class="sd">        mspass_object are consistent with the internal contents.  That</span>
<span class="sd">        involves posting some special attributes seen below to handle this issue.</span>
<span class="sd">        Since Metadata is volatile we need to be sure these are consistent or</span>
<span class="sd">        timing can be destroyed on data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this adds a small overhead but it guarantees Metadata and internal t0</span>
        <span class="c1"># values are consistent.  Shouldn&#39;t happen unless the user messes with them</span>
        <span class="c1"># incorrectly, but this safety is prudent to reduce the odds of mysterious</span>
        <span class="c1"># timing errors in data.  Note it sets the metadata entry starttime</span>
        <span class="c1"># as the primary need for interfacing with obspy</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_t0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="c1"># This will need to be modified if we ever expand time types beyond two</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_is_relative</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">shifted</span><span class="p">():</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;starttime_shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_reference</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;time_standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Relative&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;time_standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;UTC&quot;</span>
        <span class="c1"># If it is a seismogram, we need to update the tmatrix in the metadata to be consistent with the internal tmatrix</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">t_matrix</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">tmatrix</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">tmatrix</span> <span class="o">=</span> <span class="n">t_matrix</span>
            <span class="c1"># also update the cardinal and orthogonal attributes</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;cardinal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">cardinal</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the processing history of a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param prev_history_object_id: the previous history object id (if it has).</span>
<span class="sd">        :type prev_history_object_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :param collection: the collection that you want to store the history object. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        :return: current history_object_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">TIMESERIES</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">SEISMOGRAM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
        <span class="n">history_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="n">proc_history</span> <span class="o">=</span> <span class="n">ProcessingHistory</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="n">current_nodedata</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">current_nodedata</span><span class="p">()</span>

        <span class="c1"># get the alg_name and alg_id of current node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_id</span><span class="p">:</span>
            <span class="n">alg_id</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_name</span><span class="p">:</span>
            <span class="n">alg_name</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algorithm</span>
        <span class="c1"># Global History implemetnation should allow adding job_name</span>
        <span class="c1"># and job_id to this function call.  For now they are dropped</span>
        <span class="n">insert_dict</span> <span class="o">=</span> <span class="n">history2doc</span><span class="p">(</span><span class="n">proc_history</span><span class="p">,</span> <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span> <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">)</span>
        <span class="c1"># We need this below, but history2doc sets it with the &quot;_id&quot; key</span>
        <span class="n">current_uuid</span> <span class="o">=</span> <span class="n">insert_dict</span><span class="p">[</span><span class="s2">&quot;save_uuid&quot;</span><span class="p">]</span>
        <span class="n">history_id</span> <span class="o">=</span> <span class="n">history_col</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">insert_dict</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>

        <span class="c1"># clear the history chain of the mspass object</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">clear_history</span><span class="p">()</span>
        <span class="c1"># set_as_origin with uuid set to the newly generated id</span>
        <span class="c1"># Note we have to convert to a string to match C++ function type</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span><span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_uuid</span><span class="p">),</span> <span class="n">atomic_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">history_id</span>

    <span class="k">def</span> <span class="nf">_load_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">history_object_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;undefined&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;undefined&quot;</span><span class="p">,</span>
        <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;history_object&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads processing history into an atomic data object or initializes</span>
<span class="sd">        history tree if one did not exist.</span>

<span class="sd">        We store history data on a save in documents in the &quot;history_object&quot;</span>
<span class="sd">        collection.  This private method loads that data when it can.</span>
<span class="sd">        Top-level behavior is controlled by the history_object_id value.</span>
<span class="sd">        If it is not None we query the history_object collection using</span>
<span class="sd">        that value as an objectId.   If that fails the tree is</span>
<span class="sd">        initialized as an origin but an error message is left on elog</span>
<span class="sd">        complaining that the history is likely invalid.</span>

<span class="sd">        When a workflow is initialized by a read, which in ProcessingHistory</span>
<span class="sd">        is what is called an &quot;origin&quot;, this function should be called with</span>
<span class="sd">        history_object_id set to None.  In that situation, it initializes</span>
<span class="sd">        the history tree (set_as_origin) with the id for the start of the</span>
<span class="sd">        chain as the waveform object id.  That is assumed always in</span>
<span class="sd">        mspass_object accesible with the key &#39;_id&#39;.  This method will</span>
<span class="sd">        throw an exception if that is not so.</span>

<span class="sd">        :param mspass_object: the target object - altered in place</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param history_object_id: :class:`bson.ObjectId.ObjectId` or None (see above)</span>
<span class="sd">        :param alg_name:  algorithm name that should be the current node</span>
<span class="sd">        of the history tree.  this should normaly be the name of th e</span>
<span class="sd">        reader method/function.</span>
<span class="sd">        :param alg_id:  algorithm id to set for the current node</span>
<span class="sd">        :param define_as_raw:  when True and history_object_id is None</span>
<span class="sd">          the starting node of the history chain will be tagged as &quot;raw&quot;.</span>
<span class="sd">          Ignored if history_object_id is used for a query.  Note on</span>
<span class="sd">          failure of such a query the chain will always have raw set false.</span>
<span class="sd">        :param collection: the collection that you want to load the processing history. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the atomic type of the mspass object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">TIMESERIES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">SEISMOGRAM</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">history_object_id</span><span class="p">:</span>
            <span class="c1"># load history if set True</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">history_object_id</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;processing_history&quot;</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">load_history</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;processing_history&quot;</span><span class="p">]))</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">new_map</span><span class="p">(</span>
                        <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">,</span> <span class="n">atomic_type</span><span class="p">,</span> <span class="n">ProcessingStatus</span><span class="o">.</span><span class="n">ORIGIN</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Required attribute (processing_history) not found in document retrieved from collection=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">collection</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Object history chain for this run will be incomplete for this datum&quot;</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                        <span class="s2">&quot;Database._load_history&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                    <span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span>
                        <span class="n">alg_name</span><span class="p">,</span>
                        <span class="n">alg_id</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]),</span>
                        <span class="n">atomic_type</span><span class="p">,</span>
                        <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No matching document found in history collection=</span><span class="si">{}</span><span class="s2"> with id=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">collection</span><span class="p">,</span> <span class="n">history_object_id</span>
                <span class="p">)</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Object history chain for this run will be incomplete for this datum&quot;</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Database._load_history&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span>
                    <span class="n">alg_name</span><span class="p">,</span>
                    <span class="n">alg_id</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]),</span>
                    <span class="n">atomic_type</span><span class="p">,</span>
                    <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span>
                <span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]),</span>
                <span class="n">atomic_type</span><span class="p">,</span>
                <span class="n">define_as_raw</span><span class="o">=</span><span class="n">define_as_raw</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_elog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">elog_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">create_tombstone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save error log for a data object. Data objects in MsPASS contain an error log object used to post any</span>
<span class="sd">        errors handled by processing functions. This function will delete the old elog entry if `elog_id` is given.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param elog_id: the previous elog object id to be appended with.</span>
<span class="sd">        :type elog_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        :param collection: the collection that you want to save the elogs. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        :return: updated elog_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">update_metadata_def</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: Need to discuss whether the _id should be linked in a dead elog entry. It</span>
        <span class="c1"># might be confusing to link the dead elog to an alive wf record.</span>
        <span class="n">oid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">()</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;WARNING:  found this datum marked dead but it had not elog entries</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Likely flaw in a custom function that didn&#39;t handle kill and elog properly&quot;</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Database._save_elog&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="n">elog</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span>

        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">docentry</span> <span class="o">=</span> <span class="n">elog2doc</span><span class="p">(</span><span class="n">elog</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_tag</span>
            <span class="k">if</span> <span class="n">oid</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="n">wf_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">oid</span>

            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;tombstone&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">elog_id</span><span class="p">:</span>
                <span class="c1"># append elog</span>
                <span class="n">elog_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">})</span>
                <span class="c1"># only append when previous elog exists</span>
                <span class="k">if</span> <span class="n">elog_doc</span><span class="p">:</span>
                    <span class="c1"># extract contents from this datum for comparison to elog_doc</span>
                    <span class="c1"># This loop appends to elog_doc logdata list removing</span>
                    <span class="c1"># duplicates that can be created if a datum is</span>
                    <span class="c1"># saved mulitple times in job</span>
                    <span class="n">logdata</span> <span class="o">=</span> <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">logdata</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]:</span>
                            <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                    <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">})</span>
                <span class="c1"># note that is should be impossible for the old elog to have tombstone entry</span>
                <span class="c1"># so we ignore the handling of that attribute here.</span>
                <span class="n">ret_elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># new insertion</span>
                <span class="n">ret_elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="k">return</span> <span class="n">ret_elog_id</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_dfile</span><span class="p">(</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="nb">dir</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="n">foff</span><span class="p">,</span>
        <span class="n">nbytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to provide generic reader of atomic data from a standard</span>
<span class="sd">        system in any accepted format.</span>

<span class="sd">        This method is used by read_data for reading atomic data.   Note</span>
<span class="sd">        ensembles are handled by a different set of private methods</span>
<span class="sd">        for efficiency.   The algorithm is a bit weird as it assumes</span>
<span class="sd">        the skeleton of the datum (mspass_object content received as arg0)</span>
<span class="sd">        has already created the storage arrays from sample data.</span>
<span class="sd">        That is done, in practice, with the C++ api that provides constructors</span>
<span class="sd">        driven by Metadata created from MongoDB documents.   Those constructors</span>
<span class="sd">        allocate and initialize the sample data arrays to zeros.</span>

<span class="sd">        Binary (default) format uses a C++ function and fread for loading</span>
<span class="sd">        sample data.  Other formats are passed to obspy&#39;s reader.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param foff: offset that marks the starting of the data in the file.</span>
<span class="sd">        :param nbytes: number of bytes to be read from the offset. This is only used when ``format`` is given.</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy writer. By default (``None``), the format will be the binary waveform.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to None. Traces will be converted to NumPy masked arrays if no value is given and gaps are present.</span>
<span class="sd">        :type fill_value: :class:`int`, :class:`float` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

        <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;Database._read_data_from_dfile:  &quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">_fread_from_file</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">,</span> <span class="n">foff</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;fread count mismatch.  Expected to read </span><span class="si">{npts}</span><span class="s2"> but fread returned a count of </span><span class="si">{count}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">npts</span><span class="o">=</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;_read_data_from_dfile&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._read_data_from_dfile:  &quot;</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;C++ function _fread_from_file failed while reading TimeSeries sample data from file=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dfile</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">merr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We can only get here if this is a Seismogram</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nsamples</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">_fread_from_file</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">,</span> <span class="n">foff</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">nsamples</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;fread count mismatch.  Expected to read </span><span class="si">{nsamples}</span><span class="s2"> doubles but fread returned a count of </span><span class="si">{count}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;_read_data_from_dfile&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._read_data_from_dfile:  &quot;</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;C++ function _fread_from_file failed while reading Seismogram sample data from file=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dfile</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">merr</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">foff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">foff</span><span class="p">)</span>
                <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">))</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="c1"># st is a &quot;stream&quot; but it may contains multiple Trace objects gaps</span>
                    <span class="c1"># but here we want only one TimeSeries, we merge these Trace objects and fill values for gaps</span>
                    <span class="c1"># we post a complaint elog entry to the mspass_object if there are gaps in the stream</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;WARNING:  gaps detected while reading file </span><span class="si">{}</span><span class="s2"> with format </span><span class="si">{}</span><span class="s2"> using obspy</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">fname</span><span class="p">,</span> <span class="nb">format</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Using specified fill defined in call to read_data&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;read_data&quot;</span><span class="p">,</span>
                            <span class="n">message</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                            <span class="n">method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                            <span class="n">interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># We can&#39;t use Trace2TimeSeries because we loose</span>
                    <span class="c1"># all but miniseed metadata if we do that.</span>
                    <span class="c1"># We do, however, need to compare post errors</span>
                    <span class="c1"># if there is a mismatch</span>
                    <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span> <span class="o">!=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistent number of data points (npts)</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Database npts=</span><span class="si">{}</span><span class="s2"> but obspy reader created a vector </span><span class="si">{}</span><span class="s2"> points long</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Set to vector size defined by reader.&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_npts</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">!=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistent starttimes detected</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Starttime in MongoDB document = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Starttime returned by obspy reader = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Set to time set by reader&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_t0</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span> <span class="o">!=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dt</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistent sample intervals&quot;</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Database has delta=</span><span class="si">{}</span><span class="s2"> but obspy reader set delta=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Set to value set by reader.&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">delta</span>
                    <span class="c1"># be less dogmatic here as endtime is computed.</span>
                    <span class="c1"># error only if computed time difference exceed half a sample</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
                        <span class="o">&gt;</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="p">):</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Inconsistent endtimes detected</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s2">&quot;Endtime expected from MongoDB document = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Endtime set by obspy reader = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Endtime is derived in mspass and should have been repaired - cannot recover this datum so it was killed&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

                    <span class="c1"># These two lines are needed to properly initialize</span>
                    <span class="c1"># the DoubleVector before calling Trace2TimeSeries</span>
                    <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="s2">&quot;float64&quot;</span>
                    <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
                    <span class="c1"># We can&#39;t use Trace2TimeSeries because we loose</span>
                    <span class="c1"># all but miniseed metadata if we do that.</span>
                    <span class="c1"># We do, however, need to compare post errors</span>
                    <span class="c1"># if there is a mismatch</span>

                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Error during read with format=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Unable to reconstruct data vector&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="c1"># This was previous form.   The toSeismogram run as a</span>
                    <span class="c1"># method is an unnecessary confusion and I don&#39;t think</span>
                    <span class="c1"># setting npts or data are necessary given the code of</span>
                    <span class="c1"># Stream2Seismogram - st.toSeismogram is an alias for that</span>
                    <span class="c1"># This is almost but not quite equivalent to this:</span>
                    <span class="c1"># mspass_object = Stream2Seismogram(st,cardinal=True)</span>
                    <span class="c1"># Seems Stream2Seismogram does not properly handle</span>
                    <span class="c1"># the data pointer</span>
                    <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Error during read with format=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Unable to reconstruct Seismogram data matrix&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_read_data_from_gridfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">gridfs_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method used to read sample data from MongoDB&#39;s gridfs</span>
<span class="sd">        storage for atomic MsPASS data objects.  Like the</span>
<span class="sd">        comparable &quot;file&quot; reader this method assumes the skeleton of</span>
<span class="sd">        the datum received as mspass_object in arg0 has the array</span>
<span class="sd">        memory storage already constructed and initialized.   This function</span>
<span class="sd">        then simply moves the sample data from gridfs into the data</span>
<span class="sd">        array of mspass_object.   Appropriate behavior for a private</span>
<span class="sd">        method but why this method should not be used externally</span>
<span class="sd">        by anyone but an expert.</span>

<span class="sd">        There is a minor sanity check as the method tests for the existence</span>
<span class="sd">        of the (frozen) key &quot;npts&quot; in the Metadata container of mspass_object.</span>
<span class="sd">        It will throw a KeyError if that key-value pair is not defined.</span>
<span class="sd">        It then does a sanity check against the npts attribute of</span>
<span class="sd">        mspass_object.   That safety adds a minor overhead but reduces</span>
<span class="sd">        the odds of a seg fault.</span>


<span class="sd">        :param mspass_object: skeleton of the data object to load sample</span>
<span class="sd">          data into.   Assumes data array exists and is length consistent</span>
<span class="sd">          with the &quot;npts&quot; Metadata value.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param gridfs_id: the object id of the data stored in gridfs.</span>
<span class="sd">        :type gridfs_id: :class:`bson.ObjectId.ObjectId`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">file_id</span><span class="o">=</span><span class="n">gridfs_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">):</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Required key npts is not defined in the document for this datum&quot;</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Database._read_data_from_gridfs&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">!=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._read_data_from_gridfs: &quot;</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Metadata value for npts is </span><span class="si">{}</span><span class="s2"> but datum attribute npts is </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">],</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Illegal inconsistency that should not happen and is a fatal error&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="n">npts</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="c1"># fh.seek(16)</span>
            <span class="n">float_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
            <span class="n">float_array</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">float_array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">np_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">npts</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">file_size</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">file_size</span> <span class="o">!=</span> <span class="n">npts</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Size mismatch in sample data.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Number of points in gridfs file=</span><span class="si">%d</span><span class="s2"> but wf document expected </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">file_size</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Database._read_data_from_gridfs&quot;</span><span class="p">,</span>
                    <span class="n">message</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="c1"># v1 did a transpose on write that this reversed - unnecessary</span>
            <span class="c1"># np_arr = np_arr.reshape(npts, 3).transpose()</span>
            <span class="n">np_arr</span> <span class="o">=</span> <span class="n">np_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="n">np_arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._read_data_from_gridfs:  arg0 must be a TimeSeries or Seismogram</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Actual type=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_s3_continuous</span><span class="p">(</span>
        <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read data stored in s3 and load it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
            <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
            <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
            <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">station</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;net&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;sta&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;chan&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">KEY</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()),</span> <span class="nb">format</span><span class="o">=</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
                <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
                <span class="c1"># We only want the Trace object not the stream to convert</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
                <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
                <span class="c1"># loc, and startime all match</span>
                <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="s2">&quot;float64&quot;</span>
                <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># this is not a error proof test for validity, but best I can do here</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_s3_lambda</span><span class="p">(</span>
        <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">station</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;net&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;sta&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;chan&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">Database</span><span class="o">.</span><span class="n">_download_windowed_mseed_file</span><span class="p">(</span>
                <span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="p">,</span>
                <span class="n">year</span><span class="p">,</span>
                <span class="n">day_of_year</span><span class="p">,</span>
                <span class="n">network</span><span class="p">,</span>
                <span class="n">station</span><span class="p">,</span>
                <span class="n">channel</span><span class="p">,</span>
                <span class="n">location</span><span class="p">,</span>
                <span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
                <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
                <span class="c1"># We only want the Trace object not the stream to convert</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
                <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
                <span class="c1"># loc, and startime all match</span>
                <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="s2">&quot;float64&quot;</span>
                <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># this is not a error proof test for validity, but best I can do here</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3_lambda.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">def</span> <span class="nf">_read_data_from_s3_event</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="nb">dir</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="n">foff</span><span class="p">,</span>
        <span class="n">nbytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the stored data from a file and loads it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param foff: offset that marks the starting of the data in the file.</span>
<span class="sd">        :param nbytes: number of bytes to be read from the offset. This is only used when ``format`` is given.</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy writer. By default (``None``), the format will be the binary waveform.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>

        <span class="c1"># check if fname exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="c1"># fname might now exist, but could download from s3</span>
            <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
                <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
                <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>
            <span class="n">KEY</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;event_waveforms/&quot;</span>
                <span class="o">+</span> <span class="n">year</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                <span class="o">+</span> <span class="n">year</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="n">day_of_year</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                <span class="o">+</span> <span class="n">filename</span>
                <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
            <span class="p">)</span>
            <span class="c1"># try to download the mseed file from s3 and save it locally</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
                <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="c1"># temporarily write data into a file</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                    <span class="c1"># the object does not exist</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">foff</span><span class="p">)</span>
            <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">))</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
            <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="s2">&quot;float64&quot;</span>
                <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># this is not a error proof test for validity, but best I can do here</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_fdsn</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
        <span class="n">provider</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;provider&quot;</span><span class="p">]</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">provider</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span><span class="p">,</span> <span class="n">iso8601</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span>
            <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>
        <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
        <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="s2">&quot;float64&quot;</span>
            <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># this is not a error proof test for validity, but best I can do here</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_url</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a file from url and loads it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param url: the url that points to a :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`.</span>
<span class="sd">        :type url: :class:`str`</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy reader. If not specified, the ObsPy reader will try to detect the format automatically.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="c1"># Catch HTTP errors.</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while downloading: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">url</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
            <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
            <span class="c1"># We only want the Trace object not the stream to convert</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
            <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
            <span class="c1"># loc, and startime all match</span>
            <span class="n">tr_data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="s2">&quot;float64&quot;</span>
            <span class="p">)</span>  <span class="c1">#   Convert the nparray type to double, to match the DoubleVector</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="c1"># Note that the following convertion could be problematic because</span>
            <span class="c1"># it assumes there are three traces in the file, and they are in</span>
            <span class="c1"># the order of E, N, Z.</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="c1"># this is not a error proof test for validity, but best I can do here</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_locdata</span><span class="p">(</span><span class="n">chanlist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the list returned by obspy channels attribute</span>
<span class="sd">        for a Station object and returns a dict of unique</span>
<span class="sd">        geographic location fields values keyed by loc code.  This algorithm</span>
<span class="sd">        would be horribly inefficient for large lists with</span>
<span class="sd">        many duplicates, but the assumption here is the list</span>
<span class="sd">        will always be small</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alllocs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">chanlist</span><span class="p">:</span>
            <span class="n">alllocs</span><span class="p">[</span><span class="n">chan</span><span class="o">.</span><span class="n">location_code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">start_date</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">end_date</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">elevation</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">alllocs</span>

    <span class="k">def</span> <span class="nf">_site_is_not_in_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_to_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper functoin for save_inventory.</span>
<span class="sd">        Tests if dict content of record_to_test is</span>
<span class="sd">        in the site collection.  Inverted logic in one sense</span>
<span class="sd">        as it returns true when the record is not yet in</span>
<span class="sd">        the database.  Uses key of net,sta,loc,starttime</span>
<span class="sd">        and endtime.  All tests are simple equality.</span>
<span class="sd">        Should be ok for times as stationxml uses nearest</span>
<span class="sd">        day as in css3.0.</span>

<span class="sd">        originally tried to do the time interval tests with a</span>
<span class="sd">        query, but found it was a bit cumbersone to say the least.</span>
<span class="sd">        Because this particular query is never expected to return</span>
<span class="sd">        a large number of documents we resort to a linear</span>
<span class="sd">        search through all matches on net,sta,loc rather than</span>
<span class="sd">        using a confusing and ugly query construct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">queryrecord</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="c1"># this returns a warning that count is depricated but</span>
        <span class="c1"># I&#39;m getting confusing results from google search on the</span>
        <span class="c1"># topic so will use this for now</span>
        <span class="n">nrec</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Now do the linear search on time for a match</span>
            <span class="n">st0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="n">et0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
            <span class="n">time_fudge_factor</span> <span class="o">=</span> <span class="mf">10.0</span>
            <span class="n">stp</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">stm</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="n">etp</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">etm</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">sttest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="n">ettest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sttest</span> <span class="o">&gt;</span> <span class="n">stm</span> <span class="ow">and</span> <span class="n">sttest</span> <span class="o">&lt;</span> <span class="n">stp</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&gt;</span> <span class="n">etm</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&lt;</span> <span class="n">etp</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_channel_is_not_in_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_to_test</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper functoin for save_inventory.</span>
<span class="sd">        Tests if dict content of record_to_test is</span>
<span class="sd">        in the site collection.  Inverted logic in one sense</span>
<span class="sd">        as it returns true when the record is not yet in</span>
<span class="sd">        the database.  Uses key of net,sta,loc,starttime</span>
<span class="sd">        and endtime.  All tests are simple equality.</span>
<span class="sd">        Should be ok for times as stationxml uses nearest</span>
<span class="sd">        day as in css3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">queryrecord</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="c1"># this returns a warning that count is depricated but</span>
        <span class="c1"># I&#39;m getting confusing results from google search on the</span>
        <span class="c1"># topic so will use this for now</span>
        <span class="n">nrec</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Now do the linear search on time for a match</span>
            <span class="n">st0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="n">et0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
            <span class="n">time_fudge_factor</span> <span class="o">=</span> <span class="mf">10.0</span>
            <span class="n">stp</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">stm</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="n">etp</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">etm</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">sttest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="n">ettest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sttest</span> <span class="o">&gt;</span> <span class="n">stm</span> <span class="ow">and</span> <span class="n">sttest</span> <span class="o">&lt;</span> <span class="n">stp</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&gt;</span> <span class="n">etm</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&lt;</span> <span class="n">etp</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_handle_null_starttime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Somewhat trivial standardized private method for handling null</span>
<span class="sd">        (None) starttime values.  Returns UTCDateTime object for 0</span>
<span class="sd">        epoch time to mesh with obspy&#39;s times where this method is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_handle_null_endtime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c1"># This constant is used below to set endtime to a time</span>
        <span class="c1"># in the far future if it is null</span>
        <span class="n">DISTANTFUTURE</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2051</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DISTANTFUTURE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

<div class="viewcode-block" id="Database.save_inventory"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_inventory">[docs]</a>    <span class="k">def</span> <span class="nf">save_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">networks_to_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SY&quot;</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves contents of all components of an obspy inventory</span>
<span class="sd">        object to documents in the site and channel collections.</span>
<span class="sd">        The site collection is sufficient for Seismogram objects but</span>
<span class="sd">        TimeSeries data will normally need to be connected to the</span>
<span class="sd">        channel collection.   The algorithm used will not add</span>
<span class="sd">        duplicates based on the following keys:</span>

<span class="sd">        For site:</span>
<span class="sd">            net</span>
<span class="sd">            sta</span>
<span class="sd">            chan</span>
<span class="sd">            loc</span>
<span class="sd">            starttime::endtime - this check is done cautiously with</span>
<span class="sd">              a 10 s fudge factor to avoid the issue of floating point</span>
<span class="sd">              equal tests.   Probably overly paranoid since these</span>
<span class="sd">              fields are normally rounded to a time at the beginning</span>
<span class="sd">              of a utc day, but small cost to pay for stabilty because</span>
<span class="sd">              this function is not expected to be run millions of times</span>
<span class="sd">              on a huge collection.</span>

<span class="sd">        for channels:</span>
<span class="sd">            net</span>
<span class="sd">            sta</span>
<span class="sd">            chan</span>
<span class="sd">            loc</span>
<span class="sd">            starttime::endtime - same approach as for site with same</span>
<span class="sd">               issues - note especially 10 s fudge factor.   This is</span>
<span class="sd">               necessary because channel metadata can change more</span>
<span class="sd">               frequently than site metadata (e.g. with a sensor</span>
<span class="sd">               orientation or sensor swap)</span>

<span class="sd">        The channel collection can contain full response data</span>
<span class="sd">        that can be obtained by extracting the data with the key</span>
<span class="sd">        &quot;serialized_inventory&quot; and running pickle loads on the returned</span>
<span class="sd">        string.</span>

<span class="sd">        A final point of note is that not all Inventory objects are created</span>
<span class="sd">        equally.   Inventory objects appear to us to be designed as an image</span>
<span class="sd">        of stationxml data.  The problem is that stationxml, like SEED, has to</span>
<span class="sd">        support a lot of complexity faced by data centers that end users</span>
<span class="sd">        like those using this package do not need or want to know.   The</span>
<span class="sd">        point is this method tries to untangle the complexity and aims to reduce the</span>
<span class="sd">        result to a set of documents in the site and channel collection</span>
<span class="sd">        that can be cross referenced to link the right metadata with all</span>
<span class="sd">        waveforms in a dataset.</span>

<span class="sd">        :param inv: is the obspy Inventory object of station data to save.</span>
<span class="sd">        :networks_to_exclude: should contain a list (or tuple) of</span>
<span class="sd">            SEED 2 byte network codes that are to be ignored in</span>
<span class="sd">            processing.   Default is SY which is used for synthetics.</span>
<span class="sd">            Set to None if if all are to be loaded.</span>
<span class="sd">        :verbose:  print informational lines if true.  If false</span>
<span class="sd">        works silently)</span>

<span class="sd">        :return:  tuple with</span>
<span class="sd">          0 - integer number of site documents saved</span>
<span class="sd">          1 -integer number of channel documents saved</span>
<span class="sd">          2 - number of distinct site (net,sta,loc) items processed</span>
<span class="sd">          3 - number of distinct channel items processed</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># site is a frozen name for the collection here.  Perhaps</span>
        <span class="c1"># should be a variable with a default</span>
        <span class="c1"># to do: need to change source_id to be a copy of the _id string.</span>

        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">n_site_saved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_chan_saved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_site_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_chan_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
            <span class="c1"># Inventory object I got from webservice download</span>
            <span class="c1"># makes the sta variable here a net:sta combination</span>
            <span class="c1"># We can get the net code like this</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">code</span>
            <span class="c1"># This adds feature to skip data for any net code</span>
            <span class="c1"># listed in networks_to_exclude</span>
            <span class="k">if</span> <span class="n">networks_to_exclude</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">networks_to_exclude</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="c1"># Each x now has a station field, BUT tests I ran</span>
            <span class="c1"># say for my example that field has one entry per</span>
            <span class="c1"># x.  Hence, we can get sta name like this</span>
            <span class="n">stalist</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">stations</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stalist</span><span class="p">:</span>
                <span class="n">sta</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">code</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">start_date</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">end_date</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">starttime</span><span class="p">)</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">endtime</span><span class="p">)</span>
                <span class="n">latitude</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">latitude</span>
                <span class="n">longitude</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">longitude</span>
                <span class="c1"># stationxml files seen to put elevation in m. We</span>
                <span class="c1"># always use km so need to convert</span>
                <span class="n">elevation</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">elevation</span> <span class="o">/</span> <span class="mf">1000.0</span>
                <span class="c1"># an obnoxious property of station xml files obspy is giving me</span>
                <span class="c1"># is that the start_dates and end_dates on the net:sta section</span>
                <span class="c1"># are not always consistent with the channel data.  In particular</span>
                <span class="c1"># loc codes are a problem. So we pull the required metadata from</span>
                <span class="c1"># the chans data and will override locations and time ranges</span>
                <span class="c1"># in station section with channel data</span>
                <span class="n">chans</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">channels</span>
                <span class="n">locdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_locdata</span><span class="p">(</span><span class="n">chans</span><span class="p">)</span>
                <span class="c1"># Assume loc code of 0 is same as rest</span>
                <span class="c1"># loc=_extract_loc_code(chanlist[0])</span>
                <span class="c1"># TODO Delete when sure we don&#39;t need to keep the full thing</span>
                <span class="c1"># picklestr = pickle.dumps(x)</span>
                <span class="n">all_locs</span> <span class="o">=</span> <span class="n">locdata</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">all_locs</span><span class="p">:</span>
                    <span class="c1"># If multiple loc codes are present on the second pass</span>
                    <span class="c1"># rec will contain the ObjectId of the document inserted</span>
                    <span class="c1"># in the previous pass - an obnoxious property of insert_one</span>
                    <span class="c1"># This initialization guarantees an empty container</span>
                    <span class="n">rec</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
                    <span class="n">lkey</span> <span class="o">=</span> <span class="n">loc</span>
                    <span class="n">loc_tuple</span> <span class="o">=</span> <span class="n">locdata</span><span class="p">[</span><span class="n">lkey</span><span class="p">]</span>
                    <span class="c1"># We use these attributes linked to loc code rather than</span>
                    <span class="c1"># the station data - experience shows they are not</span>
                    <span class="c1"># consistent and we should use this set.</span>
                    <span class="n">loc_lat</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">loc_lon</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">loc_elev</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="c1"># for consistency convert this to km too</span>
                    <span class="n">loc_elev</span> <span class="o">=</span> <span class="n">loc_elev</span> <span class="o">/</span> <span class="mf">1000.0</span>
                    <span class="n">loc_edepth</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                    <span class="n">loc_stime</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">loc_stime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">loc_stime</span><span class="p">)</span>
                    <span class="n">loc_etime</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">loc_etime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">loc_etime</span><span class="p">)</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_lat</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_lon</span>
                    <span class="c1"># save coordinates in both geoJSON and &quot;legacy&quot;</span>
                    <span class="c1"># format</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_lon</span><span class="p">,</span> <span class="n">loc_lat</span><span class="p">]</span>
                    <span class="c1"># Illegal lon,lat values will cause this to throw a</span>
                    <span class="c1"># ValueError exception.   We let it do that as</span>
                    <span class="c1"># it indicates a problem datum</span>
                    <span class="n">rec</span> <span class="o">=</span> <span class="n">geoJSON_doc</span><span class="p">(</span><span class="n">loc_lat</span><span class="p">,</span> <span class="n">loc_lon</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">rec</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;location&quot;</span><span class="p">)</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;elev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_elev</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;edepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_edepth</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">latitude</span> <span class="o">!=</span> <span class="n">loc_lat</span>
                        <span class="ow">or</span> <span class="n">longitude</span> <span class="o">!=</span> <span class="n">loc_lon</span>
                        <span class="ow">or</span> <span class="n">elevation</span> <span class="o">!=</span> <span class="n">loc_elev</span>
                    <span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="n">net</span><span class="p">,</span>
                            <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                            <span class="n">sta</span><span class="p">,</span>
                            <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                            <span class="n">loc</span><span class="p">,</span>
                            <span class="s2">&quot; (Warning):  station section position is not consistent with loc code position&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data in loc code section overrides station section&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Station section coordinates:  &quot;</span><span class="p">,</span>
                            <span class="n">latitude</span><span class="p">,</span>
                            <span class="n">longitude</span><span class="p">,</span>
                            <span class="n">elevation</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;loc code section coordinates:  &quot;</span><span class="p">,</span>
                            <span class="n">loc_lat</span><span class="p">,</span>
                            <span class="n">loc_lon</span><span class="p">,</span>
                            <span class="n">loc_elev</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_is_not_in_db</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
                        <span class="c1"># Note this sets site_id to an ObjectId for the insertion</span>
                        <span class="c1"># We use that to define a duplicate we tag as site_id</span>
                        <span class="n">site_id</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                            <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">site_id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;site_id&quot;</span><span class="p">:</span> <span class="n">site_id</span><span class="p">}}</span>
                        <span class="p">)</span>
                        <span class="n">n_site_saved</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;net:sta:loc=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">loc</span><span class="p">,</span>
                                <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                <span class="n">starttime</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="p">,</span>
                                <span class="s2">&quot; added to site collection&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;net:sta:loc=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">loc</span><span class="p">,</span>
                                <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                <span class="n">starttime</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="p">,</span>
                                <span class="s2">&quot; is already in site collection - ignored&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="n">n_site_processed</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># done with site now handle channel</span>
                    <span class="c1"># Because many features are shared we can copy rec</span>
                    <span class="c1"># note this has to be a deep copy</span>
                    <span class="n">chanrec</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
                    <span class="c1"># We don&#39;t want this baggage in the channel documents</span>
                    <span class="c1"># keep them only in the site collection</span>
                    <span class="c1"># del chanrec[&#39;serialized_inventory&#39;]</span>
                    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">chans</span><span class="p">:</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">code</span>
                        <span class="c1"># the Dip attribute in a stationxml file</span>
                        <span class="c1"># is like strike-dip and relative to horizontal</span>
                        <span class="c1"># line with positive down.  vang is the</span>
                        <span class="c1"># css30 attribute that is spherical coordinate</span>
                        <span class="c1"># theta angle</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;vang&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">dip</span> <span class="o">+</span> <span class="mf">90.0</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;hang&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">azimuth</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;edepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">depth</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">start_date</span>
                        <span class="n">et</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">end_date</span>
                        <span class="c1"># as above be careful of null values for either end of the time range</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
                        <span class="n">et</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">timestamp</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">timestamp</span>
                        <span class="n">n_chan_processed</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_is_not_in_db</span><span class="p">(</span><span class="n">chanrec</span><span class="p">):</span>
                            <span class="n">picklestr</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
                            <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picklestr</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">chanrec</span><span class="p">)</span>
                            <span class="c1"># insert_one has an obnoxious behavior in that it</span>
                            <span class="c1"># inserts the ObjectId in chanrec.  In this loop</span>
                            <span class="c1"># we reuse chanrec so we have to delete the id field</span>
                            <span class="c1"># howeveer, we first want to update the record to</span>
                            <span class="c1"># have chan_id provide an  alternate key to that id</span>
                            <span class="c1"># object_id - that makes this consistent with site</span>
                            <span class="c1"># we actually use the return instead of pulling from</span>
                            <span class="c1"># chanrec</span>
                            <span class="n">idobj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
                            <span class="n">dbchannel</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                                <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;chan_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">}}</span>
                            <span class="p">)</span>
                            <span class="k">del</span> <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
                            <span class="n">n_chan_saved</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s2">&quot;net:sta:loc:chan=&quot;</span><span class="p">,</span>
                                    <span class="n">net</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">sta</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">loc</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">chan</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
                                    <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                    <span class="n">st</span><span class="p">,</span>
                                    <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                    <span class="n">et</span><span class="p">,</span>
                                    <span class="s2">&quot; added to channel collection&quot;</span><span class="p">,</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s2">&quot;net:sta:loc:chan=&quot;</span><span class="p">,</span>
                                    <span class="n">net</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">sta</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">loc</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">chan</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
                                    <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                    <span class="n">st</span><span class="p">,</span>
                                    <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                    <span class="n">et</span><span class="p">,</span>
                                    <span class="s2">&quot; already in channel collection - ignored&quot;</span><span class="p">,</span>
                                <span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># For now we will always print this summary information</span>
        <span class="c1"># For expected use it would be essential information</span>
        <span class="c1">#</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Database.save_inventory processing summary:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of site records processed=&quot;</span><span class="p">,</span> <span class="n">n_site_processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of site records saved=&quot;</span><span class="p">,</span> <span class="n">n_site_saved</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of channel records processed=&quot;</span><span class="p">,</span> <span class="n">n_chan_processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of channel records saved=&quot;</span><span class="p">,</span> <span class="n">n_chan_saved</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">n_site_saved</span><span class="p">,</span> <span class="n">n_chan_saved</span><span class="p">,</span> <span class="n">n_site_processed</span><span class="p">,</span> <span class="n">n_chan_processed</span><span class="p">])</span></div>

<div class="viewcode-block" id="Database.read_inventory"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_inventory">[docs]</a>    <span class="k">def</span> <span class="nf">read_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads an obspy inventory object limited by one or more</span>
<span class="sd">        keys.   Default is to load the entire contents of the</span>
<span class="sd">        site collection.   Note the load creates an obspy</span>
<span class="sd">        inventory object that is returned.  Use load_stations</span>
<span class="sd">        to return the raw data used to construct an Inventory.</span>

<span class="sd">        :param net:  network name query string.  Can be a single</span>
<span class="sd">        unique net code or use MongoDB&#39;s expression query</span>
<span class="sd">        mechanism (e.g. &quot;{&#39;$gt&#39; : 42}).  Default is all</span>
<span class="sd">        :param sta: statoin name query string.  Can be a single</span>
<span class="sd">        station name or a MongoDB query expression.</span>
<span class="sd">        :param loc:  loc code to select.  Can be a single unique</span>
<span class="sd">        location (e.g. &#39;01&#39;) or a MongoDB expression query.</span>
<span class="sd">        :param time:   limit return to stations with</span>
<span class="sd">        startime&lt;time&lt;endtime.  Input is assumed an</span>
<span class="sd">        epoch time NOT an obspy UTCDateTime. Use a conversion</span>
<span class="sd">        to epoch time if necessary.</span>
<span class="sd">        :return:  obspy Inventory of all stations matching the</span>
<span class="sd">        query parameters</span>
<span class="sd">        :rtype:  obspy Inventory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">net</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Inventory</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="n">serialized</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;serialized_inventory&quot;</span><span class="p">]</span>
                <span class="n">netw</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">serialized</span><span class="p">)</span>
                <span class="c1"># It might be more efficient to build a list of</span>
                <span class="c1"># Network objects but here we add them one</span>
                <span class="c1"># station at a time.  Note the extend method</span>
                <span class="c1"># if poorly documented in obspy</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">netw</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Database.get_seed_site"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_seed_site">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;NONE&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The site collection is assumed to have a one to one</span>
<span class="sd">        mapping of net:sta:loc:starttime - endtime.</span>
<span class="sd">        This method uses a restricted query to match the</span>
<span class="sd">        keys given and returns the MongoDB document matching the keys.</span>
<span class="sd">        The (optional) time arg is used for a range match to find</span>
<span class="sd">        period between the site startime and endtime.</span>
<span class="sd">        Returns None if there is no match.</span>

<span class="sd">        An all to common metadata problem is to have duplicate entries in</span>
<span class="sd">        site for the same data.   The default behavior of this method is</span>
<span class="sd">        to print a warning whenever a match is ambiguous</span>
<span class="sd">        (i.e. more than on document matches the keys).  Set verbose false to</span>
<span class="sd">        silence such warnings if you know they are harmless.</span>

<span class="sd">        An all to common metadata problem is to have duplicate entries in</span>
<span class="sd">        site for the same data.   The default behavior of this method is</span>
<span class="sd">        to print a warning whenever a match is ambiguous</span>
<span class="sd">        (i.e. more than on document matches the keys).  Set verbose false to</span>
<span class="sd">        silence such warnings if you know they are harmless.</span>

<span class="sd">        The seed modifier in the name is to emphasize this method is</span>
<span class="sd">        for data originating as the SEED format that use net:sta:loc:chan</span>
<span class="sd">        as the primary index.</span>

<span class="sd">        Note this method may be DEPRICATED in the future as it has been</span>
<span class="sd">        largely superceded by BasicMatcher implementations in the</span>
<span class="sd">        normalize module.</span>

<span class="sd">        :param net:  network name to match</span>
<span class="sd">        :param sta:  station name to match</span>
<span class="sd">        :param loc:   optional loc code to made (empty string ok and common)</span>
<span class="sd">        default ignores loc in query.</span>
<span class="sd">        :param time: epoch time for requested metadata.  Default undefined</span>
<span class="sd">          and will cause the function to simply return the first document</span>
<span class="sd">          matching the name keys only.   (This is rarely what you want, but</span>
<span class="sd">          there is no standard default for this argument.)</span>
<span class="sd">        :param verbose:  When True (the default) this method will issue a</span>
<span class="sd">          print warning message when the match is ambiguous - multiple</span>
<span class="sd">          docs match the specified keys.   When set False such warnings</span>
<span class="sd">          will be suppressed.  Use false only if you know the duplicates</span>
<span class="sd">          are harmless and you are running on a large data set and</span>
<span class="sd">          you want to reduce the log size.</span>

<span class="sd">        :return: MongoDB doc matching query</span>
<span class="sd">        :rtype:  python dict (document) of result.  None if there is no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="s2">&quot;NONE&quot;</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;get_seed_site (WARNING):  query=&quot;</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returned &quot;</span><span class="p">,</span> <span class="n">matchsize</span><span class="p">,</span> <span class="s2">&quot; documents - should be exactly one&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returning first entry found&quot;</span><span class="p">)</span>
            <span class="n">stadoc</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">stadoc</span></div>

<div class="viewcode-block" id="Database.get_seed_channel"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_seed_channel">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The channel collection is assumed to have a one to one</span>
<span class="sd">        mapping of net:sta:loc:chan:starttime - endtime.</span>
<span class="sd">        This method uses a restricted query to match the</span>
<span class="sd">        keys given and returns the document matching the specified keys.</span>

<span class="sd">        The optional loc code is handled specially.  The reason is</span>
<span class="sd">        that it is common to have the loc code empty.  In seed data that</span>
<span class="sd">        puts two ascii blank characters in the 2 byte packet header</span>
<span class="sd">        position for each miniseed blockette.  With pymongo that</span>
<span class="sd">        can be handled one of three ways that we need to handle gracefully.</span>
<span class="sd">        That is, one can either set a literal two blank character</span>
<span class="sd">        string, an empty string (&quot;&quot;), or a MongoDB NULL.   To handle</span>
<span class="sd">        that confusion this algorithm first queries for all matches</span>
<span class="sd">        without loc defined.  If only one match is found that is</span>
<span class="sd">        returned immediately.  If there are multiple matches we</span>
<span class="sd">        search though the list of docs returned for a match to</span>
<span class="sd">        loc being conscious of the null string oddity.</span>

<span class="sd">        The (optional) time arg is used for a range match to find</span>
<span class="sd">        period between the site startime and endtime.  If not used</span>
<span class="sd">        the first occurence will be returned (usually ill adivsed)</span>
<span class="sd">        Returns None if there is no match.  Although the time argument</span>
<span class="sd">        is technically option it usually a bad idea to not include</span>
<span class="sd">        a time stamp because most stations saved as seed data have</span>
<span class="sd">        time variable channel metadata.</span>

<span class="sd">        Note this method may be DEPRICATED in the future as it has been</span>
<span class="sd">        largely superceded by BasicMatcher implementations in the</span>
<span class="sd">        normalize module.</span>

<span class="sd">        :param net:  network name to match</span>
<span class="sd">        :param sta:  station name to match</span>
<span class="sd">        :param chan:  seed channel code to match</span>
<span class="sd">        :param loc:   optional loc code to made (empty string ok and common)</span>
<span class="sd">           default ignores loc in query.</span>
<span class="sd">        :param time: epoch time for requested metadata</span>
<span class="sd">        :param verbose:  When True (the default) this method will issue a</span>
<span class="sd">           print warning message when the match is ambiguous - multiple</span>
<span class="sd">           docs match the specified keys.   When set False such warnings</span>
<span class="sd">           will be suppressed.  Use false only if you know the duplicates</span>
<span class="sd">           are harmless and you are running on a large data set and</span>
<span class="sd">           you want to reduce the log size.</span>

<span class="sd">        :return: handle to query return</span>
<span class="sd">        :rtype:  MondoDB Cursor object of query result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note we only land here when the above yields multiple matches</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We could get here one of two ways.  There could</span>
                <span class="c1"># be multiple loc codes and the user didn&#39;t specify</span>
                <span class="c1"># a choice or they wanted the empty string (2 cases).</span>
                <span class="c1"># We also have to worry about the case where the</span>
                <span class="c1"># time was not specified but needed.</span>
                <span class="c1"># The complexity below tries to unravel all those possibities</span>
                <span class="n">testquery</span> <span class="o">=</span> <span class="n">query</span>
                <span class="n">testquery</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;get_seed_channel:  multiple matches found for net=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot; sta=&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot; and channel=&quot;</span><span class="p">,</span>
                                <span class="n">chan</span><span class="p">,</span>
                                <span class="s2">&quot; with null loc code</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;Assuming database problem with duplicate documents in channel collection</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;Returning first one found&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;get_seed_channel:  &quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;query with &quot;</span>
                            <span class="o">+</span> <span class="n">net</span>
                            <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                            <span class="o">+</span> <span class="n">sta</span>
                            <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                            <span class="o">+</span> <span class="n">chan</span>
                            <span class="o">+</span> <span class="s2">&quot; and null loc is ambiguous</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;Specify at least time but a loc code if is not truly null&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we land here if a null match didn&#39;t work.</span>
                    <span class="c1"># Try one more recovery with setting loc to an emtpy</span>
                    <span class="c1"># string</span>
                    <span class="n">testquery</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s2">&quot;get_seed_channel:  multiple matches found for net=&quot;</span><span class="p">,</span>
                                    <span class="n">net</span><span class="p">,</span>
                                    <span class="s2">&quot; sta=&quot;</span><span class="p">,</span>
                                    <span class="n">sta</span><span class="p">,</span>
                                    <span class="s2">&quot; and channel=&quot;</span><span class="p">,</span>
                                    <span class="n">chan</span><span class="p">,</span>
                                    <span class="s2">&quot; with null loc code tested with empty string</span><span class="se">\n</span><span class="s2">&quot;</span>
                                    <span class="s2">&quot;Assuming database problem with duplicate documents in channel collection</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;Returning first one found&quot;</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                                <span class="s2">&quot;get_seed_channel:  &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;recovery query attempt with &quot;</span>
                                <span class="o">+</span> <span class="n">net</span>
                                <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                                <span class="o">+</span> <span class="n">sta</span>
                                <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                                <span class="o">+</span> <span class="n">chan</span>
                                <span class="o">+</span> <span class="s2">&quot; and null loc converted to empty string is ambiguous</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;Specify at least time but a loc code if is not truly null&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="Database.get_response"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_response">[docs]</a>    <span class="k">def</span> <span class="nf">get_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an obspy Response object for seed channel defined by</span>
<span class="sd">        the standard keys net, sta, chan, and loc and a time stamp.</span>
<span class="sd">        Input time can be a UTCDateTime or an epoch time stored as a float.</span>

<span class="sd">        :param db:  mspasspy Database handle containing a channel collection</span>
<span class="sd">          to be queried</span>
<span class="sd">        :param net: seed network code (required)</span>
<span class="sd">        :param sta: seed station code (required)</span>
<span class="sd">        :param chan:  seed channel code (required)</span>
<span class="sd">        :param loc:  seed net code.  If None loc code will not be</span>
<span class="sd">          included in the query.  If loc is anything else it is passed</span>
<span class="sd">          as a literal.  Sometimes loc codes are not defined by in the</span>
<span class="sd">          seed data and are literal two ascii space characters.  If so</span>
<span class="sd">          MongoDB translates those to &quot;&quot;.   Use loc=&quot;&quot; for that case or</span>
<span class="sd">          provided the station doesn&#39;t mix null and other loc codes use None.</span>
<span class="sd">        :param time:  time stamp for which the response is requested.</span>
<span class="sd">          seed metadata has a time range for validity this field is</span>
<span class="sd">          required.   Can be passed as either a UTCDateTime object or</span>
<span class="sd">          a raw epoch time stored as a python float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">chan</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">net</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;get_response:  missing one of required arguments:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;net, sta, chan, or time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;net&quot;</span><span class="p">:</span> <span class="n">net</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">:</span> <span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">:</span> <span class="n">chan</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span>  <span class="c1"># set here but not used</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">t0</span><span class="p">}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">t0</span><span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;No matching documents found in channel for &quot;</span><span class="p">,</span>
                <span class="n">net</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="n">sta</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
                <span class="n">chan</span><span class="p">,</span>
                <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="s2">&quot;&lt;-&quot;</span><span class="p">,</span>
                <span class="s2">&quot; at time=&quot;</span><span class="p">,</span>
                <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="s2">&quot; matching documents found in channel for &quot;</span><span class="p">,</span>
                <span class="n">net</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="n">sta</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="s2">&quot;&lt;-&quot;</span><span class="p">,</span>
                <span class="s2">&quot; at time=&quot;</span><span class="p">,</span>
                <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There should be just one - returning the first one found&quot;</span><span class="p">)</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">]</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chan</span><span class="o">.</span><span class="n">response</span></div>

<div class="viewcode-block" id="Database.save_catalog"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_catalog">[docs]</a>    <span class="k">def</span> <span class="nf">save_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the contents of an obspy Catalog object to MongoDB</span>
<span class="sd">        source collection.  All contents are saved even with</span>
<span class="sd">        no checking for existing sources with duplicate</span>
<span class="sd">        data.   Like the comparable save method for stations,</span>
<span class="sd">        save_inventory, the assumption is pre or post cleanup</span>
<span class="sd">        will be preformed if duplicates are a major issue.</span>

<span class="sd">        :param cat: is the Catalog object to be saved</span>
<span class="sd">        :param verbose: Print informational data if true.</span>
<span class="sd">        When false (default) it does it&#39;s work silently.</span>

<span class="sd">        :return: integer count of number of items saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># perhaps should demand db is handle to the source collection</span>
        <span class="c1"># but I think the cost of this lookup is tiny</span>
        <span class="c1"># to do: need to change source_id to be a copy of the _id string.</span>

        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">nevents</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">cat</span><span class="p">:</span>
            <span class="c1"># event variable in loop is an Event object from cat</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">preferred_origin</span><span class="p">()</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">preferred_magnitude</span><span class="p">()</span>
            <span class="n">picklestr</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># rec[&#39;source_id&#39;]=source_id</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">latitude</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">longitude</span>
            <span class="c1"># save the epicenter data in both legacy format an d</span>
            <span class="c1"># geoJSON format.  Either can technically be used in a</span>
            <span class="c1"># geospatial query but the geoJSON version is always</span>
            <span class="c1"># preferred</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">latitude</span><span class="p">]</span>
            <span class="c1"># note this function updates rec and returns the upodate</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">geoJSON_doc</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">rec</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;epicenter&quot;</span><span class="p">)</span>
            <span class="c1"># It appears quakeml puts source depths in meter</span>
            <span class="c1"># convert to km</span>
            <span class="c1"># also obspy&#39;s catalog object seesm to allow depth to be</span>
            <span class="c1"># a None so we have to test for that condition to avoid</span>
            <span class="c1"># aborts</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">depth</span> <span class="o">/</span> <span class="mf">1000.0</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">otime</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">time</span>
            <span class="c1"># This attribute of UTCDateTime is the epoch time</span>
            <span class="c1"># In mspass we only story time as epoch times</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">otime</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mag</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;magnitude_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">magnitude_type</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;serialized_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picklestr</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
            <span class="c1"># the return of an insert_one has the object id of the insertion</span>
            <span class="c1"># set as inserted_id.  We save taht as source_id as a more</span>
            <span class="c1"># intuitive key that _id</span>
            <span class="n">idobj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;source_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">}})</span>
            <span class="n">nevents</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nevents</span></div>

<div class="viewcode-block" id="Database.load_event"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_event">[docs]</a>    <span class="k">def</span> <span class="nf">load_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a bson record of source data matching the unique id</span>
<span class="sd">        defined by source_id.   The idea is that magic string would</span>
<span class="sd">        be extraced from another document (e.g. in an arrival collection)</span>
<span class="sd">        and used to look up the event with which it is associated in</span>
<span class="sd">        the source collection.</span>

<span class="sd">        This function is a relic and may be depricated.  I originally</span>
<span class="sd">        had a different purpose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dbsource</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;source_id&quot;</span><span class="p">:</span> <span class="n">source_id</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="c1">#  Methods for handling miniseed data</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_mseed_index</span><span class="p">(</span><span class="n">index_record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper used to convert C++ struct/class mseed_index to a dict</span>
<span class="sd">        to use for saving to mongod.  Note loc is only set if it is not</span>
<span class="sd">        zero length - consistent with mspass approach</span>

<span class="sd">        :param index_record:  mseed_index record to convert</span>
<span class="sd">        :return: dict containing index data converted to dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">sta</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">net</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">chan</span>
        <span class="k">if</span> <span class="n">index_record</span><span class="o">.</span><span class="n">loc</span><span class="p">:</span>
            <span class="n">o</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">loc</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">samprate</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">index_record</span><span class="o">.</span><span class="n">samprate</span><span class="p">)</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">starttime</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;last_packet_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">last_packet_time</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">foff</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">npts</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">endtime</span>
        <span class="k">return</span> <span class="n">o</span>

<div class="viewcode-block" id="Database.index_mseed_file"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_file">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">segment_time_tears</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">elog_collection</span><span class="o">=</span><span class="s2">&quot;elog&quot;</span><span class="p">,</span>
        <span class="n">return_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize_channel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data.  This function scans a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument.  I builds an index</span>
<span class="sd">        for the file and writes the index to mongodb</span>
<span class="sd">        in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default).   The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>
<span class="sd">        The index is appropriate ONLY if the data on the file are created</span>
<span class="sd">        by concatenating data with packets sorted by net, sta, loc, chan, time</span>
<span class="sd">        AND the data are contiguous in time.   The original</span>
<span class="sd">        concept for this function came from the need to handle large files</span>
<span class="sd">        produced by concanentation of miniseed single-channel files created</span>
<span class="sd">        by obpsy&#39;s mass_downloader.   i.e. the basic model is the input</span>
<span class="sd">        files are assumed to be something comparable to running the unix</span>
<span class="sd">        cat command on a set of single-channel, contingous time sequence files.</span>
<span class="sd">        There are other examples that do the same thing (e.g. antelope&#39;s</span>
<span class="sd">        miniseed2days).</span>

<span class="sd">        We emphasize this function only builds an index - it does not</span>
<span class="sd">        convert any data.   It has to scan the entire file deriving the</span>
<span class="sd">        index from data retrieved from miniseed packets with libmseed so</span>
<span class="sd">        for large data sets this can take a long time.</span>

<span class="sd">        Actual seismic data stored as miniseed are prone to time tears.</span>
<span class="sd">        That can happen at the instrument level in at least two common</span>
<span class="sd">        ways: (1) dropped packets from telemetry issues, or (2) instrument</span>
<span class="sd">        timing jumps when a clock loses external lock to gps or some</span>
<span class="sd">        other standard and the rock is restored.  The behavior is this</span>
<span class="sd">        function is controlled by the input parameter</span>
<span class="sd">        segment_time_tears.  When true a new index entry is created</span>
<span class="sd">        any time the start time of a packet differs from that computed</span>
<span class="sd">        from the endtime of the last packet by more than one sample</span>
<span class="sd">        AND net:sta:chan:loc are constant.  The default for this</span>
<span class="sd">        parameter is false because data with many dropped packets from</span>
<span class="sd">        telemetry are common and can create overwhelming numbers of</span>
<span class="sd">        index entries quickly.  When false the scan only creates a new</span>
<span class="sd">        index record when net, sta, chan, or loc change between successive</span>
<span class="sd">        packets.  Our reader has gap handling functions to handle</span>
<span class="sd">        time tears.  Set segment_time_tears true only when you are</span>
<span class="sd">        confident the data set does not contain a large number of dropped</span>
<span class="sd">        packets.</span>

<span class="sd">        Note to parallelize this function put a list of files in a Spark</span>
<span class="sd">        RDD or a Dask bag and parallelize the call the this function.</span>
<span class="sd">        That can work because MongoDB is designed for parallel operations</span>
<span class="sd">        and we use the thread safe version of the libmseed reader.</span>

<span class="sd">        Finally, note that cross referencing with the channel and/or</span>
<span class="sd">        source collections should be a common step after building the</span>
<span class="sd">        index with this function.  The reader found elsewhere in this</span>
<span class="sd">        module will transfer linking ids (i.e. channel_id and/or source_id)</span>
<span class="sd">        to TimeSeries objects when it reads the data from the files</span>
<span class="sd">        indexed by this function.</span>

<span class="sd">        :param dfile:  file name of data to be indexed.  Asssumed to be</span>
<span class="sd">          the leaf node of the path - i.e. it contains no directory information</span>
<span class="sd">          but just the file name.</span>
<span class="sd">        :param dir:  directory name.  This can be a relative path from the</span>
<span class="sd">          current directory be be advised it will always be converted to an</span>
<span class="sd">          fully qualified path.  If it is undefined (the default) the function</span>
<span class="sd">          assumes the file is in the current working directory and will use</span>
<span class="sd">          the result of the python getcwd command as the directory path</span>
<span class="sd">          stored in the database.</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">          index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">          to use anything but the default.</span>
<span class="sd">        :param segment_time_tears: boolean controlling handling of data gaps</span>
<span class="sd">          defined by constant net, sta, chan, and loc but a discontinuity</span>
<span class="sd">          in time tags for successive packets.  See above for a more extensive</span>
<span class="sd">          discussion of how to use this parameter.  Default is True.</span>
<span class="sd">        :param elog_collection:  name to write any error logs messages</span>
<span class="sd">          from the miniseed reader.  Default is &quot;elog&quot;, which is the</span>
<span class="sd">          same as for TimeSeries and Seismogram data, but the cross reference</span>
<span class="sd">          keys here are keyed by &quot;wf_miniseed_id&quot;.</span>
<span class="sd">        :param return_ids:  if set True the function will return a tuple</span>
<span class="sd">          with two id lists.  The 0 entry is an array of ids from the</span>
<span class="sd">          collection (wf_miniseed by default) of index entries saved and</span>
<span class="sd">          the 1 entry will contain the ids in the elog_collection of</span>
<span class="sd">          error log entry insertions.  The 1 entry will be empty if the</span>
<span class="sd">          reader found no errors and the error log was empty (the hopefully</span>
<span class="sd">          normal situation).  When this argument is False (the default) it</span>
<span class="sd">          returns None.  Set true if you need to build some kind of cross</span>
<span class="sd">          reference to read errors to build some custom cleaning method</span>
<span class="sd">          for specialized processing that can be done more efficiently.</span>
<span class="sd">          By default it is fast only to associate an error log entry with</span>
<span class="sd">          a particular waveform index entry. (we store the saved index</span>
<span class="sd">          MongoDB document id with each elog entry)</span>
<span class="sd">        :param normalize_channel:  boolean controlling normalization with</span>
<span class="sd">          the channel collection.   When set True (default is false) the</span>
<span class="sd">          method will call the Database.get_seed_channel method, extract</span>
<span class="sd">          the id from the result, and set the result as &quot;channel_id&quot; before</span>
<span class="sd">          writing the wf_miniseed document.  Set this argument true if</span>
<span class="sd">          you have a relatively complete channel collection assembled</span>
<span class="sd">          before running a workflow to index a set of miniseed files</span>
<span class="sd">          (a common raw data starting point).</span>
<span class="sd">        :param verbose:  boolean passed to get_seed_channel.  This</span>
<span class="sd">          argument has no effect unless normalize_channel is set True.</span>
<span class="sd">          It is necessary because the get_seed_channel function has no</span>
<span class="sd">          way to log errors except calling print.  A very common metadata</span>
<span class="sd">          error is duplicate and/or time overlaps in channel metadata.</span>
<span class="sd">          Those are usually harmless so the default for this parameter is</span>
<span class="sd">          False.  Set this True if you are using inline normalization</span>
<span class="sd">          (normalize_channel set True) and you aren&#39;t certain your</span>
<span class="sd">          channel collection has no serious inconsistencies.</span>
<span class="sd">        :exception: This function can throw a range of error types for</span>
<span class="sd">          a long list of possible io issues.   Callers should use a</span>
<span class="sd">          generic handler to avoid aborts in a large job.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="c1"># If dir is not define assume current directory.  Otherwise</span>
        <span class="c1"># use realpath to make sure the directory is the full path</span>
        <span class="c1"># We store the full path in mongodb</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dfile_uuid</span><span class="p">(</span><span class="s2">&quot;mseed&quot;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
        <span class="c1"># TODO:  should have a way to pass verbose to this function</span>
        <span class="c1"># present verbose is not appropriate.</span>
        <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">elog</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mseed_file_indexer</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">segment_time_tears</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;No such file or directory&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()))</span>
        <span class="n">ids_affected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_mseed_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odir</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
            <span class="c1"># mseed is dogmatically UTC so we always set it this way</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;time_standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;UTC&quot;</span>
            <span class="n">thisid</span> <span class="o">=</span> <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="n">ids_affected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize_channel</span><span class="p">:</span>
            <span class="c1"># these quantities are always defined unless there was a read error</span>
            <span class="c1"># and I don&#39;t think we can get here if we had a read error.</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
            <span class="n">stime</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
                <span class="n">chandoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed_channel</span><span class="p">(</span>
                    <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">stime</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chandoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seed_channel</span><span class="p">(</span>
                    <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">stime</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">chandoc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;channel_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chandoc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>

        <span class="c1"># log_ids is created here so it is defined but empty in</span>
        <span class="c1"># the tuple returned when return_ids is true</span>
        <span class="n">log_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elog_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span>

            <span class="n">errs</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()</span>
            <span class="n">jobid</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_job_id</span><span class="p">()</span>
            <span class="n">logdata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">errs</span><span class="p">:</span>
                <span class="n">logdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;job_id&quot;</span><span class="p">:</span> <span class="n">jobid</span><span class="p">,</span>
                        <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                        <span class="s2">&quot;badness&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">badness</span><span class="p">),</span>
                        <span class="s2">&quot;error_message&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
                        <span class="s2">&quot;process_id&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">p_id</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="n">docentry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;logdata&quot;</span><span class="p">:</span> <span class="n">logdata</span><span class="p">}</span>
            <span class="c1"># To mesh with the standard elog collection we add a copy of the</span>
            <span class="c1"># error messages with a tag for each id in the ids_affected list.</span>
            <span class="c1"># That should make elog connection to wf_miniseed records exactly</span>
            <span class="c1"># like wf_TimeSeries records but with a different collection link</span>
            <span class="k">for</span> <span class="n">wfid</span> <span class="ow">in</span> <span class="n">ids_affected</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;wf_miniseed_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wfid</span>
                <span class="n">elogid</span> <span class="o">=</span> <span class="n">elog_col</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
                <span class="n">log_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elogid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ids_affected</span><span class="p">,</span> <span class="n">log_ids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Database.save_dataframe"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">save_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">one_to_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tansfer a dataframe into a set of documents, and store them</span>
<span class="sd">        in a specified collection. In one_to_one mode every row in the</span>
<span class="sd">        dataframe will be saved in the specified mongodb collection.</span>
<span class="sd">        Otherwise duplicates would be discarded.</span>

<span class="sd">        Note we first call the dropna method of DataFrame to eliminate</span>
<span class="sd">        None values to mesh with how MongoDB handles Nulls; not</span>
<span class="sd">        consistent with DataFrame implemenations that mimic relational</span>
<span class="sd">        database tables where nulls are a hole in the table.</span>

<span class="sd">        :param df: Pandas.Dataframe object, the input to be transfered into mongodb</span>
<span class="sd">        documents</span>
<span class="sd">        :param collection:  MongoDB collection name to be used to save the</span>
<span class="sd">        (often subsetted) tuples of filename as documents in this collection.</span>
<span class="sd">        :param null_values:  is an optional dict defining null field values.</span>
<span class="sd">        When used an == test is applied to each attribute with a key</span>
<span class="sd">        defined in the null_vlaues python dict.  If == returns True, the</span>
<span class="sd">        value will be set as None in dataframe. If your table has a lot of null</span>
<span class="sd">        fields this option can save space, but readers must not require the null</span>
<span class="sd">        field.  The default is None which it taken to mean there are no null</span>
<span class="sd">        fields defined.</span>
<span class="sd">        :param one_to_one: a boolean to control if the set should be filtered by</span>
<span class="sd">        rows.  The default is True which means every row in the dataframe will</span>
<span class="sd">        create a single MongoDB document. If False the (normally reduced) set</span>
<span class="sd">        of attributes defined by attributes_to_use will be filtered with the</span>
<span class="sd">        panda/dask dataframe drop_duplicates method before converting the</span>
<span class="sd">        dataframe to documents and saving them to MongoDB.  That approach</span>
<span class="sd">        is important, for example, to filter things like Antelope &quot;site&quot; or</span>
<span class="sd">        &quot;sitechan&quot; attributes created by a join to something like wfdisc and</span>
<span class="sd">        saved as a text file to be processed by this function.</span>
<span class="sd">        :param parallel:  a boolean that determine if dask api will be used for</span>
<span class="sd">        operations on the dataframe, default is false.</span>
<span class="sd">        :return:  integer count of number of documents added to collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">and</span> <span class="n">_mspasspy_has_dask</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">daskdf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">one_to_one</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

        <span class="c1">#   For those null values, set them to None</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">null_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">null_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if parallel and _mspasspy_has_dask:</span>
<span class="sd">            df = daskdf.from_pandas(df, chunksize=1, sort=False)</span>
<span class="sd">            df = df.apply(lambda x: x.dropna(), axis=1).compute()</span>
<span class="sd">        else:</span>
<span class="sd">            df = df.apply(pd.Series.dropna, axis=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">dropna</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">doc_list</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc_list</span><span class="p">):</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_many</span><span class="p">(</span><span class="n">doc_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Database.save_textfile"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_textfile">[docs]</a>    <span class="k">def</span> <span class="nf">save_textfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;textfile&quot;</span><span class="p">,</span>
        <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">s+&quot;</span><span class="p">,</span>
        <span class="n">type_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header_line</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">one_to_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">insert_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import and parse a textfile into set of documents, and store them</span>
<span class="sd">        into a mongodb collection. This function consists of two steps:</span>
<span class="sd">        1. Textfile2Dataframe: Convert the input textfile into a Pandas dataframe</span>
<span class="sd">        2. save_dataframe: Insert the documents in that dataframe into a mongodb</span>
<span class="sd">        collection</span>

<span class="sd">        :param filename:  path to text file that is to be read to create the</span>
<span class="sd">        table object that is to be processed (internally we use pandas or</span>
<span class="sd">        dask dataframes)</span>
<span class="sd">        :param collection:  MongoDB collection name to be used to save the</span>
<span class="sd">        (often subsetted) tuples of filename as documents in this collection.</span>
<span class="sd">        :param separator: The delimiter used for seperating fields,</span>
<span class="sd">        the default is &quot;\s+&quot;, which is the regular expression of &quot;one or more</span>
<span class="sd">        spaces&quot;.</span>
<span class="sd">            For csv file, its value should be set to &#39;,&#39;.</span>
<span class="sd">            This parameter will be passed into pandas.read_csv or dask.dataframe.read_csv.</span>
<span class="sd">            To learn more details about the usage, check the following links:</span>
<span class="sd">            https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</span>
<span class="sd">            https://docs.dask.org/en/latest/generated/dask.dataframe.read_csv.html</span>
<span class="sd">        :param type_dict: pairs of each attribute and its type, usedd to validate</span>
<span class="sd">        the type of each input item</span>
<span class="sd">        :param header_line: defines the line to be used as the attribute names for</span>
<span class="sd">        columns, if is &lt; 0, an attribute_names is required. Please note that if an</span>
<span class="sd">        attribute_names is provided, the attributes defined in header_line will</span>
<span class="sd">        always be override.</span>
<span class="sd">        :param attribute_names: This argument must be either a list of (unique)</span>
<span class="sd">        string names to define the attribute name tags for each column of the</span>
<span class="sd">        input table.   The length of the array must match the number of</span>
<span class="sd">        columns in the input table or this function will throw a MsPASSError</span>
<span class="sd">        exception.   This argument is None by default which means the</span>
<span class="sd">        function will assume the line specified by the &quot;header_line&quot; argument as</span>
<span class="sd">        column headers defining the attribute name.  If header_line is less</span>
<span class="sd">        than 0 this argument will be required.  When header_line is &gt;= 0</span>
<span class="sd">        and this argument (attribute_names) is defined all the names in</span>
<span class="sd">        this list will override those stored in the file at the specified</span>
<span class="sd">        line number.</span>
<span class="sd">        :param  rename_attributes:   This is expected to be a python dict</span>
<span class="sd">        keyed by names matching those defined in the file or attribute_names</span>
<span class="sd">        array (i.e. the panda/dataframe column index names) and values defining</span>
<span class="sd">        strings to use to override the original names.   That usage, of course,</span>
<span class="sd">        is most common to override names in a file.  If you want to change all</span>
<span class="sd">        the name use a custom attributes_name array as noted above.  This</span>
<span class="sd">        argument is mostly to rename a small number of anomalous names.</span>
<span class="sd">        :param attributes_to_use:  If used this argument must define a list of</span>
<span class="sd">        attribute names that define the subset of the dataframe dataframe</span>
<span class="sd">        attributes that are to be saved.  For relational db users this is</span>
<span class="sd">        effectively a &quot;select&quot; list of attribute names.  The default is</span>
<span class="sd">        None which is taken to mean no selection is to be done.</span>
<span class="sd">        :param one_to_one: is an important boolean use to control if the</span>
<span class="sd">        output is or is not filtered by rows.  The default is True</span>
<span class="sd">        which means every tuple in the input file will create a single row in</span>
<span class="sd">        dataframe. (Useful, for example, to construct an wf_miniseed</span>
<span class="sd">        collection css3.0 attributes.)  If False the (normally reduced) set</span>
<span class="sd">        of attributes defined by attributes_to_use will be filtered with the</span>
<span class="sd">        panda/dask dataframe drop_duplicates method.  That approach</span>
<span class="sd">        is important, for example, to filter things like Antelope &quot;site&quot; or</span>
<span class="sd">        &quot;sitechan&quot; attributes created by a join to something like wfdisc and</span>
<span class="sd">        saved as a text file to be processed by this function.</span>
<span class="sd">        :param parallel:  When true we use the dask dataframe operation.</span>
<span class="sd">        The default is false meaning the simpler, identical api panda</span>
<span class="sd">        operators are used.</span>
<span class="sd">        :param insert_column: a dictionary of new columns to add, and their value(s).</span>
<span class="sd">        If the content is a single value, it can be passedto define a constant value</span>
<span class="sd">        for the entire column of data. The content can also be a list, in that case,</span>
<span class="sd">        the list should contain values that are to be set, and it must be the same</span>
<span class="sd">        length as the number of tuples in the table.</span>
<span class="sd">        :return:  Integer count of number of documents added to collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">Textfile2Dataframe</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span>
            <span class="n">type_dict</span><span class="o">=</span><span class="n">type_dict</span><span class="p">,</span>
            <span class="n">header_line</span><span class="o">=</span><span class="n">header_line</span><span class="p">,</span>
            <span class="n">attribute_names</span><span class="o">=</span><span class="n">attribute_names</span><span class="p">,</span>
            <span class="n">rename_attributes</span><span class="o">=</span><span class="n">rename_attributes</span><span class="p">,</span>
            <span class="n">attributes_to_use</span><span class="o">=</span><span class="n">attributes_to_use</span><span class="p">,</span>
            <span class="n">one_to_one</span><span class="o">=</span><span class="n">one_to_one</span><span class="p">,</span>
            <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="n">insert_column</span><span class="o">=</span><span class="n">insert_column</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
            <span class="n">null_values</span><span class="o">=</span><span class="n">null_values</span><span class="p">,</span>
            <span class="n">one_to_one</span><span class="o">=</span><span class="n">one_to_one</span><span class="p">,</span>
            <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_kill_zero_length_live</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a small helper function used by _save_sample_data to</span>
<span class="sd">        handle the wrong but speecial case of a datum marked live but</span>
<span class="sd">        with a zero length data vector.   It kills any such datum</span>
<span class="sd">        and posts a standard error message. For ensembles the entire</span>
<span class="sd">        ensemble is scanned for data with such errors.   Note this</span>
<span class="sd">        function is a necesary evil as save_data will abort in this situation</span>
<span class="sd">        if the data are not passed through this filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Nothing to save for this datum.  Datum was marked live but the sample data is zero length</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Nothing saved.  Killing this datum so it will be saved in cemetery&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;_save_sample_data&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensembles only land here - internal use assures that but</span>
            <span class="c1"># external use would require more caution</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">npts</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                        <span class="s2">&quot;_save_sample_data&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">mspass_object</span>

    <span class="k">def</span> <span class="nf">_save_sample_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;gridfs&quot;</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save sample data arrays for any MsPASS data objects.</span>

<span class="sd">        The sample data in a seismic data object is normally dominates</span>
<span class="sd">        the size of the container.  This function standardizes saving the</span>
<span class="sd">        sample data with a single method.   Behavior is dependent upon</span>
<span class="sd">        parameters passed in a fairly complex way.   The behavor is best</span>
<span class="sd">        understood as a hierarchy summarized as follows:</span>

<span class="sd">        1)  The top level switch is the data type.  Atomic types</span>
<span class="sd">        (TimeSeries and Seismogram) are handled differently from ensembles.</span>
<span class="sd">        The main distinction is atomic saves always involve some version of</span>
<span class="sd">        open, write, and close where open and close may be a file handle or</span>
<span class="sd">        a network connection.  Ensembles are normally written to a single</span>
<span class="sd">        file, but there are options to dismember the ensemble into multiple</span>
<span class="sd">        files driven by the &quot;dir&quot; and &quot;dfile&quot; attributes of the members.</span>
<span class="sd">        See description below of &quot;use_member_dfile_value&quot; parameter.</span>

<span class="sd">        2) The &quot;storage_mode&quot; argument determines what medium will hold the</span>
<span class="sd">        sample data.  Currently accepted values are &quot;file&quot; and &quot;gridfs&quot;</span>
<span class="sd">        but other options may be added in the near future to support cloud</span>
<span class="sd">        computing.</span>

<span class="sd">        3) The &quot;format&quot; argument can be used to specify an alternative</span>
<span class="sd">        format for the output.  Most formats mix up metadata and sample</span>
<span class="sd">        data so be warned there is a mismatch in concept between this</span>
<span class="sd">        writer and implementations that write most formatted data.</span>

<span class="sd">        The user should be aware of an important issue with ensembles.</span>
<span class="sd">        For atomic data marked dead this function simply returns the dead</span>
<span class="sd">        datum immediately.  Ensembles do the same if the entire ensemble is</span>
<span class="sd">        marked dead, but for efficiency the function ASSUMES that there are</span>
<span class="sd">        no data marked dead within the ensemble.  Callers should guarantee</span>
<span class="sd">        that restriction by using methods in the Undertaker class to</span>
<span class="sd">        remove the dead from the container.</span>

<span class="sd">        :param mspass_object:  data to be saved.</span>
<span class="sd">        :type mspass_object:  must be one of TimeSeries, Seismogram,</span>
<span class="sd">          TimeSeriesEnsemble, or SeismogramEnsemble.  This function does NOT</span>
<span class="sd">          test input type for efficiency.  It also assumes the datum</span>
<span class="sd">          received was not previously marked dead.  dead data need to</span>
<span class="sd">          be handled differently in save.</span>

<span class="sd">        :param storage_mode:   is a string used to define the generic</span>
<span class="sd">          method for storing the sample data.  Currently must be one of</span>
<span class="sd">          two values or the function will throw an exception:</span>
<span class="sd">          (1) &quot;file&quot; causes data to be written to external files.</span>
<span class="sd">          (2) &quot;gridfs&quot; (the default) causes the sample data to be stored</span>
<span class="sd">               within the gridfs file system of MongoDB.</span>
<span class="sd">          See User&#39;s manuals for guidance on storage option tradeoffs.</span>

<span class="sd">        :param dir:  directory file is to be written. Just be writable</span>
<span class="sd">          by user or the function will throw an exception.   Default is None</span>
<span class="sd">          which initaties the following steps: if dir is defined in</span>
<span class="sd">          the object&#39;s Metadata (key &quot;dir&quot;) that string is fetched and</span>
<span class="sd">          used.  If not defined, default to current directory of the process.</span>

<span class="sd">          (Ignored when storage_mode == &quot;gridfs&quot;)</span>
<span class="sd">        :type dir:  string or None</span>

<span class="sd">        :param dfile:  file name to save the sample data for this object.</span>
<span class="sd">         Default is None which initaties the following steps: if dfile</span>
<span class="sd">         is defined in the current object&#39;s Metadata (key &quot;dfile&quot;) the</span>
<span class="sd">         string value retrieved with the dfile key is used as the file</span>
<span class="sd">         name.  If not, a unique name will be generated with a uuid</span>
<span class="sd">         generator.   (Ignored when storage_mode==&quot;gridfs&quot;)</span>
<span class="sd">        :type dfile:  string or None</span>

<span class="sd">        :param format:  optional format name to write data.  See above for</span>
<span class="sd">          limitations and caveats.  Default is None which is aliases to &quot;binary&quot;</span>
<span class="sd">          meaning a fwrite of sample array data. (Ignored when storage_mode == &quot;gridfs&quot;)</span>
<span class="sd">        :type format:  string or None</span>

<span class="sd">        :param overwrite:  If True any file name generated form dir and dfile</span>
<span class="sd">          that already exists will be overwritten.  Default is Fals which means</span>
<span class="sd">          the function alway only appends data recording foff of the start</span>
<span class="sd">          position of the write. (Ignored when storage_mode == &quot;gridfs&quot;)</span>

<span class="sd">        :exception:</span>
<span class="sd">        1) will raise a TypeError if mspass_object is not a mspass seismic</span>
<span class="sd">        data object (atomic or ensmebles).   That shouldnt&#39; normally happen</span>
<span class="sd">        for use within the Database class but Users could experiment with</span>
<span class="sd">        custom writers that would use this class method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># when datum is an ensemble the caller should use bring_out_your dead</span>
        <span class="c1"># before calling this method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">mspass_object</span><span class="p">,</span>
            <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kill_zero_length_live</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                <span class="c1"># do nothing to any datum marked dead - just return the pointer</span>
                <span class="k">return</span> <span class="n">mspass_object</span>

            <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data_to_file</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="nb">dir</span><span class="p">,</span>
                    <span class="n">dfile</span><span class="p">,</span>
                    <span class="nb">format</span><span class="p">,</span>
                    <span class="n">overwrite</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data_to_gridfs</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="n">overwrite</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;_save_sample_data:  do now know how to handle storage_mode=&quot;</span>
                    <span class="o">+</span> <span class="n">storage_mode</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mspass_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;_save_sample_data:  arg0 must be a MsPASS data object</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Type arg0 passed=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_sample_data_to_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to write sample data to a file.  Default is binary</span>
<span class="sd">        fwrite output of native vector of 8 byte floats (C double).</span>

<span class="sd">        This method puts file-based writing in a single function.   The</span>
<span class="sd">        function handles any of the 4 standard MsPASS seismic data objects</span>
<span class="sd">        BUT makes some big assumptions that caller did some housecleaning</span>
<span class="sd">        before calling this low-level function.   Key assumptions are:</span>
<span class="sd">        1.  For atomic data do NOT call this function if the datum is marked</span>
<span class="sd">            dead.</span>
<span class="sd">        2.  Similarly, ensembles are assumed pre-filtered to remove dead</span>
<span class="sd">            data.  A standard way to do that is with the Undertaker class.</span>
<span class="sd">        3.  If dir and dfile are defined the resulting path must be writable.</span>
<span class="sd">            If it is not the function will throw an exception.</span>
<span class="sd">        4.  If dir and dfile are not defined (left Null default) the</span>
<span class="sd">            function always tries to extract an attribute with the keys of</span>
<span class="sd">            &quot;dir&quot; and &quot;dfile&quot; from the object&#39;s metadata.  Note that for</span>
<span class="sd">            ensembles that means it will try to pull these from the ensemble</span>
<span class="sd">            metadata NOT that in any &quot;member&quot;.  For all data if dir is not define</span>
<span class="sd">            it default to the current directory.  If dfile is not define a</span>
<span class="sd">            unique file name is generated from a uuid generator.</span>
<span class="sd">        5.  ensembles should normally be preceded by a call to sync_ensemble_metadata</span>
<span class="sd">            to push ensemble metadata entries to all members.</span>

<span class="sd">        Be aware normal behavior of this function is to not destroy any</span>
<span class="sd">        data in existing files.  By default, if a file already exists the</span>
<span class="sd">        sample data related to the current call is appended to the file.</span>
<span class="sd">        Set the overwrite argument True to change that behavior.</span>

<span class="sd">        Also be aware ensembles are ALWAYS written so all the sample data</span>
<span class="sd">        from the ensemble are in the same file.   Readers can extract an</span>
<span class="sd">        individual member later by using the foff attribute and npts</span>
<span class="sd">        and/or nbytes to know what section of the file is be to be read.</span>

<span class="sd">        The functions supports a format option.  By default data are written</span>
<span class="sd">        with the low-level C function fwrite dumping the internal array contents</span>
<span class="sd">        that hold the sample data.  That is always the fastest way to save</span>
<span class="sd">        the sample data.  When the format variable is set the name string</span>
<span class="sd">        for the format is passed directly to obspy&#39;s generic file writer</span>
<span class="sd">        for formatted data.   Be warned that approach may not make sense for</span>
<span class="sd">        all data types and all formats.  For example, SAC output only makes</span>
<span class="sd">        sense at the atomic level so writing an ensemble in SAC format produces</span>
<span class="sd">        output that is not directly readable by SAC but the file must be</span>
<span class="sd">        dismembered into pieces in an export.   That is feasible because the</span>
<span class="sd">        we store an &quot;nbytes&quot; attribute in the returned object&#39;s</span>
<span class="sd">        member Metadata containers.</span>

<span class="sd">        This function always opens a file and closes it on exit.  Each call</span>
<span class="sd">        to the function this always has the overhead of one open, one call</span>
<span class="sd">        to seek, and one to close.</span>

<span class="sd">        The function should always be called before saving the Metadata.</span>
<span class="sd">        The reason is all the information about where it saves data are</span>
<span class="sd">        returned as Metadata attributes.  For atomic data it is in the</span>
<span class="sd">        return of the data.  For ensembles each member&#39;s Metadata contain</span>
<span class="sd">        the required attributes needed to reconstruct the object.</span>

<span class="sd">        :param mspass_object:  data to be saved.</span>
<span class="sd">        :type mspass_object:  must be one of TimeSeries, Seismogram,</span>
<span class="sd">          TimeSeriesEnsemble, or SeismogramEnsemble.  This function does NOT</span>
<span class="sd">          test input type for efficiency.  It also assumes the datum</span>
<span class="sd">          received was not previously marked dead.  dead data need to</span>
<span class="sd">          be handled differently in save.</span>

<span class="sd">        :param dir:  directory file is to be written. Just be writable</span>
<span class="sd">          by user or the function will throw an exception.   Default is None</span>
<span class="sd">          which initaties the following steps: if dir is defined in</span>
<span class="sd">          the object&#39;s Metadata (key &quot;dir&quot;) that string is fetched and</span>
<span class="sd">          used.  If not defined, default to current directory of the process.</span>
<span class="sd">        :type dir:  string or None</span>

<span class="sd">        :param dfile:  file name to save the sample data for this object.</span>
<span class="sd">          Default is None which initaties the following steps: if dfile</span>
<span class="sd">         is defined in the current object&#39;s Metadata (key &quot;dfile&quot;) the</span>
<span class="sd">         string value retrieved with the dfile key is used as the file</span>
<span class="sd">         name.  If not, a unique name will be generated with a uuid</span>
<span class="sd">         generator</span>
<span class="sd">        :type dfile:  string or None</span>

<span class="sd">        :param format:  optional format name to write data.  See above for</span>
<span class="sd">          limitations and caveats.  Default is None which is aliases to &quot;binary&quot;</span>
<span class="sd">          meaning a fwrite of sample array data.</span>
<span class="sd">        :type format:  string or None</span>

<span class="sd">        :param overwrite:  If True any file name generated form dir and dfile</span>
<span class="sd">          that already exists will be overwritten.  Default is Fals which means</span>
<span class="sd">          the function alway only appends data recording foff of the start</span>
<span class="sd">          position of the write.  WARNING:  default is False and setting</span>
<span class="sd">          it True should only be done if you are sure what you are doing.</span>
<span class="sd">          Be especially aware that with this option you can clobber files</span>
<span class="sd">          needec by other docs to reconstruct data.</span>

<span class="sd">        :return:  copy of the input with Metadata modified to contain all</span>
<span class="sd">        data required to reconstruct the object from the stored sample data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return immediately if the datum is marked dead</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">mspass_object</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;binary&quot;</span>

        <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">):</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span>
                <span class="c1"># convert to fullpath if necessary</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>

        <span class="c1"># note not else here as it means accept dfile value passed by arg</span>
        <span class="k">if</span> <span class="n">dfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;dfile&quot;</span><span class="p">):</span>
                <span class="n">dfile</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dfile_uuid</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span>
                    <span class="s2">&quot;Database._save_sample_data_file:  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;requested directory for saving data </span><span class="si">{}</span><span class="s2"> exists but is write protected (ownership?)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">dir</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try to create dir if it doesn&#39;t exist</span>
            <span class="n">newdir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="n">newdir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span>
                    <span class="s2">&quot;Database._save_sample_data_file:  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;File </span><span class="si">{}</span><span class="s2"> exists but is write protected (ownership?)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># dir and dfile are now always set if we get here.  Now</span>
        <span class="c1"># we write the sample data - different blocks for atomic data</span>
        <span class="c1"># and ensembles</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="c1"># With current logic test for None is unnecessary but</span>
            <span class="c1"># better preserved for miniscule cost</span>
            <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;binary&quot;</span><span class="p">:</span>
                <span class="c1"># Note file locks aren&#39;t needed for binary writes</span>
                <span class="c1"># because C implementation uses fwrite that is known</span>
                <span class="c1"># to be thread save (automatic locking unless forced off)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">foff</span> <span class="o">=</span> <span class="n">_fwrite_to_file</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="c1"># Use a dead datum to flag failure - caller must never</span>
                    <span class="c1"># call this method with a datum already marked dead</span>
                    <span class="k">return</span> <span class="n">mspass_object</span>
                <span class="c1"># we can compute the number of bytes written for this case</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="n">nbytes_written</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This can only be a Seismogram currently so this is not elif</span>
                    <span class="n">nbytes_written</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a+b&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                    <span class="c1"># this applies a unix lock - only works in linux</span>
                    <span class="c1"># note logic here assumes fcntl behavior that the</span>
                    <span class="c1"># lock is relesed when the file is closed</span>
                    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_EX</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">foff</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">foff</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">f_byte</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">toTrace</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">toStream</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                        <span class="c1"># DEBUG simplication of above</span>
                        <span class="c1"># strm = mspass_object.toStream()</span>
                        <span class="c1"># strm.write(f_byte,format=format)</span>
                    <span class="c1"># We now have to actually dump the buffer of f_byte</span>
                    <span class="c1"># to the file.  Is incantation does that</span>
                    <span class="n">f_byte</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="n">f_byte</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                    <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
                    <span class="n">nbytes_written</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nbytes_written</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;formatted write failure.  Number of bytes written=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">nbytes_written</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Killing this datum during save will cause it to be buried in the cemetery&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;_save_sample_data_to_file&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                        <span class="p">)</span>

            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dir</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">foff</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbytes_written</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">format</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="c1"># this method assumes input is clean with no dead dead</span>
            <span class="c1"># againt format is None is not needed but preserved</span>
            <span class="c1"># note as for atomic data locking is not needed because</span>
            <span class="c1"># the function here is written in C and uses fwrite</span>
            <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;binary&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># this works because pytbin11 support overloading</span>
                    <span class="n">foff_list</span> <span class="o">=</span> <span class="n">_fwrite_to_file</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="c1"># Use a dead datum to flag failure.</span>
                    <span class="c1"># An ensemble marked dead on input won&#39;t get here</span>
                    <span class="c1"># but we aim here to make the output in the same</span>
                    <span class="c1"># state when this error handler is involked.</span>
                    <span class="k">return</span> <span class="n">mspass_object</span>
                <span class="c1"># Update metadata for each memkber</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
                    <span class="c1"># Silently skip data marked dead</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                        <span class="c1"># use the strongly typed putters here intentionally</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dfile&quot;</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_long</span><span class="p">(</span><span class="s2">&quot;foff&quot;</span><span class="p">,</span> <span class="n">foff_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;binary&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This probably should have a rejection for some formats</span>
                <span class="c1"># for which the algorithm here is problematic.  SAC is</span>
                <span class="c1"># the biggest case in point as it it wants one datum per file</span>
                <span class="c1"># which is at odds with the approach here</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a+b&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                    <span class="c1"># this applies a unix lock - only works in linux</span>
                    <span class="c1"># note logic here assumes fcntl behavior that the</span>
                    <span class="c1"># lock is relesed when the file is closed</span>
                    <span class="n">fcntl</span><span class="o">.</span><span class="n">flock</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">LOCK_EX</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">foff</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">foff</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">f_byte</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
                        <span class="c1"># silently skip any dead members</span>
                        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                            <span class="k">continue</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">toTrace</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">toStream</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                        <span class="c1"># same incantation as above to actually write the buffer</span>
                        <span class="n">f_byte</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">ub</span> <span class="o">=</span> <span class="n">f_byte</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
                        <span class="n">nbytes_written</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">nbytes_written</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;formatted write failure.  Number of bytes written=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nbytes_written</span>
                            <span class="p">)</span>
                            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Killing this datum during save will cause it to be buried in the cemetery&quot;</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="s2">&quot;_save_sample_data_to_file&quot;</span><span class="p">,</span>
                                <span class="n">message</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;dfile&quot;</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">,</span> <span class="s2">&quot;file&quot;</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_long</span><span class="p">(</span><span class="s2">&quot;foff&quot;</span><span class="p">,</span> <span class="n">foff</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_string</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_long</span><span class="p">(</span><span class="s2">&quot;nbytes&quot;</span><span class="p">,</span> <span class="n">nbytes_written</span><span class="p">)</span>
                        <span class="c1"># make sure we are at the end of file</span>
                        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">foff</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mspass_object</span>

    <span class="k">def</span> <span class="nf">_save_sample_data_to_gridfs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the sample data array for a mspass seismic data object using</span>
<span class="sd">        the gridfs file system.   For an ensemble all members are stored</span>
<span class="sd">        with independent gridids saved in the members returned.</span>

<span class="sd">        This function shares an assumptionw with the _save_sample_data_to_file</span>
<span class="sd">        that no dead data will be passed through the function.  We do that</span>
<span class="sd">        for efficiency as this is a private method that should normally be</span>
<span class="sd">        used only by the main save_data method.</span>

<span class="sd">        :param mspass_object:  is a seismic data object to be saved.  Reiterate</span>
<span class="sd">        it must not be marked dead and for ensembles no members should be</span>
<span class="sd">        marked dead.  If they are you will, at best, save useless junk.</span>
<span class="sd">        Results are better called unpredictable as the state of dead data is</span>
<span class="sd">        undefined and could only be a default constructed object.</span>

<span class="sd">        :type mspass_object:  one of TimeSeries, Seismogram,</span>
<span class="sd">        TimeSeriesEnsemble, or Seismogram Ensemble.</span>

<span class="sd">        :param overwrite:  When set True if there is an existing datum</span>
<span class="sd">        with a matching id for the attribute &quot;gridfs_id&quot;, the existing datum</span>
<span class="sd">        will be deleted before the new data is saved.  When False a new</span>
<span class="sd">        set of documents will be created to hold the data in the gridfs</span>
<span class="sd">        system.  Default is False.</span>

<span class="sd">        :return: edited version of input (mspass_object).  Return changed</span>
<span class="sd">          only by adding metadata attributes &quot;storage_mode&quot; and &quot;gridfs_id&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">mspass_object</span>
        <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">):</span>
                <span class="n">gridfs_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gridfs_id</span><span class="p">):</span>
                    <span class="n">gfsh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">gridfs_id</span><span class="p">)</span>
            <span class="c1"># verdion 2 had a transpose here that seemed unncessary</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="n">gridfs_id</span> <span class="o">=</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridfs_id</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_save_sample_data_to_gridfs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;_save_sample_data_to_gridfs:  arg0 must be a MsPASS data object</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Data type received=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mspass_object</span>

    <span class="k">def</span> <span class="nf">_atomic_save_all_documents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">save_schema</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">,</span>
        <span class="n">wf_collection</span><span class="p">,</span>
        <span class="n">save_history</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="p">,</span>
        <span class="n">normalizing_collections</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does all the MongoDB operations needed to save an atomic</span>
<span class="sd">        MsPASS data object.   That means the wf document,</span>
<span class="sd">        elog entries if defined, and history data if defined and requested.</span>

<span class="sd">        This is a private method that exists only to eliminate redundant</span>
<span class="sd">        code in the top-level save_data method.   Ensembles are handled</span>
<span class="sd">        by a loop over atomic data members calling this function for</span>
<span class="sd">        each member.   Because it is for only internal use the</span>
<span class="sd">        argument list is fixed (in other words no kwargs).   See</span>
<span class="sd">        save_data for what the arguments mean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="n">insertion_dict</span><span class="p">,</span> <span class="n">aok</span><span class="p">,</span> <span class="n">elog</span> <span class="o">=</span> <span class="n">md2doc</span><span class="p">(</span>
            <span class="n">mspass_object</span><span class="p">,</span>
            <span class="n">save_schema</span><span class="p">,</span>
            <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">normalizing_collections</span><span class="o">=</span><span class="n">normalizing_collections</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># exclude_keys edits insertion_dict but we need to do the same to mspass_object</span>
        <span class="c1"># to assure whem data is returned it is identical to what would</span>
        <span class="c1"># come from reading it back</span>
        <span class="k">if</span> <span class="n">exclude_keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
                <span class="c1"># erase is harmless if k is not defined so we don&#39;t</span>
                <span class="c1"># guard this with an is_defined conditional</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span> <span class="o">+=</span> <span class="n">elog</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aok</span><span class="p">:</span>
            <span class="c1"># aok false currently means the result is invalid and should be killed</span>
            <span class="c1"># currently means schema enforcement errors.</span>
            <span class="c1"># Warning:  this can lead to sample data save orphans</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

        <span class="c1"># Always set starttime and endtime</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_keys</span> <span class="ow">or</span> <span class="s2">&quot;starttime&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_keys</span> <span class="ow">or</span> <span class="s2">&quot;endtime&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>

        <span class="c1"># add tag - intentionally not set in mspass_object returned</span>
        <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_tag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We need to clear data tag if was previously defined in</span>
            <span class="c1"># this case or a the old tag will be saved with this datum</span>
            <span class="k">if</span> <span class="s2">&quot;data_tag&quot;</span> <span class="ow">in</span> <span class="n">insertion_dict</span><span class="p">:</span>
                <span class="n">insertion_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;data_tag&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">storage_mode</span><span class="p">:</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># gridfs default</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
        <span class="c1"># We depend on Undertaker to save history for dead data</span>
        <span class="k">if</span> <span class="n">save_history</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="p">)</span>
            <span class="n">history_object_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># is_empty is a method of ProcessingHistory - mame is generic so possibly confusing</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="c1"># Use this trick in update_metadata too. None is needed to</span>
                <span class="c1"># avoid a TypeError exception if the name is not defined.</span>
                <span class="c1"># could do this with a conditional as an alternative</span>
                <span class="n">insertion_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">history_obj_id_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># optional history save - only done if history container is not empty</span>
                <span class="c1"># first we need to push the definition of this algorithm</span>
                <span class="c1"># to the chain.  Note it is always defined by the special</span>
                <span class="c1"># save defined with the C++ enum class mapped to python</span>
                <span class="c1"># vi ProcessingStatus</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">TIMESERIES</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">SEISMOGRAM</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">new_map</span><span class="p">(</span>
                    <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">,</span> <span class="n">atomic_type</span><span class="p">,</span> <span class="n">ProcessingStatus</span><span class="o">.</span><span class="n">SAVED</span>
                <span class="p">)</span>
                <span class="n">history_object_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">)</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>
        <span class="c1"># save elogs if the size of elog is greater than 0</span>
        <span class="n">elog_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="c1"># elog ids will be updated in the wf col when saving metadata</span>
            <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">)</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>

        <span class="c1"># finally ready to insert the wf doc - keep the id as we&#39;ll need</span>
        <span class="c1"># it for tagging any elog entries.</span>
        <span class="c1"># Note we don&#39;t save if something above killed mspass_object.</span>
        <span class="c1"># currently that only happens with errors in md2doc, but if there</span>
        <span class="c1"># are changes use the kill mechanism</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">wfid</span> <span class="o">=</span> <span class="n">wf_collection</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">insertion_dict</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>

            <span class="c1"># Put wfid into the object&#39;s meta as the new definition of</span>
            <span class="c1"># the parent of this waveform</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wfid</span>
            <span class="k">if</span> <span class="n">save_history</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="c1"># When history is enable we need to do an update to put the</span>
                <span class="c1"># wf collection id as a cross-reference.    Any value stored</span>
                <span class="c1"># above with saave_history may be incorrect.  We use a</span>
                <span class="c1"># stock test with the is_empty method for know if history data is present</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                    <span class="n">history_object_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                    <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">history_object_id</span><span class="p">}</span>
                    <span class="n">update_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">wfid</span><span class="p">}</span>
                    <span class="n">history_object_col</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_dict</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">bury</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">save_history</span><span class="o">=</span><span class="n">save_history</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mspass_object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_download_windowed_mseed_file</span><span class="p">(</span>
        <span class="n">aws_access_key_id</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">station</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">channel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">t0shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function to download the miniseed file from AWS s3.</span>
<span class="sd">        A lambda function will be called, and do the timewindowing on cloud. The output file</span>
<span class="sd">        of timewindow will then be downloaded and parsed by obspy.</span>
<span class="sd">        Finally return an obspy stream object.</span>
<span class="sd">        An example of using lambda is in /scripts/aws_lambda_examples.</span>

<span class="sd">        :param aws_access_key_id &amp; aws_secret_access_key: credential for aws, used to initialize lambda_client</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param network:  network code</span>
<span class="sd">        :param station:  station code</span>
<span class="sd">        :param channel:  channel code</span>
<span class="sd">        :param location:  location code</span>
<span class="sd">        :param duration:  window duration, default value is -1, which means no window will be performed</span>
<span class="sd">        :param t0shift: shift the start time, default is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
            <span class="n">service_name</span><span class="o">=</span><span class="s2">&quot;lambda&quot;</span><span class="p">,</span>
            <span class="n">region_name</span><span class="o">=</span><span class="s2">&quot;us-west-2&quot;</span><span class="p">,</span>
            <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
            <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">s3_input_bucket</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">s3_output_bucket</span> <span class="o">=</span> <span class="s2">&quot;mspass-scedcdata&quot;</span>  <span class="c1">#   The output file can be saved to this bucket, user might want to change it into their own bucket</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">source_key</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">source_key</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="n">event</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;src_bucket&quot;</span><span class="p">:</span> <span class="n">s3_input_bucket</span><span class="p">,</span>
            <span class="s2">&quot;dst_bucket&quot;</span><span class="p">:</span> <span class="n">s3_output_bucket</span><span class="p">,</span>
            <span class="s2">&quot;src_key&quot;</span><span class="p">:</span> <span class="n">source_key</span><span class="p">,</span>
            <span class="s2">&quot;dst_key&quot;</span><span class="p">:</span> <span class="n">source_key</span><span class="p">,</span>
            <span class="s2">&quot;save_to_s3&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s2">&quot;t0shift&quot;</span><span class="p">:</span> <span class="n">t0shift</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">lambda_client</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span>
            <span class="n">FunctionName</span><span class="o">=</span><span class="s2">&quot;TimeWindowFunction&quot;</span><span class="p">,</span>  <span class="c1">#   The name of lambda function on cloud</span>
            <span class="n">InvocationType</span><span class="o">=</span><span class="s2">&quot;RequestResponse&quot;</span><span class="p">,</span>
            <span class="n">LogType</span><span class="o">=</span><span class="s2">&quot;Tail&quot;</span><span class="p">,</span>
            <span class="n">Payload</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">event</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">response_payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Payload&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_type&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ret_type</span> <span class="o">==</span> <span class="s2">&quot;key&quot;</span>
        <span class="p">):</span>  <span class="c1"># If the ret_type is &quot;key&quot;, the output file is stored in another s3 bucket,</span>
            <span class="c1"># we have to fetch it again.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret_bucket</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ret_key</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
                    <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
                    <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                    <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">ret_bucket</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">ret_key</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
                <span class="k">return</span> <span class="n">st</span>

            <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                    <span class="c1"># the object does not exist</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret_key</span><span class="p">,</span> <span class="n">ret_bucket</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;Error while downloading the output object.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="n">filecontent</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="n">stringio_obj</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">filecontent</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">stringio_obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">st</span>

<div class="viewcode-block" id="Database.index_mseed_s3_continuous"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_s3_continuous">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_s3_continuous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s3_client</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">station</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">channel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;s3_continuous&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data. However, instead of scanning a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument, it reads the miniseed content from AWS s3.</span>
<span class="sd">        It builds and index it writes to mongodb in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default). The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>

<span class="sd">        :param s3_client:  s3 Client object given by user, which contains credentials</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param network:  network code</span>
<span class="sd">        :param station:  station code</span>
<span class="sd">        :param channel:  channel code</span>
<span class="sd">        :param location:  location code</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">            index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">            to use anything but the default.</span>
<span class="sd">        :exception: This function will do nothing if the obejct does not exist. For other</span>
<span class="sd">            exceptions, it would raise a MsPASSError.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">KEY</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">stringio_obj</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">stringio_obj</span><span class="p">)</span>
            <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

            <span class="n">stats</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;location&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]:</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="k">if</span> <span class="s2">&quot;npts&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]:</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
            <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;An ClientError occur when tyring to get the object by the KEY(&quot;</span>
                    <span class="o">+</span> <span class="n">KEY</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; with error: &quot;</span><span class="p">,</span>
                    <span class="n">e</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while index mseed file from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="Database.index_mseed_s3_event"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_s3_event">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_s3_event</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s3_client</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data. However, instead of scanning a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument, it reads the miniseed content from AWS s3.</span>
<span class="sd">        It builds and index it writes to mongodb in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default). The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>

<span class="sd">        :param s3_client:  s3 Client object given by user, which contains credentials</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param filename:  SCSN catalog event id for the event</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">            index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">            to use anything but the default.</span>
<span class="sd">        :exception: This function will do nothing if the obejct does not exist. For other</span>
<span class="sd">            exceptions, it would raise a MsPASSError.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;event_waveforms/&quot;</span>
            <span class="o">+</span> <span class="n">year</span>
            <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="o">+</span> <span class="n">year</span>
            <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="o">+</span> <span class="n">day_of_year</span>
            <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="o">+</span> <span class="n">filename</span>
            <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c1"># specify the file path</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dfile_uuid</span><span class="p">(</span><span class="s2">&quot;mseed&quot;</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
            <span class="c1"># temporarily write data into a file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>
            <span class="c1"># immediately read data from the file</span>
            <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">elog</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mseed_file_indexer</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_mseed_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;s3_event&quot;</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odir</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
                <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;An ClientError occur when tyring to get the object by the KEY(&quot;</span>
                    <span class="o">+</span> <span class="n">KEY</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; with error: &quot;</span><span class="p">,</span>
                    <span class="n">e</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while index mseed file from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="Database.index_mseed_FDSN"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_FDSN">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_FDSN</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">provider</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="p">,</span>
        <span class="n">station</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">provider</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span><span class="p">,</span> <span class="n">iso8601</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span>
            <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>
        <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
        <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;provider&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">provider</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">network</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">if</span> <span class="s2">&quot;npts&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]:</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fdsn&quot;</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
        <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_dfile_uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper function to generate a uuid for the file name,</span>
<span class="sd">        when dfile is not given or defined. The format can be &#39;mseed&#39; or</span>
<span class="sd">        other formats.  If None treat format as &quot;native_double&quot;</span>
<span class="sd">        The return value is random uuid + &quot;-&quot; + format, example:</span>
<span class="sd">        &#39;247ce5d7-06bc-4ccc-8084-5b3ff621d2d4-mseed&#39;</span>

<span class="sd">        :param format: format of the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;native_double&quot;</span>
        <span class="n">temp_uuid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="n">dfile</span> <span class="o">=</span> <span class="n">temp_uuid</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">format</span>
        <span class="k">return</span> <span class="n">dfile</span>

    <span class="k">def</span> <span class="nf">_construct_atomic_object</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">md</span><span class="p">,</span>
        <span class="n">object_type</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;Database._construct_atomic_object&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Note a CRITICAL feature of the Metadata constructors</span>
            <span class="c1"># for both of these objects is that they allocate the</span>
            <span class="c1"># buffer for the sample data and initialize it to zero.</span>
            <span class="c1"># This allows sample data readers to load the buffer without</span>
            <span class="c1"># having to handle memory management.</span>
            <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># api mismatch here.  This ccore Seismogram constructor</span>
                <span class="c1"># had an ancestor that had an option to read data here.</span>
                <span class="c1"># we never do that here</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
            <span class="c1"># if the constructor fails mspass_object will be invalid</span>
            <span class="c1"># To preserve the error we have to create a shell to hold the error</span>
            <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">()</span>
            <span class="c1"># Default constructors leaves result marked dead so below should work</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mspass_object</span>

        <span class="k">if</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">):</span>
            <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># hard code this default</span>
            <span class="n">storage_mode</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>

        <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">):</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Reader uses this as a signal to use raw binary fread C function</span>
                <span class="n">form</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># TODO:  really should check for all required md values and</span>
            <span class="c1"># do a kill with an elog message instead of depending on this to abort</span>
            <span class="k">if</span> <span class="n">form</span> <span class="ow">and</span> <span class="n">form</span> <span class="o">!=</span> <span class="s2">&quot;binary&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;nbytes&quot;</span><span class="p">):</span>
                    <span class="n">nbytes_expected</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nbytes_expected</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Formatted reader received size attribute nbytes=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">nbytes_expected</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Null file caused this datum to be killed&quot;</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">func</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                        <span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_dfile</span><span class="p">(</span>
                            <span class="n">mspass_object</span><span class="p">,</span>
                            <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">],</span>
                            <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">],</span>
                            <span class="n">md</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">],</span>
                            <span class="n">nbytes</span><span class="o">=</span><span class="n">nbytes_expected</span><span class="p">,</span>
                            <span class="nb">format</span><span class="o">=</span><span class="n">form</span><span class="p">,</span>
                            <span class="n">merge_method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                            <span class="n">merge_fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                            <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Missing required argument nbytes for formatted read&quot;</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Cannot construct this datum&quot;</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_dfile</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">],</span>
                    <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">],</span>
                    <span class="n">md</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">],</span>
                    <span class="n">merge_method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                    <span class="n">merge_fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                    <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_gridfs</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_url</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span>
                <span class="n">md</span><span class="p">[</span><span class="s2">&quot;url&quot;</span><span class="p">],</span>
                <span class="nb">format</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">md</span> <span class="k">else</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;s3_continuous&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_s3_continuous</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="p">,</span> <span class="n">aws_secret_access_key</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;s3_lambda&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_s3_lambda</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="p">,</span> <span class="n">aws_secret_access_key</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;fdsn&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_fdsn</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Earlier verision raised a TypeError with the line below</span>
            <span class="c1"># Changed after V2 to kill and lot as an error - will be an abortion</span>
            <span class="c1"># raise TypeError(&quot;Unknown storage mode: {}&quot;.format(storage_mode))</span>
            <span class="c1"># note logic above assures storage_mode is not a None</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal storage mode=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_mode</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">clear_modified</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;is_abortion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">mspass_object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_group_mdlist</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to separate the documents in mdlist into groups</span>
<span class="sd">        that simplify reading of ensembles.</span>

<span class="sd">        We allow ensembles o be created from data retrieved and constucted</span>
<span class="sd">        by mulitple methods.    Currently that is defined by three concepts</span>
<span class="sd">        we have to separate:</span>
<span class="sd">            1.  The &quot;storage_mode&quot; passed to readers defines the generic</span>
<span class="sd">                way data are stored.  The list of storage_mode options</span>
<span class="sd">                is fairly long.  The point is that different storage modes</span>
<span class="sd">                require fundamentally different read strategies.  e.g. reading</span>
<span class="sd">                from s3 is not remotely at all like reading from gridfs</span>
<span class="sd">                but both can yield valid data objects.</span>
<span class="sd">            2.  A &quot;format&quot; can be used to define a format conversion that</span>
<span class="sd">                needs to be preformed on the fly to convert the data to</span>
<span class="sd">                mspass atomic data object.</span>
<span class="sd">            3.  A special case with storage mode == &quot;files is when the</span>
<span class="sd">                data are organized into files already defined for this</span>
<span class="sd">                enemble being read.  A typical example would be data already</span>
<span class="sd">                bundled into n ensemble and saved that way with the</span>
<span class="sd">                Database.save_data method in an earlier run.  Ensemble</span>
<span class="sd">                files can be read faster by reducing the need for</span>
<span class="sd">                unnecessary file open/close pairs that are otherwise</span>
<span class="sd">                needed when reading atomic data.</span>

<span class="sd">        This function takes the input list of documents converted to</span>
<span class="sd">        to a list of `mspasspy.ccore.utility.Metadata` objects and sorts</span>
<span class="sd">        the contents into containers that define data that can be</span>
<span class="sd">        read by a common method.   We do that by returning a nested</span>
<span class="sd">        dictionary.  The top level of the dictionary is keyed by</span>
<span class="sd">        the &quot;storage_mode&quot;.   Most inputs are likely to only generate</span>
<span class="sd">        a single key but this approach allows heterogeous input</span>
<span class="sd">        definitions in a database.   Each value then defines a second</span>
<span class="sd">        dictionary with a key defined by the &quot;format&quot; field.   The</span>
<span class="sd">        leaves of the returned tree of Metadata are then lists with</span>
<span class="sd">        common values of &quot;storage_mode&quot; and &quot;format&quot;.</span>

<span class="sd">        Item 3 above is handled by a related private method called</span>
<span class="sd">        `Database._group_by_path`.   It is used in this class to</span>
<span class="sd">        handle ensemble file reading as noted in concept 3 above.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">mdlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;storage_mode&quot;</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># WARNING:  this default needs to stay consistent internally</span>
                <span class="c1"># perhaps should have it in self but isn&#39;t for now</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
            <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># WARNING:  this is also a default that needs to stay</span>
                <span class="c1"># in sync with other places in this class it is used</span>
                <span class="n">form</span> <span class="o">=</span> <span class="s2">&quot;binary&quot;</span>
            <span class="k">if</span> <span class="n">sm</span> <span class="ow">in</span> <span class="n">smdict</span><span class="p">:</span>
                <span class="n">formdict</span> <span class="o">=</span> <span class="n">smdict</span><span class="p">[</span><span class="n">sm</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">formdict</span><span class="p">:</span>
                    <span class="n">vallist</span> <span class="o">=</span> <span class="n">formdict</span><span class="p">[</span><span class="n">form</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vallist</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">vallist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                <span class="n">smdict</span><span class="p">[</span><span class="n">sm</span><span class="p">][</span><span class="n">form</span><span class="p">]</span> <span class="o">=</span> <span class="n">vallist</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we have to create the secondary dict when we land</span>
                <span class="c1"># here because it wouldn&#39;t have been previously allocated</span>
                <span class="n">formdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">formdict</span><span class="p">[</span><span class="n">form</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="p">]</span>
                <span class="n">smdict</span><span class="p">[</span><span class="n">sm</span><span class="p">]</span> <span class="o">=</span> <span class="n">formdict</span>

        <span class="k">return</span> <span class="n">smdict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_group_by_path</span><span class="p">(</span><span class="n">mdlist</span><span class="p">,</span> <span class="n">undefined_key</span><span class="o">=</span><span class="s2">&quot;undefined_filename&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes input list of Metadata containers and groups them</span>
<span class="sd">        by a &quot;path&quot; defined as the string produced by combining</span>
<span class="sd">        the &quot;dir&quot; and &quot;dfile&quot; attribute in a standard way.</span>
<span class="sd">        The return is a python dict keyed by path and values being</span>
<span class="sd">        a list extracted from mdlist of all ehtries defined by the same</span>
<span class="sd">        file.</span>

<span class="sd">        We handle the case of mdlist entries missing &quot;dir&quot; or &quot;dfile&quot; by</span>
<span class="sd">        putting them into a list keyed by the string defined by the</span>
<span class="sd">        &quot;udnefined_key&quot; attribute (see above for default.)   Caller should</span>
<span class="sd">        treat these as abortions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pathdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">mdlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;dir&quot;</span> <span class="ow">in</span> <span class="n">md</span> <span class="ow">and</span> <span class="s2">&quot;dfile&quot;</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pathdict</span><span class="p">:</span>
                    <span class="n">pathdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pathdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">undefined_key</span> <span class="ow">in</span> <span class="n">pathdict</span><span class="p">:</span>
                    <span class="n">pathdict</span><span class="p">[</span><span class="n">undefined_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pathdict</span><span class="p">[</span><span class="n">undefined_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pathdict</span>

    <span class="k">def</span> <span class="nf">_load_ensemble_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdlist</span><span class="p">,</span> <span class="n">object_type</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to efficiently load ensembles stored in a file.</span>

<span class="sd">        When reading a ensemble stored in one or more files it is much</span>
<span class="sd">        faster to open the file containing multiple records and read</span>
<span class="sd">        that file sequentially than using an atomic read for each member</span>
<span class="sd">        that would open, seek, read, and close the file for each member.</span>
<span class="sd">        This method standardizes reading from a single file when</span>
<span class="sd">        the data are stored as raw binary samples (C double floating point).</span>
<span class="sd">        It can be used to construct either a SeismogramEnsemble or</span>
<span class="sd">        TimeSeriesEnsemble driven by an input list of MongoDB</span>
<span class="sd">        documents convert to list of Metadata containers.</span>

<span class="sd">        The algorithm runs fast by using a C++ function bound to python</span>
<span class="sd">        with pybind11 (_fread_from_file).  For that reason this method</span>
<span class="sd">        must ONLY be called for a list with all the data from a single</span>
<span class="sd">        file.   The algorithm is designed for speed so it does not verify</span>
<span class="sd">        that each entry in mdlist has the same dir and dfile as that</span>
<span class="sd">        passed as arguments.   Garbage read or seg faults are nearly</span>
<span class="sd">        guaranteed if that is violated and this method is used outside</span>
<span class="sd">        the normal use as a component of the chain of private methods used</span>
<span class="sd">        by the `Database.read_data` method.  i.e. use this method with</span>
<span class="sd">        extreme caution if used for a different application than</span>
<span class="sd">        internal use for the Database class.</span>

<span class="sd">        The algorithm has to do some fairly weird things to match the</span>
<span class="sd">        API of _fread_from_file and to handle the range of errors</span>
<span class="sd">        that can happen in this composite read operation.   Some points</span>
<span class="sd">        to note for maintenance of this function are:</span>
<span class="sd">            1.  This utilizes the newer concept in MsPASS of abortions.</span>
<span class="sd">                Any error that invalidates a member ends up putting that</span>
<span class="sd">                datum into component[1] of the returned tuple (see below).</span>
<span class="sd">                The result is a clean emsembled return in component 0</span>
<span class="sd">                meaning it has no dead members.</span>
<span class="sd">            2.  For efficiency the algorithm produces a list of</span>
<span class="sd">                member index numbers. By that it means the</span>
<span class="sd">                member[i] has index value i.  What that means is that</span>
<span class="sd">                the array passed to _fread_from_file is a list of i</span>
<span class="sd">                values telling the reader in which member slot the</span>
<span class="sd">                data are to be loaded.   The list is sorted by foff</span>
<span class="sd">                to allow fread to do it&#39;s job efficiently because</span>
<span class="sd">                buffering makes sequential reads with fread about as fast</span>
<span class="sd">                as any io operation possible.  The alternative would</span>
<span class="sd">                have been to have _fread_from_file read in i order</span>
<span class="sd">                (i.e. a normal loop) but that could involve a lot of</span>
<span class="sd">                seeks positions outside the buffer.  Future maintainers</span>
<span class="sd">                are warned of this rather odd algorithm, but note it</span>
<span class="sd">                was done that way for speed.</span>

<span class="sd">        :param mdlist: iterable list of Metadata objects.  These are used</span>
<span class="sd">         to create the ensemble members using a feature of the C++ api that</span>
<span class="sd">         a skeleton of an atomic object can be created form Metadata alone.</span>
<span class="sd">         The sample array is allocated and defined from number of points</span>
<span class="sd">         defined in the Metadata container and that is used by fread to</span>
<span class="sd">         load the sample data when reading.   Needless to say corrupted</span>
<span class="sd">         data for npts or foff are guaranteed trouble.  Other Metadata</span>
<span class="sd">         attributes are copied verbatim to the atomic data. If any</span>
<span class="sd">         constructors using the Metadata fail the error message is posted</span>
<span class="sd">         and these are pushed to the list of abortions.</span>
<span class="sd">        :type mslist:  iterable container of Metadata objects (normally a list)</span>
<span class="sd">        :param object_type: used internally to distinguish TimeSeriesEnsemble</span>
<span class="sd">          and SeismogramEnsemble</span>
<span class="sd">        :param dir: directory name while for file that is to be openned.</span>
<span class="sd">        :param dfile: file name for file that is to be openned and read.</span>

<span class="sd">        :return:  tuple with two components.</span>
<span class="sd">          0 - ensemble that is the result.  It will be marked dead if no</span>
<span class="sd">              members were successfully read</span>
<span class="sd">          1 - a list of members (not an ensemble a python list) of</span>
<span class="sd">              data that failed during construction for one reason or another.</span>
<span class="sd">              We refer to this type of dead data in MsPASS as an abortion</span>
<span class="sd">              as it died before it was born.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because this is private method that should only be used</span>
        <span class="c1"># interally we do no type checking for speed.</span>
        <span class="n">nmembers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">(</span><span class="n">nmembers</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">Seismogram</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">SeismogramEnsemble</span><span class="p">(</span><span class="n">nmembers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._load_enemble_file:  Received illegal value for object_type argument</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Received object_type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">object_type</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be eithre TimeSeriesEnsemble or SeismogramEnsemble&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">abortions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">mdlist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Note a CRITICAL feature of the Metadata constructors</span>
                <span class="c1"># for both of these objects is that they allocate the</span>
                <span class="c1"># buffer for the sample data and initialize it to zero.</span>
                <span class="c1"># This allows sample data readers to load the buffer without</span>
                <span class="c1"># having to handle memory management.</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># api mismatch here.  This ccore Seismogram constructor</span>
                    <span class="c1"># had an ancestor that had an option to read data here.</span>
                    <span class="c1"># we never do that here</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
                <span class="c1"># if the constructor fails mspass_object will be invalid</span>
                <span class="c1"># To preserve the error we have to create a shell to hold the error</span>
                <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">()</span>
                <span class="c1"># Default constructors leaves result marked dead so below should work</span>
                <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
                <span class="c1"># there may be a C++ function to copy Metadata like this</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="c1"># We push bad data to the abortions list.  Caller should</span>
                <span class="c1"># handle them specially.</span>
                <span class="n">abortions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># this constructs a list of pairs (tuples) with foff and npts</span>
        <span class="c1"># values.</span>
        <span class="n">foff_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># convenient alias only here.  Works because in python this just</span>
            <span class="c1"># sets d as a pointer and doesn&#39;t create a copy</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;foff&quot;</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">foff_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># These members will not be handled by the</span>
                <span class="c1"># _fread_from_file C++ function below.  It sets data</span>
                <span class="c1"># live on success.  Because these don&#39;t generate an</span>
                <span class="c1"># entrty in foff_list they will not be handled.</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;This datum was missing required foff attribute.&quot;</span>
                <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Database._load_enemble_file&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>

        <span class="c1"># default for list sort is to use component 0 and sort in ascending</span>
        <span class="c1"># order.  That is waht we want for read efficiency</span>
        <span class="n">foff_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># I think pybind11 maps a list of int values to used as</span>
        <span class="c1"># input to the fread function below requiring an</span>
        <span class="c1"># input of an std::vector&lt;long int&gt; container.  In C++ a vector</span>
        <span class="c1"># and list are different concepts but I think that is what pybind11 does</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">foff_list</span><span class="p">:</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># note _fread_from_file extracs foff from each member using index</span>
        <span class="c1"># to (potentially) skip around in the container</span>
        <span class="c1"># it never throws an exception but can return a negative</span>
        <span class="c1"># number used to signal file open error</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">_fread_from_file</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Open failed on dfile=</span><span class="si">{}</span><span class="s2"> for dir=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dfile</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;Database._load_ensemble_file&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="c1"># Use this Undertaker method to pull out any data killed during</span>
        <span class="c1"># the read.  Add them to the abortions list to create a clean</span>
        <span class="c1"># ensemble to return</span>
        <span class="n">cleaned_ensemble</span><span class="p">,</span> <span class="n">bodies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">bring_out_your_dead</span><span class="p">(</span><span class="n">ensemble</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bodies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">bodies</span><span class="p">:</span>
                <span class="n">abortions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cleaned_ensemble</span><span class="p">,</span> <span class="n">abortions</span>

    <span class="k">def</span> <span class="nf">_construct_ensemble</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mdlist</span><span class="p">,</span>
        <span class="n">object_type</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to create an ensemble from a list of Metadata</span>
<span class="sd">        containers. Like the atomic version but for ensembles.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because this is expected to only be used internally there</span>
        <span class="c1"># is not type checking or arg validation.</span>
        <span class="n">nmembers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">(</span><span class="n">nmembers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">SeismogramEnsemble</span><span class="p">(</span><span class="n">nmembers</span><span class="p">)</span>

        <span class="c1"># first group by storage mode</span>
        <span class="n">smdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_mdlist</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="n">smdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sm</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="c1"># only binary currently works for ensemble files</span>
                <span class="n">file_dict</span> <span class="o">=</span> <span class="n">smdict</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">file_dict</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">form</span> <span class="o">==</span> <span class="s2">&quot;binary&quot;</span><span class="p">:</span>
                        <span class="n">bf_mdlist</span> <span class="o">=</span> <span class="n">file_dict</span><span class="p">[</span><span class="s2">&quot;binary&quot;</span><span class="p">]</span>
                        <span class="c1"># This method, defined above, groups data by</span>
                        <span class="c1"># file name</span>
                        <span class="n">bf_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_by_path</span><span class="p">(</span><span class="n">bf_mdlist</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">bf_dict</span><span class="p">:</span>
                            <span class="n">this_mdl</span> <span class="o">=</span> <span class="n">bf_dict</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_mdl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="c1"># _group_by_path assures all compomnents of this_mdl</span>
                                <span class="c1"># have the same value of dir and file.  Use an iteration to</span>
                                <span class="c1"># assure dir and dfile are present in one of the components</span>
                                <span class="c1"># TODO:  this may have an issue if there are entries marked undefined</span>
                                <span class="c1"># needs a controlled tests.</span>
                                <span class="nb">dir</span> <span class="o">=</span> <span class="s2">&quot;UNDEFINED&quot;</span>
                                <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">this_mdl</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;dir&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;dfile&quot;</span><span class="p">):</span>
                                        <span class="nb">dir</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span>
                                        <span class="n">dfile</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
                                        <span class="k">break</span>
                                <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s2">&quot;UNDEFINED&quot;</span><span class="p">:</span>
                                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database.construct_ensemble:  &quot;</span>
                                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;binary file reader section could not find values for dir and/or dfile&quot;</span>
                                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;This should not happen but was trapped to avoid mysterious errors&quot;</span>
                                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>

                                <span class="n">ens_tmp</span><span class="p">,</span> <span class="n">abortions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_ensemble_file</span><span class="p">(</span>
                                    <span class="n">this_mdl</span><span class="p">,</span> <span class="n">object_type</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span>
                                <span class="p">)</span>

                                <span class="c1"># the above guarantees ens_tmp has no dead dead</span>
                                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ens_tmp</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">abortions</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">handle_abortion</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_mdl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_atomic_object</span><span class="p">(</span>
                                    <span class="n">this_mdl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">object_type</span><span class="p">,</span>
                                    <span class="n">merge_method</span><span class="p">,</span>
                                    <span class="n">merge_fill_value</span><span class="p">,</span>
                                    <span class="n">merge_interpolation_samples</span><span class="p">,</span>
                                    <span class="n">aws_access_key_id</span><span class="p">,</span>
                                    <span class="n">aws_secret_access_key</span><span class="p">,</span>
                                <span class="p">)</span>
                                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">handle_abortion</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Database._construct_ensemble:  &quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Reading binary file section retrieved a zero length&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; list of Metadata associated with path key=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">path</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Bug that shouldn&#39;t happen but was trapped as a safety&quot;</span>
                                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># for all formatted data we currently only use atomic reader</span>
                        <span class="n">this_mdlist</span> <span class="o">=</span> <span class="n">file_dict</span><span class="p">[</span><span class="n">form</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">this_mdlist</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_atomic_object</span><span class="p">(</span>
                                <span class="n">md</span><span class="p">,</span>
                                <span class="n">object_type</span><span class="p">,</span>
                                <span class="n">merge_method</span><span class="p">,</span>
                                <span class="n">merge_fill_value</span><span class="p">,</span>
                                <span class="n">merge_interpolation_samples</span><span class="p">,</span>
                                <span class="n">aws_access_key_id</span><span class="p">,</span>
                                <span class="n">aws_secret_access_key</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                                <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">handle_abortion</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">smdict</span><span class="p">[</span><span class="n">sm</span><span class="p">]:</span>
                    <span class="n">this_mdlist</span> <span class="o">=</span> <span class="n">smdict</span><span class="p">[</span><span class="n">sm</span><span class="p">][</span><span class="n">form</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">this_mdlist</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_atomic_object</span><span class="p">(</span>
                            <span class="n">md</span><span class="p">,</span>
                            <span class="n">object_type</span><span class="p">,</span>
                            <span class="n">merge_method</span><span class="p">,</span>
                            <span class="n">merge_fill_value</span><span class="p">,</span>
                            <span class="n">merge_interpolation_samples</span><span class="p">,</span>
                            <span class="n">aws_access_key_id</span><span class="p">,</span>
                            <span class="n">aws_secret_access_key</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                            <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stedronsky</span><span class="o">.</span><span class="n">handle_abortion</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ensemble</span></div>


<div class="viewcode-block" id="index_mseed_file_parallel"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.index_mseed_file_parallel">[docs]</a><span class="k">def</span> <span class="nf">index_mseed_file_parallel</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parallel wrapper for the index_mseed_file method in the Database class.</span>
<span class="sd">    We use this wrapper to handle the possible error in the original method,</span>
<span class="sd">    where the file dir and name are pointing to a file that doesn&#39;t exist.</span>
<span class="sd">    User could use this wrapper when they want to run the task in parallel,</span>
<span class="sd">    result will then be an RDD/bag of either None or error message strings.</span>
<span class="sd">    User would need to scan the RDD/bag to search for thing not None for errors.</span>

<span class="sd">    :param db: The MsPass core database handle that we want to index into</span>
<span class="sd">    :param arg: All the arguments that users pass into the original</span>
<span class="sd">    index_mseed_file method</span>
<span class="sd">    :return: None or error message string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">db</span><span class="o">.</span><span class="n">index_mseed_file</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">FileNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="md2doc"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.md2doc">[docs]</a><span class="k">def</span> <span class="nf">md2doc</span><span class="p">(</span>
    <span class="n">md</span><span class="p">,</span>
    <span class="n">save_schema</span><span class="p">,</span>
    <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
    <span class="n">normalizing_collections</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{}:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a Metadata container to a python dict applying a schema constraints.</span>

<span class="sd">    This function is used in all database save operations to guaranteed the</span>
<span class="sd">    Metadata container in a mspass data object is consistent with</span>
<span class="sd">    requirements for MongDB defined by a specified schema.   It</span>
<span class="sd">    dogmatically enforces readonly restrictions in the schema by</span>
<span class="sd">    changing the key for any fields marked readonly and found to have</span>
<span class="sd">    been set as changed.  Such entries change to &quot;READONLYERROR_&quot; + k</span>
<span class="sd">    where k is the original key marked readonly.  See user&#39;s manual for</span>
<span class="sd">    a discussion of why this is done.</span>

<span class="sd">    Other schema constraints are controlled by the setting of mode.</span>
<span class="sd">    Mode must be one of &quot;promiscuous&quot;,&quot;cautious&quot;, or &quot;pedantic&quot; or</span>
<span class="sd">    the function will raise a MsPASS error marked fatal.   That is the</span>
<span class="sd">    only exception this function can throw.  It will never happen when</span>
<span class="sd">    used with the Database class method but is possible if a user uses</span>
<span class="sd">    this function in a different implementation.</span>

<span class="sd">    The contents of the data associated with the md argument (arg0) are assumed</span>
<span class="sd">    to have passed through the private database method _sync_metadata_before_update</span>
<span class="sd">    before calling this function.  Anyone usingn this function outside the</span>
<span class="sd">    Database class should assure a comparable algorithm is not required.</span>

<span class="sd">    Note the return is a tuple.  See below for details.</span>

<span class="sd">    :param md: contains a Metadata container that is to be converted.</span>
<span class="sd">    :type md:  For normal use in mspass md is a larger data object that</span>
<span class="sd">      inherits Metadata.  That is, in most uses it is a TimeSeries or</span>
<span class="sd">      Seismogram object.  It can be a raw Metadata container and the</span>
<span class="sd">      algorithm should work</span>
<span class="sd">    :param save_schema:  The Schema class to be used for constraints</span>
<span class="sd">      in building the doc for MongoDB use.  See User&#39;s Manual for details</span>
<span class="sd">      on how a schema is defined and used in MsPASS.</span>
<span class="sd">    :type save_schema:  Schema class</span>
<span class="sd">    :param exclude_keys: list of keys (strings) to be excluded from</span>
<span class="sd">      the output python dict.   Note &quot;_id&quot; is always excluded to mess</span>
<span class="sd">      with required MongoDB usage.  Default is None which means no</span>
<span class="sd">      values are excluded.  Note is harmless to list keys that are not</span>
<span class="sd">      present in md - does nothing except for a minor cost to test for existence.</span>
<span class="sd">    :type exclude_keys: list of strings</span>
<span class="sd">    :param mode: Must be one of &quot;promiscuous&quot;, &quot;caution&quot;, or &quot;pedantic&quot;.</span>
<span class="sd">      See User&#39;s Manual for which to use.  Default is &quot;promiscuous&quot;.</span>
<span class="sd">      The function will throw MsPASSError exception if not one of the three</span>
<span class="sd">      keywords list.</span>
<span class="sd">    :type mode: str</span>

<span class="sd">    :return:  Result is a returned as a tuple appropriate for the</span>
<span class="sd">      normal use of this function inside the Database class.</span>
<span class="sd">      The contents of the tuple are:</span>

<span class="sd">      0 - python dictionary of edited result ready to save as MongoDB document</span>
<span class="sd">      1 - boolean equivalent of the &quot;live&quot; attribute of TimeSeries and Seismogram.</span>
<span class="sd">          i.e. if True the result can be considered valid.  If False something</span>
<span class="sd">          was very wrong with the input and the contents of 0 is invalid and</span>
<span class="sd">          should not be used.  When False the error log in 2 will contain</span>
<span class="sd">          one or more error messages.</span>
<span class="sd">      2 - An ErrorLogger object that may or may not contain any error logging</span>
<span class="sd">          messages.  Callers should call the size method of the this entry</span>
<span class="sd">          and handle the list of error messages it contains if size is not zero.</span>
<span class="sd">          Note the right way to do that for TimeSeries and Seismogram is to</span>
<span class="sd">          use operator += for the elog attribute of the datum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this is necessary in case someone uses this outside Database</span>
    <span class="c1"># it should never happen when used by Database methods</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;md2doc:  Illegal value for mode=&quot;</span> <span class="o">+</span> <span class="n">mode</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; must be one of: promiscuous, cautious, or pedantic&quot;</span>
        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>

    <span class="c1"># Result is a tuple made up of these three items.  Return</span>
    <span class="c1"># bundles them.  Here we define them as symbols for clarity</span>
    <span class="n">insertion_doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">aok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">elog</span> <span class="o">=</span> <span class="n">ErrorLogger</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Original code had this - required now to be done by caller</span>
    <span class="c1"># self._sync_metadata_before_update(mspass_object)</span>

    <span class="c1"># First step in this algorithm is to edit the metadata contents</span>
    <span class="c1"># to handle a variety of potential issues.</span>
    <span class="c1"># This method of Metadata returns a list of all</span>
    <span class="c1"># attributes that were changed after creation of the</span>
    <span class="c1"># object to which they are attached.</span>
    <span class="n">changed_key_list</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">modified</span><span class="p">()</span>

    <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>

    <span class="c1"># clear all the aliases</span>
    <span class="c1"># TODO  check for potential bug in handling clear_aliases</span>
    <span class="c1"># and modified method - i.e. keys returned by modified may be</span>
    <span class="c1"># aliases</span>
    <span class="n">save_schema</span><span class="o">.</span><span class="n">clear_aliases</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>

    <span class="c1"># remove any values with only spaces</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># remove any defined items in exclude list</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># the special mongodb key _id is currently set readonly in</span>
    <span class="c1"># the mspass schema.  It would be cleared in the following loop</span>
    <span class="c1"># but it is better to not depend on that external constraint.</span>
    <span class="c1"># The reason is the insert_one used below for wf collections</span>
    <span class="c1"># will silently update an existing record if the _id key</span>
    <span class="c1"># is present in the update record.  We want this method</span>
    <span class="c1"># to always save the current copy with a new id and so</span>
    <span class="c1"># we make sure we clear it</span>
    <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>

    <span class="c1"># always strip normalizing data from standard collections</span>
    <span class="c1"># Note this usage puts the definition of &quot;standard collection&quot;</span>
    <span class="c1"># to the default of the argument normalizing_collection of this</span>
    <span class="c1"># function.   May want to allow callers to set this and add a</span>
    <span class="c1"># value for the list to args of this function</span>
    <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">_erase_normalized</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">,</span> <span class="n">normalizing_collections</span><span class="p">)</span>
    <span class="c1"># this section creates a python dict from the metadata container.</span>
    <span class="c1"># it applies safties based on mode argument (see user&#39;s manual)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
        <span class="c1"># A python dictionary can use Metadata as a constructor due to</span>
        <span class="c1"># the way the bindings were defined</span>
        <span class="n">insertion_doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                        <span class="n">newkey</span> <span class="o">=</span> <span class="s2">&quot;READONLYERROR_&quot;</span> <span class="o">+</span> <span class="n">k</span>
                        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">change_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span>
                        <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;Database.save_data&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;readonly attribute with key=&quot;</span>
                            <span class="o">+</span> <span class="n">k</span>
                            <span class="o">+</span> <span class="s2">&quot; was improperly modified.  Saved changed value with key=&quot;</span>
                            <span class="o">+</span> <span class="n">newkey</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Other modes have to test every key and type of value</span>
        <span class="c1"># before continuing.  pedantic kills data with any problems</span>
        <span class="c1"># Cautious tries to fix the problem first</span>
        <span class="c1"># Note many errors can be posted - one for each problem key-value pair</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">insertion_doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                        <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;pedantic mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s2">&quot; type of stored value=&quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                            <span class="o">+</span> <span class="s2">&quot; does not match schema expectation=&quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                        <span class="p">)</span>
                        <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;Database.save_data&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;message&quot;</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Careful if another mode is added here.  else means cautious in this logic</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># The following convert the actual value in a dict to a required type.</span>
                            <span class="c1"># This is because the return of type() is the class reference.</span>
                            <span class="n">insertion_doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;cautious mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                            <span class="c1">#  cannot convert required keys -&gt; kill the object</span>
                            <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;cautious mode error:  key=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Required key value could not be converted to required type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Actual type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Python error exception message caught:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="s2">&quot;Database.save&quot;</span><span class="p">,</span>
                                    <span class="n">message</span><span class="p">,</span>
                                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Value associated with this key &quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;could not be converted to required type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">())</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Actual type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="s2">&quot;Entry for this key will not be saved in database&quot;</span>
                                <span class="p">)</span>
                                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="s2">&quot;md2doc&quot;</span><span class="p">,</span>
                                    <span class="n">message</span><span class="p">,</span>
                                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                                <span class="p">)</span>
                                <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">insertion_doc</span><span class="p">,</span> <span class="n">aok</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span></div>


<div class="viewcode-block" id="elog2doc"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.elog2doc">[docs]</a><span class="k">def</span> <span class="nf">elog2doc</span><span class="p">(</span><span class="n">elog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract error log messages for storage in MongoDB</span>

<span class="sd">    This function can be thought of as a formatter for an ErrorLogger</span>
<span class="sd">    object.   The error log is a list of what is more or less a C struct (class)</span>
<span class="sd">    This function converts the log to list of python dictionaries</span>
<span class="sd">    with keys being the names of the symbols in the C code.  The list</span>
<span class="sd">    of dict objects is then stored in a python dictionary with the</span>
<span class="sd">    single key &quot;logdata&quot; that is returned.  If the log is entry</span>
<span class="sd">    an empty dict is returned.  That means the return is either empty</span>
<span class="sd">    or with one key-value pair with key==&quot;logdata&quot;.</span>

<span class="sd">    :param elog:   ErrorLogger object to be reformatted.</span>
<span class="sd">      (Note for all mspass seismic data objects == self.elog)</span>
<span class="sd">    :return:  python dictionary as described above</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elog</span><span class="p">,</span> <span class="n">ErrorLogger</span><span class="p">):</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logdata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()</span>
            <span class="n">jobid</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_job_id</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">errs</span><span class="p">:</span>
                <span class="n">logdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;job_id&quot;</span><span class="p">:</span> <span class="n">jobid</span><span class="p">,</span>
                        <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                        <span class="s2">&quot;badness&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">badness</span><span class="p">),</span>
                        <span class="s2">&quot;error_message&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
                        <span class="s2">&quot;process_id&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">p_id</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;logdata&quot;</span><span class="p">:</span> <span class="n">logdata</span><span class="p">}</span>
        <span class="c1"># note with this logic if elog is empty returns an empty dict</span>
        <span class="k">return</span> <span class="n">doc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;elog2doc:  &quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;arg0 has unsupported type =</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">elog</span><span class="p">)))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be an instance of mspasspy.ccore.util.ErrorLogger&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="history2doc"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.history2doc">[docs]</a><span class="k">def</span> <span class="nf">history2doc</span><span class="p">(</span>
    <span class="n">proc_history</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">job_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">job_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract ProcessingHistory data and package into a python dictionary.</span>

<span class="sd">    This function can be thought of as a formatter for the ProcessingHistory</span>
<span class="sd">    container in a MsPASS data object.  It returns a python dictionary</span>
<span class="sd">    that, if retrieved, can be used to reconstruct the ProcessingHistory</span>
<span class="sd">    container.  We do that a fairly easy way here by using pickle.dumps</span>
<span class="sd">    of the container that is saved with the key &quot;processing_history&quot;.</span>

<span class="sd">    :param proc_history:   history container to be reformatted</span>
<span class="sd">    :type proc_history:  Must be an instance of a</span>
<span class="sd">      mspasspy.ccore.util.ProcessingHistory object or a TypeError</span>
<span class="sd">      exception will be thrown.</span>

<span class="sd">    :param alg_id:   algorithm id for caller.   By default this is</span>
<span class="sd">      extracted from the last entry in the history tree.  Use other</span>
<span class="sd">      than the default should be necessary only if called from a</span>
<span class="sd">      nonstandard writer.</span>
<span class="sd">      (See C++ doxygen page on ProcessingHistory for concept ).</span>
<span class="sd">    :param alg_id:  string</span>

<span class="sd">    :param alg_name:  name of calling algorithm.   By default this is</span>
<span class="sd">      extracted from the last entry in the history tree.  Use other</span>
<span class="sd">      than the default should be necessary only if called from a</span>
<span class="sd">      nonstandard writer.</span>
<span class="sd">      (See C++ doxygen page on ProcessingHistory for concept ).</span>
<span class="sd">    :type alg_name:  string</span>

<span class="sd">    :param job_name:  optional job name string.  If set the value</span>
<span class="sd">      will be saved in output with the &quot;job_name&quot;.  By default</span>
<span class="sd">      there will be no value for the &quot;job_name&quot; key</span>
<span class="sd">    :type job_name:  string (default None taken to mean do not save)</span>

<span class="sd">    :param job_id:  optional job id string.  If set the value</span>
<span class="sd">      will be saved in output with the &quot;job_id&quot;.  By default</span>
<span class="sd">      there will be no value for the &quot;job_id&quot; key</span>
<span class="sd">    :type job_id:  string (default None taken to mean do not save)</span>

<span class="sd">    :return:  python dictoinary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proc_history</span><span class="p">,</span> <span class="n">ProcessingHistory</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;history2doc:  &quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;arg0 has unsupported type =</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">proc_history</span><span class="p">)))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be an instance of mspasspy.ccore.util.ProcessingHistory&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">current_uuid</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">id</span><span class="p">()</span>  <span class="c1"># uuid in the current node</span>
    <span class="n">current_nodedata</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">current_nodedata</span><span class="p">()</span>
    <span class="n">current_stage</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">stage</span><span class="p">()</span>
    <span class="c1"># get the alg_name and alg_id of current node</span>
    <span class="k">if</span> <span class="n">alg_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alg_id</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algid</span>
    <span class="k">if</span> <span class="n">alg_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alg_name</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algorithm</span>

    <span class="n">history_binary</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">proc_history</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;save_uuid&quot;</span><span class="p">:</span> <span class="n">current_uuid</span><span class="p">,</span>
        <span class="s2">&quot;save_stage&quot;</span><span class="p">:</span> <span class="n">current_stage</span><span class="p">,</span>
        <span class="s2">&quot;processing_history&quot;</span><span class="p">:</span> <span class="n">history_binary</span><span class="p">,</span>
        <span class="s2">&quot;alg_id&quot;</span><span class="p">:</span> <span class="n">alg_id</span><span class="p">,</span>
        <span class="s2">&quot;alg_name&quot;</span><span class="p">:</span> <span class="n">alg_name</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">job_name</span><span class="p">:</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;job_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_name</span>
    <span class="k">if</span> <span class="n">job_id</span><span class="p">:</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;job_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_id</span>
    <span class="k">return</span> <span class="n">doc</span></div>


<div class="viewcode-block" id="doc2md"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.doc2md">[docs]</a><span class="k">def</span> <span class="nf">doc2md</span><span class="p">(</span>
    <span class="n">doc</span><span class="p">,</span> <span class="n">database_schema</span><span class="p">,</span> <span class="n">metadata_schema</span><span class="p">,</span> <span class="n">wfcol</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is more or less the inverse of md2doc.   md2doc is</span>
<span class="sd">    needed by writers to convert Metadata to a python dict for saving</span>
<span class="sd">    with pymongo.   This function is similarly needed for readers to</span>
<span class="sd">    translate MongoDB documents into the Metadata container used by</span>
<span class="sd">    MsPASS data objects.</span>

<span class="sd">    This function can optionally apply schema constraints using the</span>
<span class="sd">    same schema class used by the Database class.  In fact, normal use</span>
<span class="sd">    would pass the schema class from the instance of Database that was</span>
<span class="sd">    used in loading the document to be converted (arg0).</span>

<span class="sd">    This function was built from a skeleton that was originally part of</span>
<span class="sd">    the read_data method of Database.  Its behavior for</span>
<span class="sd">    differnt modes is inherited from that implementation for backward</span>
<span class="sd">    compatibility.  The returns structure is a necessary evil with that</span>
<span class="sd">    change in the implementatoin, but is exactly the same as md2doc for</span>
<span class="sd">    consistency.</span>

<span class="sd">    The way the mode argument is handled is slightly different than</span>
<span class="sd">    for md2doc because of the difference in the way this function is</span>
<span class="sd">    expected to be used.  This function builds the Metadata container</span>
<span class="sd">    that is used in all readers to drive the construction of atomic</span>
<span class="sd">    data objects.  See below for a description of what different settings</span>
<span class="sd">    of mode.</span>

<span class="sd">    :param doc:  document (dict) to be converted to Metadata</span>
<span class="sd">    :type doc:  python dict assumed (there is no internal test for efficiency)</span>
<span class="sd">    An associative array with string keys operator [] are the main requirements.</span>
<span class="sd">    e.g. this function might work with a Metadata container to apply</span>
<span class="sd">    schema constraints.</span>

<span class="sd">    :param metadata_schema:  instance of MetadataSchema class that can</span>
<span class="sd">    optionally be used to impose schema constraints.</span>
<span class="sd">    :type metadata_schema:  :class:`mspasspy.db.schema.MetadataSchema`</span>

<span class="sd">    :param wfcol:  Collection name from which doc was retrieved.   It should</span>
<span class="sd">    normally alreacy be known by the caller so we require it to be passed</span>
<span class="sd">    with this required arg.</span>
<span class="sd">    :type wfcol:   string</span>

<span class="sd">    :param mode: read mode as described in detail in User&#39;s Manual.</span>
<span class="sd">    Behavior for this function is as follows:</span>
<span class="sd">        &quot;promiscuous&quot; - (default)  no checks are applied to any key-value</span>
<span class="sd">           pairs and the result is a one-to-one translation of the input.</span>
<span class="sd">        &quot;cautious&quot; - Type constraints in the schema are enforced and</span>
<span class="sd">          automatically conveted if possible.  If conversion is needed</span>
<span class="sd">          and fails the live/dead boolan in the return will be set to</span>
<span class="sd">          signal this datum should be killed.  There will also be elog entries.</span>
<span class="sd">        &quot;pedantic&quot; - type conversions are strongly enforced.  If any</span>
<span class="sd">          type mismatch of a value occurs the live/dead boolean returned</span>
<span class="sd">          will be set to signal a kill and there will be one or more</span>
<span class="sd">          error messages in the elog return.</span>
<span class="sd">    :type mode: string (must match one of the above or the function will throw</span>
<span class="sd">        a ValueError exception.</span>

<span class="sd">    :return 3-component tuple:  0 = converted Metadata container,</span>
<span class="sd">      1 - boolean equivalent to &quot;live&quot;.  i.e. if True the results is valid</span>
<span class="sd">      while if False constructing an object from the result is ill advised,</span>
<span class="sd">      2 - ErrorLogger object containing in error messages.  Callers should</span>
<span class="sd">        test if the result of the size method of the return is &gt; 0 and</span>
<span class="sd">        handle the error messages as desired.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elog</span> <span class="o">=</span> <span class="n">ErrorLogger</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exclude_keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">md</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">md</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">aok</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>
        <span class="n">dropped_keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">is_alias</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dropped_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dropped_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;While running with mode=</span><span class="si">{}</span><span class="s2"> found </span><span class="si">{}</span><span class="s2"> entries not defined in schema</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dropped_keys</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;The attributes linked to the following keys were dropped from converted Metadata container</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dropped_keys</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="n">d</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;doc2md&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
        <span class="n">aok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">fatal_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">converted_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cautious&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">unique_key</span> <span class="o">=</span> <span class="n">database_schema</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="c1"># try to convert the mismatch attribute</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># convert the attribute to the correct type</span>
                            <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">database_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">unique_key</span><span class="p">):</span>
                                <span class="n">fatal_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;cautious mode: Required attribute </span><span class="si">{}</span><span class="s2"> has type </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Schema requires this attribute have type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Type conversion not possible - datum linked to this document will be killed&quot;</span>
                                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;doc2md&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">converted_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">converted_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;WARNING:  while running in cautious mode the value associated with the following keys required an automatic type conversion:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">converted_keys</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="n">c</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Running clean_collection method is recommended&quot;</span>
                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;doc2md&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Informational</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fatal_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="n">fatal_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;pedantic mode: Required attribute </span><span class="si">{}</span><span class="s2"> has type </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s2">&quot;Schema requires this attribute have type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Type mismatches are not allowed in pedantic mode - datum linked to this document will be killed&quot;</span>
                        <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;doc2md&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fatal_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">aok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Unrecognized value for mode=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; Must be one of promiscuous, cautious, or pedantic&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">md</span><span class="p">,</span> <span class="n">aok</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span></div>


<div class="viewcode-block" id="doclist2mdlist"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.doclist2mdlist">[docs]</a><span class="k">def</span> <span class="nf">doclist2mdlist</span><span class="p">(</span>
    <span class="n">doclist</span><span class="p">,</span>
    <span class="n">database_schema</span><span class="p">,</span>
    <span class="n">metadata_schema</span><span class="p">,</span>
    <span class="n">wfcol</span><span class="p">,</span>
    <span class="n">exclude_keys</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a cleaned array of Metadata containers that can be used to</span>
<span class="sd">    construct a TimeSeriesEnsemble or SeismogramEnsemble.</span>

<span class="sd">    This function is like doc2md but for an input given as a list of docs (python dict).</span>
<span class="sd">    The main difference is the return tuple is very different.</span>
<span class="sd">    The function has to robustly handle the fact that sometimes converting</span>
<span class="sd">    a document to md is problematic.  The issues are defined in the</span>
<span class="sd">    related `doc2md` function that is used here for the atomic operation of</span>
<span class="sd">    converting a given document to a Metadata object.   The issue we have to</span>
<span class="sd">    face is what to do with warning message and documents that have</span>
<span class="sd">    fatal flaws (marked dead when passed through doc2md).  Warning</span>
<span class="sd">    messages are passed to the ErrorLogger component of the returned tuple.</span>
<span class="sd">    Callers should either print those messages or post them to the</span>
<span class="sd">    ensemble metadata that is expected to be constructed after calling</span>
<span class="sd">    this function.   In &quot;cautious&quot; and &quot;pedantic&quot; mode doc2md may mark</span>
<span class="sd">    a datum as bad with a kill return.  When a document is &quot;killed&quot;</span>
<span class="sd">    by doc2md it is dropped and two thi</span>

<span class="sd">    :param doclist:  list of documents to be converted to Metadata with schema</span>
<span class="sd">    constraints</span>
<span class="sd">    :type doclist:  any iterable container holding an array of dict containers</span>
<span class="sd">    with rational content (i.e. expected to be a MongoDB document with attributes</span>
<span class="sd">    defined for a set of seismic data objects.)</span>

<span class="sd">    ---other here --</span>

<span class="sd">    :return:  array with three components:</span>
<span class="sd">        0 - filtered array of Metadata containers</span>
<span class="sd">        1 - live boolean.   Set False only if conversion of all the documents</span>
<span class="sd">            in doclist failed.</span>
<span class="sd">        2 - ErrorLogger where warning and kill messages are posted (see above)</span>
<span class="sd">        3 - an array of documents that could not be converted (i.e. marked</span>
<span class="sd">            bad when processed with doc2md.)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mdlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ensemble_elog</span> <span class="o">=</span> <span class="n">ErrorLogger</span><span class="p">()</span>
    <span class="n">bodies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">doclist</span><span class="p">:</span>
        <span class="n">md</span><span class="p">,</span> <span class="n">live</span><span class="p">,</span> <span class="n">elog</span> <span class="o">=</span> <span class="n">doc2md</span><span class="p">(</span>
            <span class="n">doc</span><span class="p">,</span> <span class="n">database_schema</span><span class="p">,</span> <span class="n">metadata_schema</span><span class="p">,</span> <span class="n">wfcol</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">mode</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">live</span><span class="p">:</span>
            <span class="n">mdlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bodies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ensemble_elog</span> <span class="o">+=</span> <span class="n">elog</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">live</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">live</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mdlist</span><span class="p">,</span> <span class="n">live</span><span class="p">,</span> <span class="n">ensemble_elog</span><span class="p">,</span> <span class="n">bodies</span><span class="p">]</span></div>


<div class="viewcode-block" id="parse_normlist"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.parse_normlist">[docs]</a><span class="k">def</span> <span class="nf">parse_normlist</span><span class="p">(</span><span class="n">input_nlist</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses a list of multiple accepted types to return a list of Matchers.</span>

<span class="sd">    This function is more or less a translator to create a list of</span>
<span class="sd">    subclasses of the BasicMatcher class used for generic normalization.</span>
<span class="sd">    The input list (input_nlist) can be one of two things.  If the</span>
<span class="sd">    list is a set of strings the strings are assumed to define</span>
<span class="sd">    collection names.  It then constructs a database-driven</span>
<span class="sd">    matcher class using the ObjectId method that is the stock</span>
<span class="sd">    MongoDB indexing method.   Specifically, for each collection</span>
<span class="sd">    name it creates an instance of the generic ObjectIdDBMatcher</span>
<span class="sd">    class pointing to the named collection.   The other allowed</span>
<span class="sd">    type for the members of the input list are children of the</span>
<span class="sd">    base class called `BasicMatcher` defined in spasspy.db.normalize.</span>
<span class="sd">    `BasicMatcher` abstracts the task required for normalization</span>
<span class="sd">    and provides a generic mechanism to load normalization data</span>
<span class="sd">    including data defined outside of MongoDB (e.g. a pandas DataFrame).</span>
<span class="sd">    If the list contains anything but a string or a child of</span>
<span class="sd">    BasicMatcher the function will abort throwing a TypeError</span>
<span class="sd">    exception.  On success it returns a list of children of</span>
<span class="sd">    `BasicMatcher` that can be used to normalize any wf</span>
<span class="sd">    document retried from MongoDB assuming the matching</span>
<span class="sd">    algorithm is valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This import has to appear here to avoid a circular import</span>
    <span class="kn">from</span> <span class="nn">mspasspy.db.normalize</span> <span class="kn">import</span> <span class="n">BasicMatcher</span><span class="p">,</span> <span class="n">ObjectIdDBMatcher</span>

    <span class="n">normalizer_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Need this for backward compatibility for site, channel, and source</span>
    <span class="c1"># These lists are more restricitive than original algorithm but</span>
    <span class="c1"># will hopefully not cause a serious issue.</span>
    <span class="c1"># We use a dict keyed by collection name with lists passed to</span>
    <span class="c1"># matcher constructor</span>
    <span class="n">atl_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">lid_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;hang&quot;</span><span class="p">,</span> <span class="s2">&quot;vang&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span>
    <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>
    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
    <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>

    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span>
    <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>
    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
    <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>

    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span>
    <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>
    <span class="n">klist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">,</span> <span class="s2">&quot;mb&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;mw&quot;</span><span class="p">]</span>
    <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">klist</span>
    <span class="c1"># could dogmatically insist input_nlist is a list but all we</span>
    <span class="c1"># need to require is it be iterable.</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">input_nlist</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Assume this is a collection name and use the id normalizer with db</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
                <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span>
                <span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;site&quot;</span><span class="p">:</span>
                <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span>
                <span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span>
                <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">atl_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
                <span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">lid_map</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Do not have a method to handle normalize with collection name=&quot;</span> <span class="o">+</span> <span class="n">n</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Database.read_data&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="c1"># intensionally let this constructor throw an exception if</span>
            <span class="c1"># it fails - python should unwinde such errors if the happen</span>
            <span class="n">this_normalizer</span> <span class="o">=</span> <span class="n">ObjectIdDBMatcher</span><span class="p">(</span>
                <span class="n">db</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
                <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="s2">&quot;collection&quot;</span><span class="p">]</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="s2">&quot;attributes_to_load&quot;</span><span class="p">]</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="s2">&quot;load_if_defined&quot;</span><span class="p">]</span>
            <span class="n">this_normalizer</span> <span class="o">=</span> <span class="n">ObjectIdDBMatcher</span><span class="p">(</span>
                <span class="n">db</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
                <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">BasicMatcher</span><span class="p">):</span>
            <span class="n">this_normalizer</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;parse_normlist: unsupported type for entry in normalize argument list</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Found item in list of type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Item must be a string, dict, or subclass of BasicMatcher&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">normalizer_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_normalizer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">normalizer_list</span></div>


<span class="k">def</span> <span class="nf">_erase_normalized</span><span class="p">(</span>
    <span class="n">md</span><span class="p">,</span> <span class="n">normalizing_collections</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Metadata</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Erases data from a Metadata container assumed to come from normalization.</span>

<span class="sd">    In MsPASS attributes loaded with data from normalizing collections</span>
<span class="sd">    are always of the form collection_key where collection is the name of the</span>
<span class="sd">    normalizing collection and key is a simpler named used to store that</span>
<span class="sd">    attribute in the normalizing collection.   e.g. the &quot;lat&quot; latitude of</span>
<span class="sd">    an entry in the &quot;site&quot; collection would be posted to a waveform</span>
<span class="sd">    Metadata as &quot;site_lat&quot;.  One does not normally want to copy such</span>
<span class="sd">    attributes back to the database when saving as it defeats the purpose of</span>
<span class="sd">    normalization and can create confusions about which copy is definitive.</span>
<span class="sd">    For that reason Database such attributes are erased before saving</span>
<span class="sd">    unless overridden.   This simple function standardizes that process.</span>

<span class="sd">    This function is mainly for internal use and has no safties.</span>

<span class="sd">    :param md:  input Metadata container to use.   Note this can be a</span>
<span class="sd">      MsPASS seismic data object that inherits metadata and the function</span>
<span class="sd">      will work as it copies the content to a Metadata container.</span>
<span class="sd">    :type md:  :class:`mspasspy.ccore.utility.Metadata` or a C++ data</span>
<span class="sd">      object that inherits Metadata (that means all MsPASS seismid data objects)</span>
<span class="sd">    :param normalizing_collection:  list of standard collection names that</span>
<span class="sd">      are defined for normalization.   These are an argument only to put them</span>
<span class="sd">      in a standard place.  They should not be changed unless a new</span>
<span class="sd">      normalizing collection name is added or a different schema is used</span>
<span class="sd">      that has different names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make a copy - not essential but small cost for stability</span>
    <span class="c1"># make a copy - not essential but small cost for stability</span>
    <span class="n">mdout</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mdout</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">split_list</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># gt allows things like channel_foo_bar</span>
            <span class="k">if</span> <span class="n">split_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span>  <span class="c1"># never erase any of the form word_id</span>
                <span class="k">if</span> <span class="n">split_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">normalizing_collections</span><span class="p">:</span>
                    <span class="n">mdout</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mdout</span>


<div class="viewcode-block" id="geoJSON_doc"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.geoJSON_doc">[docs]</a><span class="k">def</span> <span class="nf">geoJSON_doc</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;epicenter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function to create a geoJSON format point object document</span>
<span class="sd">    from a points specified by latitude and longitude. The format</span>
<span class="sd">    for a geoJSON point isn&#39;t that strange but how to structure it into</span>
<span class="sd">    a mongoDB document for use with geospatial queries is not as</span>
<span class="sd">    clear from current MongoDB documentation.  This function makes that</span>
<span class="sd">    proess easier.</span>

<span class="sd">    The required inpput is latitude (lat) and longitude (lon).  The</span>
<span class="sd">    values are assumed to be in degrees for compatibility with MongoDB.</span>
<span class="sd">    That means latitude must be -90&lt;=lat&lt;=90 and longitude</span>
<span class="sd">    must satisfy -180&lt;=lat&lt;=180.  The function will try to handle the</span>
<span class="sd">    common situation with 0&lt;=lon&lt;=360 by wrapping 90-&gt;180 values to</span>
<span class="sd">    -180-&gt;0,  A ValueError exception is thrown if</span>
<span class="sd">    for any other situation with lot or lon outside those bounds.</span>

<span class="sd">    If you specify the optional &quot;doc&quot; argument it is assumed to be</span>
<span class="sd">    a python dict to which the geoJSON point data is to be added.</span>
<span class="sd">    By default a new dict is created that will contain only the</span>
<span class="sd">    geoJSON point data.  The doc options is useful if you want to</span>
<span class="sd">    add the geoJSON data to the document before appending it.</span>
<span class="sd">    The default is more useful for updates to add geospatial</span>
<span class="sd">    query capabilities to a collection with lat-lon data that is</span>
<span class="sd">    not properl structure.  In all cases the geoJSON data is a</span>
<span class="sd">    itself a python dict but a value associated accessible from</span>
<span class="sd">    the output dict with te key defined by the &quot;key&quot; argument</span>
<span class="sd">    (default is &#39;epicenter&#39;, which is appropriate for earthquake</span>
<span class="sd">    source data.)</span>
<span class="sd">    with a</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outval</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">outval</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Point&quot;</span>
    <span class="n">lon</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>  <span class="c1"># make this it is a float for database consistency</span>
    <span class="k">if</span> <span class="n">lon</span> <span class="o">&gt;</span> <span class="mf">180.0</span> <span class="ow">and</span> <span class="n">lon</span> <span class="o">&lt;=</span> <span class="mf">360.0</span><span class="p">:</span>
        <span class="c1"># we do this correction silently</span>
        <span class="n">lon</span> <span class="o">-=</span> <span class="mf">360.0</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lat</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">90.0</span> <span class="ow">or</span> <span class="n">lat</span> <span class="o">&gt;</span> <span class="mf">90.0</span> <span class="ow">or</span> <span class="n">lon</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">180.0</span> <span class="ow">or</span> <span class="n">lon</span> <span class="o">&gt;</span> <span class="mf">180.0</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;geoJSON_doc:  Illegal geographic input</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;latitude received=</span><span class="si">{}</span><span class="s2">  MongoDB requires [-90,90] range</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;longitude received=</span><span class="si">{}</span><span class="s2">  MongoDB requires [-180,180] range&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">lon</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">outval</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">lat</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
        <span class="n">retdoc</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="n">retdoc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">outval</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">retdoc</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">outval</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">retdoc</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>