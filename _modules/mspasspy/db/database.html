<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.db.database &mdash; MsPASS 0.0.1 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
</ul>
<p><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../../../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>mspasspy.db.database</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mspasspy.db.database</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for connecting to MongoDB.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">dask.bag</span> <span class="k">as</span> <span class="nn">daskbag</span>
<span class="kn">import</span> <span class="nn">dask.dataframe</span> <span class="k">as</span> <span class="nn">daskdf</span>
<span class="kn">import</span> <span class="nn">gridfs</span>
<span class="kn">import</span> <span class="nn">pymongo</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">from</span> <span class="nn">obspy.clients.fdsn</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">Inventory</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span>
<span class="kn">import</span> <span class="nn">boto3</span><span class="o">,</span> <span class="nn">botocore</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">base64</span>

<span class="kn">from</span> <span class="nn">mspasspy.ccore.io</span> <span class="kn">import</span> <span class="n">_mseed_file_indexer</span>

<span class="kn">from</span> <span class="nn">mspasspy.ccore.seismic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">Seismogram</span><span class="p">,</span>
    <span class="n">_CoreSeismogram</span><span class="p">,</span>
    <span class="n">DoubleVector</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.utility</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Metadata</span><span class="p">,</span>
    <span class="n">MsPASSError</span><span class="p">,</span>
    <span class="n">AtomicType</span><span class="p">,</span>
    <span class="n">ErrorSeverity</span><span class="p">,</span>
    <span class="n">dmatrix</span><span class="p">,</span>
    <span class="n">ProcessingHistory</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.db.schema</span> <span class="kn">import</span> <span class="n">DatabaseSchema</span><span class="p">,</span> <span class="n">MetadataSchema</span>
<span class="kn">from</span> <span class="nn">mspasspy.util.converter</span> <span class="kn">import</span> <span class="n">Textfile2Dataframe</span>


<div class="viewcode-block" id="read_distributed_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.read_distributed_data">[docs]</a><span class="k">def</span> <span class="nf">read_distributed_data</span><span class="p">(</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">cursor</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;dask&quot;</span><span class="p">,</span>
    <span class="n">npartitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spark_context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function should be used to read an entire dataset that is to be handled</span>
<span class="sd">    by subsequent parallel operations.  The function can be thought of as</span>
<span class="sd">    loading the entire data set into a parallel container (rdd for spark</span>
<span class="sd">    implementations or bag for a dask implementatio).   It doesn&#39;t really do</span>
<span class="sd">    that to be scalable but conceptually the container that is the output of</span>
<span class="sd">    this method is a handle to the entire data set defined by the input</span>
<span class="sd">    cursor.   The normal use of this function is to construct a query of</span>
<span class="sd">    the desired waveform collection with the MongoDB find operation.</span>
<span class="sd">    MongoDB find returns the cursor object that is the expected input.</span>
<span class="sd">    All other arguments are options that change behavior as described below.</span>

<span class="sd">    :param db: the database from which the data are to be read.</span>
<span class="sd">    :type db: :class:`mspasspy.db.database.Database`.</span>
<span class="sd">    :param cursor: mongodb cursor defining what &quot;the dataset&quot; is.  It would</span>
<span class="sd">      normally be the output of the find method with a workflow dependent</span>
<span class="sd">      query.</span>
<span class="sd">    :type cursor: :class:`pymongo.cursor.CursorType`</span>
<span class="sd">    :param mode: reading mode that controls how the function interacts with</span>
<span class="sd">      the schema definition for the data type.   Must be one of</span>
<span class="sd">      [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;].   See user&#39;s manual for a</span>
<span class="sd">      detailed description of what the modes mean.  Default is &#39;promiscuous&#39;</span>
<span class="sd">      which turns off all schema checks and loads all attributes defined for</span>
<span class="sd">      each object read.</span>
<span class="sd">    :type mode: :class:`str`</span>
<span class="sd">    :param normalize: list of collections that are to used for data</span>
<span class="sd">      normalization. (see User&#39;s manual and MongoDB documentation for</span>
<span class="sd">      details on this concept)  Briefly normalization means common</span>
<span class="sd">      metadata like source and receiver geometry are defined in separate</span>
<span class="sd">      smaller collections that are linked through this mechanism</span>
<span class="sd">      during reads. Default uses no normalization.</span>
<span class="sd">    :type normalize: a :class:`list` of :class:`str`</span>
<span class="sd">    :param load_history: boolean (True or False) switch used to enable or</span>
<span class="sd">      disable object level history mechanism.   When set True each datum</span>
<span class="sd">      will be tagged with its origin id that defines the leaf nodes of a</span>
<span class="sd">      history G-tree.  See the User&#39;s manual for additional details of this</span>
<span class="sd">      feature.  Default is False.</span>
<span class="sd">    :param exclude_keys: Sometimes it is helpful to remove one or more</span>
<span class="sd">      attributes stored in the database from the data&#39;s Metadata (header)</span>
<span class="sd">      so they will not cause problems in downstream processing.</span>
<span class="sd">    :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">    :param format: Set the format of the parallel container to define the</span>
<span class="sd">      dataset.   Must be either &quot;spark&quot; or &quot;dask&quot; or the job will abort</span>
<span class="sd">      immediately with an exception</span>
<span class="sd">    :type format: :class:`str`</span>
<span class="sd">    :param spark_context: If using spark this argument is required.  Spark</span>
<span class="sd">      defines the concept of a &quot;context&quot; that is a global control object that</span>
<span class="sd">      manages schduling.  See online Spark documentation for details on</span>
<span class="sd">      this concept.</span>
<span class="sd">    :type spark_context: :class:`pyspark.SparkContext`</span>
<span class="sd">    :param npartitions: The number of desired partitions for Dask or the number</span>
<span class="sd">      of slices for Spark. By default Dask will use 100 and Spark will determine</span>
<span class="sd">      it automatically based on the cluster.</span>
<span class="sd">    :type npartitions: :class:`int`</span>
<span class="sd">    :param data_tag:  The definition of a dataset can become ambiguous</span>
<span class="sd">      when partially processed data are saved within a workflow.   A common</span>
<span class="sd">      example would be windowing long time blocks of data to shorter time</span>
<span class="sd">      windows around a particular seismic phase and saving the windowed data.</span>
<span class="sd">      The windowed data can be difficult to distinguish from the original</span>
<span class="sd">      with standard queries.  For this reason we make extensive use of &quot;tags&quot;</span>
<span class="sd">      for save and read operations to improve the efficiency and simplify</span>
<span class="sd">      read operations.   Default turns this off by setting the tag null (None).</span>
<span class="sd">    :type data_tag: :class:`str`</span>
<span class="sd">    :return: container defining the parallel dataset.  A spark `RDD` if format</span>
<span class="sd">      is &quot;Spark&quot; and a dask &#39;bag&#39; if format is &quot;dask&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;spark&quot;</span><span class="p">:</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="n">spark_context</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">numSlices</span><span class="o">=</span><span class="n">npartitions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">cur</span><span class="p">:</span> <span class="n">db</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span>
                <span class="n">cur</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">load_history</span><span class="o">=</span><span class="n">load_history</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;dask&quot;</span><span class="p">:</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="n">daskbag</span><span class="o">.</span><span class="n">from_sequence</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">npartitions</span><span class="o">=</span><span class="n">npartitions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">cur</span><span class="p">:</span> <span class="n">db</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span>
                <span class="n">cur</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">load_history</span><span class="o">=</span><span class="n">load_history</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only spark and dask are supported&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Database"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database">[docs]</a><span class="k">class</span> <span class="nc">Database</span><span class="p">(</span><span class="n">pymongo</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">Database</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MsPASS core database handle.  All MongoDB database operation in MsPASS</span>
<span class="sd">    should utilize this object.  This object is a subclass of the</span>
<span class="sd">    Database class of pymongo.  It extends the class in several ways</span>
<span class="sd">    fundamental to the MsPASS framework:</span>

<span class="sd">    1. It abstracts read and write operations for seismic data managed</span>
<span class="sd">       by the framework.   Note reads and writes are for atomic objects.</span>
<span class="sd">       Use the distributed read and write functions for parallel handling of</span>
<span class="sd">       complete data sets.</span>
<span class="sd">    2. It contains methods for managing the most common seismic Metadata</span>
<span class="sd">       (namely source and receiver geometry and receiver response data).</span>
<span class="sd">    3. It adds a schema that can (optionally) be used to enforce type</span>
<span class="sd">       requirements and/or provide aliasing.</span>
<span class="sd">    4. Manages error logging data.</span>
<span class="sd">    5. Manages (optional) processing history data</span>

<span class="sd">    The class currently has only one constructor normally called with</span>
<span class="sd">    a variant of the following:</span>
<span class="sd">      db=Database(dbclient,&#39;mydatabase&#39;)</span>
<span class="sd">    where dbclient is either a MongoDB database client instance or</span>
<span class="sd">    (recommended) the MsPASS DBClient wrapper (a subclass of the</span>
<span class="sd">    pymongo client).  The second argument is the database &quot;name&quot;</span>
<span class="sd">    passed to the MongoDB server that defines your working database.</span>
<span class="sd">    Optional parameters are:</span>

<span class="sd">    :param db_schema: Set the name for the database schema to use with this</span>
<span class="sd">      handle.  Default is the MsPASS schema. (See User&#39;s Manual for details)</span>
<span class="sd">    :param md_schema:  Set the name for the Metadata schema.   Default is</span>
<span class="sd">      the MsPASS definitions.  (see User&#39;s Manual for details)</span>

<span class="sd">    As a subclass of pymongo Database the constructor accepts any</span>
<span class="sd">    parameters defined for the base class (see pymongo documentation)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">db_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">md_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Database</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_schema</span><span class="p">,</span> <span class="n">DatabaseSchema</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">db_schema</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">(</span><span class="n">db_schema</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">DatabaseSchema</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md_schema</span><span class="p">,</span> <span class="n">MetadataSchema</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">md_schema</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md_schema</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">(</span><span class="n">md_schema</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">MetadataSchema</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># somewhat weird that this import is requiired here but it won&#39;t</span>
        <span class="c1"># work without it.  Not sure how the symbol MongoClient is required</span>
        <span class="c1"># here but it is - ignore if a lint like ide says MongoClient is not used</span>
        <span class="kn">from</span> <span class="nn">pymongo</span> <span class="kn">import</span> <span class="n">MongoClient</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;_Database__client&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="Database.set_metadata_schema"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.set_metadata_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method to change the metadata schema defined for this</span>
<span class="sd">        instance of a database handle.  This method sets the metadata</span>
<span class="sd">        schema (interal namespace).  Use set_database_schema to change</span>
<span class="sd">        the stored data schema.</span>

<span class="sd">        :param schema: an instance of :class:`mspsspy.db.schema.MetadataSchema.</span>
<span class="sd">          WARNING this is not a name - is a MsPASS object consructed from a name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">schema</span></div>

<div class="viewcode-block" id="Database.set_database_schema"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.set_database_schema">[docs]</a>    <span class="k">def</span> <span class="nf">set_database_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method to change the database schema defined for this</span>
<span class="sd">        instance of a database handle.  This method sets the database</span>
<span class="sd">        schema (namespace for attributes saved in MongoDB).  Use metadata_schema</span>
<span class="sd">        to change the in memory namespace.</span>

<span class="sd">        :param schema: an instance of :class:`mspsspy.db.schema.DatabaseSchema.</span>
<span class="sd">          WARNING this is not a name - is a MsPASS object consructed from  aname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span> <span class="o">=</span> <span class="n">schema</span></div>

<div class="viewcode-block" id="Database.read_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">object_id</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;read_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
        <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">retrieve_history_record</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the core MsPASS reader for constructing Seismogram or TimeSeries</span>
<span class="sd">        objects from data managed with MondoDB through MsPASS.   It is the</span>
<span class="sd">        core reader for serial processing where a typical algorithm would be:</span>

<span class="sd">          query= { ... properly constructed MondoDB query or just &#39;{}&#39;}</span>
<span class="sd">          cursor=db.collection.find(query)  # collection is wf_TimeSeries or wf_Seismogram</span>
<span class="sd">          for doc in cursor:</span>
<span class="sd">            id=doc[&#39;_id&#39;]</span>
<span class="sd">            d=db.read_data(id)</span>
<span class="sd">              ...   # additional processing here</span>

<span class="sd">        The above loop will construct one Seismogram or TimeSeries (depending on</span>
<span class="sd">        which collection is referenced) for handling within the for loop.</span>
<span class="sd">        Use the read_distributed_data function to read a dataset for</span>
<span class="sd">        parallel processing.  This function is designed to handle one atomic</span>
<span class="sd">        object at a time.  It is, in fact, called in read_distributed_data</span>
<span class="sd">        Optional parameters control read behavior and additional options</span>
<span class="sd">        not always needed.  An important one for handling reads from a</span>
<span class="sd">        a dataset saved partway through a workflow is data_tag.</span>

<span class="sd">        :param object_id: MongoDB object id of the wf document to be constructed from</span>
<span class="sd">          data defined in the database.  The object id is guaranteed unique and provides</span>
<span class="sd">          a unique link to a unique document or nothing.   In the later case the</span>
<span class="sd">          function will return a None.</span>
<span class="sd">        :type cursor: :class:`pymongo.cursor.CursorType`</span>
<span class="sd">        :param mode: reading mode that controls how the function interacts with</span>
<span class="sd">          the schema definition for the data type.   Must be one of</span>
<span class="sd">          [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;].   See user&#39;s manual for a</span>
<span class="sd">          detailed description of what the modes mean.  Default is &#39;promiscuous&#39;</span>
<span class="sd">          which turns off all schema checks and loads all attributes defined for</span>
<span class="sd">          each object read.</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param normalize: list of collections that are to used for data</span>
<span class="sd">          normalization. (see User&#39;s manual and MongoDB documentation for</span>
<span class="sd">          details on this concept)  Briefly normalization means common</span>
<span class="sd">          metadata like source and receiver geometry are defined in separate</span>
<span class="sd">          smaller collections that are linked through this mechanism</span>
<span class="sd">          during reads. Default uses no normalization.</span>
<span class="sd">        :type normalize: a :class:`list` of :class:`str`</span>
<span class="sd">        :param load_history: boolean (True or False) switch used to enable or</span>
<span class="sd">          disable object level history mechanism.   When set True each datum</span>
<span class="sd">          will be tagged with its origin id that defines the leaf nodes of a</span>
<span class="sd">          history G-tree.  See the User&#39;s manual for additional details of this</span>
<span class="sd">          feature.  Default is False.</span>
<span class="sd">        :param exclude_keys: Sometimes it is helpful to remove one or more</span>
<span class="sd">          attributes stored in the database from the data&#39;s Metadata (header)</span>
<span class="sd">          so they will not cause problems in downstream processing.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection:  Specify an alternate collection name to</span>
<span class="sd">          use for reading the data.  The default sets the collection name</span>
<span class="sd">          based on the data type and automatically loads the correct schema.</span>
<span class="sd">          The collection listed must be defined in the schema and satisfy</span>
<span class="sd">          the expectations of the reader.  This is an advanced option that</span>
<span class="sd">          is indended only to simplify extensions to the reader.</span>
<span class="sd">        :param data_tag:  The definition of a dataset can become ambiguous</span>
<span class="sd">          when partially processed data are saved within a workflow.   A common</span>
<span class="sd">          example would be windowing long time blocks of data to shorter time</span>
<span class="sd">          windows around a particular seismic phase and saving the windowed data.</span>
<span class="sd">          The windowed data can be difficult to distinguish from the original</span>
<span class="sd">          with standard queries.  For this reason we make extensive use of &quot;tags&quot;</span>
<span class="sd">          for save and read operations to improve the efficiency and simplify</span>
<span class="sd">          read operations.   Default turns this off by setting the tag null (None).</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">        :type alg_name: :class:`str`</span>
<span class="sd">        :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">        :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param define_as_raw: a boolean control whether we would like to set_as_origin when loading processing history</span>
<span class="sd">        :type define_as_raw: :class:`bool`</span>
<span class="sd">        :param retrieve_history_record: a boolean control whether we would like to load processing history</span>
<span class="sd">        :type retrieve_history_record: :class:`bool`</span>
<span class="sd">        :param method: Methodology to handle overlaps/gaps of traces. Defaults to 0.</span>
<span class="sd">            See `__add__ &lt;https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.__add__.html#obspy.core.trace.Trace.__add__&gt;` for details on methods 0 and 1,</span>
<span class="sd">            see `_cleanup &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream._cleanup.html#obspy.core.stream.Stream._cleanup&gt;` for details on method -1.</span>
<span class="sd">            Any merge operation performs a cleanup merge as a first step (method -1).</span>
<span class="sd">        :type method: :class:`int`</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to None.</span>
<span class="sd">        :type fill_value: :class:`int`, :class:`float` or None</span>
<span class="sd">        :param interpolation_samples: Used only for method=1. It specifies the number of samples</span>
<span class="sd">            which are used to interpolate between overlapping traces. Default to 0.</span>
<span class="sd">            If set to -1 all overlapping samples are interpolated.</span>
<span class="sd">        :type interpolation_samples: :class:`int`</span>
<span class="sd">        :return: either :class:`mspasspy.ccore.seismic.TimeSeries`</span>
<span class="sd">          or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> is not defined in database schema&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection</span><span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported, but </span><span class="si">{}</span><span class="s2"> is requested. Please check the data_type of </span><span class="si">{}</span><span class="s2"> collection.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">object_type</span><span class="p">,</span> <span class="n">wf_collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only promiscuous, cautious and pedantic are supported, but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">normalize</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># This assumes the name of a metadata schema matches the data type it defines.</span>
        <span class="n">read_metadata_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

        <span class="c1"># We temporarily swap the main collection defined by the metadata schema by</span>
        <span class="c1"># the wf_collection. This ensures the method works consistently for any</span>
        <span class="c1"># user-specified collection argument.</span>
        <span class="n">metadata_schema_collection</span> <span class="o">=</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metadata_schema_collection</span> <span class="o">!=</span> <span class="n">wf_collection</span><span class="p">:</span>
            <span class="n">temp_metadata_schema</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">)</span>
            <span class="n">temp_metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="n">swap_collection</span><span class="p">(</span>
                <span class="n">metadata_schema_collection</span><span class="p">,</span> <span class="n">wf_collection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
            <span class="p">)</span>
            <span class="n">read_metadata_schema</span> <span class="o">=</span> <span class="n">temp_metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

        <span class="c1"># find the corresponding document according to object id</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span>
        <span class="n">object_doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">object_doc</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;data_tag&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">object_doc</span> <span class="ow">or</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">data_tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># 1. build metadata as dict</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>

        <span class="c1"># 1.1 read in the attributes from the document in the database</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="c1"># FIXME: note that we do not check whether the attributes&#39; type in the database matches the schema&#39;s definition.</span>
            <span class="c1"># This may or may not be correct. Should test in practice and get user feedbacks.</span>
            <span class="k">if</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">is_alias</span><span class="p">(</span>
                <span class="n">k</span>
            <span class="p">):</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># 1.2 read the attributes in the metadata schema</span>
        <span class="c1"># col_dict is a hashmap used to store the normalized records by the normalized_id in object_doc</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># log_error_msg is used to record all the elog entries generated during the reading process</span>
        <span class="c1"># After the mspass_object is created, we would post every elog entry with the messages in the log_error_msg.</span>
        <span class="n">log_error_msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="c1"># explanation of the 4 conditions in the following if statement</span>
            <span class="c1"># 1.2.1. col is not None and is a normalized collection name</span>
            <span class="c1"># 1.2.2. normalized key id exists in the wf document</span>
            <span class="c1"># 1.2.3. k is not one of the exclude keys</span>
            <span class="c1"># 1.2.4. col is in the normalize list provided by user</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">col</span>
                <span class="ow">and</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">wf_collection</span>
                <span class="ow">and</span> <span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">object_doc</span>
                <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_keys</span>
                <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">normalize</span>
            <span class="p">):</span>
                <span class="c1"># try to find the corresponding record in the normalized collection from the database</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_dict</span><span class="p">:</span>
                    <span class="n">col_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]})</span>
                <span class="c1"># might unable to find the normalized document by the normalized_id in the object_doc</span>
                <span class="c1"># we skip reading this attribute</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">col_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="c1"># this attribute may be missing in the normalized record we retrieve above</span>
                <span class="c1"># in this case, we skip reading this attribute</span>
                <span class="c1"># however, if it is a required attribute for the normalized collection</span>
                <span class="c1"># we should post an elog entry to the associated wf object created after.</span>
                <span class="n">unique_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unique_k</span> <span class="ow">in</span> <span class="n">col_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">unique_k</span><span class="p">):</span>
                        <span class="n">log_error_msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="s2">&quot;Attribute </span><span class="si">{}</span><span class="s2"> is required in collection </span><span class="si">{}</span><span class="s2">, but is missing in the document with id=</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">unique_k</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_dict</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">unique_k</span><span class="p">]</span>

        <span class="c1"># 1.3 schema check normalized data according to the read mode</span>
        <span class="n">is_dead</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fatal_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cautious&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">unique_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="c1"># try to convert the mismatch attribute</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># convert the attribute to the correct type</span>
                            <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">unique_key</span><span class="p">):</span>
                                <span class="n">fatal_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">is_dead</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">log_error_msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s2">&quot;cautious mode: Required attribute </span><span class="si">{}</span><span class="s2"> has type </span><span class="si">{}</span><span class="s2">, forbidden by definition and unable to convert&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">k</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="n">fatal_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">is_dead</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">log_error_msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="s2">&quot;pedantic mode: </span><span class="si">{}</span><span class="s2"> has type </span><span class="si">{}</span><span class="s2">, forbidden by definition&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">k</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

        <span class="c1"># 1.4 create a mspass object by passing MetaData</span>
        <span class="c1"># if not changing the fatal key values, runtime error in construct a mspass object</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fatal_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="n">read_metadata_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bytes</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
            <span class="c1"># FIXME: This is awkward. Need to revisit when we have proper constructors.</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">md</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">md</span><span class="p">},</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># FIXME: if npts is in the exclude list or not in the schema, the following won&#39;t work.</span>
            <span class="c1"># May need to consider adding a &quot;required&quot; key to the metadata schema to avoid invalid combination.</span>
            <span class="k">if</span> <span class="s2">&quot;npts&quot;</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span> <span class="o">=</span> <span class="n">Seismogram</span><span class="p">(</span><span class="n">_CoreSeismogram</span><span class="p">(</span><span class="n">md</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

        <span class="c1"># not continue step 2 &amp; 3 if the mspass object is dead</span>
        <span class="k">if</span> <span class="n">is_dead</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">log_error_msg</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;read_data&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 2.load data from different modes</span>
            <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_dfile</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">,</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">],</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">],</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">],</span>
                        <span class="n">nbytes</span><span class="o">=</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">],</span>
                        <span class="nb">format</span><span class="o">=</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">],</span>
                        <span class="n">merge_method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                        <span class="n">merge_fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_dfile</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">,</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">],</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">],</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">],</span>
                        <span class="n">merge_method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                        <span class="n">merge_fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_gridfs</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_url</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span>
                    <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;url&quot;</span><span class="p">],</span>
                    <span class="nb">format</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">object_doc</span> <span class="k">else</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;s3_continuous&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_s3_continuous</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="p">,</span> <span class="n">aws_secret_access_key</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;s3_lambda&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_s3_lambda</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="p">,</span> <span class="n">aws_secret_access_key</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;fdsn&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_data_from_fdsn</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown storage mode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_mode</span><span class="p">))</span>

            <span class="c1"># 3.load history</span>
            <span class="k">if</span> <span class="n">load_history</span><span class="p">:</span>
                <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">history_obj_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_history</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">,</span>
                        <span class="n">object_doc</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">],</span>
                        <span class="n">alg_name</span><span class="p">,</span>
                        <span class="n">alg_id</span><span class="p">,</span>
                        <span class="n">define_as_raw</span><span class="p">,</span>
                        <span class="n">retrieve_history_record</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">clear_modified</span><span class="p">()</span>

            <span class="c1"># 4.post complaint elog entries if any</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">log_error_msg</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;read_data&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.save_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;gridfs&quot;</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method to save an atomic data object (TimeSeries or Seismogram)</span>
<span class="sd">        to be managed with MongoDB.  The Metadata are stored as documents in</span>
<span class="sd">        a MongoDB collection.  The waveform data can be stored in a conventional</span>
<span class="sd">        file system or in MongoDB&#39;s gridfs system.   At the time this docstring</span>
<span class="sd">        was written testing was still in progress to establish the relative</span>
<span class="sd">        performance of file system io versus gridfs, but our working hypothesis</span>
<span class="sd">        is the answer of which is faster will be configuration dependent. In</span>
<span class="sd">        either case the goal of this function is to make a save operation as</span>
<span class="sd">        simple as possible by abstracting the complications involved in</span>
<span class="sd">        the actual save.</span>

<span class="sd">        Any errors messages held in the object being saved are always</span>
<span class="sd">        written to documents in MongoDB is a special collection defined in</span>
<span class="sd">        the schema.   Saving object level history is optional.</span>

<span class="sd">        There are multiple options described below.  One worth emphasizing is</span>
<span class="sd">        &quot;data_tag&quot;.   Such a tag is essential for intermediate saves of</span>
<span class="sd">        a dataset if there is no other unique way to distinguish the</span>
<span class="sd">        data in is current state from data saved earlier.  For example,</span>
<span class="sd">        consider a job that did nothing but read waveform segments spanning</span>
<span class="sd">        a long time period (e.g. day files),cutting out a shorter time window,</span>
<span class="sd">        and then saving windowed data.  Crafting an unambiguous query to</span>
<span class="sd">        find only the windowed data in that situation could be challenging</span>
<span class="sd">        or impossible.  Hence, we recommend a data tag always be used for</span>
<span class="sd">        most saves.</span>

<span class="sd">        The mode parameter needs to be understood by all users of this</span>
<span class="sd">        function.  All modes enforce a schema constraint for &quot;readonly&quot;</span>
<span class="sd">        attributes.   An immutable (readonly) attribute by definition</span>
<span class="sd">        should not be changed during processing.   During a save</span>
<span class="sd">        all attributes with a key defined as readonly are tested</span>
<span class="sd">        with a method in the Metadata container that keeps track of</span>
<span class="sd">        any Metadata changes.  If a readonly attribute is found to</span>
<span class="sd">        have been changed it will be renamed with the prefix</span>
<span class="sd">        &quot;READONLYERROR_&quot;, saved, and an error posted (e.g. if you try</span>
<span class="sd">        to alter site_lat (a readonly attribute) in a workflow when</span>
<span class="sd">        you save the waveform you will find an entry with the key</span>
<span class="sd">        READONERROR_site_lat.)   In the default &#39;promiscuous&#39; mode</span>
<span class="sd">        all other attributes are blindly saved to the database as</span>
<span class="sd">        name value pairs with no safeties.  In &#39;cautious&#39; mode we</span>
<span class="sd">        add a type check.  If the actual type of an attribute does not</span>
<span class="sd">        match what the schema expect, this method will try to fix the</span>
<span class="sd">        type error before saving the data.  If the conversion is</span>
<span class="sd">        successful it will be saved with a complaint error posted</span>
<span class="sd">        to elog.  If it fails, the attribute will not be saved, an</span>
<span class="sd">        additional error message will be posted, and the save</span>
<span class="sd">        algorithm continues.  In &#39;pedantic&#39; mode, in contrast, all</span>
<span class="sd">        type errors are considered to invalidate the data.</span>
<span class="sd">        Similar error messages to that in &#39;cautious&#39; mode are posted</span>
<span class="sd">        but any type errors will cause the datum passed as arg 0</span>
<span class="sd">        to be killed. The lesson is saves can leave entries that</span>
<span class="sd">        may need to be examined in elog and when really bad will</span>
<span class="sd">        cause the datum to be marked dead after the save.</span>

<span class="sd">        This method can throw an exception but only for errors in</span>
<span class="sd">        usage (i.e. arguments defined incorrectly)</span>

<span class="sd">        :param mspass_object: the object you want to save.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param mode: This parameter defines how attributes defined with</span>
<span class="sd">          key-value pairs in MongoDB documents are to be handled on reading.</span>
<span class="sd">          By &quot;to be handled&quot; we mean how strongly to enforce name and type</span>
<span class="sd">          specification in the schema for the type of object being constructed.</span>
<span class="sd">          Options are [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;] with &#39;promiscuous&#39;</span>
<span class="sd">          being the default.  See the User&#39;s manual for more details on</span>
<span class="sd">          the concepts and how to use this option.</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param storage_mode: Must be either &quot;gridfs&quot; or &quot;file.  When set to</span>
<span class="sd">          &quot;gridfs&quot; the waveform data are stored internally and managed by</span>
<span class="sd">          MongoDB.  If set to &quot;file&quot; the data will be stored in a file system</span>
<span class="sd">          with the dir and dfile arguments defining a file name.   The</span>
<span class="sd">          default is &quot;gridfs&quot;.</span>
<span class="sd">        :type storage_mode: :class:`str`</span>
<span class="sd">        :param dir: file directory for storage.  This argument is ignored if</span>
<span class="sd">          storage_mode is set to &quot;gridfs&quot;.  When storage_mode is &quot;file&quot; it</span>
<span class="sd">          sets the directory in a file system where the data should be saved.</span>
<span class="sd">          Note this can be an absolute or relative path.  If the path is</span>
<span class="sd">          relative it will be expanded with the standard python library</span>
<span class="sd">          path functions to a full path name for storage in the database</span>
<span class="sd">          document with the attribute &quot;dir&quot;.  As for any io we remind the</span>
<span class="sd">          user that you much have write permission in this directory.</span>
<span class="sd">          The writer will also fail if this directory does not already</span>
<span class="sd">          exist.  i.e. we do not attempt to</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name for storage of waveform data.  As with dir</span>
<span class="sd">          this parameter is ignored if storage_mode is &quot;gridfs&quot; and is</span>
<span class="sd">          required only if storage_mode is &quot;file&quot;.   Note that this file</span>
<span class="sd">          name does not have to be unique.  The writer always calls positions</span>
<span class="sd">          the write pointer to the end of the file referenced and sets the</span>
<span class="sd">          attribute &quot;foff&quot; to that position. That allows automatic appends to</span>
<span class="sd">          files without concerns about unique names.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param format: the format of the file. This can be one of the</span>
<span class="sd">          `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.write.html#supported-formats&gt;`__</span>
<span class="sd">          of ObsPy writer. The default the python None which the method</span>
<span class="sd">          assumes means to store the data in its raw binary form.  The default</span>
<span class="sd">          should normally be used for efficiency.  Alternate formats are</span>
<span class="sd">          primarily a simple export mechanism.  See the User&#39;s manual for</span>
<span class="sd">          more details on data export.  Used only for &quot;file&quot; storage mode.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        :param overwrite:  If true gridfs data linked to the original</span>
<span class="sd">          waveform will be replaced by the sample data from this save.</span>
<span class="sd">          Default is false, and should be the normal use.  This option</span>
<span class="sd">          should never be used after a reduce operator as the parents</span>
<span class="sd">          are not tracked and the space advantage is likely minimal for</span>
<span class="sd">          the confusion it would cause.   This is most useful for light, stable</span>
<span class="sd">          preprocessing with a set of map operators to regularize a data</span>
<span class="sd">          set before more extensive processing.  It can only be used when</span>
<span class="sd">          storage_mode is set to gridfs.</span>
<span class="sd">        :type overwrite:  boolean</span>
<span class="sd">        :param exclude_keys: Metadata can often become contaminated with</span>
<span class="sd">          attributes that are no longer needed or a mismatch with the data.</span>
<span class="sd">          A type example is the bundle algorithm takes three TimeSeries</span>
<span class="sd">          objects and produces a single Seismogram from them.  That process</span>
<span class="sd">          can, and usually does, leave things like seed channel names and</span>
<span class="sd">          orientation attributes (hang and vang) from one of the components</span>
<span class="sd">          as extraneous baggage.   Use this of keys to prevent such attributes</span>
<span class="sd">          from being written to the output documents.  Not if the data being</span>
<span class="sd">          saved lack these keys nothing happens so it is safer, albeit slower,</span>
<span class="sd">          to have the list be as large as necessary to eliminate any potential</span>
<span class="sd">          debris.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: The default for this parameter is the python</span>
<span class="sd">          None.  The default should be used for all but data export functions.</span>
<span class="sd">          The normal behavior is for this writer to use the object</span>
<span class="sd">          data type to determine the schema is should use for any type or</span>
<span class="sd">          name enforcement.  This parameter allows an alernate collection to</span>
<span class="sd">          be used with or without some different name and type restrictions.</span>
<span class="sd">          The most common use of anything other than the default is an</span>
<span class="sd">          export to a diffrent format.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key.  See above and</span>
<span class="sd">          User&#39;s manual for guidance on how the use of this option.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        :return: Data object as saved (if killed it will be dead)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">storage_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown storage mode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only promiscuous, cautious and pedantic are supported, but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># below we try to capture permission issue before writing anything to the database.</span>
        <span class="c1"># However, in the case that a storage is almost full, exceptions can still be</span>
        <span class="c1"># thrown, which could mess up the database record.</span>
        <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dfile</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">dir</span><span class="p">:</span>
                <span class="c1"># Note the following uses the dir and dfile defined in the data object.</span>
                <span class="c1"># It will ignore these two keys already in the collection in an update</span>
                <span class="c1"># transaction, and the dir and dfile in the collection will be replaced.</span>
                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;dir&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;dfile&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dir or dfile is not specified in data object&quot;</span><span class="p">)</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">])</span>
                <span class="n">dfile</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span>
                        <span class="s2">&quot;No write permission to the save file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the following loop finds the top level of existing parents to fname</span>
                <span class="c1"># and check for write permission to that directory.</span>
                <span class="k">for</span> <span class="n">path_item</span> <span class="ow">in</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePath</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_item</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path_item</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span>
                                <span class="s2">&quot;No write permission to the save directory: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">dir</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">break</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>

        <span class="c1"># should define wf_collection here because if the mspass_object is dead</span>
        <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
            <span class="c1"># A weird construct</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># FIXME starttime will be automatically created in this function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

            <span class="c1"># This method of Metadata returns a list of all</span>
            <span class="c1"># attributes that were changed after creation of the</span>
            <span class="c1"># object to which they are attached.</span>
            <span class="n">changed_key_list</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">modified</span><span class="p">()</span>

            <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

            <span class="c1"># clear all the aliases</span>
            <span class="c1"># TODO  check for potential bug in handling clear_aliases</span>
            <span class="c1"># and modified method - i.e. keys returned by modified may be</span>
            <span class="c1"># aliases</span>
            <span class="n">save_schema</span><span class="o">.</span><span class="n">clear_aliases</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>

            <span class="c1"># remove any values with only spaces</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                    <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># remove any defined items in exclude list</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                    <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="c1"># the special mongodb key _id is currently set readonly in</span>
            <span class="c1"># the mspass schema.  It would be cleard in the following loop</span>
            <span class="c1"># but it is better to not depend on that external constraint.</span>
            <span class="c1"># The reason is the insert_one used below for wf collections</span>
            <span class="c1"># will silently update an existing record if the _id key</span>
            <span class="c1"># is present in the update record.  We want this method</span>
            <span class="c1"># to always save the current copy with a new id and so</span>
            <span class="c1"># we make sure we clear it</span>
            <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="c1"># Now remove any readonly data</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                            <span class="n">newkey</span> <span class="o">=</span> <span class="s2">&quot;READONLYERROR_&quot;</span> <span class="o">+</span> <span class="n">k</span>
                            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">change_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="s2">&quot;Database.save_data&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;readonly attribute with key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; was improperly modified.  Saved changed value with key=&quot;</span>
                                <span class="o">+</span> <span class="n">newkey</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="c1"># Done editing, now we convert copied_metadata to a python dict</span>
            <span class="c1"># using this Metadata method or the long version when in cautious or pedantic mode</span>
            <span class="n">insertion_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
                <span class="c1"># A python dictionary can use Metadata as a constructor due to</span>
                <span class="c1"># the way the bindings were defined</span>
                <span class="n">insertion_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Other modes have to test every key and type of value</span>
                <span class="c1"># before continuing.  pedantic kills data with any problems</span>
                <span class="c1"># Cautious tries to fix the problem first</span>
                <span class="c1"># Note many errors can be posted - one for each problem key-value pair</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;pedantic mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="s2">&quot; type of stored value=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot; does not match schema expectation=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                <span class="p">)</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="s2">&quot;Database.save_data&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;message&quot;</span><span class="p">,</span>
                                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Careful if another mode is added here.  else means cautious in this logic</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="c1"># The following convert the actual value in a dict to a required type.</span>
                                    <span class="c1"># This is because the return of type() is the class reference.</span>
                                    <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span>
                                        <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                                    <span class="c1">#  cannot convert required keys -&gt; kill the object</span>
                                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;cautious mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot; Required key value could not be converted to required type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                            <span class="o">+</span> <span class="s2">&quot; actual type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                        <span class="p">)</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Python error exception message caught:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                            <span class="s2">&quot;Database.save&quot;</span><span class="p">,</span>
                                            <span class="n">message</span><span class="p">,</span>
                                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                                        <span class="p">)</span>
                                    <span class="c1"># cannot convert normal keys -&gt; erase the key</span>
                                    <span class="c1"># TODO should we post a Complaint entry to the elog?</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Note we jump here immediately if mspass_object was marked dead</span>
        <span class="c1"># on entry.  Data can, however, be killed in metadata section</span>
        <span class="c1"># above so we need repeat the test for live</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>
            <span class="n">gridfs_id</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="c1"># TODO:  be sure this can&#39;t throw an exception</span>
                <span class="n">foff</span><span class="p">,</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_data_to_dfile</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span>
                <span class="p">)</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dir</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">foff</span>
                <span class="k">if</span> <span class="nb">format</span><span class="p">:</span>
                    <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbytes</span>
                    <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">format</span>
            <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="s2">&quot;gridfs_id&quot;</span> <span class="ow">in</span> <span class="n">insertion_dict</span><span class="p">:</span>
                    <span class="n">gridfs_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_data_to_gridfs</span><span class="p">(</span>
                        <span class="n">mspass_object</span><span class="p">,</span> <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gridfs_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_data_to_gridfs</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridfs_id</span>
                <span class="c1"># TODO will support url mode later</span>
                <span class="c1"># elif storage_mode == &quot;url&quot;:</span>
                <span class="c1">#    pass</span>

            <span class="c1"># save history if not empty</span>
            <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="p">)</span>
            <span class="n">history_object_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="c1"># Use this trick in update_metadata too. None is needed to</span>
                <span class="c1"># avoid a TypeError exception if the name is not defined.</span>
                <span class="c1"># could do this with a conditional as an alternative</span>
                <span class="n">insertion_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">history_obj_id_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># optional history save - only done if history container is not empty</span>
                <span class="n">history_object_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">)</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>

            <span class="c1"># add tag</span>
            <span class="k">if</span> <span class="n">data_tag</span><span class="p">:</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="s2">&quot;data_tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_tag</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need to clear data tag if was previously defined in</span>
                <span class="c1"># this case or a the old tag will be saved with this datum</span>
                <span class="k">if</span> <span class="s2">&quot;data_tag&quot;</span> <span class="ow">in</span> <span class="n">insertion_dict</span><span class="p">:</span>
                    <span class="n">insertion_dict</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="s2">&quot;data_tag&quot;</span><span class="p">)</span>
            <span class="c1"># We don&#39;t want an elog_id in the insertion at this point.</span>
            <span class="c1"># A option to consider is if we need an update after _save_elog</span>
            <span class="c1"># section below to post elog_id back.</span>

            <span class="c1"># test will fail here because there might be some Complaint elog post to the wf above</span>
            <span class="c1"># we need to save the elog and get the elog_id</span>
            <span class="c1"># then associate with the wf document so that we could insert in the wf_collection</span>

            <span class="c1"># save elogs if the size of elog is greater than 0</span>
            <span class="n">elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="c1"># elog ids will be updated in the wf col when saving metadata</span>
                <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">insertion_dict</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>

            <span class="c1"># finally ready to insert the wf doc - keep the id as we&#39;ll need</span>
            <span class="c1"># it for tagging any elog entries</span>
            <span class="n">wfid</span> <span class="o">=</span> <span class="n">wf_collection</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">insertion_dict</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="c1"># Put wfid into the object&#39;s meta as the new definition of</span>
            <span class="c1"># the parent of this waveform</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wfid</span>

            <span class="c1"># we may probably set the gridfs_id field in the mspass_object</span>
            <span class="k">if</span> <span class="n">gridfs_id</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridfs_id</span>
            <span class="c1"># we may probably set the history_object_id field in the mspass_object</span>
            <span class="k">if</span> <span class="n">history_object_id</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>
            <span class="c1"># we may probably set the elog_id field in the mspass_object</span>
            <span class="k">if</span> <span class="n">elog_id</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>

            <span class="c1"># Empty error logs are skipped.  When nonzero tag them with tid</span>
            <span class="c1"># just returned</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># elog_id_name = self.database_schema.default_name(&#39;elog&#39;) + &#39;_id&#39;</span>
                <span class="c1"># _save_elog uses a  null id as a signal to add a new record</span>
                <span class="c1"># When we land here the record must be new since it is</span>
                <span class="c1"># associated with a new wf document.  elog_id=None is default</span>
                <span class="c1"># but set it explicitly for clarity</span>

                <span class="c1"># This is comment out becuase we need to save it before inserting into the wf_collection</span>
                <span class="c1"># elog_id = self._save_elog(mspass_object, elog_id=None)</span>

                <span class="c1"># cross reference for elog entry, assoicate the wfid to the elog entry</span>
                <span class="n">elog_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)]</span>
                <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">insertion_dict</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]}</span>
                <span class="n">elog_col</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                    <span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}}</span>
                <span class="p">)</span>
            <span class="c1"># When history is enable we need to do an update to put the</span>
            <span class="c1"># wf collection id as a cross-reference.    Any value stored</span>
            <span class="c1"># above with saave_history may be incorrect.  We use a</span>
            <span class="c1"># stock test with the is_empty method for know if history data is present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="n">history_object_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">history_object_id</span><span class="p">}</span>
                <span class="n">update_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">wfid</span><span class="p">}</span>
                <span class="n">history_object_col</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_dict</span><span class="p">})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We land here when the input is dead or was killed during a</span>
            <span class="c1"># cautious or pedantic mode edit of the metadata.</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="n">old_elog_id</span><span class="p">)</span>
        <span class="c1"># Both live and dead data land here.</span>
        <span class="k">return</span> <span class="n">mspass_object</span></div>

    <span class="c1"># clean the collection fixing any type errors and removing any aliases using the schema currently defined for self</span>

<div class="viewcode-block" id="Database.clean_collection"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.clean_collection">[docs]</a>    <span class="k">def</span> <span class="nf">clean_collection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_undefined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">required_xref_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_missing_xref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delete_missing_required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method can be used to fix a subset of common database problems</span>
<span class="sd">        created during processing that can cause problems if the user tries to</span>
<span class="sd">        read back data saved with such blemishes.   The subset of problems</span>
<span class="sd">        are defined as those that are identified by the &quot;dbverify&quot; command</span>
<span class="sd">        line tool or it&#39;s Database equivalent (the verify method of this class).</span>
<span class="sd">        This method is an alternative to the command line tool dbverify.  Use</span>
<span class="sd">        this method for more surgical fixes that require a query to limit</span>
<span class="sd">        the application of the fix.</span>

<span class="sd">        :param collection: the collection you would like to clean. If not specified, use the default wf collection</span>
<span class="sd">        :type collection: :class:`str`</span>
<span class="sd">        :param query: this is a python dict that is assumed to be a query</span>
<span class="sd">         to MongoDB to limit suite of documents to which the requested cleanup</span>
<span class="sd">         methods are applied.  The default will process the entire database</span>
<span class="sd">         collection specified.</span>
<span class="sd">        :type query: :class:`dict`</span>
<span class="sd">        :param rename_undefined: when set the options is assumed to contain</span>
<span class="sd">          a python dict defining how to rename a set of attributes. Each member</span>
<span class="sd">          of the dict is assumed to be of the form ``{original_key:new_key}``</span>
<span class="sd">          Each document handled will change the key from &quot;original_key&quot; to</span>
<span class="sd">          &quot;new_key&quot;.</span>
<span class="sd">        :type rename_undefined: :class:`dict`</span>
<span class="sd">        :param delete_undefined: attributes undefined in the schema can</span>
<span class="sd">          be problematic.  As a minimum they waste storage and memory if they</span>
<span class="sd">          are baggage.  At worst they may cause a downstream process to abort</span>
<span class="sd">          or mark some or all data dead.  On the other hand, undefined data may</span>
<span class="sd">          contain important information you need that for some reason is</span>
<span class="sd">          not defined in the schema.  In that case do not run this method to</span>
<span class="sd">          clear these.  When set true all attributes matching the query will</span>
<span class="sd">          have undefined attributes cleared.</span>
<span class="sd">        :param required_xref_list: in MsPASS we use &quot;normalization&quot; of some common</span>
<span class="sd">          attributes for efficiency.  The stock ones currently are &quot;source&quot;, &quot;site&quot;,</span>
<span class="sd">          and &quot;channel&quot;.  This list is a intimately linked to the</span>
<span class="sd">          delete_missing_xref option.  When that is true this list is</span>
<span class="sd">          enforced to clean debris.  Typical examples are [&#39;site_id&#39;,&#39;source_id&#39;]</span>
<span class="sd">          to require source and receiver geometry.</span>
<span class="sd">        :type required_xref_list: :class:`list`</span>
<span class="sd">        :param delete_missing_xref: Turn this option on to impose a brutal</span>
<span class="sd">          fix for data with missing (required) cross referencing data.  This</span>
<span class="sd">          clean operation, for example, might be necessary to clean up a</span>
<span class="sd">          data set with some channels that defy all attempts to find valid</span>
<span class="sd">          receiver metadata (stationxml stuff for passive data, survey data for</span>
<span class="sd">          active source data).  This clean method is a blunt instrument that</span>
<span class="sd">          should be used as a last resort.  When true the is list of xref</span>
<span class="sd">          keys defined by required_xref_list are tested any document that lacks</span>
<span class="sd">          of the keys will be deleted from the database.</span>
<span class="sd">        :param delete_missing_required: Set to ``True`` to delete this document if any required keys in the database schema is missing. Default is ``False``.</span>
<span class="sd">        :param verbose: Set to ``True`` to print all the operations. Default is ``False``.</span>
<span class="sd">        :param verbose_keys: a list of keys you want to added to better identify problems when error happens. It&#39;s used in the print messages.</span>
<span class="sd">        :type verbose_keys: :class:`list` of :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">verbose_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">verbose_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">required_xref_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">required_xref_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">rename_undefined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename_undefined</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">fixed_cnt</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># fix the queried documents in the collection</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)]</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="c1"># no match documents return</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fixed_cnt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">fixed_attr_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean</span><span class="p">(</span>
                        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span>
                        <span class="n">collection</span><span class="p">,</span>
                        <span class="n">rename_undefined</span><span class="p">,</span>
                        <span class="n">delete_undefined</span><span class="p">,</span>
                        <span class="n">required_xref_list</span><span class="p">,</span>
                        <span class="n">delete_missing_xref</span><span class="p">,</span>
                        <span class="n">delete_missing_required</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="p">,</span>
                        <span class="n">verbose_keys</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_attr_cnt</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_cnt</span><span class="p">:</span>
                            <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">fixed_cnt</span></div>

    <span class="c1"># clean a single document in the given collection atomically</span>
<div class="viewcode-block" id="Database.clean"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">document_id</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">rename_undefined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">required_xref_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delete_missing_xref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delete_missing_required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the atomic level operation for cleaning a single database</span>
<span class="sd">        document with one or more common fixes.  The clean_collection method</span>
<span class="sd">        is mainly a loop that calls this method for each document it is asked to</span>
<span class="sd">        handle.  Most users will likely not need or want to call this method</span>
<span class="sd">        directly but use the clean_collection method instead.  See the docstring</span>
<span class="sd">        for clean_collection for a less cyptic description of the options as</span>
<span class="sd">        the options are identical.</span>

<span class="sd">        :param document_id: the value of the _id field in the document you want to clean</span>
<span class="sd">        :type document_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param collection: the name of collection saving the document. If not specified, use the default wf collection</span>
<span class="sd">        :param rename_undefined: Specify a :class:`dict` of ``{original_key:new_key}`` to rename the undefined keys in the document.</span>
<span class="sd">        :type rename_undefined: :class:`dict`</span>
<span class="sd">        :param delete_undefined: Set to ``True`` to delete undefined keys in the doc. ``rename_undefined`` will not work if this is ``True``. Default is ``False``.</span>
<span class="sd">        :param required_xref_list: a :class:`list` of xref keys to be checked.</span>
<span class="sd">        :type required_xref_list: :class:`list`</span>
<span class="sd">        :param delete_missing_xref: Set to ``True`` to delete this document if any keys specified in ``required_xref_list`` is missing. Default is ``False``.</span>
<span class="sd">        :param delete_missing_required: Set to ``True`` to delete this document if any required keys in the database schema is missing. Default is ``False``.</span>
<span class="sd">        :param verbose: Set to ``True`` to print all the operations. Default is ``False``.</span>
<span class="sd">        :param verbose_keys: a list of keys you want to added to better identify problems when error happens. It&#39;s used in the print messages.</span>
<span class="sd">        :type verbose_keys: :class:`list` of :class:`str`</span>

<span class="sd">        :return: number of fixes applied to each key</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">verbose_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">required_xref_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">required_xref_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">rename_undefined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename_undefined</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># validate parameters</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">verbose_keys</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;verbose_keys should be a list , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">verbose_keys</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">rename_undefined</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;rename_undefined should be a dict , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rename_undefined</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">required_xref_list</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;required_xref_list should be a list , but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">required_xref_list</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">print_messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fixed_cnt</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># if the document does not exist in the db collection, return</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">document_id</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> document _id: </span><span class="si">{}</span><span class="s2">, is not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">collection</span><span class="p">,</span> <span class="n">document_id</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fixed_cnt</span>

        <span class="c1"># access each key</span>
        <span class="n">log_id_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># get all the values of the verbose_keys</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">verbose_keys</span><span class="p">:</span>
                <span class="n">log_id_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">log_helper</span> <span class="o">=</span> <span class="s2">&quot;collection </span><span class="si">{}</span><span class="s2"> document _id: </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">log_id_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">log_helper</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># 1. check if the document has all the required fields</span>
        <span class="n">missing_required_attr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">has_alias</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="c1"># get the aliases list of the key</span>
                    <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">aliases</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">keys_for_checking</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># check if any key appear in the doc</span>
                <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_for_checking</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                        <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key_in_doc</span><span class="p">:</span>
                    <span class="n">missing_required_attr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_required_attr_list</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;required attribute: &quot;</span>
            <span class="k">for</span> <span class="n">missing_attr</span> <span class="ow">in</span> <span class="n">missing_required_attr_list</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_attr</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;are missing.&quot;</span>

            <span class="c1"># delete this document</span>
            <span class="k">if</span> <span class="n">delete_missing_required</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_data</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span> <span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> the document is deleted.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">fixed_cnt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>

        <span class="c1"># 2. check if the document has all xref keys in the required_xref_list list provided by user</span>
        <span class="n">missing_xref_key_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xref_k</span> <span class="ow">in</span> <span class="n">required_xref_list</span><span class="p">:</span>
            <span class="c1"># xref_k in required_xref_list list should be defined in schema first</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">xref_k</span><span class="p">):</span>
                <span class="n">unique_xref_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_k</span><span class="p">)</span>
                <span class="c1"># xref_k should be a reference key as well</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_xref_key</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">):</span>
                    <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">has_alias</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">):</span>
                        <span class="c1"># get the aliases list of the key</span>
                        <span class="n">keys_for_checking</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">aliases</span><span class="p">(</span>
                            <span class="n">unique_xref_k</span>
                        <span class="p">)</span>
                    <span class="n">keys_for_checking</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">)</span>
                    <span class="c1"># check if any key appear in the doc</span>
                    <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_for_checking</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                            <span class="n">key_in_doc</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">key_in_doc</span><span class="p">:</span>
                        <span class="n">missing_xref_key_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_xref_k</span><span class="p">)</span>
        <span class="c1"># missing required xref keys, should be deleted</span>
        <span class="k">if</span> <span class="n">missing_xref_key_list</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;required xref keys: &quot;</span>
            <span class="k">for</span> <span class="n">missing_key</span> <span class="ow">in</span> <span class="n">missing_xref_key_list</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing_key</span><span class="p">)</span>
            <span class="n">error_msg</span> <span class="o">+=</span> <span class="s2">&quot;are missing.&quot;</span>

            <span class="c1"># delete this document</span>
            <span class="k">if</span> <span class="n">delete_missing_xref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delete_data</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span> <span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2"> the document is deleted.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">fixed_cnt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">log_helper</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>

        <span class="c1"># 3. try to fix the mismtach errors in the doc</span>
        <span class="n">update_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># if not the schema keys, ignore schema type check enforcement</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="c1"># delete undefined attributes in the doc if delete_undefined is True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">delete_undefined</span><span class="p">:</span>
                    <span class="c1"># try to rename the user specified keys</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_undefined</span><span class="p">:</span>
                        <span class="n">update_dict</span><span class="p">[</span><span class="n">rename_undefined</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">update_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="c1"># to remove aliases, get the unique key name defined in the schema</span>
            <span class="n">unique_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">update_dict</span><span class="p">[</span><span class="n">unique_k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span>
                        <span class="n">unique_k</span>
                    <span class="p">)(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">attribute </span><span class="si">{}</span><span class="s2"> conversion from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> is done.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">log_helper</span><span class="p">,</span>
                            <span class="n">unique_k</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fixed_cnt</span><span class="p">:</span>
                        <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fixed_cnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">print_messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">attribute </span><span class="si">{}</span><span class="s2"> conversion from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> cannot be done.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">log_helper</span><span class="p">,</span>
                            <span class="n">unique_k</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_k</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># attribute values remain the same</span>
                <span class="n">update_dict</span><span class="p">[</span><span class="n">unique_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># 4. update the fixed attributes in the document in the collection</span>
        <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}</span>
        <span class="c1"># use replace_one here because there may be some aliases in the document</span>
        <span class="n">col</span><span class="o">.</span><span class="n">replace_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="n">update_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">print_messages</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fixed_cnt</span></div>

<div class="viewcode-block" id="Database.verify"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.verify">[docs]</a>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document_id</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span> <span class="n">tests</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;xref&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;undefined&quot;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an atomic-level operation to search for known issues in</span>
<span class="sd">        Metadata stored in a database and needed to construct a valid</span>
<span class="sd">        data set for starting a workflow.  By &quot;atomic&quot; we main the operation</span>
<span class="sd">        is for a single document in MongoDB linked to an atomic data</span>
<span class="sd">        object (currently that means TimeSeries or Seismogram objects).</span>
<span class="sd">        The tests are the same as those available through the command</span>
<span class="sd">        line tool dbverify.  See the man page for that tool and the</span>
<span class="sd">        user&#39;s manual for more details about the tests this method</span>
<span class="sd">        enables.</span>

<span class="sd">        :param document_id: the value of the _id field in the document you want to verify</span>
<span class="sd">        :type document_id: :class:`bson.objectid.ObjectId` of document to be tested</span>
<span class="sd">        :param collection: the name of collection to which document_id is</span>
<span class="sd">         expected to provide a unique match.  If not specified, uses the default wf collection</span>
<span class="sd">        :param tests: this should be a python list of test to apply by</span>
<span class="sd">         name keywords.  Test nams allowed are &#39;xref&#39;, &#39;type&#39;,</span>
<span class="sd">         and &#39;undefined&#39;.   Default runs all tests.   Specify a subset of those</span>
<span class="sd">         keywords to be more restrictive.</span>
<span class="sd">        :type tests: :class:`list` of :class:`str`</span>

<span class="sd">        :return: a python dict keyed by a problematic key.  The value in each</span>
<span class="sd">          entry is the name of the failed test (i.e. &#39;xref&#39;, &#39;type&#39;, or &#39;undefined&#39;)</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        :excpetion: This method will throw a fatal error exception if the</span>
<span class="sd">          id received does no match any document in the database.  That is</span>
<span class="sd">          intentional as the method should normally appear in a loop over</span>
<span class="sd">          ids found after query and the ids should then always be valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check tests</span>
        <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xref&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;undefined&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;only xref, type and undefined are supported, but </span><span class="si">{}</span><span class="s2"> is requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">test</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># remove redundant if happens</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tests</span><span class="p">))</span>

        <span class="n">problematic_keys</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">document_id</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Database.verify:  objectid=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">document_id</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; has no matching document in &quot;</span>
                <span class="o">+</span> <span class="n">collection</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># run the tests</span>
        <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;xref&quot;</span><span class="p">:</span>
                <span class="c1"># test every possible xref keys in the doc</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xref_key</span><span class="p">(</span>
                        <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_bad_xref_key</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                            <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;undefined&quot;</span><span class="p">:</span>
                <span class="n">undefined_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_undefined_keys</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">undefined_keys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
                <span class="c1"># check if there are type mismatch between keys in doc and keys in schema</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_mismatch_key</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">problematic_keys</span><span class="p">:</span>
                            <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">problematic_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">problematic_keys</span></div>

    <span class="k">def</span> <span class="nf">_check_xref_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">xref_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atmoic function checks for a single xref_key in a single document</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>
<span class="sd">        :param xref_key:  the xref key we need to check in the document</span>

<span class="sd">        :return: (is_bad_xref_key, is_bad_wf)</span>
<span class="sd">        :rtype: a :class:`tuple` of two :class:`bool`s</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># if xref_key is not defind -&gt; not checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">xref_key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="c1"># if xref_key is not a xref_key -&gt; not checking</span>
        <span class="n">unique_xref_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_xref_key</span><span class="p">(</span><span class="n">unique_xref_key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="c1"># if the xref_key is not in the doc -&gt; bad_wf</span>
        <span class="k">if</span> <span class="n">xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span> <span class="ow">and</span> <span class="n">unique_xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

        <span class="k">if</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">xref_key_val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">xref_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xref_key_val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">unique_xref_key</span><span class="p">]</span>

        <span class="c1"># if we can&#39;t find document in the normalized collection/invalid xref_key naming -&gt; bad_xref_key</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">unique_xref_key</span> <span class="ow">and</span> <span class="n">unique_xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span>
            <span class="n">normalized_collection_name</span> <span class="o">=</span> <span class="n">unique_xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">normalized_collection_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span>
                <span class="n">normalized_collection_name</span>
            <span class="p">)</span>
            <span class="n">normalized_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">normalized_collection_name</span><span class="p">]</span>
            <span class="c1"># try to find the referenced docuement</span>
            <span class="n">normalized_doc</span> <span class="o">=</span> <span class="n">normalized_col</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">xref_key_val</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">normalized_doc</span><span class="p">:</span>
                <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># invalid xref_key name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_bad_xref_key</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span>

    <span class="k">def</span> <span class="nf">_check_undefined_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atmoic function checks for if there are undefined required keys in a single document</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>

<span class="sd">        :return: undefined_keys</span>
<span class="sd">        :rtype: :class:`list`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">undefined_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># check if doc has every required key in the collection schema</span>
        <span class="n">unique_doc_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># change possible aliases to unique keys</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">unique_doc_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_doc_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># check every required keys in the collection schema</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">required_keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_doc_keys</span><span class="p">:</span>
                <span class="n">undefined_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">undefined_keys</span>

    <span class="k">def</span> <span class="nf">_check_mismatch_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This atmoic function checks for if the key is mismatch with the schema</span>

<span class="sd">        :param doc:  the wf document, which is a type of dict</span>
<span class="sd">        :param collection: the name of collection saving the document.</span>
<span class="sd">        :param key:  the key we need to check in the document</span>

<span class="sd">        :return: is_mismatch_key, if True, it means key is mismatch with the schema</span>
<span class="sd">        :rtype: :class:`bool`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_mismatch_key</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">unique_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span> <span class="k">else</span> <span class="n">doc</span><span class="p">[</span><span class="n">unique_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">unique_key</span><span class="p">)):</span>
                <span class="n">is_mismatch_key</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_mismatch_key</span>

    <span class="k">def</span> <span class="nf">_delete_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">keylist</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes all occurrences of attributes linked to keys defined</span>
<span class="sd">        in a list of keywords passed as (required) keylist argument.</span>
<span class="sd">        If a key is not in a given document no action is taken.</span>

<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param keylist:  list of keys for elements of each document</span>
<span class="sd">        that are to be deleted.   key are not test against schema</span>
<span class="sd">        but all matches will be deleted.</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when ``True`` edit will produce a line of printed</span>
<span class="sd">        output describing what was deleted.  Use this option only if</span>
<span class="sd">        you know from dbverify the number of changes to be made are small.</span>

<span class="sd">        :return:  dict keyed by the keys of all deleted entries.  The value</span>
<span class="sd">        of each entry is the number of documents the key was deleted from.</span>
<span class="sd">        :rtype: :class:`dict`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># preload counts to 0 so we get a return saying 0 when no changes</span>
        <span class="c1"># are made</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">todel</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keylist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">todel</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Deleted &quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="s2">&quot; with key=&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot; from doc with id=&quot;</span><span class="p">,</span> <span class="nb">id</span>
                        <span class="p">)</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$unset&quot;</span><span class="p">:</span> <span class="n">todel</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_rename_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">rename_map</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames specified keys for all or a subset of documents in a</span>
<span class="sd">        MongoDB collection.   The updates are driven by an input python</span>
<span class="sd">        dict passed as the rename_map argument. The keys of rename_map define</span>
<span class="sd">        doc keys that should be changed.  The values of the key-value</span>
<span class="sd">        pairs in rename_map are the new keys assigned to each match.</span>


<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param rename_map:  remap definition dict used as described above.</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when true edit will produce a line of printed</span>
<span class="sd">        output describing what was deleted.  Use this option only if</span>
<span class="sd">        you know from dbverify the number of changes to be made are small.</span>
<span class="sd">        When false the function runs silently.</span>

<span class="sd">        :return:  dict keyed by the keys of all changed entries.  The value</span>
<span class="sd">        of each entry is the number of documents changed.  The keys are the</span>
<span class="sd">        original keys.  displays of result should old and new keys using</span>
<span class="sd">        the rename_map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># preload counts to 0 so we get a return saying 0 when no changes</span>
        <span class="c1"># are made</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rename_map</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">newkey</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Changed attribute with key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; to have new key=&quot;</span><span class="p">,</span>
                            <span class="n">newkey</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attribute value=&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">doc</span><span class="p">[</span><span class="n">newkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">replace_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="n">doc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_fix_attribute_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function attempts to fix type collisions in the schema defined</span>
<span class="sd">        for the specified database and collection.  It tries to fix any</span>
<span class="sd">        type mismatch that can be repaired by the python equivalent of a</span>
<span class="sd">        type cast (an obscure syntax that can be seen in the actual code).</span>
<span class="sd">        Known examples are it can cleanly convert something like an int to</span>
<span class="sd">        a float or vice-versa, but it cannot do something like convert an</span>
<span class="sd">        alpha string to a number. Note, however, that python does cleanly</span>
<span class="sd">        convert simple number strings to number.  For example:  x=int(&#39;10&#39;)</span>
<span class="sd">        will yield an &quot;int&quot; class number of 10.  x=int(&#39;foo&#39;), however, will</span>
<span class="sd">        not work.   Impossible conversions will not abort the function but</span>
<span class="sd">        will generate an error message printed to stdout.  The function</span>
<span class="sd">        continues on so if there are a large number of such errors the</span>
<span class="sd">        output could become voluminous.  ALWAYS run dbverify before trying</span>
<span class="sd">        this function (directly or indirectly through the command line</span>
<span class="sd">        tool dbclean).</span>

<span class="sd">        :param collection:  MongoDB collection to be updated</span>
<span class="sd">        :param query: optional query string passed to find database</span>
<span class="sd">        collection method.  Can be used to limit edits to documents</span>
<span class="sd">        matching the query.  Default is the entire collection.</span>
<span class="sd">        :param verbose:  when true edit will produce one or more lines of</span>
<span class="sd">        printed output for each change it makes.  The default is false.</span>
<span class="sd">        Needless verbose should be avoided unless you are certain the</span>
<span class="sd">        number of changes it will make are small.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;////////Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;/////////&quot;</span><span class="p">)</span>
            <span class="n">up_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Warning:  in doc with id=&quot;</span><span class="p">,</span>
                            <span class="nb">id</span><span class="p">,</span>
                            <span class="s2">&quot;found key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; that is not defined in the schema&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Value of key-value pair=&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot check type for an unknown attribute name&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">newval</span> <span class="o">=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span><span class="n">val</span><span class="p">)</span>
                        <span class="n">up_d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">newval</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;Changed data for key=&quot;</span><span class="p">,</span>
                                <span class="n">k</span><span class="p">,</span>
                                <span class="s2">&quot; from &quot;</span><span class="p">,</span>
                                <span class="n">val</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">newval</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;////////Document id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot;/////////&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;WARNING:  could not convert attribute with key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; and value=&quot;</span><span class="p">,</span>
                            <span class="n">val</span><span class="p">,</span>
                            <span class="s2">&quot; to required type=&quot;</span><span class="p">,</span>
                            <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This error was thrown and handled:  &quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="nb">id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">up_d</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">_check_links</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xref_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">error_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks for missing cross-referencing ids in a</span>
<span class="sd">        specified wf collection (i.e. wf_TimeSeries or wf_Seismogram)</span>
<span class="sd">        It scans the wf collection to detect two potential errors:</span>
<span class="sd">        (1) documents with the normalization key completely missing</span>
<span class="sd">        and (2) documents where the key is present does not match any</span>
<span class="sd">        document in normalization collection.   By default this</span>
<span class="sd">        function operates silently assuming the caller will</span>
<span class="sd">        create a readable report from the return that defines</span>
<span class="sd">        the documents that had errors.  This function is used in the</span>
<span class="sd">        verify standalone program that acts as a front end to tests</span>
<span class="sd">        in this module.  The function can be run in independently</span>
<span class="sd">        so there is a verbose option to print errors as they are encountered.</span>

<span class="sd">        :param xref_key: the normalized key you would like to check</span>
<span class="sd">        :param collection:  mspass waveform collection on which the normalization</span>
<span class="sd">        check is to be performed.  default is wf_TimeSeries.</span>
<span class="sd">        Currently only accepted alternative is wf_Seismogram.</span>
<span class="sd">        :param wfquery:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire wf collection.</span>
<span class="sd">        :param verbose:  when True errors will be printed.  By default</span>
<span class="sd">        the function works silently and you should use the output to</span>
<span class="sd">        interact with any errors returned.</span>
<span class="sd">        :param error_limit: Is a sanity check on the number of errors logged.</span>
<span class="sd">        Errors of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  returns a tuple with two lists.  Both lists are ObjectIds</span>
<span class="sd">        of the scanned wf collection that have errors.  component 0</span>
<span class="sd">        of the tuple contains ids of wf entries that have the normalization</span>
<span class="sd">        id set but the id does not resolve with the normalization collection.</span>
<span class="sd">        component 1 contains the ids of documents in the wf collection that</span>
<span class="sd">        do not contain the normalization id key at all (a more common problem)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># schema doesn&#39;t currently have a way to list normalized</span>
        <span class="c1"># collection names.  For now we just freeze the names</span>
        <span class="c1"># and put them in this one place for maintainability</span>

        <span class="c1"># undefined collection name in the schema</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_links:  collection </span><span class="si">{}</span><span class="s2"> is not defined in database schema&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># get all the xref_keys in the collection by schema</span>
        <span class="n">xref_keys_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">xref_keys</span><span class="p">()</span>

        <span class="c1"># the list of xref_key that should be checked</span>
        <span class="n">xref_keys</span> <span class="o">=</span> <span class="n">xref_key</span>

        <span class="c1"># if xref_key is not defined, check all xref_keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xref_key</span><span class="p">:</span>
            <span class="n">xref_keys</span> <span class="o">=</span> <span class="n">xref_keys_list</span>

        <span class="c1"># if specified as a single key, wrap it as a list for better processing next</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">xref_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">xref_key</span><span class="p">]</span>

        <span class="c1"># check every key in the xref_key list if it is legal</span>
        <span class="k">for</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">xref_keys</span><span class="p">:</span>
            <span class="n">unique_xref_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">xref_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unique_xref_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xref_keys_list</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_links:  illegal value for normalize arg=&quot;</span> <span class="o">+</span> <span class="n">xref_key</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span>

        <span class="c1"># We accumulate bad ids in this list that is returned</span>
        <span class="n">bad_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">missing_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># check for each xref_key in xref_keys</span>
        <span class="k">for</span> <span class="n">xref_key</span> <span class="ow">in</span> <span class="n">xref_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">xref_key</span> <span class="ow">and</span> <span class="n">xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;id&quot;</span><span class="p">:</span>
                <span class="n">normalize</span> <span class="o">=</span> <span class="n">xref_key</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">normalize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">normalize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_links:  illegal value for normalize arg=&quot;</span>
                    <span class="o">+</span> <span class="n">xref_key</span>
                    <span class="o">+</span> <span class="s2">&quot; should be in the form of xxx_id&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">dbwf</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">dbwf</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;checklinks:  &quot;</span>
                    <span class="o">+</span> <span class="n">wf_collection</span>
                    <span class="o">+</span> <span class="s2">&quot; collection has no data matching query=&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">wfquery</span><span class="p">),</span>
                    <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Starting cross reference link check for &quot;</span><span class="p">,</span>
                    <span class="n">wf_collection</span><span class="p">,</span>
                    <span class="s2">&quot; collection using id=&quot;</span><span class="p">,</span>
                    <span class="n">xref_key</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This should resolve links to &quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="s2">&quot; collection&quot;</span><span class="p">)</span>

            <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbwf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
                <span class="n">wfid</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
                <span class="n">is_bad_xref_key</span><span class="p">,</span> <span class="n">is_bad_wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xref_key</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span> <span class="n">wf_collection</span><span class="p">,</span> <span class="n">xref_key</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_bad_xref_key</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wfid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bad_id_list</span><span class="p">:</span>
                        <span class="n">bad_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">wfid</span><span class="p">),</span> <span class="s2">&quot; link with &quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">xref_key</span><span class="p">),</span> <span class="s2">&quot; failed&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_id_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">error_limit</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;checklinks:  number of bad id errors exceeds internal limit&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_bad_wf</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wfid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missing_id_list</span><span class="p">:</span>
                        <span class="n">missing_id_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfid</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">wfid</span><span class="p">),</span> <span class="s2">&quot; is missing required key=&quot;</span><span class="p">,</span> <span class="n">xref_key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_id_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">error_limit</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;checklinks:  number of missing id errors exceeds internal limit&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">bad_id_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_id_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                <span class="p">):</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bad_id_list</span><span class="p">,</span> <span class="n">missing_id_list</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_check_attribute_types</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">error_limit</span><span class="o">=</span><span class="mi">1000</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the integrity of all attributes</span>
<span class="sd">        found in a specfied collection.  It is designed to detect two</span>
<span class="sd">        kinds of problems:  (1) type mismatches between what is stored</span>
<span class="sd">        in the database and what is defined for the schema, and (2)</span>
<span class="sd">        data with a key that is not recognized.  Both tests are necessary</span>
<span class="sd">        because unlike a relational database MongoDB is very promiscuous</span>
<span class="sd">        about type and exactly what goes into a document.  MongoDB pretty</span>
<span class="sd">        much allow type it knows about to be associated with any key</span>
<span class="sd">        you choose.   In MsPASS we need to enforce some type restrictions</span>
<span class="sd">        to prevent C++ wrapped algorithms from aborting with type mismatches.</span>
<span class="sd">        Hence, it is important to run this test on all collections needed</span>
<span class="sd">        by a workflow before starting a large job.</span>

<span class="sd">        :param collection:  MongoDB collection that is to be scanned</span>
<span class="sd">        for errors.  Note with normalized data this function should be</span>
<span class="sd">        run on the appropriate wf collection and all normalization</span>
<span class="sd">        collections the wf collection needs to link to.</span>
<span class="sd">        :param query:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire collection requested.</span>
<span class="sd">        :param verbose:  when True errors will be printed.   The default is</span>
<span class="sd">        False and the function will do it&#39;s work silently.   Verbose is</span>
<span class="sd">        most useful in an interactive python session where the function</span>
<span class="sd">        is called directly.  Most users will run this function</span>
<span class="sd">        as part of tests driven by the dbverify program.</span>
<span class="sd">        :param error_limit: Is a sanity check the number of errors logged</span>
<span class="sd">        The number of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  returns a tuple with two python dict containers.</span>
<span class="sd">        The component 0 python dict contains details of type mismatch errors.</span>
<span class="sd">        Component 1 contains details for data with undefined keys.</span>
<span class="sd">        Both python dict containers are keyed by the ObjectId of the</span>
<span class="sd">        document from which they were retrieved.  The values associated</span>
<span class="sd">        with each entry are like MongoDB subdocuments.  That is, the value</span>
<span class="sd">        return is itself a dict. The dict value contains key-value pairs</span>
<span class="sd">        that defined the error (type mismatch for 0 and undefined for 1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># The following two can throw MsPASS errors but we let them</span>
        <span class="c1"># do so. Callers should have a handler for MsPASSError</span>
        <span class="n">dbschema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="c1"># This holds the schema for the collection to be scanned</span>
        <span class="c1"># dbschema is mostly an index to one of these</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">dbschema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_attribute_types:  query=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; yields zero matching documents&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">bad_type_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">undefined_key_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">bad_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">undefined_keys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">bad_types</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;doc with id=&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="s2">&quot; type mismatch for key=&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;value=&quot;</span><span class="p">,</span>
                                <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                <span class="s2">&quot; does not match expected type=&quot;</span><span class="p">,</span>
                                <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">undefined_keys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;doc with id=&quot;</span><span class="p">,</span>
                            <span class="nb">id</span><span class="p">,</span>
                            <span class="s2">&quot; has undefined key=&quot;</span><span class="p">,</span>
                            <span class="n">k</span><span class="p">,</span>
                            <span class="s2">&quot; with value=&quot;</span><span class="p">,</span>
                            <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bad_type_docs</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_types</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">undefined_key_docs</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">undefined_keys</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">undefined_key_docs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_type_docs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span>
            <span class="p">):</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bad_type_docs</span><span class="p">,</span> <span class="n">undefined_key_docs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_check_required</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">],</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">error_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies a test to assure a list of attributes</span>
<span class="sd">        are defined and of the right type.   This function is needed</span>
<span class="sd">        because certain attributes are essential in two different contexts.</span>
<span class="sd">        First, for waveform data there are some attributes that are</span>
<span class="sd">        required to construct the data object (e.g. sample interal or</span>
<span class="sd">        sample rate, start time, etc.).  Secondly, workflows generally</span>
<span class="sd">        require certain Metadata and what is required depends upon the</span>
<span class="sd">        workflow.  For example, any work with sources normally requires</span>
<span class="sd">        information about both station and instrument properties as well</span>
<span class="sd">        as source.  The opposite is noise correlation work where only</span>
<span class="sd">        station information is essential.</span>

<span class="sd">        :param collection:  MongoDB collection that is to be scanned</span>
<span class="sd">        for errors.  Note with normalized data this function should be</span>
<span class="sd">        run on the appropriate wf collection and all normalization</span>
<span class="sd">        collections the wf collection needs to link to.</span>
<span class="sd">        :param keys:  is a list of strings that are to be checked</span>
<span class="sd">        against the contents of the collection.  Note one of the first</span>
<span class="sd">        things the function does is test for the validity of the keys.</span>
<span class="sd">        If they are not defined in the schema the function will throw</span>
<span class="sd">        a MsPASSError exception.</span>
<span class="sd">        :param query:  optional dict passed as a query to limit the</span>
<span class="sd">        documents scanned by the function.   Default will process the</span>
<span class="sd">        entire collection requested.</span>
<span class="sd">        :param verbose:  when True errors will be printed.   The default is</span>
<span class="sd">        False and the function will do it&#39;s work silently.   Verbose is</span>
<span class="sd">        most useful in an interactive python session where the function</span>
<span class="sd">        is called directly.  Most users will run this function</span>
<span class="sd">        as part of tests driven by the dbverify program.</span>
<span class="sd">        :param error_limit: Is a sanity check the number of errors logged</span>
<span class="sd">        The number of any type are limited to this number (default 1000).</span>
<span class="sd">        The idea is errors should be rare and if this number is exceeded</span>
<span class="sd">        you have a big problem you need to fix before scanning again.</span>
<span class="sd">        The number should be large enough to catch all condition but</span>
<span class="sd">        not so huge it become cumbersome.  With no limit or a memory</span>
<span class="sd">        fault is even possible on a huge dataset.</span>
<span class="sd">        :return:  tuple with two components. Both components contain a</span>
<span class="sd">        python dict container keyed by ObjectId of problem documents.</span>
<span class="sd">        The values in the component 0 dict are themselves python dict</span>
<span class="sd">        containers that are like MongoDB subdocuments).  The key-value</span>
<span class="sd">        pairs in that dict are required data with a type mismatch with the schema.</span>
<span class="sd">        The values in component 1 are python lists of keys that had</span>
<span class="sd">        no assigned value but were defined as required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_required:  list of required keys is empty &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;- nothing to test&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># The following two can throw MsPASS errors but we let them</span>
        <span class="c1"># do so. Callers should have a handler for MsPASSError</span>
        <span class="n">dbschema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span>
        <span class="c1"># This holds the schema for the collection to be scanned</span>
        <span class="c1"># dbschema is mostly an index to one of these</span>
        <span class="n">col_schema</span> <span class="o">=</span> <span class="n">dbschema</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="c1"># We first make sure the user didn&#39;t make a mistake in giving an</span>
        <span class="c1"># invalid key for the required list</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;check_required:  schema has no definition for key=&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;check_required:  query=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; yields zero matching documents&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">undef</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">wrong_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
            <span class="n">undef_this</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">wrong_this</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">undef_this</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">wrong_this</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undef_this</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">undef</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">undef_this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrong_this</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wrong_types</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_this</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrong_types</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">undef</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">error_limit</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">wrong_types</span><span class="p">,</span> <span class="n">undef</span><span class="p">])</span>

<div class="viewcode-block" id="Database.update_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">update_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cautious&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method if you want to save the output of a processing algorithm</span>
<span class="sd">        whose output is only posted to metadata.   That can be something as</span>
<span class="sd">        simple as a little python function that does some calculations on other</span>
<span class="sd">        metadata field, or as elaborate as a bound FORTRAN or C/C++ function</span>
<span class="sd">        that computes something, posts the results to Metadata, but doesn&#39;t</span>
<span class="sd">        actually alter the sample data.   A type example of the later is an amplitude</span>
<span class="sd">        calculation that posts the computed amplitude to some metadata key value.</span>

<span class="sd">        This method will ONLY attempt to update Metadata attributes stored in the</span>
<span class="sd">        data passed (mspass_object) that have been marked as having been</span>
<span class="sd">        changed since creation of the data object.  The default mode will</span>
<span class="sd">        check entries against the schema and attempt to fix any type</span>
<span class="sd">        mismatches (mode==&#39;cautious&#39; for this algorithm).  In cautious or</span>
<span class="sd">        pedantic mode this method can end up posting a lot of errors in</span>
<span class="sd">        elog for data object (mspass_object) being handled.  In</span>
<span class="sd">        promiscuous mode there are no safeties and the any values</span>
<span class="sd">        that are defined in Metadata as having been changed will be</span>
<span class="sd">        posted as an update to the parent wf document to the data object.</span>

<span class="sd">        A feature of the schema that is considered an unbreakable rule is</span>
<span class="sd">        that any attribute marked &quot;readonly&quot; in the schema cannot by</span>
<span class="sd">        definition be updated with this method.  It utilizes the same</span>
<span class="sd">        method for handling this as the save_data method.  That is,</span>
<span class="sd">        for all &quot;mode&quot; parameters if an key is defined in the schema as</span>
<span class="sd">        readonly and it is listed as having been modified, it will</span>
<span class="sd">        be save with a new key creating by adding the prefix</span>
<span class="sd">        &quot;READONLYERROR_&quot; .  e.g. if we had a site_sta read as</span>
<span class="sd">        &#39;AAK&#39; but we changed it to &#39;XYZ&#39; in a workflow, when we tried</span>
<span class="sd">        to save the data you will find an entry in the document</span>
<span class="sd">        of {&#39;READONLYERROR_site_sta&#39; : &#39;XYZ&#39;}</span>

<span class="sd">        :param mspass_object: the object you want to update.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param exclude_keys: a list of metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param force_keys: a list of metadata attributes you want to force</span>
<span class="sd">         to be updated.   Normally this method will only update attributes</span>
<span class="sd">         that have been marked as changed since creation of the parent data</span>
<span class="sd">         object.  If data with these keys is found in the mspass_object they</span>
<span class="sd">         will be added to the update record.</span>
<span class="sd">        :type force_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param mode: This parameter defines how attributes defines how</span>
<span class="sd">          strongly to enforce schema constraints. As described above</span>
<span class="sd">          &#39;promiscuous&#39; justs updates all changed values with no schema</span>
<span class="sd">          tests.  &#39;cautious&#39;, the default, enforces type constraints and</span>
<span class="sd">          tries to convert easily fixed type mismatches (e.g. int to floats</span>
<span class="sd">          of vice versa).  Both &#39;cautious&#39; and &#39;pedantic&#39; may leave one or</span>
<span class="sd">          more complaint message in the elog of mspass_object on how the</span>
<span class="sd">          method did or did not fix mismatches with the schema.  Both</span>
<span class="sd">          also will drop any key-value pairs where the value cannot be</span>
<span class="sd">          converted to the type defined in the schema.</span>

<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">        :type alg_name: :class:`str`</span>
<span class="sd">        :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">        :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :return: mspass_object data.  Normally this is an unaltered copy</span>
<span class="sd">          of the data passed through mspass_object.  If there are errors,</span>
<span class="sd">          however, the elog will contain new messages.  Note any such</span>
<span class="sd">          messages are volatile and will not be saved to the database</span>
<span class="sd">          until the save_data method is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;:  only TimeSeries and Seismogram are supported</span><span class="se">\n</span><span class="s2">Received data of type=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># Return a None immediately if the data is marked dead - signal it did nothing</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span> <span class="s2">&quot;cautious&quot;</span><span class="p">,</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;: only promiscuous, cautious and pedantic are supported, but </span><span class="si">{}</span><span class="s2"> was requested.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mode</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">wfid</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="n">alg_name</span>
                <span class="o">+</span> <span class="s2">&quot;: input data object is missing required waveform object id value (_id) - update is not possible without it&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
            <span class="c1"># A weird construct</span>
            <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>
        <span class="c1"># One last check.  Make sure a document with the _id in mspass_object</span>
        <span class="c1"># exists.  If it doesn&#39;t exist, post an elog about this</span>
        <span class="n">test_doc</span> <span class="o">=</span> <span class="n">wf_collection</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wfid</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_doc</span><span class="p">:</span>  <span class="c1"># find_one returns None if find fails</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Cannot find the document in the wf collection by the _id field in the object&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># FIXME starttime will be automatically created in this function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

        <span class="c1"># This method of Metadata returns a list of all</span>
        <span class="c1"># attributes that were changed after creation of the</span>
        <span class="c1"># object to which they are attached.</span>
        <span class="n">changed_key_list</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">modified</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">force_keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">force_keys</span><span class="p">:</span>
                <span class="n">changed_key_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">copied_metadata</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

        <span class="c1"># clear all the aliases</span>
        <span class="c1"># TODO  check for potential bug in handling clear_aliases</span>
        <span class="c1"># and modified method - i.e. keys returned by modified may be</span>
        <span class="c1"># aliases</span>
        <span class="n">save_schema</span><span class="o">.</span><span class="n">clear_aliases</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">)</span>

        <span class="c1"># remove any values with only spaces</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># remove any defined items in exclude list</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclude_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># Now remove any readonly data</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                        <span class="n">newkey</span> <span class="o">=</span> <span class="s2">&quot;READONLYERROR_&quot;</span> <span class="o">+</span> <span class="n">k</span>
                        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">change_key</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;Database.update_metadata&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;readonly attribute with key=&quot;</span>
                            <span class="o">+</span> <span class="n">k</span>
                            <span class="o">+</span> <span class="s2">&quot; was improperly modified.  Saved changed value with key=&quot;</span>
                            <span class="o">+</span> <span class="n">newkey</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">copied_metadata</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="c1"># Done editing, now we convert copied_metadata to a python dict</span>
        <span class="c1"># using this Metadata method or the long version when in cautious or pedantic mode</span>
        <span class="n">insertion_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;promiscuous&quot;</span><span class="p">:</span>
            <span class="c1"># In this case we blindly update all entries that show</span>
            <span class="c1"># as modified that aren&#39;t in the exclude list</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                    <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Other modes have to test every key and type of value</span>
            <span class="c1"># before continuing.  pedantic logs an error for all problems</span>
            <span class="c1"># Both attempt to fix type mismatches before update.  Cautious</span>
            <span class="c1"># is silent unless the type problem cannot be repaired.  In that</span>
            <span class="c1"># case both will not attempt to update the offending key-value</span>
            <span class="c1"># Note many errors can be posted - one for each problem key-value pair</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">copied_metadata</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">changed_key_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;pedantic mode error:  key=&quot;</span> <span class="o">+</span> <span class="n">k</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="s2">&quot; type of stored value=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot; does not match schema expectation=&quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting to correct type mismatch&quot;</span>
                                <span class="p">)</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                <span class="p">)</span>
                            <span class="c1"># Note we land here for both pedantic and cautious but not promiscuous</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># The following convert the actual value in a dict to a required type.</span>
                                <span class="c1"># This is because the return of type() is the class reference.</span>
                                <span class="n">old_value</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">)(</span>
                                    <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="p">)</span>
                                <span class="n">new_value</span> <span class="o">=</span> <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="s2">&quot;Had to convert type of data with key=&quot;</span>
                                    <span class="o">+</span> <span class="n">k</span>
                                    <span class="o">+</span> <span class="s2">&quot; from &quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">old_value</span><span class="p">))</span>
                                    <span class="o">+</span> <span class="s2">&quot; to &quot;</span>
                                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">new_value</span><span class="p">))</span>
                                <span class="p">)</span>
                                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                    <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Cannot update data with key=&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                                    <span class="c1"># pedantic mode</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                    <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                        <span class="s2">&quot;pedantic mode error: key value could not be converted to required type=&quot;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                        <span class="o">+</span> <span class="s2">&quot; actual type=&quot;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                        <span class="o">+</span> <span class="s2">&quot;, the object is killed&quot;</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># cautious mode</span>
                                    <span class="k">if</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot; Required key value could not be converted to required type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                            <span class="o">+</span> <span class="s2">&quot; actual type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                            <span class="o">+</span> <span class="s2">&quot;, the object is killed&quot;</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                                            <span class="s2">&quot; Value stored has type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                            <span class="o">+</span> <span class="s2">&quot; which cannot be converted to type=&quot;</span>
                                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_schema</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                                            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Data for this key will not be changed or set in the database&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Python error exception message caught:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="n">message</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                                <span class="c1"># post elog entry into the mspass_object</span>
                                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span> <span class="ow">or</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">is_required</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                        <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                        <span class="n">alg_name</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                                    <span class="p">)</span>
                                <span class="c1"># The None arg2 cause pop to not throw</span>
                                <span class="c1"># an exception if k isn&#39;t defined - a bit ambigous in the try block</span>
                                <span class="n">insertion_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pedantic&quot;</span><span class="p">:</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="n">alg_name</span><span class="p">,</span>
                                <span class="s2">&quot;cannot update data with key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; because it is not defined in the schema&quot;</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                                <span class="n">alg_name</span><span class="p">,</span>
                                <span class="s2">&quot;key=&quot;</span>
                                <span class="o">+</span> <span class="n">k</span>
                                <span class="o">+</span> <span class="s2">&quot; is not defined in the schema.  Updating record, but this may cause downstream problems&quot;</span><span class="p">,</span>
                                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">insertion_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># ugly python indentation with this logic.  We always land here in</span>
        <span class="c1"># any mode when we&#39;ve passed over the entire metadata dict</span>
        <span class="c1"># if it is dead, it&#39;s considered something really bad happens, we should not update the object</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">wf_collection</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wfid</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">insertion_dict</span><span class="p">},</span> <span class="n">upsert</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.update_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_data">[docs]</a>    <span class="k">def</span> <span class="nf">update_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;cautious&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;Database.update_data&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates both metadata and sample data corresponding to an input data</span>
<span class="sd">        object.</span>

<span class="sd">        Since storage of data objects in MsPASS is broken into multiple</span>
<span class="sd">        collections and storage methods, doing a full data update has some</span>
<span class="sd">        complexity.   This method handles the problem differently for the</span>
<span class="sd">        different pieces:</span>
<span class="sd">            1. An update is performed on the parent wf collection document.</span>
<span class="sd">               That update makes use of the related Database method</span>
<span class="sd">               called update_metadata.</span>
<span class="sd">            2. If the error log is not empty it is saved.</span>
<span class="sd">            3. If the history container has contents it is saved.</span>
<span class="sd">            4. The sample data is the thorniest problem. Currently this</span>
<span class="sd">               method will only do sample updates for data stored in</span>
<span class="sd">               the mongodb gridfs system.   With files containing multiple</span>
<span class="sd">               waveforms it would be necessary to append to the files and</span>
<span class="sd">               this could create a blaat problem with large data sets so</span>
<span class="sd">               we do not currently support that type of update.</span>

<span class="sd">        :param mspass_object: the object you want to update.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param exclude_keys: a list of metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param force_keys: a list of metadata attributes you want to force</span>
<span class="sd">         to be updated.   Normally this method will only update attributes</span>
<span class="sd">         that have been marked as changed since creation of the parent data</span>
<span class="sd">         object.  If data with these keys is found in the mspass_object they</span>
<span class="sd">         will be added to the update record.</span>
<span class="sd">        :type force_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param mode: This parameter defines how attributes defines how</span>
<span class="sd">          strongly to enforce schema constraints. As described above</span>
<span class="sd">          &#39;promiscuous&#39; justs updates all changed values with no schema</span>
<span class="sd">          tests.  &#39;cautious&#39;, the default, enforces type constraints and</span>
<span class="sd">          tries to convert easily fixed type mismatches (e.g. int to floats</span>
<span class="sd">          of vice versa).  Both &#39;cautious&#39; and &#39;pedantic&#39; may leave one or</span>
<span class="sd">          more complaint message in the elog of mspass_object on how the</span>
<span class="sd">          method did or did not fix mismatches with the schema.  Both</span>
<span class="sd">          also will drop any key-value pairs where the value cannot be</span>
<span class="sd">          converted to the type defined in the schema.</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">          (defaults to &#39;Database.update_data&#39; and should not normally need to be changed)</span>
<span class="sd">        :type alg_name: :class:`str`</span>
<span class="sd">        :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">        :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :return: mspass_object data.  Normally this is an unaltered copy</span>
<span class="sd">          of the data passed through mspass_object.  If there are errors,</span>
<span class="sd">          however, the elog will contain new messages.  All such messages,</span>
<span class="sd">          howevever, should be saved in the elog collection because elog</span>
<span class="sd">          is the last collection updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="c1"># First update metadata.  update_metadata will throw an exception</span>
        <span class="c1"># only for usage errors.   We test the elog size to check if there</span>
        <span class="c1"># are other warning messages and add a summary if there were any</span>
        <span class="n">logsize0</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">force_keys</span><span class="o">=</span><span class="n">force_keys</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="n">logsize</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="c1"># A bit verbose, but we post this warning to make it clear the</span>
        <span class="c1"># problem originated from update_data - probably not really needed</span>
        <span class="c1"># but better to be though I think</span>
        <span class="k">if</span> <span class="n">logsize</span> <span class="o">&gt;</span> <span class="n">logsize0</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="n">alg_name</span><span class="p">,</span>
                <span class="s2">&quot;update_metadata posted </span><span class="si">{nerr}</span><span class="s2"> messages during update&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">nerr</span><span class="o">=</span><span class="p">(</span><span class="n">logsize</span> <span class="o">-</span> <span class="n">logsize0</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># optional handle history - we need to update the wf record later with this value</span>
        <span class="c1"># if it is set</span>
        <span class="n">update_record</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="p">)</span>
        <span class="n">history_object_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="n">history_object_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">)</span>
            <span class="n">update_record</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>

        <span class="c1"># Now handle update of sample data.  The gridfs method used here</span>
        <span class="c1"># handles that correctly based on the gridfs id.</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;storage_mode&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                        <span class="n">alg_name</span><span class="p">,</span>
                        <span class="s2">&quot;found storage_mode=&quot;</span>
                        <span class="o">+</span> <span class="n">storage_mode</span>
                        <span class="o">+</span> <span class="s2">&quot;  Only support update to gridfs.  Changing to gridfs storage for sample data update&quot;</span><span class="p">,</span>
                        <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">alg_name</span><span class="p">,</span>
                    <span class="s2">&quot;storage_mode attribute was not set in Metadata of this object - setting as gridfs for update&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
                <span class="n">update_record</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gridfs&quot;</span>
            <span class="c1"># This logic depends upon a feature of _save_data_to_gridfs.</span>
            <span class="c1"># if the gridfs_id parameter is defined it does an update</span>
            <span class="c1"># when it is not defined it creates a new gridfs &quot;file&quot;. In both</span>
            <span class="c1"># cases the id needed to get the right datum is returned</span>
            <span class="k">if</span> <span class="s2">&quot;gridfs_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">gridfs_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_data_to_gridfs</span><span class="p">(</span>
                    <span class="n">mspass_object</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gridfs_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_data_to_gridfs</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridfs_id</span>
            <span class="c1"># There is a possible efficiency gain right here.  Not sure if</span>
            <span class="c1"># gridfs_id is altered when the sample data are updated in place.</span>
            <span class="c1"># if we can be sure the returned gridfs_id is the same as the</span>
            <span class="c1"># input in that case, we would omit gridfs_id from the update</span>
            <span class="c1"># record and most data would not require the final update</span>
            <span class="c1"># transaction below</span>
            <span class="n">update_record</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gridfs_id</span>
            <span class="c1"># should define wf_collection here because if the mspass_object is dead</span>
            <span class="k">if</span> <span class="n">collection</span><span class="p">:</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">collection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This returns a string that is the collection name for this atomic data type</span>
                <span class="c1"># A weird construct</span>
                <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">save_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
            <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span>

            <span class="n">elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="c1"># FIXME I think here we should check if elog_id field exists in the mspass_object</span>
                <span class="c1"># and we should update the elog entry if mspass_object already had one</span>
                <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                    <span class="n">old_elog_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">old_elog_id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># elog ids will be updated in the wf col when saving metadata</span>
                <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="n">old_elog_id</span><span class="p">)</span>
                <span class="n">update_record</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>

                <span class="c1"># update elog collection</span>
                <span class="c1"># we have to do the xref to wf collection like this too</span>
                <span class="n">elog_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)]</span>
                <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">}</span>
                <span class="n">elog_col</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                    <span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}}</span>
                <span class="p">)</span>
            <span class="c1"># finally we need to update the wf document if we set anything</span>
            <span class="c1"># in update_record</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">update_record</span><span class="p">):</span>
                <span class="n">filter_</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]}</span>
                <span class="n">wf_collection</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span><span class="n">filter_</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_record</span><span class="p">})</span>
                <span class="c1"># we may probably set the elog_id field in the mspass_object</span>
                <span class="k">if</span> <span class="n">elog_id</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_id</span>
                <span class="c1"># we may probably set the history_object_id field in the mspass_object</span>
                <span class="k">if</span> <span class="n">history_object_id</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">history_object_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dead data land here</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">old_elog_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_elog</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="n">old_elog_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mspass_object</span></div>

<div class="viewcode-block" id="Database.read_ensemble_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_ensemble_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_ensemble_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">objectid_list</span><span class="p">,</span>
        <span class="n">ensemble_metadata</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf&quot;</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;read_ensemble_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an subset of a dataset with some logical grouping into an Ensemble container.</span>

<span class="sd">        Ensembles are a core concept in MsPASS that are a generalization of</span>
<span class="sd">        fixed &quot;gather&quot; types frozen into every seismic reflection processing</span>
<span class="sd">        system we know of.  This reader is driven by a python list of</span>
<span class="sd">        MongoDB object ids.  The method calls the atomic read_data</span>
<span class="sd">        method for object_id to assemble the members of the ensemble.</span>
<span class="sd">        All arguments except the objectid_list and ensemble_metadata are</span>
<span class="sd">        passed directly to the read_data method in that loop.  The read_data</span>
<span class="sd">        method and the User&#39;s manual have more information about how those</span>
<span class="sd">        common arguments are used.</span>

<span class="sd">        :param objectid_list: a :class:`list` of :class:`bson.objectid.ObjectId`,</span>
<span class="sd">          of the ids defining the ensemble members or a :class:`pymongo.cursor.Cursor`</span>
<span class="sd">        :param ensemble_metadata:  is a dict or dict like container containing</span>
<span class="sd">          metadata to be stored in the ensemble&#39;s Metadata (common to the group)</span>
<span class="sd">          container.  A common choice would be to post the query used to</span>
<span class="sd">          define this ensemble, but there are not restictions.  The contents are</span>
<span class="sd">          simply copied verbatim to the ensemble metadata container. The default</span>
<span class="sd">          is an empty dict which translates to an empty ensemble metadata container.</span>
<span class="sd">        :type ensemble_metadata: python dict or any container that is iterable</span>
<span class="sd">          and supports the [key] key associative array syntax will work.</span>
<span class="sd">          (Note this means both Metadata containers or mongodb docs both can</span>
<span class="sd">          be used) The type of this arg is not tested so you may get a</span>
<span class="sd">          mysterious exception if the data the arg defines does no meet the</span>
<span class="sd">          two rules.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param normalize: normalized collection you want to read into a mspass object</span>
<span class="sd">        :type normalize: a :class:`list` of :class:`str`</span>
<span class="sd">        :param load_history: ``True`` to load object-level history into the mspasspy object.</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being read.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param collection: the collection name in the database that the object is stored. If not specified, use the default wf collection in the schema.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to filter the read. If not match, the record will be skipped.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        :return: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wf_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported, but </span><span class="si">{}</span><span class="s2"> is requested. Please check the data_type of </span><span class="si">{}</span><span class="s2"> collection.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">object_type</span><span class="p">,</span> <span class="n">wf_collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># if objectid_list is a cursor, convert the cursor to a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">objectid_list</span><span class="p">,</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">Cursor</span><span class="p">):</span>
            <span class="n">objectid_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objectid_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">is</span> <span class="n">TimeSeries</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objectid_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ensemble</span> <span class="o">=</span> <span class="n">SeismogramEnsemble</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objectid_list</span><span class="p">))</span>
        <span class="c1"># Here we post the ensemble metdata - see docstring notes on this feature</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ensemble_metadata</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensemble_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">objectid_list</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_data</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                <span class="n">load_history</span><span class="o">=</span><span class="n">load_history</span><span class="p">,</span>
                <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                <span class="n">collection</span><span class="o">=</span><span class="n">wf_collection</span><span class="p">,</span>
                <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># explicitly mark empty ensembles dead.  Otherwise assume if</span>
        <span class="c1"># we got this far we can mark it live</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ensemble</span></div>

<div class="viewcode-block" id="Database.save_ensemble_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_ensemble_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_ensemble_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;gridfs&quot;</span><span class="p">,</span>
        <span class="n">dir_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dfile_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;save_ensemble_data&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save an Ensemble container of a group of data objecs to MongoDB.</span>

<span class="sd">        Ensembles are a core concept in MsPASS that are a generalization of</span>
<span class="sd">        fixed &quot;gather&quot; types frozen into every seismic reflection processing</span>
<span class="sd">        system we know of.   This is is a writer for data stored in such a</span>
<span class="sd">        container.  It is little more than a loop over each &quot;member&quot; of the</span>
<span class="sd">        ensemble calling the Database.save_data method for each member.</span>
<span class="sd">        For that reason most of the arguments are passed downstream directly</span>
<span class="sd">        to save_data.   See the save_data method and the User&#39;s manual for</span>
<span class="sd">        more verbose descriptions of their behavior and expected use.</span>

<span class="sd">        The only complexity in handling an ensemble is that our implementation</span>
<span class="sd">        has a separate Metadata container associated with the overall group</span>
<span class="sd">        that is assumed to be constant for every member of the ensemble.  For this</span>
<span class="sd">        reason before entering the loop calling save_data on each member</span>
<span class="sd">        the method calls the objects sync_metadata method that copies (overwrites if</span>
<span class="sd">        previously defined) the ensemble attributes to each member.  That assure</span>
<span class="sd">        atomic saves will not lose their association with a unique ensemble</span>
<span class="sd">        indexing scheme.</span>

<span class="sd">        A final feature of note is that an ensemble can be marked dead.</span>
<span class="sd">        If the entire ensemble is set dead this function returns</span>
<span class="sd">        immediately and does nothing.</span>


<span class="sd">        :param ensemble_object: the ensemble you want to save.</span>
<span class="sd">        :type ensemble_object: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param storage_mode: &quot;gridfs&quot; stores the object in the mongodb grid file system (recommended). &quot;file&quot; stores</span>
<span class="sd">            the object in a binary file, which requires ``dfile`` and ``dir``.</span>
<span class="sd">        :type storage_mode: :class:`str`</span>
<span class="sd">        :param dir_list: A :class:`list` of file directories if using &quot;file&quot; storage mode. File directory is ``str`` type.</span>
<span class="sd">        :param dfile_list: A :class:`list` of file names if using &quot;file&quot; storage mode. File name is ``str`` type.</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being stored.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param exclude_objects: A list of indexes, where each specifies a object in the ensemble you want to exclude from being saved. Starting from 0.</span>
<span class="sd">        :type exclude_objects: :class:`list`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata schema.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to tag the saved wf document.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ensemble_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dfile_list</span><span class="p">:</span>
            <span class="n">dfile_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">))]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dir_list</span><span class="p">:</span>
            <span class="n">dir_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">exclude_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># sync_metadata is a ccore method of the Ensemble  template</span>
        <span class="n">ensemble_object</span><span class="o">.</span><span class="n">sync_metadata</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">storage_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_objects</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
                        <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                        <span class="n">storage_mode</span><span class="o">=</span><span class="n">storage_mode</span><span class="p">,</span>
                        <span class="nb">dir</span><span class="o">=</span><span class="n">dir_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">dfile</span><span class="o">=</span><span class="n">dfile_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                        <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                        <span class="n">data_tag</span><span class="o">=</span><span class="n">data_tag</span><span class="p">,</span>
                        <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                        <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;url&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown storage mode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">storage_mode</span><span class="p">))</span></div>

<div class="viewcode-block" id="Database.update_ensemble_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.update_ensemble_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">update_ensemble_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ensemble_object</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;promiscuous&quot;</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="s2">&quot;update_ensemble_metadata&quot;</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates (or save if it&#39;s new) the mspasspy ensemble object, including saving the processing history, elogs</span>
<span class="sd">        and metadata attributes.</span>

<span class="sd">        This method is a companion to save_ensemble_data. The relationship is</span>
<span class="sd">        comparable to that between the save_data and update_metadata methods.</span>
<span class="sd">        In particular, this method is mostly for internal use to save the</span>
<span class="sd">        contents of the Metadata container in each ensemble member.  Like</span>
<span class="sd">        save_ensemble_data it is mainly a loop over ensemble members calling</span>
<span class="sd">        update_metadata on each member.  Also like update_metadata it is</span>
<span class="sd">        advanced usage to use this method directly.  Most users will apply</span>
<span class="sd">        it under the hood as part of calls to save_ensemble_data.</span>

<span class="sd">        :param ensemble_object: the ensemble you want to update.</span>
<span class="sd">        :type ensemble_object: either :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param mode: reading mode regarding schema checks, should be one of [&#39;promiscuous&#39;,&#39;cautious&#39;,&#39;pedantic&#39;]</span>
<span class="sd">        :type mode: :class:`str`</span>
<span class="sd">        :param exclude_keys: the metadata attributes you want to exclude from being updated.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param exclude_objects: a list of indexes, where each specifies a object in the ensemble you want to</span>
<span class="sd">        exclude from being saved. The index starts at 0.</span>
<span class="sd">        :type exclude_objects: :class:`list`</span>
<span class="sd">        :param collection: the collection name you want to use. If not specified, use the defined collection in the metadata</span>
<span class="sd">        schema.</span>
<span class="sd">        :param ignore_metadata_changed_test: if specify as ``True``, we do not check the whether attributes we want to update are in the Metadata.modified() set. Default to be ``False``.</span>
<span class="sd">        :param data_tag: a user specified &quot;data_tag&quot; key to tag the saved wf document.</span>
<span class="sd">        :type data_tag: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_objects</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># Skip data listed for exclusion and those that are marked dead</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_objects</span> <span class="ow">and</span> <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_metadata</span><span class="p">(</span>
                    <span class="n">ensemble_object</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">exclude_keys</span><span class="o">=</span><span class="n">exclude_keys</span><span class="p">,</span>
                    <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
                    <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.delete_data"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.delete_data">[docs]</a>    <span class="k">def</span> <span class="nf">delete_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">object_id</span><span class="p">,</span>
        <span class="n">object_type</span><span class="p">,</span>
        <span class="n">remove_unreferenced_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">clear_history</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">clear_elog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete method for handling mspass data objects (TimeSeries and Seismograms).</span>

<span class="sd">        Delete is one of the basic operations any database system should</span>
<span class="sd">        support (the last letter of the acronymn CRUD is delete).  Deletion is</span>
<span class="sd">        nontrivial with seismic data stored with the model used in MsPASS.</span>
<span class="sd">        The reason is that the content of the objects are spread between</span>
<span class="sd">        multiple collections and sometimes use storage in files completely</span>
<span class="sd">        outside MongoDB.   This method, however, is designed to handle that</span>
<span class="sd">        and when given the object id defining a document in one of the wf</span>
<span class="sd">        collections, it will delete the wf document entry and manage the</span>
<span class="sd">        waveform data.  If the data are stored in gridfs the deletion of</span>
<span class="sd">        the waveform data will be immediate.  If the data are stored in</span>
<span class="sd">        disk files the file will be deleted when there are no more references</span>
<span class="sd">        in the wf collection for the exact combination of dir and dfile associated</span>
<span class="sd">        an atomic deletion.  Error log and history data deletion linked to</span>
<span class="sd">        a datum is optional.</span>


<span class="sd">        :param object_id: the wf object id you want to delete.</span>
<span class="sd">        :type object_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param object_type: the object type you want to delete, must be one of [&#39;TimeSeries&#39;, &#39;Seismogram&#39;]</span>
<span class="sd">        :type object_type: :class:`str`</span>
<span class="sd">        :param remove_unreferenced_files: if ``True``, we will try to remove the file that no wf data is referencing. Default to be ``False``</span>
<span class="sd">        :param clear_history: if ``True``, we will clear the processing history of the associated wf object, default to be ``True``</span>
<span class="sd">        :param clear_elog: if ``True``, we will clear the elog entries of the associated wf object, default to be ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="s2">&quot;Seismogram&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

        <span class="c1"># get the wf collection name in the schema</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="o">==</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
            <span class="n">detele_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detele_schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="n">wf_collection_name</span> <span class="o">=</span> <span class="n">detele_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>

        <span class="c1"># user might pass a mspass object by mistake</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">object_id</span>

        <span class="c1"># fetch the document by the given object id</span>
        <span class="n">object_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">object_doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find document in wf collection by _id: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oid</span><span class="p">),</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># delete the document just retrieved from the database</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span>

        <span class="c1"># delete gridfs/file depends on storage mode, and unreferenced files</span>
        <span class="n">storage_mode</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">storage_mode</span> <span class="o">==</span> <span class="s2">&quot;gridfs&quot;</span><span class="p">:</span>
            <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">]):</span>
                <span class="n">gfsh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;gridfs_id&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">storage_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">remove_unreferenced_files</span><span class="p">:</span>
            <span class="n">dir_name</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span>
            <span class="n">dfile_name</span> <span class="o">=</span> <span class="n">object_doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span>
            <span class="c1"># find if there are any remaining matching documents with dir and dfile</span>
            <span class="n">match_doc_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">wf_collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;dir&quot;</span><span class="p">:</span> <span class="n">dir_name</span><span class="p">,</span> <span class="s2">&quot;dfile&quot;</span><span class="p">:</span> <span class="n">dfile_name</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="c1"># delete this file</span>
            <span class="k">if</span> <span class="n">match_doc_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">dfile_name</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c1"># clear history</span>
        <span class="k">if</span> <span class="n">clear_history</span><span class="p">:</span>
            <span class="n">history_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
            <span class="n">history_obj_id_name</span> <span class="o">=</span> <span class="n">history_collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="k">if</span> <span class="n">history_obj_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">history_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">history_obj_id_name</span><span class="p">]}</span>
                <span class="p">)</span>

        <span class="c1"># clear elog</span>
        <span class="k">if</span> <span class="n">clear_elog</span><span class="p">:</span>
            <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">wf_collection_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="n">elog_collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span>
            <span class="n">elog_id_name</span> <span class="o">=</span> <span class="n">elog_collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
            <span class="c1"># delete the one by elog_id in mspass object</span>
            <span class="k">if</span> <span class="n">elog_id_name</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">elog_id_name</span><span class="p">]})</span>
            <span class="c1"># delete the documents with the wf_id equals to obejct[&#39;_id&#39;]</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_many</span><span class="p">({</span><span class="n">wf_id_name</span><span class="p">:</span> <span class="n">oid</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">_load_collection_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Master Private Method</span>

<span class="sd">        Reads metadata from a requested collection and loads standard attributes from collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the collection_id attribute set to link it to a unique document in source.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded. Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching document are loaded.</span>
<span class="sd">        :param collection: requested collection metadata should be loaded</span>
<span class="sd">        :type collection: :class:`str`</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only live mspass object can load metadata&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">Seismogram</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;channel data can not be loaded into Seismogram&quot;</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>

        <span class="c1"># 1. get the metadata schema based on the mspass object type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>

        <span class="n">wf_collection</span> <span class="o">=</span> <span class="n">metadata_def</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span>
        <span class="n">object_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">wf_collection</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">object_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;only TimeSeries and Seismogram are supported, but </span><span class="si">{}</span><span class="s2"> is requested. Please check the data_type of </span><span class="si">{}</span><span class="s2"> collection.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">object_type</span><span class="p">,</span> <span class="n">wf_collection</span>
                <span class="p">),</span>
                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">wf_collection_metadata_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">[</span><span class="n">object_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

        <span class="n">collection_id</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="c1"># 2. get the collection_id from the current mspass_object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">collection_id</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;no </span><span class="si">{}</span><span class="s2"> in the mspass object&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">collection_id</span><span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">object_doc_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">collection_id</span><span class="p">]</span>

        <span class="c1"># 3. find the unique document associated with this source id in the source collection</span>
        <span class="n">object_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">object_doc_id</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">object_doc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;no match found in </span><span class="si">{}</span><span class="s2"> collection for source_id = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">collection</span><span class="p">,</span> <span class="n">object_doc_id</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># 4. use this document to update the mspass object</span>
        <span class="n">key_dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wf_collection_metadata_schema</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">wf_collection_metadata_schema</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="n">collection</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_keys</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_undefined</span><span class="p">:</span>
                    <span class="n">key_dict</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique_name</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="p">)</span>

        <span class="c1"># 5. add extra keys if include_undefined is true</span>
        <span class="k">if</span> <span class="n">include_undefined</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">object_doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_dict</span><span class="p">:</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">object_doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

<div class="viewcode-block" id="Database.load_source_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_source_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_source_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;serialized_event&quot;</span><span class="p">,</span> <span class="s2">&quot;magnitude_type&quot;</span><span class="p">],</span>
        <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the source collection and loads standard attributes in source collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the source_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class</span>
<span class="sd">        or an ensemble (TimeSeriesEnsemble or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the source data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a shot gather.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default are attributes not normally need that are loaded from QuakeML.  Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching source document are loaded.</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.load_site_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_site_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_site_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the site collection and loads standard attributes in site collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the site_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class or an ensemble (TimeSeriesEnsemble</span>
<span class="sd">        or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the site data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a common-receiver gather.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default is None.  Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :type exclude_keys: a :class:`list` of :class:`str`</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching site document are loaded.</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Database.load_channel_metadata"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_channel_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">load_channel_metadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">exclude_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">],</span>
        <span class="n">include_undefined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads metadata from the channel collection and loads standard attributes in channel collection to the data passed as mspass_object.</span>
<span class="sd">        The method will only work if mspass_object has the site_id attribute set to link it to a unique document in source.</span>

<span class="sd">        Note the mspass_object can be either an atomic object (TimeSeries or Seismogram) with a Metadata container base class or an ensemble (TimeSeriesEnsemble</span>
<span class="sd">        or SeismogramEnsemble).</span>
<span class="sd">        Ensembles will have the site data posted to the ensemble Metadata and not the members.</span>
<span class="sd">        This should be the stock way to assemble the generalization of a common-receiver gather of TimeSeries data for a common sensor component.</span>

<span class="sd">        :param mspass_object:   data where the metadata is to be loaded</span>
<span class="sd">        :type mspass_object:  :class:`mspasspy.ccore.seismic.TimeSeries`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.Seismogram`,</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.TimeSeriesEnsemble` or</span>
<span class="sd">            :class:`mspasspy.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">        :param exclude_keys: list of attributes that should not normally be loaded.</span>
<span class="sd">            Default excludes the serialized obspy class that is used to store response data.   Ignored if include_undefined is set ``True``.</span>
<span class="sd">        :param include_undefined:  when ``True`` all data in the matching channel document are loaded</span>

<span class="sd">        :raises mspasspy.ccore.utility.MsPASSError: any detected errors will cause a MsPASSError to be thrown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                <span class="n">mspass_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">member_object</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_collection_metadata</span><span class="p">(</span>
                    <span class="n">member_object</span><span class="p">,</span> <span class="n">exclude_keys</span><span class="p">,</span> <span class="n">include_undefined</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span>
                <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sync_metadata_before_update</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MsPASS data objects are designed to cleanly handle what we call relative</span>
<span class="sd">        and UTC time.  This small helper function assures the Metadata of</span>
<span class="sd">        mspass_object are consistent with the internal contents.  That</span>
<span class="sd">        involves posting some special attributes seen below to handle this issue.</span>
<span class="sd">        Since Metadata is volatile we need to be sure these are consistent or</span>
<span class="sd">        timing can be destroyed on data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this adds a small overhead but it guarantees Metadata and internal t0</span>
        <span class="c1"># values are consistent.  Shouldn&#39;t happen unless the user messes with them</span>
        <span class="c1"># incorrectly, but this safety is prudent to reduce the odds of mysterious</span>
        <span class="c1"># timing errors in data</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_t0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
        <span class="c1"># This will need to be modified if we ever expand time types beyond two</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_is_relative</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">shifted</span><span class="p">():</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;startime_shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_reference</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;time_standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Relative&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;utc_convertible&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;time_standard&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;UTC&quot;</span>
        <span class="c1"># If it is a seismogram, we need to update the tmatrix in the metadata to be consistent with the internal tmatrix</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">t_matrix</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">tmatrix</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">tmatrix</span> <span class="o">=</span> <span class="n">t_matrix</span>
            <span class="c1"># also update the cardinal and orthogonal attributes</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;cardinal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">cardinal</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the processing history of a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param prev_history_object_id: the previous history object id (if it has).</span>
<span class="sd">        :type prev_history_object_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param collection: the collection that you want to store the history object. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        :return: current history_object_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">TIMESERIES</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">SEISMOGRAM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="c1"># get the wf id name in the schema</span>
        <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">update_metadata_def</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>

        <span class="c1"># get the wf id in the mspass object</span>
        <span class="n">oid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
        <span class="n">history_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="n">proc_history</span> <span class="o">=</span> <span class="n">ProcessingHistory</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="n">current_uuid</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">id</span><span class="p">()</span>  <span class="c1"># uuid in the current node</span>
        <span class="n">current_nodedata</span> <span class="o">=</span> <span class="n">proc_history</span><span class="o">.</span><span class="n">current_nodedata</span><span class="p">()</span>
        <span class="c1"># get the alg_name and alg_id of current node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_id</span><span class="p">:</span>
            <span class="n">alg_id</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_name</span><span class="p">:</span>
            <span class="n">alg_name</span> <span class="o">=</span> <span class="n">current_nodedata</span><span class="o">.</span><span class="n">algorithm</span>

        <span class="n">history_binary</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">proc_history</span><span class="p">)</span>
        <span class="c1"># todo save jobname jobid when global history module is done</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># construct the insert dict for saving into database</span>
            <span class="n">insert_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">current_uuid</span><span class="p">,</span>
                <span class="s2">&quot;processing_history&quot;</span><span class="p">:</span> <span class="n">history_binary</span><span class="p">,</span>
                <span class="s2">&quot;alg_id&quot;</span><span class="p">:</span> <span class="n">alg_id</span><span class="p">,</span>
                <span class="s2">&quot;alg_name&quot;</span><span class="p">:</span> <span class="n">alg_name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">oid</span><span class="p">:</span>
                <span class="n">insert_dict</span><span class="p">[</span><span class="n">wf_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">oid</span>
            <span class="c1"># insert new one</span>
            <span class="n">history_col</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">insert_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">pymongo</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">DuplicateKeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;The history object to be saved has a duplicate uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="c1"># clear the history chain of the mspass object</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">clear_history</span><span class="p">()</span>
        <span class="c1"># set_as_origin with uuid set to the newly generated id</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span><span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">,</span> <span class="n">current_uuid</span><span class="p">,</span> <span class="n">atomic_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_uuid</span>

    <span class="k">def</span> <span class="nf">_load_history</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="n">history_object_id</span><span class="p">,</span>
        <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">define_as_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">retrieve_history_record</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load (in place) the processing history into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param history_object_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param collection: the collection that you want to load the processing history. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the atomic type of the mspass object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">TIMESERIES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atomic_type</span> <span class="o">=</span> <span class="n">AtomicType</span><span class="o">.</span><span class="n">SEISMOGRAM</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;history_object&quot;</span><span class="p">)</span>
        <span class="c1"># load history if set True</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">history_object_id</span><span class="p">})</span>
        <span class="c1"># retrieve_history_record</span>
        <span class="k">if</span> <span class="n">retrieve_history_record</span><span class="p">:</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">load_history</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;processing_history&quot;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set the associated history_object_id as the uuid of the origin</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_name</span><span class="p">:</span>
                <span class="n">alg_name</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_id</span><span class="p">:</span>
                <span class="n">alg_id</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">set_as_origin</span><span class="p">(</span>
                <span class="n">alg_name</span><span class="p">,</span> <span class="n">alg_id</span><span class="p">,</span> <span class="n">history_object_id</span><span class="p">,</span> <span class="n">atomic_type</span><span class="p">,</span> <span class="n">define_as_raw</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_elog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">elog_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save error log for a data object. Data objects in MsPASS contain an error log object used to post any</span>
<span class="sd">        errors handled by processing functions. This function will delete the old elog entry if `elog_id` is given.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param elog_id: the previous elog object id to be appended with.</span>
<span class="sd">        :type elog_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        :param collection: the collection that you want to save the elogs. If not specified, use the defined</span>
<span class="sd">        collection in the schema.</span>
<span class="sd">        :return: updated elog_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">TimeSeries</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">update_metadata_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">Seismogram</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">wf_id_name</span> <span class="o">=</span> <span class="n">update_metadata_def</span><span class="o">.</span><span class="n">collection</span><span class="p">(</span><span class="s2">&quot;_id&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">collection</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database_schema</span><span class="o">.</span><span class="n">default_name</span><span class="p">(</span><span class="s2">&quot;elog&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: Need to discuss whether the _id should be linked in a dead elog entry. It</span>
        <span class="c1"># might be confusing to link the dead elog to an alive wf record.</span>
        <span class="n">oid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">oid</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>

        <span class="n">elog</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logdata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">docentry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;logdata&quot;</span><span class="p">:</span> <span class="n">logdata</span><span class="p">}</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()</span>
            <span class="n">jobid</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_job_id</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">errs</span><span class="p">:</span>
                <span class="n">logdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;job_id&quot;</span><span class="p">:</span> <span class="n">jobid</span><span class="p">,</span>
                        <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                        <span class="s2">&quot;badness&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">badness</span><span class="p">),</span>
                        <span class="s2">&quot;error_message&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
                        <span class="s2">&quot;process_id&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">p_id</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">oid</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="n">wf_id_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">oid</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;tombstone&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">elog_id</span><span class="p">:</span>
                <span class="c1"># append elog</span>
                <span class="n">elog_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">})</span>
                <span class="c1"># only append when previous elog exists</span>
                <span class="k">if</span> <span class="n">elog_doc</span><span class="p">:</span>
                    <span class="c1"># if the same object was updated twice, the elog entry will be duplicated</span>
                    <span class="c1"># the following list comprehension line removes the duplicates and preserves</span>
                    <span class="c1"># the order. May need some practice to see if such a behavior makes sense.</span>
                    <span class="p">[</span>
                        <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">logdata</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span>
                    <span class="p">]</span>
                    <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elog_doc</span><span class="p">[</span><span class="s2">&quot;logdata&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">delete_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">elog_id</span><span class="p">})</span>
                <span class="c1"># note that is should be impossible for the old elog to have tombstone entry</span>
                <span class="c1"># so we ignore the handling of that attribute here.</span>
                <span class="n">ret_elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># new insertion</span>
                <span class="n">ret_elog_id</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="k">return</span> <span class="n">ret_elog_id</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_dfile</span><span class="p">(</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="nb">dir</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="n">foff</span><span class="p">,</span>
        <span class="n">nbytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_method</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">merge_fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_interpolation_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the stored data from a file and loads it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param foff: offset that marks the starting of the data in the file.</span>
<span class="sd">        :param nbytes: number of bytes to be read from the offset. This is only used when ``format`` is given.</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy writer. By default (``None``), the format will be the binary waveform.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        :param fill_value: Fill value for gaps. Defaults to None. Traces will be converted to NumPy masked arrays if no value is given and gaps are present.</span>
<span class="sd">        :type fill_value: :class:`int`, :class:`float` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">foff</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">:</span>
                <span class="n">float_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;npts is not defined&quot;</span><span class="p">)</span>
                    <span class="n">float_array</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">float_array</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;npts is not defined&quot;</span><span class="p">)</span>
                    <span class="n">float_array</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)):</span>
                            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_array</span><span class="p">[</span>
                                <span class="n">i</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span>
                            <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">))</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="c1"># st is a &quot;stream&quot; but it may contains multiple Trace objects gaps</span>
                    <span class="c1"># but here we want only one TimeSeries, we merge these Trace objects and fill values for gaps</span>
                    <span class="c1"># we post a complaint elog entry to the mspass_object if there are gaps in the stream</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="s2">&quot;read_data&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;There are gaps in this stream when reading file by obspy and they are merged into one Trace object by filling value in the gaps.&quot;</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                            <span class="n">method</span><span class="o">=</span><span class="n">merge_method</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="n">merge_fill_value</span><span class="p">,</span>
                            <span class="n">interpolation_samples</span><span class="o">=</span><span class="n">merge_interpolation_samples</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
                    <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
                    <span class="c1"># loc, and startime all match</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_save_data_to_dfile</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves sample data as a binary dump of the sample data. Save a mspasspy object as a pure binary dump of</span>
<span class="sd">        the sample data in native (Fortran) order. Opens the file and ALWAYS appends data to the end of the file.</span>

<span class="sd">        This method is subject to several issues to beware of before using them:</span>
<span class="sd">        (1) they are subject to damage by other processes/program, (2) updates are nearly impossible without</span>
<span class="sd">        stranding (potentially large quantities) of data in the middle of files or</span>
<span class="sd">        corrupting a file with a careless insert, and (3) when the number of files</span>
<span class="sd">        gets large managing them becomes difficult.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.write.html#supported-formats&gt;`__ of ObsPy reader. By default (``None``), the format will be the binary waveform.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        :return: Position of first data sample (foff) and the size of the saved chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;a+b&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">foff</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">format</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="c1"># fixme DoubleVector</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="n">ub</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_byte</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">toTrace</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">toStream</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f_byte</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
                <span class="n">f_byte</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ub</span> <span class="o">=</span> <span class="n">f_byte</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">foff</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_data_to_gridfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">gridfs_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a mspasspy object sample data to MongoDB grid file system. We recommend to use this method</span>
<span class="sd">        for saving a mspasspy object inside MongoDB.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param gridfs_id: if the data is already stored and you want to update it, you should provide the object id</span>
<span class="sd">        of the previous data, which will be deleted. A new document will be inserted instead.</span>
<span class="sd">        :type gridfs_id: :class:`bson.objectid.ObjectId`.</span>
<span class="sd">        :return inserted gridfs object id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gridfs_id</span> <span class="ow">and</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gridfs_id</span><span class="p">):</span>
            <span class="n">gfsh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">gridfs_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">ub</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_read_data_from_gridfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">gridfs_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read data stored in gridfs and load it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param gridfs_id: the object id of the data stored in gridfs.</span>
<span class="sd">        :type gridfs_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gfsh</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">gfsh</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">file_id</span><span class="o">=</span><span class="n">gridfs_id</span><span class="p">)</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;@</span><span class="si">%d</span><span class="s2">d&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;npts&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;npts is not defined&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]):</span>
                <span class="n">emess</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Size mismatch in sample data. Number of points in gridfs file = </span><span class="si">%d</span><span class="s2"> but expected </span><span class="si">%d</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emess</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]):</span>
                    <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_data_from_s3_continuous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read data stored in s3 and load it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
            <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
            <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
            <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">station</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;net&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;sta&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;chan&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">KEY</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()),</span> <span class="nb">format</span><span class="o">=</span><span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
                <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
                <span class="c1"># We only want the Trace object not the stream to convert</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
                <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
                <span class="c1"># loc, and startime all match</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">def</span> <span class="nf">_read_data_from_s3_lambda</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">station</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;net&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;sta&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;chan&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_download_windowed_mseed_file</span><span class="p">(</span>
                <span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="p">,</span>
                <span class="n">year</span><span class="p">,</span>
                <span class="n">day_of_year</span><span class="p">,</span>
                <span class="n">network</span><span class="p">,</span>
                <span class="n">station</span><span class="p">,</span>
                <span class="n">channel</span><span class="p">,</span>
                <span class="n">location</span><span class="p">,</span>
                <span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
                <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
                <span class="c1"># We only want the Trace object not the stream to convert</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
                <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
                <span class="c1"># loc, and startime all match</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3_lambda.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">def</span> <span class="nf">_read_data_from_s3_event</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mspass_object</span><span class="p">,</span>
        <span class="nb">dir</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="n">foff</span><span class="p">,</span>
        <span class="n">nbytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_access_key_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the stored data from a file and loads it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param dir: file directory.</span>
<span class="sd">        :type dir: :class:`str`</span>
<span class="sd">        :param dfile: file name.</span>
<span class="sd">        :type dfile: :class:`str`</span>
<span class="sd">        :param foff: offset that marks the starting of the data in the file.</span>
<span class="sd">        :param nbytes: number of bytes to be read from the offset. This is only used when ``format`` is given.</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy writer. By default (``None``), the format will be the binary waveform.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>

        <span class="c1"># check if fname exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="c1"># fname might now exist, but could download from s3</span>
            <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
                <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
                <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>
            <span class="n">KEY</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;event_waveforms/&quot;</span>
                <span class="o">+</span> <span class="n">year</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                <span class="o">+</span> <span class="n">year</span>
                <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                <span class="o">+</span> <span class="n">day_of_year</span>
                <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                <span class="o">+</span> <span class="n">filename</span>
                <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
            <span class="p">)</span>
            <span class="c1"># try to download the mseed file from s3 and save it locally</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
                <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="c1"># temporarily write data into a file</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                    <span class="c1"># the object does not exist</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while read data from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">foff</span><span class="p">)</span>
            <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">))</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
            <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
                <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
                <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_read_data_from_fdsn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
        <span class="n">provider</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;provider&quot;</span><span class="p">]</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span>
        <span class="n">network</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">station</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">provider</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span><span class="p">,</span> <span class="n">iso8601</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span>
            <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>
        <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
        <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_data_from_url</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a file from url and loads it into a mspasspy object.</span>

<span class="sd">        :param mspass_object: the target object.</span>
<span class="sd">        :type mspass_object: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        :param url: the url that points to a :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`.</span>
<span class="sd">        :type url: :class:`str`</span>
<span class="sd">        :param format: the format of the file. This can be one of the `supported formats &lt;https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html#supported-formats&gt;`__ of ObsPy reader. If not specified, the ObsPy reader will try to detect the format automatically.</span>
<span class="sd">        :type format: :class:`str`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">flh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="c1"># Catch HTTP errors.</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while downloading: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">url</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">flh</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="c1"># st is a &quot;stream&quot; but it only has one member here because we are</span>
            <span class="c1"># reading single net,sta,chan,loc grouping defined by the index</span>
            <span class="c1"># We only want the Trace object not the stream to convert</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we convert this to a TimeSeries and load other Metadata</span>
            <span class="c1"># Note the exclusion copy and the test verifying net,sta,chan,</span>
            <span class="c1"># loc, and startime all match</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
            <span class="c1"># Note that the following convertion could be problematic because</span>
            <span class="c1"># it assumes there are three traces in the file, and they are in</span>
            <span class="c1"># the order of E, N, Z.</span>
            <span class="n">sm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">toSeismogram</span><span class="p">(</span><span class="n">cardinal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">()</span>
            <span class="n">mspass_object</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only TimeSeries and Seismogram are supported&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_locdata</span><span class="p">(</span><span class="n">chanlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the list returned by obspy channels attribute</span>
<span class="sd">        for a Station object and returns a dict of unique</span>
<span class="sd">        edepth values keyed by loc code.  This algorithm</span>
<span class="sd">        would be horribly inefficient for large lists with</span>
<span class="sd">        many duplicates, but the assumption here is the list</span>
<span class="sd">        will always be small</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alllocs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">chanlist</span><span class="p">:</span>
            <span class="n">alllocs</span><span class="p">[</span><span class="n">chan</span><span class="o">.</span><span class="n">location_code</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">start_date</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">end_date</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">longitude</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">elevation</span><span class="p">,</span>
                <span class="n">chan</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">alllocs</span>

    <span class="k">def</span> <span class="nf">_site_is_not_in_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_to_test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper functoin for save_inventory.</span>
<span class="sd">        Tests if dict content of record_to_test is</span>
<span class="sd">        in the site collection.  Inverted logic in one sense</span>
<span class="sd">        as it returns true when the record is not yet in</span>
<span class="sd">        the database.  Uses key of net,sta,loc,starttime</span>
<span class="sd">        and endtime.  All tests are simple equality.</span>
<span class="sd">        Should be ok for times as stationxml uses nearest</span>
<span class="sd">        day as in css3.0.</span>

<span class="sd">        originally tried to do the time interval tests with a</span>
<span class="sd">        query, but found it was a bit cumbersone to say the least.</span>
<span class="sd">        Because this particular query is never expected to return</span>
<span class="sd">        a large number of documents we resort to a linear</span>
<span class="sd">        search through all matches on net,sta,loc rather than</span>
<span class="sd">        using a confusing and ugly query construct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">queryrecord</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="c1"># this returns a warning that count is depricated but</span>
        <span class="c1"># I&#39;m getting confusing results from google search on the</span>
        <span class="c1"># topic so will use this for now</span>
        <span class="n">nrec</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Now do the linear search on time for a match</span>
            <span class="n">st0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="n">et0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
            <span class="n">time_fudge_factor</span> <span class="o">=</span> <span class="mf">10.0</span>
            <span class="n">stp</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">stm</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="n">etp</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">etm</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">sttest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="n">ettest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sttest</span> <span class="o">&gt;</span> <span class="n">stm</span> <span class="ow">and</span> <span class="n">sttest</span> <span class="o">&lt;</span> <span class="n">stp</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&gt;</span> <span class="n">etm</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&lt;</span> <span class="n">etp</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_channel_is_not_in_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_to_test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper functoin for save_inventory.</span>
<span class="sd">        Tests if dict content of record_to_test is</span>
<span class="sd">        in the site collection.  Inverted logic in one sense</span>
<span class="sd">        as it returns true when the record is not yet in</span>
<span class="sd">        the database.  Uses key of net,sta,loc,starttime</span>
<span class="sd">        and endtime.  All tests are simple equality.</span>
<span class="sd">        Should be ok for times as stationxml uses nearest</span>
<span class="sd">        day as in css3.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">queryrecord</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="n">queryrecord</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="c1"># this returns a warning that count is depricated but</span>
        <span class="c1"># I&#39;m getting confusing results from google search on the</span>
        <span class="c1"># topic so will use this for now</span>
        <span class="n">nrec</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">queryrecord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Now do the linear search on time for a match</span>
            <span class="n">st0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="n">et0</span> <span class="o">=</span> <span class="n">record_to_test</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
            <span class="n">time_fudge_factor</span> <span class="o">=</span> <span class="mf">10.0</span>
            <span class="n">stp</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">stm</span> <span class="o">=</span> <span class="n">st0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="n">etp</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">+</span> <span class="n">time_fudge_factor</span>
            <span class="n">etm</span> <span class="o">=</span> <span class="n">et0</span> <span class="o">-</span> <span class="n">time_fudge_factor</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="n">sttest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="n">ettest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sttest</span> <span class="o">&gt;</span> <span class="n">stm</span> <span class="ow">and</span> <span class="n">sttest</span> <span class="o">&lt;</span> <span class="n">stp</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&gt;</span> <span class="n">etm</span> <span class="ow">and</span> <span class="n">ettest</span> <span class="o">&lt;</span> <span class="n">etp</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_handle_null_starttime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_handle_null_endtime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c1"># This constant is used below to set endtime to a time</span>
        <span class="c1"># in the far future if it is null</span>
        <span class="n">DISTANTFUTURE</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2051</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DISTANTFUTURE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

<div class="viewcode-block" id="Database.save_inventory"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_inventory">[docs]</a>    <span class="k">def</span> <span class="nf">save_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">networks_to_exclude</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;SY&quot;</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves contents of all components of an obspy inventory</span>
<span class="sd">        object to documents in the site and channel collections.</span>
<span class="sd">        The site collection is sufficient for Seismogram objects but</span>
<span class="sd">        TimeSeries data will normally need to be connected to the</span>
<span class="sd">        channel collection.   The algorithm used will not add</span>
<span class="sd">        duplicates based on the following keys:</span>

<span class="sd">        For site:</span>
<span class="sd">            net</span>
<span class="sd">            sta</span>
<span class="sd">            chan</span>
<span class="sd">            loc</span>
<span class="sd">            starttime::endtime - this check is done cautiously with</span>
<span class="sd">              a 10 s fudge factor to avoid the issue of floating point</span>
<span class="sd">              equal tests.   Probably overly paranoid since these</span>
<span class="sd">              fields are normally rounded to a time at the beginning</span>
<span class="sd">              of a utc day, but small cost to pay for stabilty because</span>
<span class="sd">              this function is not expected to be run millions of times</span>
<span class="sd">              on a huge collection.</span>

<span class="sd">        for channels:</span>
<span class="sd">            net</span>
<span class="sd">            sta</span>
<span class="sd">            chan</span>
<span class="sd">            loc</span>
<span class="sd">            starttime::endtime - same approach as for site with same</span>
<span class="sd">               issues - note especially 10 s fudge factor.   This is</span>
<span class="sd">               necessary because channel metadata can change more</span>
<span class="sd">               frequently than site metadata (e.g. with a sensor</span>
<span class="sd">               orientation or sensor swap)</span>

<span class="sd">        The channel collection can contain full response data</span>
<span class="sd">        that can be obtained by extracting the data with the key</span>
<span class="sd">        &quot;serialized_inventory&quot; and running pickle loads on the returned</span>
<span class="sd">        string.</span>

<span class="sd">        A final point of note is that not all Inventory objects are created</span>
<span class="sd">        equally.   Inventory objects appear to us to be designed as an image</span>
<span class="sd">        of stationxml data.  The problem is that stationxml, like SEED, has to</span>
<span class="sd">        support a lot of complexity faced by data centers that end users</span>
<span class="sd">        like those using this package do not need or want to know.   The</span>
<span class="sd">        point is this method tries to untangle the complexity and aims to reduce the</span>
<span class="sd">        result to a set of documents in the site and channel collection</span>
<span class="sd">        that can be cross referenced to link the right metadata with all</span>
<span class="sd">        waveforms in a dataset.</span>

<span class="sd">        :param inv: is the obspy Inventory object of station data to save.</span>
<span class="sd">        :networks_to_exclude: should contain a list (or tuple) of</span>
<span class="sd">            SEED 2 byte network codes that are to be ignored in</span>
<span class="sd">            processing.   Default is SY which is used for synthetics.</span>
<span class="sd">            Set to None if if all are to be loaded.</span>
<span class="sd">        :verbose:  print informational lines if true.  If false</span>
<span class="sd">        works silently)</span>

<span class="sd">        :return:  tuple with</span>
<span class="sd">          0 - integer number of site documents saved</span>
<span class="sd">          1 -integer number of channel documents saved</span>
<span class="sd">          2 - number of distinct site (net,sta,loc) items processed</span>
<span class="sd">          3 - number of distinct channel items processed</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># site is a frozen name for the collection here.  Perhaps</span>
        <span class="c1"># should be a variable with a default</span>
        <span class="c1"># to do: need to change source_id to be a copy of the _id string.</span>

        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">n_site_saved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_chan_saved</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_site_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_chan_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
            <span class="c1"># Inventory object I got from webservice download</span>
            <span class="c1"># makes the sta variable here a net:sta combination</span>
            <span class="c1"># We can get the net code like this</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">code</span>
            <span class="c1"># This adds feature to skip data for any net code</span>
            <span class="c1"># listed in networks_to_exclude</span>
            <span class="k">if</span> <span class="n">networks_to_exclude</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">networks_to_exclude</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="c1"># Each x now has a station field, BUT tests I ran</span>
            <span class="c1"># say for my example that field has one entry per</span>
            <span class="c1"># x.  Hence, we can get sta name like this</span>
            <span class="n">stalist</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">stations</span>
            <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stalist</span><span class="p">:</span>
                <span class="n">sta</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">code</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">start_date</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">end_date</span>
                <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">starttime</span><span class="p">)</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">endtime</span><span class="p">)</span>
                <span class="n">latitude</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">latitude</span>
                <span class="n">longitude</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">longitude</span>
                <span class="c1"># stationxml files seen to put elevation in m. We</span>
                <span class="c1"># always use km so need to convert</span>
                <span class="n">elevation</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">elevation</span> <span class="o">/</span> <span class="mf">1000.0</span>
                <span class="c1"># an obnoxious property of station xml files obspy is giving me</span>
                <span class="c1"># is that the start_dates and end_dates on the net:sta section</span>
                <span class="c1"># are not always consistent with the channel data.  In particular</span>
                <span class="c1"># loc codes are a problem. So we pull the required metadata from</span>
                <span class="c1"># the chans data and will override locations and time ranges</span>
                <span class="c1"># in station section with channel data</span>
                <span class="n">chans</span> <span class="o">=</span> <span class="n">station</span><span class="o">.</span><span class="n">channels</span>
                <span class="n">locdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_locdata</span><span class="p">(</span><span class="n">chans</span><span class="p">)</span>
                <span class="c1"># Assume loc code of 0 is same as rest</span>
                <span class="c1"># loc=_extract_loc_code(chanlist[0])</span>
                <span class="c1"># TODO Delete when sure we don&#39;t need to keep the full thing</span>
                <span class="c1"># picklestr = pickle.dumps(x)</span>
                <span class="n">all_locs</span> <span class="o">=</span> <span class="n">locdata</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">all_locs</span><span class="p">:</span>
                    <span class="c1"># If multiple loc codes are present on the second pass</span>
                    <span class="c1"># rec will contain the objectid of the document inserted</span>
                    <span class="c1"># in the previous pass - an obnoxious property of insert_one</span>
                    <span class="c1"># This initialization guarantees an empty container</span>
                    <span class="n">rec</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
                    <span class="n">lkey</span> <span class="o">=</span> <span class="n">loc</span>
                    <span class="n">loc_tuple</span> <span class="o">=</span> <span class="n">locdata</span><span class="p">[</span><span class="n">lkey</span><span class="p">]</span>
                    <span class="c1"># We use these attributes linked to loc code rather than</span>
                    <span class="c1"># the station data - experience shows they are not</span>
                    <span class="c1"># consistent and we should use this set.</span>
                    <span class="n">loc_lat</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">loc_lon</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">loc_elev</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                    <span class="c1"># for consistency convert this to km too</span>
                    <span class="n">loc_elev</span> <span class="o">=</span> <span class="n">loc_elev</span> <span class="o">/</span> <span class="mf">1000.0</span>
                    <span class="n">loc_edepth</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
                    <span class="n">loc_stime</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">loc_stime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">loc_stime</span><span class="p">)</span>
                    <span class="n">loc_etime</span> <span class="o">=</span> <span class="n">loc_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">loc_etime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">loc_etime</span><span class="p">)</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_lat</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_lon</span>
                    <span class="c1"># This is MongoDBs way to set a geographic</span>
                    <span class="c1"># point - allows spatial queries.  Note longitude</span>
                    <span class="c1"># must be first of the pair</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc_lat</span><span class="p">,</span> <span class="n">loc_lon</span><span class="p">]</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;elev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_elev</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;edepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_edepth</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
                    <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endtime</span><span class="o">.</span><span class="n">timestamp</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">latitude</span> <span class="o">!=</span> <span class="n">loc_lat</span>
                        <span class="ow">or</span> <span class="n">longitude</span> <span class="o">!=</span> <span class="n">loc_lon</span>
                        <span class="ow">or</span> <span class="n">elevation</span> <span class="o">!=</span> <span class="n">loc_elev</span>
                    <span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="n">net</span><span class="p">,</span>
                            <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                            <span class="n">sta</span><span class="p">,</span>
                            <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                            <span class="n">loc</span><span class="p">,</span>
                            <span class="s2">&quot; (Warning):  station section position is not consistent with loc code position&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data in loc code section overrides station section&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Station section coordinates:  &quot;</span><span class="p">,</span>
                            <span class="n">latitude</span><span class="p">,</span>
                            <span class="n">longitude</span><span class="p">,</span>
                            <span class="n">elevation</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;loc code section coordinates:  &quot;</span><span class="p">,</span>
                            <span class="n">loc_lat</span><span class="p">,</span>
                            <span class="n">loc_lon</span><span class="p">,</span>
                            <span class="n">loc_elev</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_site_is_not_in_db</span><span class="p">(</span><span class="n">rec</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
                        <span class="c1"># Note this sets site_id to an ObjectID for the insertion</span>
                        <span class="c1"># We use that to define a duplicate we tag as site_id</span>
                        <span class="n">site_id</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                            <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">site_id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;site_id&quot;</span><span class="p">:</span> <span class="n">site_id</span><span class="p">}}</span>
                        <span class="p">)</span>
                        <span class="n">n_site_saved</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;net:sta:loc=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">loc</span><span class="p">,</span>
                                <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                <span class="n">starttime</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="p">,</span>
                                <span class="s2">&quot; added to site collection&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;net:sta:loc=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                <span class="n">loc</span><span class="p">,</span>
                                <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                <span class="n">starttime</span><span class="p">,</span>
                                <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="p">,</span>
                                <span class="s2">&quot; is already in site collection - ignored&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="n">n_site_processed</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># done with site now handle channel</span>
                    <span class="c1"># Because many features are shared we can copy rec</span>
                    <span class="c1"># note this has to be a deep copy</span>
                    <span class="n">chanrec</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
                    <span class="c1"># We don&#39;t want this baggage in the channel documents</span>
                    <span class="c1"># keep them only in the site collection</span>
                    <span class="c1"># del chanrec[&#39;serialized_inventory&#39;]</span>
                    <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">chans</span><span class="p">:</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">code</span>
                        <span class="c1"># the Dip attribute in a stationxml file</span>
                        <span class="c1"># is like strike-dip and relative to horizontal</span>
                        <span class="c1"># line with positive down.  vang is the</span>
                        <span class="c1"># css30 attribute that is spherical coordinate</span>
                        <span class="c1"># theta angle</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;vang&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">dip</span> <span class="o">+</span> <span class="mf">90.0</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;hang&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">azimuth</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;edepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">depth</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">start_date</span>
                        <span class="n">et</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">end_date</span>
                        <span class="c1"># as above be careful of null values for either end of the time range</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_starttime</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
                        <span class="n">et</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_null_endtime</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">timestamp</span>
                        <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">timestamp</span>
                        <span class="n">n_chan_processed</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_is_not_in_db</span><span class="p">(</span><span class="n">chanrec</span><span class="p">):</span>
                            <span class="n">picklestr</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span>
                            <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picklestr</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">chanrec</span><span class="p">)</span>
                            <span class="c1"># insert_one has an obnoxious behavior in that it</span>
                            <span class="c1"># inserts the ObjectId in chanrec.  In this loop</span>
                            <span class="c1"># we reuse chanrec so we have to delete the id field</span>
                            <span class="c1"># howeveer, we first want to update the record to</span>
                            <span class="c1"># have chan_id provide an  alternate key to that id</span>
                            <span class="c1"># object_id - that makes this consistent with site</span>
                            <span class="c1"># we actually use the return instead of pulling from</span>
                            <span class="c1"># chanrec</span>
                            <span class="n">idobj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
                            <span class="n">dbchannel</span><span class="o">.</span><span class="n">update_one</span><span class="p">(</span>
                                <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;chan_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">}}</span>
                            <span class="p">)</span>
                            <span class="k">del</span> <span class="n">chanrec</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
                            <span class="n">n_chan_saved</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s2">&quot;net:sta:loc:chan=&quot;</span><span class="p">,</span>
                                    <span class="n">net</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">sta</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">loc</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">chan</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
                                    <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                    <span class="n">st</span><span class="p">,</span>
                                    <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                    <span class="n">et</span><span class="p">,</span>
                                    <span class="s2">&quot; added to channel collection&quot;</span><span class="p">,</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s2">&quot;net:sta:loc:chan=&quot;</span><span class="p">,</span>
                                    <span class="n">net</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">sta</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">loc</span><span class="p">,</span>
                                    <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                                    <span class="n">chan</span><span class="o">.</span><span class="n">code</span><span class="p">,</span>
                                    <span class="s2">&quot;for time span &quot;</span><span class="p">,</span>
                                    <span class="n">st</span><span class="p">,</span>
                                    <span class="s2">&quot; to &quot;</span><span class="p">,</span>
                                    <span class="n">et</span><span class="p">,</span>
                                    <span class="s2">&quot; already in channel collection - ignored&quot;</span><span class="p">,</span>
                                <span class="p">)</span>

        <span class="c1"># Tried this to create a geospatial index.   Failing</span>
        <span class="c1"># in later debugging for unknown reason.   Decided it</span>
        <span class="c1"># should be a done externally anyway as we don&#39;t use</span>
        <span class="c1"># that feature now - thought of doing so but realized</span>
        <span class="c1"># was unnecessary baggage</span>
        <span class="c1"># dbcol.create_index([&quot;coords&quot;,GEOSPHERE])</span>
        <span class="c1">#</span>
        <span class="c1"># For now we will always print this summary information</span>
        <span class="c1"># For expected use it would be essential information</span>
        <span class="c1">#</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Database.save_inventory processing summary:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of site records processed=&quot;</span><span class="p">,</span> <span class="n">n_site_processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of site records saved=&quot;</span><span class="p">,</span> <span class="n">n_site_saved</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of channel records processed=&quot;</span><span class="p">,</span> <span class="n">n_chan_processed</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of channel records saved=&quot;</span><span class="p">,</span> <span class="n">n_chan_saved</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">n_site_saved</span><span class="p">,</span> <span class="n">n_chan_saved</span><span class="p">,</span> <span class="n">n_site_processed</span><span class="p">,</span> <span class="n">n_chan_processed</span><span class="p">])</span></div>

<div class="viewcode-block" id="Database.read_inventory"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.read_inventory">[docs]</a>    <span class="k">def</span> <span class="nf">read_inventory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads an obspy inventory object limited by one or more</span>
<span class="sd">        keys.   Default is to load the entire contents of the</span>
<span class="sd">        site collection.   Note the load creates an obspy</span>
<span class="sd">        inventory object that is returned.  Use load_stations</span>
<span class="sd">        to return the raw data used to construct an Inventory.</span>

<span class="sd">        :param net:  network name query string.  Can be a single</span>
<span class="sd">        unique net code or use MongoDB&#39;s expression query</span>
<span class="sd">        mechanism (e.g. &quot;{&#39;$gt&#39; : 42}).  Default is all</span>
<span class="sd">        :param sta: statoin name query string.  Can be a single</span>
<span class="sd">        station name or a MongoDB query expression.</span>
<span class="sd">        :param loc:  loc code to select.  Can be a single unique</span>
<span class="sd">        location (e.g. &#39;01&#39;) or a MongoDB expression query.</span>
<span class="sd">        :param time:   limit return to stations with</span>
<span class="sd">        startime&lt;time&lt;endtime.  Input is assumed an</span>
<span class="sd">        epoch time NOT an obspy UTCDateTime. Use a conversion</span>
<span class="sd">        to epoch time if necessary.</span>
<span class="sd">        :return:  obspy Inventory of all stations matching the</span>
<span class="sd">        query parameters</span>
<span class="sd">        :rtype:  obspy Inventory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">net</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Inventory</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stations</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                <span class="n">serialized</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;serialized_inventory&quot;</span><span class="p">]</span>
                <span class="n">netw</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">serialized</span><span class="p">)</span>
                <span class="c1"># It might be more efficient to build a list of</span>
                <span class="c1"># Network objects but here we add them one</span>
                <span class="c1"># station at a time.  Note the extend method</span>
                <span class="c1"># if poorly documented in obspy</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">netw</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Database.get_seed_site"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_seed_site">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;NONE&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The site collection is assumed to have a one to one</span>
<span class="sd">        mapping of net:sta:loc:starttime - endtime.</span>
<span class="sd">        This method uses a restricted query to match the</span>
<span class="sd">        keys given and returns a dict of coordinate data;</span>
<span class="sd">        lat, lon, elev, edepth.</span>
<span class="sd">        The (optional) time arg is used for a range match to find</span>
<span class="sd">        period between the site startime and endtime.</span>
<span class="sd">        Returns None if there is no match.</span>

<span class="sd">        The seed modifier in the name is to emphasize this method is</span>
<span class="sd">        for data originating as the SEED format that use net:sta:loc:chan</span>
<span class="sd">        as the primary index.</span>

<span class="sd">        :param net:  network name to match</span>
<span class="sd">        :param sta:  station name to match</span>
<span class="sd">        :param loc:   optional loc code to made (empty string ok and common)</span>
<span class="sd">        default ignores loc in query.</span>
<span class="sd">        :param time: epoch time for requested metadata</span>

<span class="sd">        :return: MongoDB doc (dict) matching query</span>
<span class="sd">        :rtype:  python dict (document) of result.  None if there is no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="s2">&quot;NONE&quot;</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;get_seed_site (WARNING):  query=&quot;</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returned &quot;</span><span class="p">,</span> <span class="n">matchsize</span><span class="p">,</span> <span class="s2">&quot; documents - should be exactly one&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Returning first entry found&quot;</span><span class="p">)</span>
            <span class="n">stadoc</span> <span class="o">=</span> <span class="n">dbsite</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">stadoc</span></div>

<div class="viewcode-block" id="Database.get_seed_channel"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_seed_channel">[docs]</a>    <span class="k">def</span> <span class="nf">get_seed_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">sta</span><span class="p">,</span> <span class="n">chan</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The channel collection is assumed to have a one to one</span>
<span class="sd">        mapping of net:sta:loc:chan:starttime - endtime.</span>
<span class="sd">        This method uses a restricted query to match the</span>
<span class="sd">        keys given and returns a dict of the document contents</span>
<span class="sd">        associated with that key.  Note net, sta, and chan are required</span>
<span class="sd">        but loc is optional.</span>

<span class="sd">        The optional loc code is handled specially.  The reason is</span>
<span class="sd">        that it is common to have the loc code empty.  In seed data that</span>
<span class="sd">        puts two ascii blank characters in the 2 byte packet header</span>
<span class="sd">        position for each miniseed blockette.  With pymongo that</span>
<span class="sd">        can be handled one of three ways that we need to handle gracefully.</span>
<span class="sd">        That is, one can either set a literal two blank character</span>
<span class="sd">        string, an empty string (&quot;&quot;), or a MongoDB NULL.   To handle</span>
<span class="sd">        that confusion this algorithm first queries for all matches</span>
<span class="sd">        without loc defined.  If only one match is found that is</span>
<span class="sd">        returned immediately.  If there are multiple matches we</span>
<span class="sd">        search though the list of docs returned for a match to</span>
<span class="sd">        loc being conscious of the null string oddity.</span>

<span class="sd">        The (optional) time arg is used for a range match to find</span>
<span class="sd">        period between the site startime and endtime.  If not used</span>
<span class="sd">        the first occurence will be returned (usually ill adivsed)</span>
<span class="sd">        Returns None if there is no match.  Although the time argument</span>
<span class="sd">        is technically option it usually a bad idea to not include</span>
<span class="sd">        a time stamp because most stations saved as seed data have</span>
<span class="sd">        time variable channel metadata.</span>

<span class="sd">        :param net:  network name to match</span>
<span class="sd">        :param sta:  station name to match</span>
<span class="sd">        :param chan:  seed channel code to match</span>
<span class="sd">        :param loc:   optional loc code to made (empty string ok and common)</span>
<span class="sd">        default ignores loc in query.</span>
<span class="sd">        :param time: epoch time for requested metadata</span>

<span class="sd">        :return: handle to query return</span>
<span class="sd">        :rtype:  MondoDB Cursor object of query result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">}</span>
        <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note we only land here when the above yields multiple matches</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We could get here one of two ways.  There could</span>
                <span class="c1"># be multiple loc codes and the user didn&#39;t specify</span>
                <span class="c1"># a choice or they wanted the empty string (2 cases).</span>
                <span class="c1"># We also have to worry about the case where the</span>
                <span class="c1"># time was not specified but needed.</span>
                <span class="c1"># The complexity below tries to unravel all those possibities</span>
                <span class="n">testquery</span> <span class="o">=</span> <span class="n">query</span>
                <span class="n">testquery</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;get_seed_channel:  multiple matches found for net=&quot;</span><span class="p">,</span>
                            <span class="n">net</span><span class="p">,</span>
                            <span class="s2">&quot; sta=&quot;</span><span class="p">,</span>
                            <span class="n">sta</span><span class="p">,</span>
                            <span class="s2">&quot; and channel=&quot;</span><span class="p">,</span>
                            <span class="n">chan</span><span class="p">,</span>
                            <span class="s2">&quot; with null loc code</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="s2">&quot;Assuming database problem with duplicate documents in channel collection</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Returning first one found&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                            <span class="s2">&quot;get_seed_channel:  &quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;query with &quot;</span>
                            <span class="o">+</span> <span class="n">net</span>
                            <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                            <span class="o">+</span> <span class="n">sta</span>
                            <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                            <span class="o">+</span> <span class="n">chan</span>
                            <span class="o">+</span> <span class="s2">&quot; and null loc is ambiguous</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;Specify at least time but a loc code if is not truly null&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we land here if a null match didn&#39;t work.</span>
                    <span class="c1"># Try one more recovery with setting loc to an emtpy</span>
                    <span class="c1"># string</span>
                    <span class="n">testquery</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">matchsize</span> <span class="o">=</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;get_seed_channel:  multiple matches found for net=&quot;</span><span class="p">,</span>
                                <span class="n">net</span><span class="p">,</span>
                                <span class="s2">&quot; sta=&quot;</span><span class="p">,</span>
                                <span class="n">sta</span><span class="p">,</span>
                                <span class="s2">&quot; and channel=&quot;</span><span class="p">,</span>
                                <span class="n">chan</span><span class="p">,</span>
                                <span class="s2">&quot; with null loc code tested with empty string</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="s2">&quot;Assuming database problem with duplicate documents in channel collection</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;Returning first one found&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="k">return</span> <span class="n">dbchannel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">testquery</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                                <span class="s2">&quot;get_seed_channel:  &quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;recovery query attempt with &quot;</span>
                                <span class="o">+</span> <span class="n">net</span>
                                <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                                <span class="o">+</span> <span class="n">sta</span>
                                <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
                                <span class="o">+</span> <span class="n">chan</span>
                                <span class="o">+</span> <span class="s2">&quot; and null loc converted to empty string is ambiguous</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="o">+</span> <span class="s2">&quot;Specify at least time but a loc code if is not truly null&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;Fatal&quot;</span><span class="p">,</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="Database.get_response"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.get_response">[docs]</a>    <span class="k">def</span> <span class="nf">get_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chan</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an obspy Response object for seed channel defined by</span>
<span class="sd">        the standard keys net, sta, chan, and loc and a time stamp.</span>
<span class="sd">        Input time can be a UTCDateTime or an epoch time stored as a float.</span>

<span class="sd">        :param db:  mspasspy Database handle containing a channel collection</span>
<span class="sd">          to be queried</span>
<span class="sd">        :param net: seed network code (required)</span>
<span class="sd">        :param sta: seed station code (required)</span>
<span class="sd">        :param chan:  seed channel code (required)</span>
<span class="sd">        :param loc:  seed net code.  If None loc code will not be</span>
<span class="sd">          included in the query.  If loc is anything else it is passed</span>
<span class="sd">          as a literal.  Sometimes loc codes are not defined by in the</span>
<span class="sd">          seed data and are literal two ascii space characters.  If so</span>
<span class="sd">          MongoDB translates those to &quot;&quot;.   Use loc=&quot;&quot; for that case or</span>
<span class="sd">          provided the station doesn&#39;t mix null and other loc codes use None.</span>
<span class="sd">        :param time:  time stamp for which the response is requested.</span>
<span class="sd">          seed metadata has a time range for validity this field is</span>
<span class="sd">          required.   Can be passed as either a UTCDateTime object or</span>
<span class="sd">          a raw epoch time stored as a python float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">chan</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">net</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;get_response:  missing one of required arguments:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;net, sta, chan, or time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Invalid&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;net&quot;</span><span class="p">:</span> <span class="n">net</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">:</span> <span class="n">sta</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">:</span> <span class="n">chan</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span>  <span class="c1"># set here but not used</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">UTCDateTime</span><span class="p">):</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">t0</span><span class="p">}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">t0</span><span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;No matching documents found in channel for &quot;</span><span class="p">,</span>
                <span class="n">net</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="n">sta</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
                <span class="n">chan</span><span class="p">,</span>
                <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="s2">&quot;&lt;-&quot;</span><span class="p">,</span>
                <span class="s2">&quot; at time=&quot;</span><span class="p">,</span>
                <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="s2">&quot; matching documents found in channel for &quot;</span><span class="p">,</span>
                <span class="n">net</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="n">sta</span><span class="p">,</span>
                <span class="s2">&quot;:&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="s2">&quot;&lt;-&quot;</span><span class="p">,</span>
                <span class="s2">&quot; at time=&quot;</span><span class="p">,</span>
                <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">t0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There should be just one - returning the first one found&quot;</span><span class="p">)</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;serialized_channel_data&quot;</span><span class="p">]</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chan</span><span class="o">.</span><span class="n">response</span></div>

<div class="viewcode-block" id="Database.save_catalog"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_catalog">[docs]</a>    <span class="k">def</span> <span class="nf">save_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the contents of an obspy Catalog object to MongoDB</span>
<span class="sd">        source collection.  All contents are saved even with</span>
<span class="sd">        no checking for existing sources with duplicate</span>
<span class="sd">        data.   Like the comparable save method for stations,</span>
<span class="sd">        save_inventory, the assumption is pre or post cleanup</span>
<span class="sd">        will be preformed if duplicates are a major issue.</span>

<span class="sd">        :param cat: is the Catalog object to be saved</span>
<span class="sd">        :param verbose: Print informational data if true.</span>
<span class="sd">        When false (default) it does it&#39;s work silently.</span>

<span class="sd">        :return: integer count of number of items saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># perhaps should demand db is handle to the source collection</span>
        <span class="c1"># but I think the cost of this lookup is tiny</span>
        <span class="c1"># to do: need to change source_id to be a copy of the _id string.</span>

        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">nevents</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">cat</span><span class="p">:</span>
            <span class="c1"># event variable in loop is an Event object from cat</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">preferred_origin</span><span class="p">()</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">preferred_magnitude</span><span class="p">()</span>
            <span class="n">picklestr</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># rec[&#39;source_id&#39;]=source_id</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">latitude</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">longitude</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">longitude</span><span class="p">]</span>
            <span class="c1"># It appears quakeml puts source depths in meter</span>
            <span class="c1"># convert to km</span>
            <span class="c1"># also obspy&#39;s catalog object seesm to allow depth to be</span>
            <span class="c1"># a None so we have to test for that condition to avoid</span>
            <span class="c1"># aborts</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">depth</span> <span class="o">/</span> <span class="mf">1000.0</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">otime</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">time</span>
            <span class="c1"># This attribute of UTCDateTime is the epoch time</span>
            <span class="c1"># In mspass we only story time as epoch times</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">otime</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mag</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;magnitude_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">magnitude_type</span>
            <span class="n">rec</span><span class="p">[</span><span class="s2">&quot;serialized_event&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">picklestr</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
            <span class="c1"># the return of an insert_one has the object id of the insertion</span>
            <span class="c1"># set as inserted_id.  We save taht as source_id as a more</span>
            <span class="c1"># intuitive key that _id</span>
            <span class="n">idobj</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">update_one</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;source_id&quot;</span><span class="p">:</span> <span class="n">idobj</span><span class="p">}})</span>
            <span class="n">nevents</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">nevents</span></div>

<div class="viewcode-block" id="Database.load_event"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.load_event">[docs]</a>    <span class="k">def</span> <span class="nf">load_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a bson record of source data matching the unique id</span>
<span class="sd">        defined by source_id.   The idea is that magic string would</span>
<span class="sd">        be extraced from another document (e.g. in an arrival collection)</span>
<span class="sd">        and used to look up the event with which it is associated in</span>
<span class="sd">        the source collection.</span>

<span class="sd">        This function is a relic and may be depricated.  I originally</span>
<span class="sd">        had a different purpose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbsource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dbsource</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s2">&quot;source_id&quot;</span><span class="p">:</span> <span class="n">source_id</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="c1">#  Methods for handling miniseed data</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_mseed_index</span><span class="p">(</span><span class="n">index_record</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper used to convert C++ struct/class mseed_index to a dict</span>
<span class="sd">        to use for saving to mongod.  Note loc is only set if it is not</span>
<span class="sd">        zero length - consistent with mspass approach</span>

<span class="sd">        :param index_record:  mseed_index record to convert</span>
<span class="sd">        :return: dict containing index data converted to dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">sta</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">net</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">chan</span>
        <span class="k">if</span> <span class="n">index_record</span><span class="o">.</span><span class="n">loc</span><span class="p">:</span>
            <span class="n">o</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">loc</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">samprate</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">index_record</span><span class="o">.</span><span class="n">samprate</span><span class="p">)</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">starttime</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;last_packet_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">last_packet_time</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;foff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">foff</span>
        <span class="n">o</span><span class="p">[</span><span class="s2">&quot;nbytes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_record</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="c1"># FIXME: The following are commented out because some simple tests showed that</span>
        <span class="c1">#   the numbers are very different from the data being read by ObsPy&#39;s reader.</span>
        <span class="c1"># o[&#39;endtime&#39;] = index_record.endtime</span>
        <span class="c1"># o[&#39;npts&#39;] = index_record.npts</span>
        <span class="k">return</span> <span class="n">o</span>

<div class="viewcode-block" id="Database.index_mseed_file"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_file">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">segment_time_tears</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">elog_collection</span><span class="o">=</span><span class="s2">&quot;elog&quot;</span><span class="p">,</span>
        <span class="n">return_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data.  This function scans a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument.  I builds an index</span>
<span class="sd">        for the file and writes the index to mongodb</span>
<span class="sd">        in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default).   The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>
<span class="sd">        The index is appropriate ONLY if the data on the file are created</span>
<span class="sd">        by concatenating data with packets sorted by net, sta, loc, chan, time</span>
<span class="sd">        AND the data are contiguous in time.   The original</span>
<span class="sd">        concept for this function came from the need to handle large files</span>
<span class="sd">        produced by concanentation of miniseed single-channel files created</span>
<span class="sd">        by obpsy&#39;s mass_downloader.   i.e. the basic model is the input</span>
<span class="sd">        files are assumed to be something comparable to running the unix</span>
<span class="sd">        cat command on a set of single-channel, contingous time sequence files.</span>
<span class="sd">        There are other examples that do the same thing (e.g. antelope&#39;s</span>
<span class="sd">        miniseed2days).</span>

<span class="sd">        We emphasize this function only builds an index - it does not</span>
<span class="sd">        convert any data.   It has to scan the entire file deriving the</span>
<span class="sd">        index from data retrieved from miniseed packets with libmseed so</span>
<span class="sd">        for large data sets this can take a long time.</span>

<span class="sd">        Actual seismic data stored as miniseed are prone to time tears.</span>
<span class="sd">        That can happen at the instrument level in at least two common</span>
<span class="sd">        ways: (1) dropped packets from telemetry issues, or (2) instrument</span>
<span class="sd">        timing jumps when a clock loses external lock to gps or some</span>
<span class="sd">        other standard and the rock is restored.  The behavior is this</span>
<span class="sd">        function in gap handling is controlled by the input parameter</span>
<span class="sd">        segment_time_tears.  When true a new index entry is created</span>
<span class="sd">        any time the start time of a packet differs from that computed</span>
<span class="sd">        from the endtime of the last packet by more than one sample</span>
<span class="sd">        AND net:sta:chan:loc are constant.  The default for this</span>
<span class="sd">        parameter is false because data with many dropped packets from</span>
<span class="sd">        telemetry are common and can create overwhelming numbers of</span>
<span class="sd">        index entries quickly.  When false the scan only creates a new</span>
<span class="sd">        index record when net, sta, chan, or loc change between successive</span>
<span class="sd">        packets.  Our reader has gap handling functions to handle</span>
<span class="sd">        time tears.  Set segment_time_tears true only when you are</span>
<span class="sd">        confident the data set does not contain a large number of dropped</span>
<span class="sd">        packets.</span>

<span class="sd">        Note to parallelize this function put a list of files in a Spark</span>
<span class="sd">        RDD or a Dask bag and parallelize the call the this function.</span>
<span class="sd">        That can work because MongoDB is designed for parallel operations</span>
<span class="sd">        and we use the thread safe version of the libmseed reader.</span>

<span class="sd">        Finally, note that cross referencing with the channel and/or</span>
<span class="sd">        source collections should be a common step after building the</span>
<span class="sd">        index with this function.  The reader found elsewhere in this</span>
<span class="sd">        module will transfer linking ids (i.e. channel_id and/or source_id)</span>
<span class="sd">        to TimeSeries objects when it reads the data from the files</span>
<span class="sd">        indexed by this function.</span>

<span class="sd">        :param dfile:  file name of data to be indexed.  Asssumed to be</span>
<span class="sd">          the leaf node of the path - i.e. it contains no directory information</span>
<span class="sd">          but just the file name.</span>
<span class="sd">        :param dir:  directory name.  This can be a relative path from the</span>
<span class="sd">          current directory be be advised it will always be converted to an</span>
<span class="sd">          fully qualified path.  If it is undefined (the default) the function</span>
<span class="sd">          assumes the file is in the current working directory and will use</span>
<span class="sd">          the result of the python getcwd command as the directory path</span>
<span class="sd">          stored in the database.</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">          index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">          to use anything but the default.</span>
<span class="sd">        :param segment_time_tears: boolean controlling handling of data gaps</span>
<span class="sd">          defined by constant net, sta, chan, and loc but a discontinuity</span>
<span class="sd">          in time tags for successive packets.  See above for a more extensive</span>
<span class="sd">          discussion of how to use this parameter.  Default is False.</span>
<span class="sd">        :param elog_collection:  name to write any error logs messages</span>
<span class="sd">          from the miniseed reader.  Default is &quot;elog&quot;, which is the</span>
<span class="sd">          same as for TimeSeries and Seismogram data, but the cross reference</span>
<span class="sd">          keys here are keyed by &quot;wf_miniseed_id&quot;.</span>
<span class="sd">        :param return_ids:  if set True the function will return a tuple</span>
<span class="sd">          with two id lists.  The 0 entry is an array of ids from the</span>
<span class="sd">          collection (wf_miniseed by default) of index entries saved and</span>
<span class="sd">          the 1 entry will contain the ids in the elog_collection of</span>
<span class="sd">          error log entry insertions.  The 1 entry will be empty if the</span>
<span class="sd">          reader found no errors and the error log was empty (the hopefully</span>
<span class="sd">          normal situation).  When this argument is False (the default) it</span>
<span class="sd">          returns None.  Set true if you need to build some kind of cross</span>
<span class="sd">          reference to read errors to build some custom cleaning method</span>
<span class="sd">          for specialized processing that can be done more efficiently.</span>
<span class="sd">          By default it is fast only to associate an error log entry with</span>
<span class="sd">          a particular waveform index entry. (we store the saved index</span>
<span class="sd">          MongoDB document id with each elog entry)</span>
<span class="sd">        :exception: This function can throw a range of error types for</span>
<span class="sd">          a long list of possible io issues.   Callers should use a</span>
<span class="sd">          generic handler to avoid aborts in a large job.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="c1"># If dir is not define assume current directory.  Otherwise</span>
        <span class="c1"># use realpath to make sure the directory is the full path</span>
        <span class="c1"># We store the full path in mongodb</span>
        <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">elog</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mseed_file_indexer</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">ids_affected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_mseed_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odir</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
            <span class="n">thisid</span> <span class="o">=</span> <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
            <span class="n">ids_affected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisid</span><span class="p">)</span>
        <span class="c1"># log_ids is created here so it is defined but empty in</span>
        <span class="c1"># the tuple returned when return_ids is true</span>
        <span class="n">log_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elog_col</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">elog_collection</span><span class="p">]</span>

            <span class="n">errs</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_error_log</span><span class="p">()</span>
            <span class="n">jobid</span> <span class="o">=</span> <span class="n">elog</span><span class="o">.</span><span class="n">get_job_id</span><span class="p">()</span>
            <span class="n">logdata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">errs</span><span class="p">:</span>
                <span class="n">logdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;job_id&quot;</span><span class="p">:</span> <span class="n">jobid</span><span class="p">,</span>
                        <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                        <span class="s2">&quot;badness&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">badness</span><span class="p">),</span>
                        <span class="s2">&quot;error_message&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">message</span><span class="p">,</span>
                        <span class="s2">&quot;process_id&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">p_id</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="n">docentry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;logdata&quot;</span><span class="p">:</span> <span class="n">logdata</span><span class="p">}</span>
            <span class="c1"># To mesh with the standard elog collection we add a copy of the</span>
            <span class="c1"># error messages with a tag for each id in the ids_affected list.</span>
            <span class="c1"># That should make elog connection to wf_miniseed records exactly</span>
            <span class="c1"># like wf_TimeSeries records but with a different collection link</span>
            <span class="k">for</span> <span class="n">wfid</span> <span class="ow">in</span> <span class="n">ids_affected</span><span class="p">:</span>
                <span class="n">docentry</span><span class="p">[</span><span class="s2">&quot;wf_miniseed_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wfid</span>
                <span class="n">elogid</span> <span class="o">=</span> <span class="n">elog_col</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">docentry</span><span class="p">)</span><span class="o">.</span><span class="n">inserted_id</span>
                <span class="n">log_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elogid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_ids</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ids_affected</span><span class="p">,</span> <span class="n">log_ids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Database.save_dataframe"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">save_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">one_to_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tansfer a dataframe into a set of documents, and store them</span>
<span class="sd">        in a specified collection. In one_to_one mode every row in the</span>
<span class="sd">        dataframe will be saved into the mongodb, otherwise duplicates</span>
<span class="sd">        would be discarded.</span>
<span class="sd">        The dataframe will first call dropna to eliminate None values stored</span>
<span class="sd">        in it, so that after it is transfered into a document, the memory</span>
<span class="sd">        usage will be reduced.</span>
<span class="sd">        :param df: Pandas.Dataframe object, the input to be transfered into mongodb</span>
<span class="sd">        documents</span>
<span class="sd">        :param collection:  MongoDB collection name to be used to save the</span>
<span class="sd">        (often subsetted) tuples of filename as documents in this collection.</span>
<span class="sd">        :param null_values:  is an optional dict defining null field values.</span>
<span class="sd">        When used an == test is applied to each attribute with a key</span>
<span class="sd">        defined in the null_vlaues python dict.  If == returns True, the</span>
<span class="sd">        value will be set as None in dataframe. If your table has a lot of null</span>
<span class="sd">        fields this option can save space, but readers must not require the null</span>
<span class="sd">        field.  The default is None which it taken to mean there are no null</span>
<span class="sd">        fields defined.</span>
<span class="sd">        :param one_to_one: a boolean to control if the set should be filtered by</span>
<span class="sd">        rows.  The default is True which means every row in the dataframe will</span>
<span class="sd">        create a single MongoDB document. If False the (normally reduced) set</span>
<span class="sd">        of attributes defined by attributes_to_use will be filtered with the</span>
<span class="sd">        panda/dask dataframe drop_duplicates method before converting the</span>
<span class="sd">        dataframe to documents and saving them to MongoDB.  That approach</span>
<span class="sd">        is important, for example, to filter things like Antelope &quot;site&quot; or</span>
<span class="sd">        &quot;sitechan&quot; attributes created by a join to something like wfdisc and</span>
<span class="sd">        saved as a text file to be processed by this function.</span>
<span class="sd">        :param parallel:  a boolean that determine if dask api will be used for</span>
<span class="sd">        operations on the dataframe, default is false.</span>
<span class="sd">        :return:  integer count of number of documents added to collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbcol</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">daskdf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">one_to_one</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>

        <span class="c1">#   For those null values, set them to None</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">null_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">null_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if parallel:</span>
<span class="sd">            df = daskdf.from_pandas(df, chunksize=1, sort=False)</span>
<span class="sd">            df = df.apply(lambda x: x.dropna(), axis=1).compute()</span>
<span class="sd">        else:</span>
<span class="sd">            df = df.apply(pd.Series.dropna, axis=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">dropna</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">doc_list</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc_list</span><span class="p">):</span>
            <span class="n">dbcol</span><span class="o">.</span><span class="n">insert_many</span><span class="p">(</span><span class="n">doc_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Database.save_textfile"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.save_textfile">[docs]</a>    <span class="k">def</span> <span class="nf">save_textfile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;textfile&quot;</span><span class="p">,</span>
        <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">s+&quot;</span><span class="p">,</span>
        <span class="n">type_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header_line</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rename_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">one_to_one</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">insert_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Import and parse a textfile into set of documents, and store them</span>
<span class="sd">        into a mongodb collection. This function consists of two steps:</span>
<span class="sd">        1. Textfile2Dataframe: Convert the input textfile into a Pandas dataframe</span>
<span class="sd">        2. save_dataframe: Insert the documents in that dataframe into a mongodb</span>
<span class="sd">        collection</span>

<span class="sd">        :param filename:  path to text file that is to be read to create the</span>
<span class="sd">        table object that is to be processed (internally we use pandas or</span>
<span class="sd">        dask dataframes)</span>
<span class="sd">        :param collection:  MongoDB collection name to be used to save the</span>
<span class="sd">        (often subsetted) tuples of filename as documents in this collection.</span>
<span class="sd">        :param separator: The delimiter used for seperating fields,</span>
<span class="sd">        the default is &quot;\s+&quot;, which is the regular expression of &quot;one or more</span>
<span class="sd">        spaces&quot;.</span>
<span class="sd">            For csv file, its value should be set to &#39;,&#39;.</span>
<span class="sd">            This parameter will be passed into pandas.read_csv or dask.dataframe.read_csv.</span>
<span class="sd">            To learn more details about the usage, check the following links:</span>
<span class="sd">            https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html</span>
<span class="sd">            https://docs.dask.org/en/latest/generated/dask.dataframe.read_csv.html</span>
<span class="sd">        :param type_dict: pairs of each attribute and its type, usedd to validate</span>
<span class="sd">        the type of each input item</span>
<span class="sd">        :param header_line: defines the line to be used as the attribute names for</span>
<span class="sd">        columns, if is &lt; 0, an attribute_names is required. Please note that if an</span>
<span class="sd">        attribute_names is provided, the attributes defined in header_line will</span>
<span class="sd">        always be override.</span>
<span class="sd">        :param attribute_names: This argument must be either a list of (unique)</span>
<span class="sd">        string names to define the attribute name tags for each column of the</span>
<span class="sd">        input table.   The length of the array must match the number of</span>
<span class="sd">        columns in the input table or this function will throw a MsPASSError</span>
<span class="sd">        exception.   This argument is None by default which means the</span>
<span class="sd">        function will assume the line specified by the &quot;header_line&quot; argument as</span>
<span class="sd">        column headers defining the attribute name.  If header_line is less</span>
<span class="sd">        than 0 this argument will be required.  When header_line is &gt;= 0</span>
<span class="sd">        and this argument (attribute_names) is defined all the names in</span>
<span class="sd">        this list will override those stored in the file at the specified</span>
<span class="sd">        line number.</span>
<span class="sd">        :param  rename_attributes:   This is expected to be a python dict</span>
<span class="sd">        keyed by names matching those defined in the file or attribute_names</span>
<span class="sd">        array (i.e. the panda/dataframe column index names) and values defining</span>
<span class="sd">        strings to use to override the original names.   That usage, of course,</span>
<span class="sd">        is most common to override names in a file.  If you want to change all</span>
<span class="sd">        the name use a custom attributes_name array as noted above.  This</span>
<span class="sd">        argument is mostly to rename a small number of anomalous names.</span>
<span class="sd">        :param attributes_to_use:  If used this argument must define a list of</span>
<span class="sd">        attribute names that define the subset of the dataframe dataframe</span>
<span class="sd">        attributes that are to be saved.  For relational db users this is</span>
<span class="sd">        effectively a &quot;select&quot; list of attribute names.  The default is</span>
<span class="sd">        None which is taken to mean no selection is to be done.</span>
<span class="sd">        :param one_to_one: is an important boolean use to control if the</span>
<span class="sd">        output is or is not filtered by rows.  The default is True</span>
<span class="sd">        which means every tuple in the input file will create a single row in</span>
<span class="sd">        dataframe. (Useful, for example, to construct an wf_miniseed</span>
<span class="sd">        collection css3.0 attributes.)  If False the (normally reduced) set</span>
<span class="sd">        of attributes defined by attributes_to_use will be filtered with the</span>
<span class="sd">        panda/dask dataframe drop_duplicates method.  That approach</span>
<span class="sd">        is important, for example, to filter things like Antelope &quot;site&quot; or</span>
<span class="sd">        &quot;sitechan&quot; attributes created by a join to something like wfdisc and</span>
<span class="sd">        saved as a text file to be processed by this function.</span>
<span class="sd">        :param parallel:  When true we use the dask dataframe operation.</span>
<span class="sd">        The default is false meaning the simpler, identical api panda</span>
<span class="sd">        operators are used.</span>
<span class="sd">        :param insert_column: a dictionary of new columns to add, and their value(s).</span>
<span class="sd">        If the content is a single value, it can be passedto define a constant value</span>
<span class="sd">        for the entire column of data. The content can also be a list, in that case,</span>
<span class="sd">        the list should contain values that are to be set, and it must be the same</span>
<span class="sd">        length as the number of tuples in the table.</span>
<span class="sd">        :return:  Integer count of number of documents added to collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">Textfile2Dataframe</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span>
            <span class="n">type_dict</span><span class="o">=</span><span class="n">type_dict</span><span class="p">,</span>
            <span class="n">header_line</span><span class="o">=</span><span class="n">header_line</span><span class="p">,</span>
            <span class="n">attribute_names</span><span class="o">=</span><span class="n">attribute_names</span><span class="p">,</span>
            <span class="n">rename_attributes</span><span class="o">=</span><span class="n">rename_attributes</span><span class="p">,</span>
            <span class="n">attributes_to_use</span><span class="o">=</span><span class="n">attributes_to_use</span><span class="p">,</span>
            <span class="n">one_to_one</span><span class="o">=</span><span class="n">one_to_one</span><span class="p">,</span>
            <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="n">insert_column</span><span class="o">=</span><span class="n">insert_column</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="n">collection</span><span class="p">,</span>
            <span class="n">null_values</span><span class="o">=</span><span class="n">null_values</span><span class="p">,</span>
            <span class="n">one_to_one</span><span class="o">=</span><span class="n">one_to_one</span><span class="p">,</span>
            <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_download_windowed_mseed_file</span><span class="p">(</span>
        <span class="n">aws_access_key_id</span><span class="p">,</span>
        <span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">station</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">channel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">t0shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function to download the miniseed file from AWS s3.</span>
<span class="sd">        A lambda function will be called, and do the timewindowing on cloud. The output file</span>
<span class="sd">        of timewindow will then be downloaded and parsed by obspy.</span>
<span class="sd">        Finally return an obspy stream object.</span>
<span class="sd">        An example of using lambda is in /scripts/aws_lambda_examples.</span>

<span class="sd">        :param aws_access_key_id &amp; aws_secret_access_key: credential for aws, used to initialize lambda_client</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param network:  network code</span>
<span class="sd">        :param station:  station code</span>
<span class="sd">        :param channel:  channel code</span>
<span class="sd">        :param location:  location code</span>
<span class="sd">        :param duration:  window duration, default value is -1, which means no window will be performed</span>
<span class="sd">        :param t0shift: shift the start time, default is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
            <span class="n">service_name</span><span class="o">=</span><span class="s2">&quot;lambda&quot;</span><span class="p">,</span>
            <span class="n">region_name</span><span class="o">=</span><span class="s2">&quot;us-west-2&quot;</span><span class="p">,</span>
            <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
            <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">s3_input_bucket</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">s3_output_bucket</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;scedcdata&quot;</span>
        <span class="p">)</span>  <span class="c1">#   The output file can be saved to this bucket, user might want to change it into their own bucket</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">source_key</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">source_key</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="n">event</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;src_bucket&quot;</span><span class="p">:</span> <span class="n">s3_input_bucket</span><span class="p">,</span>
            <span class="s2">&quot;dst_bucket&quot;</span><span class="p">:</span> <span class="n">s3_output_bucket</span><span class="p">,</span>
            <span class="s2">&quot;src_key&quot;</span><span class="p">:</span> <span class="n">source_key</span><span class="p">,</span>
            <span class="s2">&quot;dst_key&quot;</span><span class="p">:</span> <span class="n">source_key</span><span class="p">,</span>
            <span class="s2">&quot;save_to_s3&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s2">&quot;t0shift&quot;</span><span class="p">:</span> <span class="n">t0shift</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">lambda_client</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span>
            <span class="n">FunctionName</span><span class="o">=</span><span class="s2">&quot;TimeWindowFunction&quot;</span><span class="p">,</span>  <span class="c1">#   The name of lambda function on cloud</span>
            <span class="n">InvocationType</span><span class="o">=</span><span class="s2">&quot;RequestResponse&quot;</span><span class="p">,</span>
            <span class="n">LogType</span><span class="o">=</span><span class="s2">&quot;Tail&quot;</span><span class="p">,</span>
            <span class="n">Payload</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">event</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">response_payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Payload&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="n">ret_type</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_type&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ret_type</span> <span class="o">==</span> <span class="s2">&quot;key&quot;</span>
        <span class="p">):</span>  <span class="c1"># If the ret_type is &quot;key&quot;, the output file is stored in another s3 bucket,</span>
            <span class="c1"># we have to fetch it again.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret_bucket</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ret_key</span> <span class="o">=</span> <span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">s3_client</span> <span class="o">=</span> <span class="n">boto3</span><span class="o">.</span><span class="n">client</span><span class="p">(</span>
                    <span class="s2">&quot;s3&quot;</span><span class="p">,</span>
                    <span class="n">aws_access_key_id</span><span class="o">=</span><span class="n">aws_access_key_id</span><span class="p">,</span>
                    <span class="n">aws_secret_access_key</span><span class="o">=</span><span class="n">aws_secret_access_key</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">ret_bucket</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">ret_key</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
                <span class="k">return</span> <span class="n">st</span>

            <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                    <span class="c1"># the object does not exist</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret_key</span><span class="p">,</span> <span class="n">ret_bucket</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;Error while downloading the output object.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="n">filecontent</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">response_payload</span><span class="p">[</span><span class="s2">&quot;ret_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="n">stringio_obj</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">filecontent</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">stringio_obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">st</span>

<div class="viewcode-block" id="Database.index_mseed_s3_continuous"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_s3_continuous">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_s3_continuous</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s3_client</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">station</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">channel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">storage_mode</span><span class="o">=</span><span class="s2">&quot;s3_continuous&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data. However, instead of scanning a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument, it reads the miniseed content from AWS s3.</span>
<span class="sd">        It builds and index it writes to mongodb in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default). The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>

<span class="sd">        :param s3_client:  s3 Client object given by user, which contains credentials</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param network:  network code</span>
<span class="sd">        :param station:  station code</span>
<span class="sd">        :param channel:  channel code</span>
<span class="sd">        :param location:  location code</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">            index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">            to use anything but the default.</span>
<span class="sd">        :exception: This function will do nothing if the obejct does not exist. For other</span>
<span class="sd">            exceptions, it would raise a MsPASSError.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="s2">&quot;continuous_waveforms/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">network</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">network</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">station</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>

        <span class="n">mseed_file</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">network</span> <span class="o">+</span> <span class="n">station</span> <span class="o">+</span> <span class="n">channel</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span> <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>
        <span class="n">KEY</span> <span class="o">+=</span> <span class="n">mseed_file</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">stringio_obj</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">stringio_obj</span><span class="p">)</span>
            <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
            <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

            <span class="n">stats</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;station&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;network&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;channel&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;location&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]:</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="k">if</span> <span class="s2">&quot;npts&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]:</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">storage_mode</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
            <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;An ClientError occur when tyring to get the object by the KEY(&quot;</span>
                    <span class="o">+</span> <span class="n">KEY</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; with error: &quot;</span><span class="p">,</span>
                    <span class="n">e</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while index mseed file from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="Database.index_mseed_s3_event"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_s3_event">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_s3_event</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s3_client</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">dfile</span><span class="p">,</span>
        <span class="nb">dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the first stage import function for handling the import of</span>
<span class="sd">        miniseed data. However, instead of scanning a data file defined by a directory</span>
<span class="sd">        (dir arg) and dfile (file name) argument, it reads the miniseed content from AWS s3.</span>
<span class="sd">        It builds and index it writes to mongodb in the collection defined by the collection</span>
<span class="sd">        argument (wf_miniseed by default). The index is bare bones</span>
<span class="sd">        miniseed tags (net, sta, chan, and loc) with a starttime tag.</span>

<span class="sd">        :param s3_client:  s3 Client object given by user, which contains credentials</span>
<span class="sd">        :param year:  year for the query mseed file(4 digit).</span>
<span class="sd">        :param day_of_year:  day of year for the query of mseed file(3 digit [001-366])</span>
<span class="sd">        :param filename:  SCSN catalog event id for the event</span>
<span class="sd">        :param collection:  is the mongodb collection name to write the</span>
<span class="sd">            index data to.  The default is &#39;wf_miniseed&#39;.  It should be rare</span>
<span class="sd">            to use anything but the default.</span>
<span class="sd">        :exception: This function will do nothing if the obejct does not exist. For other</span>
<span class="sd">            exceptions, it would raise a MsPASSError.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="n">BUCKET_NAME</span> <span class="o">=</span> <span class="s2">&quot;scedc-pds&quot;</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">KEY</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;event_waveforms/&quot;</span>
            <span class="o">+</span> <span class="n">year</span>
            <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="o">+</span> <span class="n">year</span>
            <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
            <span class="o">+</span> <span class="n">day_of_year</span>
            <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
            <span class="o">+</span> <span class="n">filename</span>
            <span class="o">+</span> <span class="s2">&quot;.ms&quot;</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">s3_client</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">Bucket</span><span class="o">=</span><span class="n">BUCKET_NAME</span><span class="p">,</span> <span class="n">Key</span><span class="o">=</span><span class="n">KEY</span><span class="p">)</span>
            <span class="n">mseed_content</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s2">&quot;Body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c1"># specify the file path</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">odir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">odir</span><span class="p">,</span> <span class="n">dfile</span><span class="p">)</span>
            <span class="c1"># temporarily write data into a file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mseed_content</span><span class="p">)</span>
            <span class="c1"># immediately read data from the file</span>
            <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">elog</span><span class="p">)</span> <span class="o">=</span> <span class="n">_mseed_file_indexer</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_mseed_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;s3_event&quot;</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">odir</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;dfile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfile</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
                <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
                <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">botocore</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ClientError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">response</span><span class="p">[</span><span class="s2">&quot;Error&quot;</span><span class="p">][</span><span class="s2">&quot;Code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;404&quot;</span><span class="p">:</span>
                <span class="c1"># the object does not exist</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find the object by the KEY: </span><span class="si">{}</span><span class="s2"> from the BUCKET: </span><span class="si">{}</span><span class="s2"> in s3&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KEY</span><span class="p">,</span> <span class="n">BUCKET_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;An ClientError occur when tyring to get the object by the KEY(&quot;</span>
                    <span class="o">+</span> <span class="n">KEY</span>
                    <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; with error: &quot;</span><span class="p">,</span>
                    <span class="n">e</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;Error while index mseed file from s3.&quot;</span><span class="p">,</span> <span class="s2">&quot;Fatal&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="Database.index_mseed_FDSN"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.database.Database.index_mseed_FDSN">[docs]</a>    <span class="k">def</span> <span class="nf">index_mseed_FDSN</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">provider</span><span class="p">,</span>
        <span class="n">year</span><span class="p">,</span>
        <span class="n">day_of_year</span><span class="p">,</span>
        <span class="n">network</span><span class="p">,</span>
        <span class="n">station</span><span class="p">,</span>
        <span class="n">location</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">dbh</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">provider</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
        <span class="n">day_of_year</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">day_of_year</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">day_of_year</span><span class="p">))</span> <span class="o">+</span> <span class="n">day_of_year</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="n">year</span> <span class="o">+</span> <span class="n">day_of_year</span><span class="p">,</span> <span class="n">iso8601</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms</span><span class="p">(</span>
            <span class="n">network</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span>
        <span class="p">)</span>
        <span class="c1"># there could be more than 1 trace object in the stream, merge the traces</span>
        <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;provider&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">provider</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">year</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;day_of_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day_of_year</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">station</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">network</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;sampling_rate&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="k">if</span> <span class="s2">&quot;npts&quot;</span> <span class="ow">in</span> <span class="n">stats</span> <span class="ow">and</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]:</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;npts&quot;</span><span class="p">]</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;storage_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fdsn&quot;</span>
        <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mseed&quot;</span>
        <span class="n">dbh</span><span class="o">.</span><span class="n">insert_one</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>