

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>mspasspy.db.normalize &mdash; MsPASS 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> MsPASS
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_on_HPC.html">Deploy MsPASS on HPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started_overview.html">MsPASS Setup In-Depth Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

            
          
    <a href= "../../../genindex.html">Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mspasspy.db.normalize</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mspasspy.db.normalize</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">mspasspy.ccore.utility</span> <span class="kn">import</span> <span class="n">MsPASSError</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="p">,</span> <span class="n">Metadata</span>
<span class="kn">from</span> <span class="nn">mspasspy.util.error_logger</span> <span class="kn">import</span> <span class="n">PyErrorLogger</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.seismic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">Seismogram</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.db.database</span> <span class="kn">import</span> <span class="n">Database</span>
<span class="kn">from</span> <span class="nn">mspasspy.util.decorators</span> <span class="kn">import</span> <span class="n">mspass_func_wrapper</span>

<span class="kn">from</span> <span class="nn">bson</span> <span class="kn">import</span> <span class="n">ObjectId</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span>
<span class="kn">import</span> <span class="nn">pymongo</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">type_pdd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span>
<span class="n">type_ddd</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">DataFrame</span>


<div class="viewcode-block" id="BasicMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.BasicMatcher">[docs]</a><span class="k">class</span> <span class="nc">BasicMatcher</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining the api for a generic matching capability for</span>
<span class="sd">    MongoDB normalization.   The base class is a skeleton that</span>
<span class="sd">    defines on required abstract methods and initializes a set of</span>
<span class="sd">    universal attributes all matchers need.  It cannot be instatiated directly.</span>

<span class="sd">    Matching is defined as one of two things:  (1)  a one-to-one</span>
<span class="sd">    match algorithm is guaranteed to have each search yield either</span>
<span class="sd">    exactly one match or none.  That is defined through a find_one</span>
<span class="sd">    method following the same concept in MongoDB.  (2) some</span>
<span class="sd">    matches are not unique and yield more than one document.</span>
<span class="sd">    For that case use the find method.  Unlike the MongoDB</span>
<span class="sd">    find method, however, find in this context returns a list of</span>
<span class="sd">    Metadata containers holding the set of attributes requested</span>
<span class="sd">    in lists defined on constuction.</span>

<span class="sd">    Another way of viewing this interface, in fact, is an abstraction of</span>
<span class="sd">    the find and find_one methods of MongoDB to a wider class of</span>
<span class="sd">    algorithms that may or may not utilize MongoDB directly.</span>
<span class="sd">    In particular, intermediate level classes defined below that implement</span>
<span class="sd">    different cache data structures allow input either by</span>
<span class="sd">    loading data from a MongoDB collection of from a pandas DataFrame.</span>
<span class="sd">    That can potentially provide a wide variety of applications of</span>
<span class="sd">    matching data to tabular data contained in files loaded into</span>
<span class="sd">    pandas by any of long list of standard dataframe read methods.</span>
<span class="sd">    Examples are any SQL database or antelope raw tables or views</span>
<span class="sd">    loaded as text files.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base class constructor sets only attributes considered necessary for all</span>
<span class="sd">        subclasses.   Most if not all subclasses will want to call this</span>
<span class="sd">        constructor driven by an arg list passed to the subclass constructor.</span>

<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded from the normalizing table/collection.   Default for</span>
<span class="sd">          this base class is None, but subclasses should normally define</span>
<span class="sd">          a default list.  It is important to realize that all subclasses</span>
<span class="sd">          should normally treat this list as a set of required attributes.</span>
<span class="sd">          Optional values should appear in the load_if_defined list.</span>

<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None here,</span>
<span class="sd">          subclass should set their own default values.</span>

<span class="sd">        :param aliases:   should be a python dictionary used to define</span>
<span class="sd">          alternative keys to access a data object&#39;s Metadata from that</span>
<span class="sd">          defining the same attribute in the collection/table being</span>
<span class="sd">          matched.   Note carefully the key of the dictionary is the</span>
<span class="sd">          collection/table attribute name and the value associated with</span>
<span class="sd">          that key is the alias to use to fetch Metadata.  When matchers</span>
<span class="sd">          scan the attributes_to_load and load_if_defined list they</span>
<span class="sd">          should treat missing entries in alias as meaning the key in</span>
<span class="sd">          the collection/table and Metadata are identical.  Default is</span>
<span class="sd">          a None which is used as a signal to this constructor to</span>
<span class="sd">          create an empty dictionary meaning there are no aliases.</span>
<span class="sd">        :type aliases:  python dictionary</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">attributes_to_load</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">load_if_defined</span>
        <span class="k">if</span> <span class="n">aliases</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aliases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span> <span class="o">=</span> <span class="n">aliases</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;BasicMatcher constructor: aliases argument must be either None or define a python dictionary&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method that allows the shorthand of the find_one method</span>
<span class="sd">        using the standard python meaning of this symbol.  e.g. if</span>
<span class="sd">        we have an concrete instance of a subclass of this base class</span>
<span class="sd">        for matching against ObjectIds using the implementation below</span>
<span class="sd">        called IDMatcher we assign to the symbol &quot;matcher&quot; we can</span>
<span class="sd">        get a Metadata container of the matching content for a MsPASS</span>
<span class="sd">        data object with symbol d using md = matcher(d) versus</span>
<span class="sd">        md = matcher.find_one(d).  All subclasses have this interface</span>
<span class="sd">        define because it is a (nonvirtual) base class method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="BasicMatcher.find"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.BasicMatcher.find">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstraction of the MongoDB database find method with the</span>
<span class="sd">        matching criteria defined when a concrete instance is instantiated.</span>
<span class="sd">        Like the MongoDB method implementations it should return a list</span>
<span class="sd">        of containers matching the keys found in the data passed through</span>
<span class="sd">        the mspass_object.  A key difference from MongoDB, however, is</span>
<span class="sd">        that instead of a MongoDB cursor we return a python list of Metadata</span>
<span class="sd">        containers.   In some instances that is a</span>
<span class="sd">        direct translation of a MongoDB cursor to a list of Metadata</span>
<span class="sd">        objects.  The abstraction is useful to allow small collections</span>
<span class="sd">        to be accessed faster with a generic cache algorithm (see below)</span>
<span class="sd">        and loading of tables of data through a file-based subclass</span>
<span class="sd">        of this base.  All can be treated through a common interface.</span>
<span class="sd">        WE STRESS STRONGLY that the abstraction assumes returns are</span>
<span class="sd">        always small enough to not cause a memory bloating problem.</span>
<span class="sd">        If you need the big-memory model of a cursor use it directly.</span>

<span class="sd">        All subclasses must implement this virtual</span>
<span class="sd">        method to be concrete or they cannot be instantiated.</span>
<span class="sd">        If the matching algorithm implemented is always expected to</span>
<span class="sd">        be a unique one-to-one match applications may want to have this</span>
<span class="sd">        method throw an exception as a use error.  That case should</span>
<span class="sd">        use the find_one interface defined below.</span>

<span class="sd">        All implementations should return a pair (2 component tuple).</span>
<span class="sd">        0 is expected to hold a list of Metadata containers and</span>
<span class="sd">        1 is expected to contain either a None type or an PyErrorLogger</span>
<span class="sd">        object.   The PyErrorLogger is a convenient way to pass error</span>
<span class="sd">        messages back to the caller in a manner that is easier to handle</span>
<span class="sd">        with the MsPASS error system than an exception mechanism.</span>
<span class="sd">        Callers should handle four cases that are possible for a return</span>
<span class="sd">        (Noting [] means an empty list and [...] a list with data)</span>

<span class="sd">           1. []  None  - notmatch found</span>
<span class="sd">           2. [] ErrorLog - failure with an informational message in the</span>
<span class="sd">             ErrorLog that should be preserved.  The presence of an error</span>
<span class="sd">             should imply something went wrong and it was simply a null result.</span>
<span class="sd">           3. [...] None - all is good with no detected errors</span>
<span class="sd">           4. [...] ErrorLog - valid data returned but there is a warning</span>
<span class="sd">              or informational message posted.  In this case handlers</span>
<span class="sd">              may want to examine the ErrorSeverity components of the log</span>
<span class="sd">              and handle different levels differently  (e.g. Fatal and</span>
<span class="sd">              Informational should always be treated differently)</span>

<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="BasicMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.BasicMatcher.find_one">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstraction of the MongoDB database find_one method with the</span>
<span class="sd">        matching criteria defined when a concrete instance is instantiated.</span>
<span class="sd">        Like the MongoDB method implementations should return the</span>
<span class="sd">        unique document that the keys in mspass_object are expected</span>
<span class="sd">        to define with the matching criteria defined by the instance.</span>
<span class="sd">        A type example of an always unique match is ObjectIds.</span>
<span class="sd">        When a match is found the result should be returned in a</span>
<span class="sd">        Metadata container.  The attributes returned are normally</span>
<span class="sd">        a subset of the document and are defined by the base class</span>
<span class="sd">        attributes &quot;attributes_to_load&quot; and &quot;load_if_defined&quot;.</span>
<span class="sd">        For database instances this is little more than copying</span>
<span class="sd">        desired attributes from the matching document returned by</span>
<span class="sd">        MongoDB, but for abstraction more may be involved.</span>
<span class="sd">        e.g., implemented below is a generic cached algorithm that</span>
<span class="sd">        stores a collection to be matched in memory for efficiency.</span>
<span class="sd">        That implementation allows the &quot;collection&quot; to be loaded from</span>
<span class="sd">        MongoDB or a pandas DataFrame.</span>

<span class="sd">        All implementations should return a pair (2 component tuple).</span>
<span class="sd">        0 is expected to hold a Metadata containers that was yielded by</span>
<span class="sd">        the match.  It should be returned as None if there is no match.</span>
<span class="sd">        1 is expected to contain either a None type or an PyErrorLogger</span>
<span class="sd">        object.   The PyErrorLogger is a convenient way to pass error</span>
<span class="sd">        messages back to the caller in a manner that is easier to handle</span>
<span class="sd">        with the MsPASS error system than an exception mechanism.</span>
<span class="sd">        Callers should handle four cases that are possible for a return:</span>

<span class="sd">           1, None  None  - no match found</span>
<span class="sd">           2. None ErrorLog - failure with an informational message in the</span>
<span class="sd">             ErrorLog that the caller may want be preserved or convert to</span>
<span class="sd">             an exception.</span>
<span class="sd">           3. Metadata None - all is good with no detected errors</span>
<span class="sd">           4. Metadata ErrorLog - valid data was returned but there is a warning</span>
<span class="sd">              or informational message posted.  In this case handlers</span>
<span class="sd">              may want to examine the ErrorSeverity components of the log</span>
<span class="sd">              and handle different levels differently  (e.g. Fatal and</span>
<span class="sd">              Informational should always be treated differently)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="DatabaseMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DatabaseMatcher">[docs]</a><span class="k">class</span> <span class="nc">DatabaseMatcher</span><span class="p">(</span><span class="n">BasicMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matcher using direct database queries to MongoDB.   Each call to</span>
<span class="sd">    the find method of this class constructs a query, calls the MongoDB</span>
<span class="sd">    database find method with that query, and extracts desired attributes</span>
<span class="sd">    from the return in the form of a Metadata container.  The query</span>
<span class="sd">    construction is abstracted by a virtual method called query_generator.</span>
<span class="sd">    This is an intermediate class that cannot be instantiated directly</span>
<span class="sd">    because it contains a virtual method.   User&#39;s should consult</span>
<span class="sd">    docstrings for constructors for subclasses of this intermediate class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this intermediate class.  It should not be</span>
<span class="sd">        used except by subclasses as this intermediate class</span>
<span class="sd">        is not concrete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  required arg1 must be a collection name - received invalid type&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span> <span class="o">=</span> <span class="n">require_unique_match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span> <span class="o">=</span> <span class="n">prepend_collection_name</span>

<div class="viewcode-block" id="DatabaseMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DatabaseMatcher.query_generator">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subclasses of this intermediate class MUST implement this</span>
<span class="sd">        method.  It should extract content from mspass_object and</span>
<span class="sd">        use that content to generate a MongoDB query that is</span>
<span class="sd">        passed directly to the find method of the MongoDB database</span>
<span class="sd">        handle stored within this object (self) during</span>
<span class="sd">        the class construction.  Since pymongo uses a</span>
<span class="sd">        python dict for that purpose it must return a valid</span>
<span class="sd">        query dict.  Implementations should return None if no</span>
<span class="sd">        query could be generated.  Common, for example, if a key</span>
<span class="sd">        required to generate the query is missing from mspass_object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="DatabaseMatcher.find"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DatabaseMatcher.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic database implementation of the find method for this</span>
<span class="sd">        abstraction.   It returns what the base class api specifies.</span>
<span class="sd">        That is, normally it returns a tuple with component 0 being</span>
<span class="sd">        a python list of Metadata containers.  Each container holds</span>
<span class="sd">        the subset of attributes defined by attributes_to_load and</span>
<span class="sd">        (if present) load_if_defined.  The list is the set of all</span>
<span class="sd">        documents matching the query, which at this level of the class</span>
<span class="sd">        structure is abstract.</span>

<span class="sd">        The method dogmatically requires data for all keys</span>
<span class="sd">        defined by attributes_to_load.  It will throw a MsPASSError</span>
<span class="sd">        exception with a Fatal tag if any of the required attributes</span>
<span class="sd">        are not defined in any of the documents.  The return matches</span>
<span class="sd">        the API specification for BasicMatcher.</span>

<span class="sd">        It also handles failures of the abstract query_generator</span>
<span class="sd">        through the mechanism the base class api specified:  a None</span>
<span class="sd">        return means the method could not create a valid query.</span>
<span class="sd">        Failures in the query will always post a message to elog</span>
<span class="sd">        tagging the result as &quot;Invalid&quot;.</span>

<span class="sd">        It also handles the common problem of dead data or accidentally</span>
<span class="sd">        receiving invalid data like a None.   The later may cause other</span>
<span class="sd">        algorithms to abort, but we handle it here return [None,None].</span>
<span class="sd">        We don&#39;t return an PyErrorLogger in that situation as the assumption</span>
<span class="sd">        is there is no place to put it and something else has gone really</span>
<span class="sd">        wrong.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;received invalid data.  Arg0 must be a valid MsPASS data object&quot;</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_generator</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;query_generator method failed to generate a valid query - required attributes are probably missing&quot;</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="n">number_hits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_hits</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;query = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; yielded no documents&quot;</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
        <span class="n">metadata_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">_extractData2Metadata</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">metadata_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;DatabaseMatcher.find: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">severity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">metadata_list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">metadata_list</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span></div>

<div class="viewcode-block" id="DatabaseMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DatabaseMatcher.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic database implementation of the find_one method.  The tacit</span>
<span class="sd">        assumption is that if you call find_one you are expecting a unique</span>
<span class="sd">        match to the algorithm implemented.  The actual behavior for a</span>
<span class="sd">        nonunique match is controlled by the class attribute</span>
<span class="sd">        require_unique_match.  Subclasses that want to dogmatically enforce</span>
<span class="sd">        uniqueness (appropriate for example with ObjectIds) should</span>
<span class="sd">        set require_unique_match True.   In that case if a match is not</span>
<span class="sd">        unique the method will throw an exception.  When False, which is</span>
<span class="sd">        the default, an informational message is posted and the method</span>
<span class="sd">        returns the first list element returned by find.  This method is</span>
<span class="sd">        actually little more than a wrapper around find to handle that</span>
<span class="sd">        uniqueness issue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">find_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">mdlist_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mdlist_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># somewhat messy logic to handle differnt situations</span>
            <span class="c1"># we throw an exception if the constructor set require_unique_match</span>
            <span class="c1"># True.  Otherwise we need to handle the distinction on whether or</span>
            <span class="c1"># not the return from find had an PyErrorLogger defined with data.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;query of collection </span><span class="si">{col}</span><span class="s2"> did not yield a unique match.  Found </span><span class="si">{n}</span><span class="s2"> matching documents.  Aborting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">mdlist_length</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DatabaseMatcher.find_one:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;query of collection </span><span class="si">{col}</span><span class="s2"> did not yield a unique match.  Found </span><span class="si">{n}</span><span class="s2"> matching documents.  Using first one in list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">mdlist_length</span>
                <span class="p">)</span>
                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;DatabaseMatcher.find_one&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elog</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="DictionaryCacheMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DictionaryCacheMatcher">[docs]</a><span class="k">class</span> <span class="nc">DictionaryCacheMatcher</span><span class="p">(</span><span class="n">BasicMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matcher implementing a caching method based on a python dictionary.</span>

<span class="sd">    This is an intermediate class for instances where the database collection</span>
<span class="sd">    to be matched is small enough that the in-memory model is appropriate.</span>
<span class="sd">    It should also only be used if the matching algorithm can be reduced</span>
<span class="sd">    to a single string that can serve as a unique id for each tuple.</span>

<span class="sd">    The class defines a generic dictionary cache with a string key.   The way that</span>
<span class="sd">    key is define is abstracted through two virtual methods:</span>
<span class="sd">    (1) The cache_id method creates a match key from a mspass data object.</span>
<span class="sd">        That is normally from the Metadata container but it is not</span>
<span class="sd">        restricted to that. e.g. start time for TimeSeries or</span>
<span class="sd">        Seismogram objects can be obtained from the t0 attribute</span>
<span class="sd">        directly.</span>
<span class="sd">    (2) The db_make_cache_id is called by the internal method of this</span>
<span class="sd">        intermediate class (method name is _load_normalization_cache)</span>
<span class="sd">        to build the cache index from MongoDB documents scanned to</span>
<span class="sd">        construct the cache.</span>

<span class="sd">    Two different methods to define the cache index are necessary as a</span>
<span class="sd">    generic way to implement aliases.  A type example is the mspass use</span>
<span class="sd">    of names like &quot;channel_id&quot; to refer to the ObjectId of a specific</span>
<span class="sd">    document in the channel collection.   When loading channel the name</span>
<span class="sd">    key is &quot;_id&quot; but data objects would normally have that same data</span>
<span class="sd">    defined with the key &quot;channel_id&quot;.   Similarly, if data have had</span>
<span class="sd">    aliases applied a key in the data may not match the name in a</span>
<span class="sd">    collection to be matched.   The dark side of this is it is very</span>
<span class="sd">    easy when running subclasses of this to get null results with</span>
<span class="sd">    all members of a dataset.   As always testing with a subset of</span>
<span class="sd">    data is strongly recommended before running versions of this on</span>
<span class="sd">    a large dataset.</span>

<span class="sd">    This class cannot be instantiated because it is not concrete</span>
<span class="sd">    (has abstract - virtual - methods that must be defined by subclasses)</span>
<span class="sd">    See implementations for constructor argument definitions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_or_df</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_dataframe_index_as_cache_id</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this intermediate class.  It should not be</span>
<span class="sd">        used except by subclasses as this intermediate class</span>
<span class="sd">        is not concrete.   It calls the base class constructor</span>
<span class="sd">        and then loads two internal attributes:  query and collection.</span>
<span class="sd">        It then creates the normalization python dict that applies the</span>
<span class="sd">        abstract cache_id method.  Note that only works for</span>
<span class="sd">        concrete subclasses of this intermediate class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  required arg1 must be a collection name - received invalid type&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  query argument must be a python dict container&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span> <span class="o">=</span> <span class="n">require_unique_match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span> <span class="o">=</span> <span class="n">prepend_collection_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_dataframe_index_as_cache_id</span> <span class="o">=</span> <span class="n">use_dataframe_index_as_cache_id</span>

        <span class="c1"># This is a redundant initialization but a minor cost for stability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="n">Database</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_db_load_normalization_cache</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="p">(</span><span class="n">type_ddd</span><span class="p">,</span> <span class="n">type_pdd</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_df_load_normalization_cache</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="n">collection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  required arg0 must be a mspass Database handle&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="DictionaryCacheMatcher.cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DictionaryCacheMatcher.cache_id">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementations must implement this method to define</span>
<span class="sd">        how a mspass data object, mspass_object, is to be used to</span>
<span class="sd">        construct the key to the cache dict container.   It is</span>
<span class="sd">        distinct from db_make_cache_id to allow differences in naming</span>
<span class="sd">        or even the algorithm used to construct the key from a datum</span>
<span class="sd">        relative to the database.  This complicates the interface but</span>
<span class="sd">        makes it more generic.</span>

<span class="sd">        :param mspass_object:  is expected to be a MsPASS object.</span>
<span class="sd">          Any type restrictions should be implemented in subclasses</span>
<span class="sd">          that implement the method.</span>

<span class="sd">        :return: should always return a valid string and never throw</span>
<span class="sd">          an exception.  If the algorithm fails the implementation should</span>
<span class="sd">          return a None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="DictionaryCacheMatcher.db_make_cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DictionaryCacheMatcher.db_make_cache_id">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">db_make_cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation must implement this method to define how</span>
<span class="sd">        the cache index is to be created from database documents passed</span>
<span class="sd">        through the arg doc, which pymongo always returns as a python dict.</span>
<span class="sd">        It is distinct from cache_id to allow differences in naming or</span>
<span class="sd">        the algorithm for loading the cache compared to accessing it</span>
<span class="sd">        using attributes of a data object.   If the id string cannot</span>
<span class="sd">        be created from doc an implementation should return None.</span>
<span class="sd">        The generic loaders in this class, db_load_normalization_cache</span>
<span class="sd">        and df_load_normalization_class, handle that situation cleanly</span>
<span class="sd">        but if a subclass overrides the load methods they should handle</span>
<span class="sd">        such errors.  &quot;cleanly&quot; in this case means they throw an</span>
<span class="sd">        exception which is appropriate since they are run during construction</span>
<span class="sd">        and any invalid key is not acceptable in that situation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="DictionaryCacheMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DictionaryCacheMatcher.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of find for generic cached method.   It uses the cache_id</span>
<span class="sd">        method to create the indexing string from mspass_object and then returns</span>
<span class="sd">        a match to the cache stored in self.  Only subclasses of this</span>
<span class="sd">        intermediate class can work because the cache_id method is</span>
<span class="sd">        defined as a pure virtual method in this intermediate class.</span>
<span class="sd">        That construct is used to simplify writing additional matcher</span>
<span class="sd">        classes.  All extensions need to do is define the cache_id</span>
<span class="sd">        and db_make_cache_id algorithms to build that index.</span>

<span class="sd">        :param mspass_object:  Any valid MsPASS data object.  That means</span>
<span class="sd">          TimeSeries, Seismogram, TimeSeriesEnsemble, or SeismogramEnsemble.</span>
<span class="sd">          This datum is passed to the (abstract) cache_id method to</span>
<span class="sd">          create an index string and the result is used to fetch the</span>
<span class="sd">          Metadata container matching that key.   What is required of the</span>
<span class="sd">          input is dependent on the subclass implementation of cache_id.</span>

<span class="sd">        :return:  2-component tuple following API specification in BasicMatcher.</span>
<span class="sd">          Only two possible results are possible from this implementation:</span>

<span class="sd">           None ErrorLog - failure with an error message that can be passed on</span>
<span class="sd">             if desired or printed</span>
<span class="sd">           Metadata None - all is good with no detected errors.  The Metadata</span>
<span class="sd">             container holds all attributes_to_load and any defined</span>
<span class="sd">             load_if_defined values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">find_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">find_output</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># as with the database version we use require_unique_match</span>
            <span class="c1"># to define if we should be dogmatic or not</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;query does not yield a unique match and require_unique_match is set true&quot;</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DictionaryCacheMatcher.find:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;encountered a nonunique match calling find_one - returning contents of first matching document found&quot;</span>
                <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;DictionaryCacheMatcher.find:  &quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elog</span><span class="p">]</span></div>

<div class="viewcode-block" id="DictionaryCacheMatcher.find"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DictionaryCacheMatcher.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic implementation of find method for cached tables/collections.</span>

<span class="sd">        This method is a generalization of the MongoDB database find method.</span>
<span class="sd">        It differs in two ways. First, it creates the &quot;query&quot; directly from</span>
<span class="sd">        a MsPASS data object (pymongo find requires a dict as input).</span>
<span class="sd">        Second, the result is return as a python list of Metadata containers</span>
<span class="sd">        containing what is (usually) a subset of the data stored in the</span>
<span class="sd">        original collection (table).   In contrast pymongo database find</span>
<span class="sd">        returns a database &quot;Cursor&quot; object which is their implementation of</span>
<span class="sd">        a large list that may exceed the size of memory.  A key point is</span>
<span class="sd">        the model here makes sense only if the original table itself is small</span>
<span class="sd">        enough to not cause a memory problem.  Further, find calls that</span>
<span class="sd">        yield long list may cause efficiency problems as subclasses that</span>
<span class="sd">        build on this usually will need to do a linear search through the</span>
<span class="sd">        list if they need to find a particular instance (e.g. call to find_one).</span>

<span class="sd">        :param mspass_object: data object to match against</span>
<span class="sd">          data in cache (i.e. query).</span>
<span class="sd">        :type mspass_object:  must be a valid MsPASS data object.</span>
<span class="sd">          currently that means TimeSeries, Seismogram, TimeSeriesEnsemble,</span>
<span class="sd">          or SeismogramEnsemble.   If it is anything else (e.g. None)</span>
<span class="sd">          this method will return a tuple [None, elog] with elog being</span>
<span class="sd">          a PyErrorLogger with a posted message.</span>

<span class="sd">        :return: tuple with two elements.  0 is either a list of valid Metadata</span>
<span class="sd">          container(s) or None and 1 is either None or an PyErrorLogger object.</span>
<span class="sd">          There are only two possible returns from this method:</span>
<span class="sd">              [None, elog] - find failed.  See/save elog for why it failed.</span>
<span class="sd">              [ [md1, md2, ..., mdn], None] - success with 0 a list of Metadata</span>
<span class="sd">                containing attributes_to_load and load_if_defined</span>
<span class="sd">                (if appropriate) in each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;Received datum that was not a valid MsPASS data object&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">thisid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_id</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="c1"># this should perhaps generate two different messages as the</span>
        <span class="c1"># they imply slightly different things - the current message</span>
        <span class="c1"># is accurate though</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">thisid</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">thisid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">):</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;cache_id method found no match for this datum&quot;</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">thisid</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_db_load_normalization_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This private method abstracts the process of loading a cached</span>
<span class="sd">        version of a normalizing collection.  It creates a python</span>
<span class="sd">        dict stored internally with the name self.normcache.  The</span>
<span class="sd">        container is keyed by a string created by</span>
<span class="sd">        the virtual method cache_id.  The value associated with each</span>
<span class="sd">        dict key is a python list of Metadata containers.</span>
<span class="sd">        Each component is constructed from any document matching the</span>
<span class="sd">        algorithm defined by cache_id.   The list is constructed by</span>
<span class="sd">        essentially appending a new Metadata object whenever a</span>
<span class="sd">        matching cache_id is returned.</span>

<span class="sd">        The Metadata containers normally contain only a subset of</span>
<span class="sd">        the original attributes in the collection.  The list</span>
<span class="sd">        attributes_to_load is treated as required and this method</span>
<span class="sd">        will throw a MsPASSError exception if any of them are missing</span>
<span class="sd">        from any document parsed.  Use load_if_define for attributes</span>
<span class="sd">        that are not required for your workflow.</span>

<span class="sd">        This method will throw a MsPASS fatal error in two situations:</span>
<span class="sd">            1.  If the collection following the (optional) query is empty</span>
<span class="sd">            2.  If any attribute in the self.attributes_to_load is not</span>
<span class="sd">                defined in any document loaded.  In all BasicMatcher</span>
<span class="sd">                subclasses attributes_to_load are considered required.</span>

<span class="sd">        :param db:  MsPASS Database class MongoDB database handle.  Note</span>
<span class="sd">          it can be the subclass of the base class MongooDB handle</span>
<span class="sd">          as extensions for MsPASS to the handle are not used in this method.</span>
<span class="sd">        :param collection:  string defining the MongoDB collection that is</span>
<span class="sd">          to be loaded and indexed - the normalizing collection target.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dbhandle</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection_size</span> <span class="o">=</span> <span class="n">dbhandle</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Query=&quot;</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span>
                <span class="o">+</span> <span class="s2">&quot; of collection=&quot;</span>
                <span class="o">+</span> <span class="n">collection</span>
                <span class="o">+</span> <span class="s2">&quot; yielded 0 documents - cannot construct this object&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;DictionaryCacheMatcher._load_normalization_cache:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">dbhandle</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_make_cache_id</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="c1"># This error trap may not be necessary but the api requires us</span>
            <span class="c1"># to handle a None return</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DictionaryCacheMatcher._load_normalization_cache:  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;db_make_cache_id failed - coding problem or major problem with collection=&quot;</span>
                    <span class="o">+</span> <span class="n">collection</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">_extractData2Metadata</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">,</span>
                    <span class="n">collection</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">message</span>
                    <span class="o">+</span> <span class="s2">&quot; in document number </span><span class="si">{n}</span><span class="s2"> of collection </span><span class="si">{col}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">n</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">collection</span>
                    <span class="p">),</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">severity</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_df_load_normalization_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function does the same thing as _db_load_normalization_cache, the</span>
<span class="sd">        only difference is that this current function takes one argument, which</span>
<span class="sd">        is a dataframe.</span>
<span class="sd">        :param df: a pandas/dask dataframe where we load data from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query_result</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#   Create a query</span>
            <span class="c1">#   There are multiple ways of querying in a dataframe, according to</span>
            <span class="c1">#   the experiments in https://stackoverflow.com/a/46165056/11138718</span>
            <span class="c1">#   We pick the following approach:</span>
            <span class="n">sub_conds</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">sub_conds</span><span class="p">)</span>
            <span class="n">query_result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_result</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Query=</span><span class="si">{query_str}</span><span class="s2"> of dataframe=</span><span class="si">{dataframe_str}</span><span class="s2">&quot;</span>
                <span class="s2">&quot; yielded 0 documents - cannot construct this object&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">query_str</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">),</span> <span class="n">dataframe_str</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;DictionaryCacheMatcher._load_normalization_cache:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">query_result</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_dataframe_index_as_cache_id</span><span class="p">:</span>
                <span class="n">cache_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_make_cache_id</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="c1"># This error trap may not be necessary but the api requires us</span>
            <span class="c1"># to handle a None return</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DictionaryCacheMatcher._load_normalization_cache:  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;db_make_cache_id failed - coding problem or major problem with collection=&quot;</span>
                    <span class="o">+</span> <span class="n">collection</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">_extractData2Metadata</span><span class="p">(</span>
                    <span class="n">doc</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">,</span>
                    <span class="n">collection</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">message</span>
                    <span class="o">+</span> <span class="s2">&quot; in document number </span><span class="si">{n}</span><span class="s2"> of collection </span><span class="si">{col}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">n</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">collection</span>
                    <span class="p">),</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">severity</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="DataFrameCacheMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DataFrameCacheMatcher">[docs]</a><span class="k">class</span> <span class="nc">DataFrameCacheMatcher</span><span class="p">(</span><span class="n">BasicMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matcher implementing a caching method based on a Pandas DataFrame</span>

<span class="sd">    This is an intermediate class for instances where the database collection</span>
<span class="sd">    to be matched is small enough that the in-memory model is appropriate.</span>
<span class="sd">    It should be used when the matching algorithm is readily cast into the</span>
<span class="sd">    subsetting api of a pandas DataFrame.</span>

<span class="sd">    The constructor of this intermediate class first calls the BasicMatcher</span>
<span class="sd">    (base class) constructor to initialize some common attribute including</span>
<span class="sd">    the critical lists of attributes to be loaded.   This constructor then</span>
<span class="sd">    creates the internal DataFrame cache by one of two methods.</span>
<span class="sd">    If arg0 is a MongoDB database handle it loads the data in the</span>
<span class="sd">    named collection to a DataFrame created during construction.  If the</span>
<span class="sd">    input is a DataFrame already it is simply copied selecting only</span>
<span class="sd">    columns defined by the attributes_to_load and load_if_defined lists.</span>
<span class="sd">    There is also an optional parameter, custom_null_values, that is a</span>
<span class="sd">    python dictionary defining values in a field that should be treated</span>
<span class="sd">    as a definition of a Null for that field.  The constuctor converts</span>
<span class="sd">    such values to a standard pandas null field value.</span>

<span class="sd">    This class implements generic find and find_one methods.</span>
<span class="sd">    Subclasses of this class must implement a &quot;subset&quot; method to be</span>
<span class="sd">    concrete.  A subset method is the abstract algorithm that defines</span>
<span class="sd">    a match for that instance expressed as a pandas subset operation.</span>
<span class="sd">    (For most algorithms there are multiple ways to skin that cat or is</span>
<span class="sd">     it a panda?)  See concrete subclasses for examples.</span>

<span class="sd">    This class cannot be instantiated because it is not concrete</span>
<span class="sd">    (has abstract - virtual - methods that must be defined by subclasses)</span>
<span class="sd">    See implementations for constructor argument definitions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_or_df</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">custom_null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this intermediate class.  It should not be</span>
<span class="sd">        used except by subclasses as this intermediate class</span>
<span class="sd">        is not concrete.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span> <span class="o">=</span> <span class="n">prepend_collection_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span> <span class="o">=</span> <span class="n">require_unique_match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_null_values</span> <span class="o">=</span> <span class="n">custom_null_values</span>
        <span class="c1"># this is a necessary sanity check</span>
        <span class="k">if</span> <span class="n">collection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;DataFrameCacheMatcher constructor:  collection name must be defined when prepend_collection_name is set True&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="n">collection</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;DataFrameCacheMatcher constructor:   collection argument must be a string type&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="p">(</span><span class="n">type_pdd</span><span class="p">,</span> <span class="n">type_ddd</span><span class="p">,</span> <span class="n">Database</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;DataFrameCacheMatcher constructor:  required arg0 must be either a pandas, dask Dataframe, or database handle&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DataFrameCacheMatcher constructor:  usage error.  Cannot use default of attributes_to_load (triggers loading all columns) and define a list of names for argument load_if_defined&quot;</span>
                <span class="p">)</span>
            <span class="n">aload</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">aload</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aload</span> <span class="o">=</span> <span class="n">attributes_to_load</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">aload</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">db_or_df</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">,</span> <span class="p">(</span><span class="n">type_pdd</span><span class="p">,</span> <span class="n">type_ddd</span><span class="p">))</span>
            <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">db_or_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">({})))</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_dataframe_cache</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<div class="viewcode-block" id="DataFrameCacheMatcher.find"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DataFrameCacheMatcher.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DataFrame generic implementation of find method.</span>

<span class="sd">        This method uses content in any part of the mspass_object</span>
<span class="sd">        (data object) to subset the internal DataFrame cache to</span>
<span class="sd">        return subset of tuples matching some condition defined</span>
<span class="sd">        computed through the abstract (virtual) methdod subset.</span>
<span class="sd">        It then copies entries in attributes_to_load and when not</span>
<span class="sd">        null load_if_defined into one Metadata container for each</span>
<span class="sd">        row of the returned DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">(</span>
                <span class="s2">&quot;DataFrameCacheMatcher.find&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Received datum that was not a valid MsPASS data object&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>

        <span class="n">subset_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="c1"># assume all implementations will return a 0 length dataframe</span>
        <span class="c1"># if the subset failed.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset_df</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;subset method found no match for this datum&quot;</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This loop cautiously fills one or more Metadata</span>
            <span class="c1"># containers with each row of the DataFrame generating</span>
            <span class="c1"># one Metadata container.</span>
            <span class="n">mdlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">elog</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">subset_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>
                <span class="n">notnulltest</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notnulltest</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                                <span class="n">mdkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">mdkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mdkey</span> <span class="o">=</span> <span class="n">key</span>
                        <span class="n">md</span><span class="p">[</span><span class="n">mdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">elog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                        <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;Encountered Null value for required attribute </span><span class="si">{key}</span><span class="s2"> - repairs of the input DataFrame are required&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">key</span><span class="o">=</span><span class="n">k</span>
                        <span class="p">)</span>
                        <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                            <span class="n">error_message</span><span class="p">,</span>
                            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">notnulltest</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                                <span class="n">mdkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">mdkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">mdkey</span> <span class="o">=</span> <span class="n">key</span>
                        <span class="n">md</span><span class="p">[</span><span class="n">mdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">mdlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mdlist</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="DataFrameCacheMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DataFrameCacheMatcher.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DataFrame implementation of the find_one method.</span>

<span class="sd">        This method is mostly a wrapper around the find method.</span>
<span class="sd">        It calls the find method and then does one of two thing s</span>
<span class="sd">        depending upon the value of self.require_unique_match.</span>
<span class="sd">        When that boolean is True if the match is not unique it</span>
<span class="sd">        creates an PyErrorLogger object, posts a message to the log,</span>
<span class="sd">        and then returns a [Null,elog] pair.  If self.require_unique_match</span>
<span class="sd">        is False and the match is not ambiguous, it again creates an</span>
<span class="sd">        PyErrorLogger and posts a message, but it also takes the first</span>
<span class="sd">        container in the list returned by find and returns in as</span>
<span class="sd">        component 0 of the pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">findreturn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
        <span class="n">mdlist</span> <span class="o">=</span> <span class="n">findreturn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mdlist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">findreturn</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mdlist</span><span class="p">,</span> <span class="n">findreturn</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_unique_match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;DataFrameCacheMatcher.find_one:  found </span><span class="si">{n}</span><span class="s2"> matches when require_unique_match was set true&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">findreturn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elog</span> <span class="o">=</span> <span class="n">findreturn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># This maybe should be only posted with a verbose option????</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;found </span><span class="si">{n}</span><span class="s2"> matches.  Returned first one found.  You should use find instead of find_one if the match is not unique&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mdlist</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mdlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only land here if mdlist is something for which len returns 0</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;DataFrameCacheMatchter.find_one:   find returned an empty list.  Can only happen if custom matcher has overridden find.  Find should return None if the match fails&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="DataFrameCacheMatcher.subset"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.DataFrameCacheMatcher.subset">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Required method defining how the internal DataFrame cache is</span>
<span class="sd">        to be subsetted using the contents of the data object</span>
<span class="sd">        mspass_object.   Concrete implementation must implement this class.</span>
<span class="sd">        The point of this abstract method is that the way one defines</span>
<span class="sd">        how to get the information needed to define a match with the</span>
<span class="sd">        cache is application dependent.  An implementation can use Metadata</span>
<span class="sd">        attributes, data object attributes (e.g. TimeSeries t0 attribute),</span>
<span class="sd">        or even sample data to compute a value to use in DataFrame</span>
<span class="sd">        subset condition.   This simplifies writing a custom matcher to</span>
<span class="sd">        implementing only this method as find and find_one use it.</span>

<span class="sd">        Implementations should return a zero length DataFrame if the</span>
<span class="sd">        subset condition yields a null result.  i.e. the test</span>
<span class="sd">        len(return_result) should work and return 0 if the subset</span>
<span class="sd">        produced no rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_load_dataframe_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="c1"># This is a bit error prone.  It assumes the BasicMatcher</span>
        <span class="c1"># constructor initializes a None default to an empty list</span>
        <span class="n">fulllist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">fulllist</span><span class="p">)[</span><span class="n">fulllist</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_null_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">nul_val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_null_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">nul_val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span></div>


<div class="viewcode-block" id="ObjectIdDBMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ObjectIdDBMatcher">[docs]</a><span class="k">class</span> <span class="nc">ObjectIdDBMatcher</span><span class="p">(</span><span class="n">DatabaseMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of DatabaseMatcher for ObjectIds.  In this class the virtual</span>
<span class="sd">    method query_generator uses the mspass convention of using the</span>
<span class="sd">    collection name and the magic string &quot;_id&quot; as the data object</span>
<span class="sd">    key (e.g. channel_id) but runs the query using the &quot;_id&quot; magic</span>
<span class="sd">    string used in MongoDB for the  ObjectId of each document.</span>

<span class="sd">    Users should only utilize the find_one method of this class as find,</span>
<span class="sd">    by definition, will always return only one record or None.</span>
<span class="sd">    The find method, in fact, is overloaded and attempts to use it will</span>
<span class="sd">    result in raising a MsPASSError exception.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       (default &quot;channel&quot;).</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find_one will fail.</span>
<span class="sd">      Default [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;,&quot;hang&quot;,&quot;vang&quot;].</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;hang&quot;</span><span class="p">,</span> <span class="s2">&quot;vang&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class Constructor.  Just calls the superclass constructor</span>
<span class="sd">        directly with no additions.  Sets unique match, however, to</span>
<span class="sd">        be dogmatically enforce uniqueness.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ObjectIdDBMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ObjectIdDBMatcher.query_generator">[docs]</a>    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">data_object_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">data_object_key</span><span class="p">):</span>
            <span class="n">query_id</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">data_object_key</span><span class="p">]</span>
            <span class="c1"># This is a bombproof way to create an ObjectId</span>
            <span class="c1"># works the same if query_id is a string representation of</span>
            <span class="c1"># the id or an actual ObjectId. In the later case it calls</span>
            <span class="c1"># the copy constructor.</span>
            <span class="n">testid</span> <span class="o">=</span> <span class="n">ObjectId</span><span class="p">(</span><span class="n">query_id</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">testid</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="ObjectIdMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ObjectIdMatcher">[docs]</a><span class="k">class</span> <span class="nc">ObjectIdMatcher</span><span class="p">(</span><span class="n">DictionaryCacheMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implement an ObjectId match with caching.  Most of the code for</span>
<span class="sd">    this class is derived from the superclass DictionaryCacheMatcher.</span>
<span class="sd">    It adds only a concrete implementation of the cache_id method</span>
<span class="sd">    used to construct a key for the cache defined by a python dict</span>
<span class="sd">    (self.normcache).  In this case the cache key is simply the</span>
<span class="sd">    string representation of the ObjectId of each document in</span>
<span class="sd">    the collection defined in construction.   The cache is</span>
<span class="sd">    then created by the superclass generic method _load_normalization_cache.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be loaded</span>
<span class="sd">       and cached to memory inside this object (default &quot;channel&quot;)</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param query:  optional query to apply to collection before loading</span>
<span class="sd">       document attributes into the cache.   A typical example would be</span>
<span class="sd">       a time range limit for the channel or site collection to</span>
<span class="sd">       avoid loading instruments not operational during the time span</span>
<span class="sd">       of a data set.  Default is None which causes the entire collection</span>
<span class="sd">       to be parsed.</span>
<span class="sd">    :type query:  python dict with content that defines a valid query</span>
<span class="sd">       when be passed to MongoDB the MongoDB find method.  If query is</span>
<span class="sd">       a type other than a None type or dict the constructor will</span>
<span class="sd">       throw a TypeError.</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find will fail.</span>
<span class="sd">      Default [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;,&quot;hang&quot;,&quot;vang&quot;]</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when set true all attributes loaded</span>
<span class="sd">       from the normalizing collection will have the channel name prepended.</span>
<span class="sd">       That is essential if the collection contains generic names like &quot;lat&quot;</span>
<span class="sd">       or &quot;depth&quot; that would produce ambiguous keys if used directly.</span>
<span class="sd">       (e.g. lat is used for source, channel, and site collections in the</span>
<span class="sd">        default schema.)</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;hang&quot;</span><span class="p">,</span> <span class="s2">&quot;vang&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class Constructor.  Just calls the superclass constructor</span>
<span class="sd">        directly with no additions.  It does, however, set the</span>
<span class="sd">        require_unique_match boolean True which cause the find_one</span>
<span class="sd">        method to be dogmatic in enforcing unique matches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># require_unique_match is alwatys set True here as that is</span>
        <span class="c1"># pretty much by definition.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;ObjectIdMatcher constructor:  optional query argument must be either None or a python dict&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ObjectIdMatcher.cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ObjectIdMatcher.cache_id">[docs]</a>    <span class="k">def</span> <span class="nf">cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of virtual method with this name for this matcher.</span>
<span class="sd">        It implements the MsPASS approach of defining the key for a</span>
<span class="sd">        normalizing collection as the collection name and the magic</span>
<span class="sd">        string &quot;_id&quot;  (e.g. channel_id or site_id).   It assumes</span>
<span class="sd">        the collection name is define as self.collection by the</span>
<span class="sd">        constructor of the class when it is instantiated.  It attempts</span>
<span class="sd">        to extract the expanded _id name (e.g. channel_id) from the</span>
<span class="sd">        input mspass_object.  If successful it returns the string</span>
<span class="sd">        representation of the resulting (assumed) ObjectId.  If the</span>
<span class="sd">        key is not defined it returns None as specified by the</span>
<span class="sd">        superclass api.</span>

<span class="sd">        It is important to note the class attribute,</span>
<span class="sd">        self.prepend_collection_name, is indendent of the definition of the</span>
<span class="sd">        cache_id.  i.e. what we attempt to extract as the id ALWAYS</span>
<span class="sd">        used the collection name as a prefix (channel_id and not &quot;_id&quot;).</span>
<span class="sd">        The internal boolean controls if the attributes returned by find_one</span>
<span class="sd">        will have the collection name prepended.</span>

<span class="sd">        :param mspass_object:   key-value pair container containing an id that is to</span>
<span class="sd">          be extracted.</span>
<span class="sd">        :type mspass_object:  Normally this is expected to be a mspass</span>
<span class="sd">          data object (TimeSeries, Seismogram, or ensembles of same) but</span>
<span class="sd">          it can be as simple as a python dict or Metadata with the required</span>
<span class="sd">          key defined.</span>

<span class="sd">        :return:  string representation of an ObjectId to be used</span>
<span class="sd">          to matching the cache index stored internally - find method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">testid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">[</span><span class="n">testid</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ObjectIdMatcher.db_make_cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ObjectIdMatcher.db_make_cache_id">[docs]</a>    <span class="k">def</span> <span class="nf">db_make_cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of virtual methods with this name for this matcher.</span>
<span class="sd">        It does nothing more than extract the magic &quot;_id&quot; value from doc</span>
<span class="sd">        and returns its string representation.  With MongoDB that means</span>
<span class="sd">        the string representation of the ObjectId of each collection</span>
<span class="sd">        document is used as the key for the cache.</span>

<span class="sd">        :param doc:  python dict defining a document return by MongoDB.</span>
<span class="sd">          Only the &quot;_id&quot; value is used.</span>
<span class="sd">        :type doc:  python dict container returned by pymongo - usually a</span>
<span class="sd">          cursor component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;_id&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="MiniseedDBMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedDBMatcher">[docs]</a><span class="k">class</span> <span class="nc">MiniseedDBMatcher</span><span class="p">(</span><span class="n">DatabaseMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Database implementation of matcher for miniseed data using</span>
<span class="sd">    SEED keys net:sta:chan(channel only):loc and a time interval test.</span>
<span class="sd">    Miniseed data uses the exessively complex key that combines four unique</span>
<span class="sd">    string names (net, sta, chan, and loc) and a time interval</span>
<span class="sd">    of operation to define a unique set of station metadata for each</span>
<span class="sd">    channel.  In mspass we also create the site collection without the</span>
<span class="sd">    chan attribute.  This implementation works for both channel and</span>
<span class="sd">    site under control of the collection argument.</span>

<span class="sd">    This case is the complete opposite of something like the ObjectId</span>
<span class="sd">    matcher above as the match query we need to generate is</span>
<span class="sd">    excessively long requiring up to 6 fields.</span>

<span class="sd">    The default collection name is channel which is the only</span>
<span class="sd">    correct use if applied to data created through readers applied to</span>
<span class="sd">    wf_miniseed.   The implementation can also work on Seismogram</span>
<span class="sd">    data if and only if the channel argument is then set to &quot;site&quot;.</span>
<span class="sd">    The difference is that for Seismogram data &quot;chan&quot; is a</span>
<span class="sd">    undefined concept.  In both cases the keys and content assume the mspass</span>
<span class="sd">    schema for the channel or site collections.  The constructor will</span>
<span class="sd">    throw a MsPASSError exception if the collection argument is</span>
<span class="sd">    anything but &quot;channel&quot; or &quot;site&quot; to enforce this limitation.</span>
<span class="sd">    If you use a schema other than the mspass schema the methods in</span>
<span class="sd">    this class will fail if you change any of the following keys:</span>
<span class="sd">        net, sta, chan, loc, starttime, endtime, hang, vang</span>

<span class="sd">    Users should only call</span>
<span class="sd">    the find_one method for this application.   The find_one algorithm</span>
<span class="sd">    first queries for any matches of net:sta:chan(channel only):loc(optional) and</span>
<span class="sd">    data t0 within the startime and endtime of the channel document</span>
<span class="sd">    attributes (an interval match).  That combination should yield</span>
<span class="sd">    either 1 or no matches if the channel collection is clean.</span>
<span class="sd">    However, there are known issues with station metadata that can</span>
<span class="sd">    cause multiple matches in unusual cases (Most notably overlapping</span>
<span class="sd">    time intervals defined for the same channel.)  The find_one method</span>
<span class="sd">    will handle that case returning the first one found and posting an</span>
<span class="sd">    error message that should be handled by the caller.</span>

<span class="sd">    Instantiation of this class is a call to the superclass</span>
<span class="sd">    constructor with specialized defaults and wrapper code to</span>
<span class="sd">    automatically handle potential mismatches between site and channel.</span>
<span class="sd">    The arguments for the constructor follow:</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       The default is &quot;channel&quot;.  Use &quot;site&quot; for Seismogram data.</span>
<span class="sd">       Use anything else at your own risk</span>
<span class="sd">       as the algorithm depends heavily on mspass schema definition</span>
<span class="sd">       and properties guaranteed by using the converter from obspy</span>
<span class="sd">       Inventory class loaded through web services or stationml files.</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find will fail.</span>
<span class="sd">      Default [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;,&quot;hang&quot;,&quot;vang&quot;]</span>
<span class="sd">               &quot;hang&quot;,&quot;vang&quot;,&quot;starttime&quot;,&quot;endtime&quot;]</span>
<span class="sd">      when collection is set as channel.  Smaller list of</span>
<span class="sd">      [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;] is</span>
<span class="sd">       default when collection is set as &quot;site&quot;.</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is [&quot;loc&quot;].   A common</span>
<span class="sd">      addition here may be response data (see schema definition for keys)</span>
<span class="sd">    :type load_if_defined:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">aload_tmp</span> <span class="o">=</span> <span class="n">attributes_to_load</span>
        <span class="k">if</span> <span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;hang&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span><span class="p">:</span>
                <span class="n">aload_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;hang&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;vang&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span><span class="p">:</span>
                <span class="n">aload_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;vang&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">collection</span> <span class="o">!=</span> <span class="s2">&quot;site&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedDBMatcher:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Illegal collection argument=&quot;</span>
                <span class="o">+</span> <span class="n">collection</span>
                <span class="o">+</span> <span class="s2">&quot; Must be either channel or site&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">aload_tmp</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MiniseedDBMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedDBMatcher.query_generator">[docs]</a>    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation of (required) abstract method defined</span>
<span class="sd">        in superclass DatabaseMatcher.  It generates the complex query</span>
<span class="sd">        for matching net, sta, chan, and optional loc along with the</span>
<span class="sd">        time interval match of data start time between the channel</span>
<span class="sd">        defined &quot;starttime&quot; and &quot;endtime&quot; attributes.</span>

<span class="sd">        This method provides one safety for a common data problem.</span>
<span class="sd">        A common current issue is that if miniseed data are saved</span>
<span class="sd">        to wf_TimeSeries and then read back in a later workflow</span>
<span class="sd">        the default schema will alter the keys for net, sta, chan,</span>
<span class="sd">        and loc to add the prefix &quot;READONLY_&quot; (e.g. READONLY_net).</span>
<span class="sd">        The query automatically tries to recover any of the</span>
<span class="sd">        station name keys using that recipe.</span>

<span class="sd">        :param mspass_object:   assumed to be a TimeSeries object</span>
<span class="sd">          with net, sta, chan, and (optional) loc defined.</span>
<span class="sd">          The time for the time interval test is translation to</span>
<span class="sd">          MongoDB syntax of:</span>
<span class="sd">           channel[&quot;starttime&quot;] &lt;= mspass_object.to &lt;= channel[&quot;endtime&quot;]</span>
<span class="sd">           This algorithm will abort if the statement mspass_object.t0</span>
<span class="sd">           does not resolve, which means the caller should assure</span>
<span class="sd">           the input is a TimeSeries object.</span>

<span class="sd">        :return:  normal return is a string defining the query.</span>
<span class="sd">           If any required station name keys are not defined the</span>
<span class="sd">           method will silently return a None.  Caller should handle</span>
<span class="sd">           a None condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">net</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">)</span>
        <span class="c1"># loc being null is not unusual so if is is null we just add it to query</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="c1"># We don&#39;t verify mspass_object is a valid TimeSeries here</span>
        <span class="c1"># assuming it was done prior to calling this method.</span>
        <span class="c1"># fetching t0 could cause an abort if mspass_object were not</span>
        <span class="c1"># previously validated.  An alternative would be to test</span>
        <span class="c1"># here and return None if mspass_object was not a valid TimeSeries</span>
        <span class="c1"># done this way because other bad things would happen if find</span>
        <span class="c1"># if that assumption was invalid</span>

        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lte&quot;</span><span class="p">:</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span><span class="p">}</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gte&quot;</span><span class="p">:</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">query</span></div>

<div class="viewcode-block" id="MiniseedDBMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedDBMatcher.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We overload find_one to provide the unique match needed.</span>
<span class="sd">        Most of the work is done by the query_generator method in</span>
<span class="sd">        this case.  This method is little more than a wrapper to</span>
<span class="sd">        run the find method and translating the output into the</span>
<span class="sd">        slightly different form required by find_one.   More important</span>
<span class="sd">        is the fact that the wrapper implements two safties to make the</span>
<span class="sd">        code more robust:</span>
<span class="sd">            1.  It immediately tests that mspass_object is a valid TimeSeries</span>
<span class="sd">                or Seismogram object. It will raise a TypeError exception</span>
<span class="sd">                if that is not true.  That is enforced because find_one</span>
<span class="sd">                in this context make sense only for atomic objects.</span>
<span class="sd">            2.  It handles dead data cleanly logging a message complaining</span>
<span class="sd">                that the data was already marked dead.</span>

<span class="sd">        In addition note the find method this calls is assumed to handle</span>
<span class="sd">        the case of failures in the query_generator function if any of the</span>
<span class="sd">        required net, sta, chan keys are missing from mspass_object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Be dogmatic and demand mspass_object is a TimeSeries or Seismogram (atomic)</span>
        <span class="k">if</span> <span class="n">_input_is_atomic</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="c1"># trap this unlikely but possible condition as this</span>
                <span class="c1"># condition could produce mysterious behavior</span>
                <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_is_relative</span><span class="p">():</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Usage error:  input has a relative time standard but miniseed matching requires a UTC time stamp&quot;</span>
                    <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
                <span class="n">find_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">number_matches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">number_matches</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">elog</span> <span class="o">=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{n}</span><span class="s2"> channel recorded match net:sta:chan:loc:time_interval query for this datume</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">n</span><span class="o">=</span><span class="n">number_matches</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Using first document in list returned by find method&quot;</span>
                    <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">elog</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># logged as complaint because by definition if it was</span>
                <span class="c1"># already killed it is Invalid</span>
                <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Received a datum marked dead - will not attempt match&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedDBMatcher.find_one:  this class method can only be applied to TimeSeries or Seismogram objects&quot;</span>
            <span class="p">)</span></div></div>


<div class="viewcode-block" id="MiniseedMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedMatcher">[docs]</a><span class="k">class</span> <span class="nc">MiniseedMatcher</span><span class="p">(</span><span class="n">DictionaryCacheMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cached version of matcher for miniseed station/channel Metadata.</span>

<span class="sd">    Miniseed data require 6 keys to uniquely define a single channel</span>
<span class="sd">    of data (5 at the Seismogram level where the channels are merged).</span>
<span class="sd">    A further complication for using the DictionaryCacheMatcher interface is</span>
<span class="sd">    that part of the definition is a UTC time interval defining when the</span>
<span class="sd">    metadata is valid.  We handle that in this implementation by</span>
<span class="sd">    implementing a two stage search algorithm for the find_one method.</span>
<span class="sd">    First, the cache index is defined by a unique string created from</span>
<span class="sd">    the four string keys of miniseed that the MsPASS default schema</span>
<span class="sd">    refers to with the keywords net, sta, chan, and loc.</span>
<span class="sd">    At this point in time we know of no examples of a seismic instrument</span>
<span class="sd">    where the number of distinct time intervals with different Metadata</span>
<span class="sd">    are huge so the secondary search is a simple linear search through</span>
<span class="sd">    the python list return by the generic find method using only the</span>
<span class="sd">    net, sta, chan, and loc keys as the index.</span>

<span class="sd">    The default collection name is channel which is the only</span>
<span class="sd">    correct use if applied to data created through readers applied to</span>
<span class="sd">    wf_miniseed.   The implementation can also work on Seismogram</span>
<span class="sd">    data if and only if the channel argument is then set to &quot;site&quot;.</span>
<span class="sd">    The difference is that for Seismogram data &quot;chan&quot; is a</span>
<span class="sd">    undefined concept.  In both cases the keys and content assume the mspass</span>
<span class="sd">    schema for the channel or site collections.  The constructor will</span>
<span class="sd">    throw a MsPASSError exception if the collection argument is</span>
<span class="sd">    anything but &quot;channel&quot; or &quot;site&quot; to enforce this limitation.</span>
<span class="sd">    If you use a schema other than the mspass schema the methods in</span>
<span class="sd">    this class will fail if you change any of the following keys:</span>
<span class="sd">        net, sta, chan, loc, starttime, endtime, hang, vang</span>

<span class="sd">    Users should only call the find_one method for this application.</span>
<span class="sd">    The find_one method here overrides the generic find_one in the</span>
<span class="sd">    superclass DictionaryCacheMatcher.  It implements the linear search for a</span>
<span class="sd">    matching time interval test as noted above.  Note also this</span>
<span class="sd">    class does not support Ensembles directly.   Matching instrument</span>
<span class="sd">    data is by definition what we call atomic. If you are processing</span>
<span class="sd">    ensembles you will need to write a small wrapper function that</span>
<span class="sd">    would run find_one and handle the out looping over each member of</span>
<span class="sd">    the ensemble.</span>

<span class="sd">    :param db:  MongoDB database handle containing collection to be loaded.</span>
<span class="sd">    :type db: mspass Database handle(mspasspy.db.database.Database).</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       The default is &quot;channel&quot;.  Use &quot;site&quot; for Seismogram data.</span>
<span class="sd">       Use anything else at your own risk</span>
<span class="sd">       as the algorithm depends heavily on the mspass schema definition</span>
<span class="sd">       and properties guaranteed by using the converter from obspy</span>
<span class="sd">       Inventory class loaded through web services or stationml files.</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param query:  optional query to apply to collection before loading</span>
<span class="sd">      data from the database.  This parameter is ignored if the input</span>
<span class="sd">      is a DataFrame.  A common use would be to reduce the size of the</span>
<span class="sd">      cache by using a time range limit on station metadata to only</span>
<span class="sd">      load records relevant to the dataset being processed.</span>
<span class="sd">    :type query:  python dictionary.</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find will fail.</span>
<span class="sd">      Default [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;,&quot;hang&quot;,&quot;vang&quot;]</span>
<span class="sd">               &quot;hang&quot;,&quot;vang&quot;,&quot;starttime&quot;,&quot;endtime&quot;]</span>
<span class="sd">      when collection is set as channel.  Smaller list of</span>
<span class="sd">      [&quot;_id&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;] is</span>
<span class="sd">      default when collection is set as &quot;site&quot;.  In either case the</span>
<span class="sd">      list MUST contain &quot;starttime&quot; and &quot;endtime&quot;.  The reason is the</span>
<span class="sd">      linear search step will always use those two fields in the linear</span>
<span class="sd">      search for a time interval match. Be careful in how endtime is defined</span>
<span class="sd">      that resolves to an epoch time in the distant future and not some</span>
<span class="sd">      null database attribute; a possible scenario with DataFrame</span>
<span class="sd">      input but not a concern if using mspass loaders from StationML data.</span>

<span class="sd">      Note there is also an implicit assumption that the keys &quot;net&quot; and</span>
<span class="sd">      &quot;sta&quot; are always defined.  &quot;chan&quot; must also be defined if the</span>
<span class="sd">      collection name is &quot;channel&quot;.  &quot;loc&quot; is handled as optional for</span>
<span class="sd">      database input but required if the input is via a Dataframe</span>
<span class="sd">      because we use the same cache id generator for all cases.</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is [&quot;loc&quot;].   A common</span>
<span class="sd">      addition here may be response data (see schema definition for keys)</span>
<span class="sd">    :type load_if_defined:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">aload_tmp</span> <span class="o">=</span> <span class="n">attributes_to_load</span>
        <span class="k">if</span> <span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="c1"># forcing this may be a bit too dogmatic but hang and vang</span>
            <span class="c1"># are pretty essential metadata for any channel</span>
            <span class="k">if</span> <span class="s2">&quot;hang&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span><span class="p">:</span>
                <span class="n">aload_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;hang&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;vang&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span><span class="p">:</span>
                <span class="n">aload_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;vang&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">collection</span> <span class="o">!=</span> <span class="s2">&quot;site&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedMatcher:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Illegal collection argument=&quot;</span>
                <span class="o">+</span> <span class="n">collection</span>
                <span class="o">+</span> <span class="s2">&quot; Must be either channel or site&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;starttime&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span> <span class="ow">or</span> <span class="s2">&quot;endtime&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aload_tmp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedMatcher:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Error in attribute_to_load list - List must contain starttime and endtime keys&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">aload_tmp</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MiniseedMatcher.cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedMatcher.cache_id">[docs]</a>    <span class="k">def</span> <span class="nf">cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementations of this required method.  The cache_id</span>
<span class="sd">        in this algorithm is a composite key made from net, sta, chan, and</span>
<span class="sd">        loc with a fixed separator string of &quot;_&quot;.  A typical example</span>
<span class="sd">        is IU_AAK_BHZ_00_.</span>

<span class="sd">        An added feature to mesh with MsPASS conventions is a safety</span>
<span class="sd">        for attributes that are automatically renamed when saved</span>
<span class="sd">        that are marked readonly in the schema.   Such attributes</span>
<span class="sd">        have a prepended tag, (at this time &quot;READONLYERROR_&quot;).  If</span>
<span class="sd">        one of the required keys for the index is missing (e.g. &quot;net&quot;)</span>
<span class="sd">        the function tries to then fetch the modified name</span>
<span class="sd">        (e.g. &quot;READONLYERROR_net&quot;).  If that also fails it returns</span>
<span class="sd">        a None as specified by the API.</span>

<span class="sd">        :param mspass_object:  mspass object to be matched with cache.</span>
<span class="sd">          Must contain net, sta fpr site matching and net, sta, and</span>
<span class="sd">          chan for the channel collection. If loc is not defined for</span>
<span class="sd">          any case an emtpy string in defined an the key has two</span>
<span class="sd">          trailing separator characters (e.g. IU_AAK_BHZ__)</span>

<span class="sd">        :return: normal return is a string that can be used as an index string.</span>
<span class="sd">          If any of the required keys is missing it will return a None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we make this a const</span>
        <span class="n">SEPARATOR</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">net</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chan</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">idstring</span> <span class="o">=</span> <span class="n">net</span> <span class="o">+</span> <span class="n">SEPARATOR</span> <span class="o">+</span> <span class="n">sta</span> <span class="o">+</span> <span class="n">SEPARATOR</span> <span class="o">+</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">SEPARATOR</span>
        <span class="c1"># a bit nonstandard to put chan at end but this isn&#39;t for human</span>
        <span class="c1"># consumption anyway</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="n">idstring</span> <span class="o">+=</span> <span class="n">chan</span> <span class="o">+</span> <span class="n">SEPARATOR</span>
        <span class="k">return</span> <span class="n">idstring</span></div>

<div class="viewcode-block" id="MiniseedMatcher.db_make_cache_id"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedMatcher.db_make_cache_id">[docs]</a>    <span class="k">def</span> <span class="nf">db_make_cache_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementations of this required method.  The cache_id</span>
<span class="sd">        in this algorithm is a composite key made from net, sta, chan, and</span>
<span class="sd">        loc with a fixed separator string of &quot;_&quot;.  A typical example</span>
<span class="sd">        is IU_AAK_BHZ_00_.  This method creates this string from</span>
<span class="sd">        a MongoDB document assumed passed through a python dictionary</span>
<span class="sd">        as argument doc.  Unlike the cache_id method this function</span>
<span class="sd">        does not have a safety for readonly errors.  The reason is that</span>
<span class="sd">        it is designed to be used only while loading the cache from</span>
<span class="sd">        site or channel documents.</span>

<span class="sd">        :param doc:  python dict containing a site or channel document.</span>
<span class="sd">          Must contain net, sta fpr site matching and net, sta, and</span>
<span class="sd">          chan for the channel collection. If loc is not defined for</span>
<span class="sd">          any case an emtpy string in defined an the key has two</span>
<span class="sd">          trailing separator characters (e.g. IU_AAK_BHZ__)</span>

<span class="sd">        :return: normal return is a string that can be used as an index string.</span>
<span class="sd">          If any of the required keys is missing it will return a None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we make this a const</span>
        <span class="n">SEPARATOR</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
        <span class="c1"># superclass must handle None returns for invalid document</span>
        <span class="k">if</span> <span class="s2">&quot;net&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;sta&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">sta</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;chan&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">chan</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;loc&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">idstring</span> <span class="o">=</span> <span class="n">net</span> <span class="o">+</span> <span class="n">SEPARATOR</span> <span class="o">+</span> <span class="n">sta</span> <span class="o">+</span> <span class="n">SEPARATOR</span> <span class="o">+</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">SEPARATOR</span>
        <span class="c1"># a bit nonstandard to put chan at end but this isn&#39;t for human</span>
        <span class="c1"># consumption anyway</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">==</span> <span class="s2">&quot;channel&quot;</span><span class="p">:</span>
            <span class="n">idstring</span> <span class="o">+=</span> <span class="n">chan</span> <span class="o">+</span> <span class="n">SEPARATOR</span>
        <span class="k">return</span> <span class="n">idstring</span></div>

<div class="viewcode-block" id="MiniseedMatcher.find_one"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedMatcher.find_one">[docs]</a>    <span class="k">def</span> <span class="nf">find_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We overload find_one to provide the unique match needed.</span>
<span class="sd">        The algorithm does a linear search for the first time interval</span>
<span class="sd">        for which the start time of mspass_object is within the</span>
<span class="sd">        startime &lt;= t0 &lt;= endtime range of a record stored in</span>
<span class="sd">        the cache.  This works only if starttime and endtime are</span>
<span class="sd">        defined in the set of attributes loaded so the constructor</span>
<span class="sd">        of this class enforces that restriction.   The times in</span>
<span class="sd">        starttime and endtime are assumed to be defined as epoch</span>
<span class="sd">        times as the algorithm uses a simple numeric test of the</span>
<span class="sd">        data start time with the two times.  An issue to watch out</span>
<span class="sd">        for is endtime not being set to a valid distant time but some</span>
<span class="sd">        null field that resolves to something that doesn&#39;t work in</span>
<span class="sd">        a numerical test for &lt; endtime.</span>

<span class="sd">        :param mspass_object:   data to be used for matching against the</span>
<span class="sd">        cache.  It must contain the required keys or the matching will</span>
<span class="sd">        fail.  If the datum is marked dead the algorithm will return</span>
<span class="sd">        immediately with a None response and an error message that</span>
<span class="sd">        would usually be dropped by the call in that situation.</span>
<span class="sd">        :type mspass_object:  must be one of the atomic data types of</span>
<span class="sd">          mspass (currently TimeSeries and Seismogram) with t0</span>
<span class="sd">          defined as an epoch time computed from a UTC time stamp.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Be dogmatic and demand mspass_object is a TimeSeries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="c1"># trap this unlikely but possible condition as this</span>
                <span class="c1"># condition could produce mysterious behavior</span>
                <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">time_is_relative</span><span class="p">():</span>
                    <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Usage error:  input has a relative time standard but miniseed matching requires a UTC time stamp&quot;</span>
                    <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
                <span class="n">find_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Current implementation posts a elog message that is</span>
                    <span class="c1"># returned in file_output[1].  Could consider adding to</span>
                    <span class="c1"># that log message here to clarify it was the miniseed</span>
                    <span class="c1"># instance</span>
                    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">stime_key</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;starttime&quot;</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span>
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_starttime&quot;</span>
                        <span class="p">)</span>
                        <span class="n">etime_key</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;endtime&quot;</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span>
                            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_endtime&quot;</span>
                        <span class="p">)</span>
                        <span class="n">stime</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">stime_key</span><span class="p">]</span>
                        <span class="n">etime</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">etime_key</span><span class="p">]</span>
                        <span class="n">t0</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
                        <span class="k">if</span> <span class="n">t0</span> <span class="o">&gt;=</span> <span class="n">stime</span> <span class="ow">and</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">etime</span><span class="p">:</span>
                            <span class="k">return</span> <span class="p">[</span><span class="n">md</span><span class="p">,</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="c1"># we land here if the linear search failed and no</span>
                    <span class="c1"># t0 is within the ranges defined</span>
                    <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">elog</span> <span class="o">=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;No matching records found in &quot;</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
                        <span class="o">+</span> <span class="s2">&quot; collection for:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;net=&quot;</span> <span class="o">+</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;, sta=&quot;</span> <span class="o">+</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;, chan=&quot;</span> <span class="o">+</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;loc&quot;</span><span class="p">):</span>
                        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;, loc=&quot;</span> <span class="o">+</span> <span class="n">mspass_object</span><span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;time=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span><span class="p">))</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Found a match for station codes but no channel time range contains that time &quot;</span>
                    <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elog</span> <span class="o">=</span> <span class="n">PyErrorLogger</span><span class="p">()</span>
                <span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;Received a datum marked dead - will not attempt match&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">elog</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedMatcher.find_one:  this class method can only be applied to TimeSeries or Seismogram objects&quot;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="MiniseedMatcher.find_doc"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.MiniseedMatcher.find_doc">[docs]</a>    <span class="k">def</span> <span class="nf">find_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">wfdoc_starttime_key</span><span class="o">=</span><span class="s2">&quot;starttime&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optional function to support application to bulk_normalize to</span>
<span class="sd">        set channel_id or site_id.  Acts like find_one but without support</span>
<span class="sd">        for readonly recovery.   The bigger difference is that this</span>
<span class="sd">        method accepts a python dict retrieved in a cursor loop for</span>
<span class="sd">        bulk_normalize.   Returns the Metadata container that is matched</span>
<span class="sd">        from the cache.   This uses the same algorithm as the overloaded</span>
<span class="sd">        find_one above where a linear search is used to handle the time</span>
<span class="sd">        interval matching.  Here, however, the time field is extracted</span>
<span class="sd">        from doc with the key defined by starttime.</span>

<span class="sd">        :param doc:  document (pretty much assumed to be from wf_miniseed)</span>
<span class="sd">          to be matched with channel or site.</span>
<span class="sd">        :type doc:  python dictionary - document from MongoDB</span>

<span class="sd">        :param wfdoc_starttime_key:  optional parameter to change the</span>
<span class="sd">         key used to fetch the start time of waveform data from doc.</span>
<span class="sd">         Default is &quot;starttime&quot;/</span>
<span class="sd">        :type wfdoc_starttime_key: string</span>

<span class="sd">        :return:  matching Metadata container if successful. None if</span>
<span class="sd">          matching fails for any reason.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># always abort if the starttime key is not defined.  For</span>
        <span class="c1"># current implementation wf_miniseed documents always have that</span>
        <span class="c1"># key defined so throwing an exception marked Fatal is appropriate.</span>
        <span class="k">if</span> <span class="n">wfdoc_starttime_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;MiniseedMatcher:  &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Required key defining waveform start time=&quot;</span>
                <span class="o">+</span> <span class="n">wfdoc_starttime_key</span>
                <span class="o">+</span> <span class="s2">&quot; is missing from document received&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># we use this version of the method to generate the cache key as</span>
        <span class="c1"># it works with the dict, BUT it doesn&#39;t allow the READONLYERROR</span>
        <span class="c1"># recovery</span>
        <span class="n">testid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_make_cache_id</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normcache</span><span class="p">[</span><span class="n">testid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># linear search similar to that in find_one above</span>
        <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                <span class="n">stkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;starttime&quot;</span>
                <span class="n">etkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;endtime&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stkey</span> <span class="o">=</span> <span class="s2">&quot;starttime&quot;</span>
                <span class="n">etkey</span> <span class="o">=</span> <span class="s2">&quot;endtime&quot;</span>
            <span class="c1"># let this throw an exception if fetch fails. Constructor</span>
            <span class="c1"># should guarantee these two attributes are loaded</span>
            <span class="n">stime</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">stkey</span><span class="p">]</span>
            <span class="n">etime</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">etkey</span><span class="p">]</span>
            <span class="n">dt0</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">wfdoc_starttime_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dt0</span> <span class="o">&gt;=</span> <span class="n">stime</span> <span class="ow">and</span> <span class="n">dt0</span> <span class="o">&lt;=</span> <span class="n">etime</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">md</span>

        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="EqualityMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.EqualityMatcher">[docs]</a><span class="k">class</span> <span class="nc">EqualityMatcher</span><span class="p">(</span><span class="n">DataFrameCacheMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Match with an equality test for the values of one or more keys</span>
<span class="sd">    with possible aliasing between data keys and database keys.</span>

<span class="sd">    This class can be used for matching a set of keys that together</span>
<span class="sd">    provide a unique matching capability.   Note the keys are</span>
<span class="sd">    applied sequentially to reduce the size of internal DataFrame</span>
<span class="sd">    cache in stages.  If the DataFrame is large it may improve performance</span>
<span class="sd">    if the most unique key in a series appears first.</span>

<span class="sd">    A special feature of the implementation is that we allow</span>
<span class="sd">    what is best thought of as reverse aliasing for the keys to</span>
<span class="sd">    be used for matching.   That is, the base class of this family</span>
<span class="sd">    has an attribute self.aliases that allow mapping from collection names</span>
<span class="sd">    to data object names.  The match_keys parameter here is done in</span>
<span class="sd">    the reverse order.  That is, the key of the match_keys dictionary</span>
<span class="sd">    is the data object key while the value associated with that key</span>
<span class="sd">    is the DataFrame column name to match.  The constructor of the</span>
<span class="sd">    class does a sanity check to verify the two are consistent.</span>
<span class="sd">    The constructor will throw an exception if the two dictionaries</span>
<span class="sd">    are inconstent.  Note that means if you use an actual alias through</span>
<span class="sd">    match_keys (i.e. the key and value are different) you must define</span>
<span class="sd">    the aliases dictionary with the same combination reversed.</span>
<span class="sd">    (e.g.  matchkeys={&quot;KSTA&quot;:&quot;sta&quot;} requires aliases={&quot;sta&quot;:&quot;KSTA&quot;})</span>

<span class="sd">    :param db_or_df:  MongoDB database handle or a pandas DataFrame.</span>
<span class="sd">      Most users will use the database handle version.   In that case</span>
<span class="sd">      the collection argument is used to determine what collection is</span>
<span class="sd">      loaded into the cache.   If using a DataFrame is used the</span>
<span class="sd">      collection name is only a tag defined by the user.   For a</span>
<span class="sd">      DataFrame a column index is required that contains at least</span>
<span class="sd">      the attributes defined in attribute_to_load.</span>
<span class="sd">    :type db_or_df: MongoDB database handle or pandas DataFrame.</span>

<span class="sd">    :param collection:  When using database input this is expected to be</span>
<span class="sd">      a string defining a valid MongoDB collection with documents that are</span>
<span class="sd">      to be scanned and loaded into the internal cache.  With DataFrame input</span>
<span class="sd">      this string is only a tag.  It is relevant then only if the</span>
<span class="sd">      prepend_collection_name boolean is set True.  There is no default</span>
<span class="sd">      for this parameter so it must be specified as arg 1.</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param match_keys:  python dict of keys that are to be used for</span>
<span class="sd">      the equality match.  The dict is used as an alias mechanism allowing</span>
<span class="sd">      different keys to be used for the Metadata container in data to</span>
<span class="sd">      be tested relative to the keys used in the database for the same</span>
<span class="sd">      attribute.  (a typical common example would be something like</span>
<span class="sd">      &quot;source_lat&quot; in the data matching &quot;lat&quot; in the source collection).</span>
<span class="sd">      The key for each entry in this dict is taken as the key for the</span>
<span class="sd">      data side (mspass_object) and the value assigned to that key</span>
<span class="sd">      in this input is taken as the mongoDB/DataFrame key.</span>
<span class="sd">    :type match_keys:  python dictionary</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find will fail.   There is currently no default for</span>
<span class="sd">      this parameter and it must be defined as arg 3.</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param query:  optional query to apply to collection before loading</span>
<span class="sd">      data from the database.  This parameter is ignored if the input</span>
<span class="sd">      is a DataFrame.  A common use would be to reduce the size of the</span>
<span class="sd">      cache by using a time range limit on station metadata to only</span>
<span class="sd">      load records relevant to the dataset being processed.  This</span>
<span class="sd">      parameter is currently ignored for DataFrame input as we assume</span>
<span class="sd">      pandas subsetting would be used for the same functionality</span>
<span class="sd">      in the workflow prior to calling the class constructor for this object.</span>
<span class="sd">    :type query:  python dictionary.</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default resolves to an empty list.</span>
<span class="sd">      Note this parameter is ignored for DataFrame input.</span>
<span class="sd">    :type load_if_defined:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  Default is</span>
<span class="sd">      False.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is True)</span>
<span class="sd">    :type require_unique_match:  boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_or_df</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">match_keys</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">custom_null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db_or_df</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">custom_null_values</span><span class="o">=</span><span class="n">custom_null_values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">match_keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span> <span class="o">=</span> <span class="n">match_keys</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">match_keys</span><span class="p">:</span>
                <span class="n">testkey</span> <span class="o">=</span> <span class="n">match_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="c1"># this means no aliasing for key</span>
                <span class="k">if</span> <span class="n">testkey</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">testkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
                    <span class="n">backtestkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">[</span><span class="n">testkey</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">backtestkey</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;EqualityMatcher constructor:  &quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;match_keys and aliases are inconsistent.</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;match_keys=&quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">match_keys</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot;  aliases=&quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;EqualityMatcher constructor:  &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;match_keys and aliases are inconsistent.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;match_key defines key=&quot;</span>
                        <span class="o">+</span> <span class="n">key</span>
                        <span class="o">+</span> <span class="s2">&quot; to have alias name=&quot;</span>
                        <span class="o">+</span> <span class="n">testkey</span>
                        <span class="o">+</span> <span class="s2">&quot; but alias name is not defined by aliases parameter&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;EqualityMatcher Constructor:  required argument 2 (matchkeys) must be a python dictionary&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="EqualityMatcher.subset"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.EqualityMatcher.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation of this virtual method of DataFrameMatcher</span>
<span class="sd">        for this class.</span>

<span class="sd">        The subset is done sequentially driven by the order key order</span>
<span class="sd">        of the self.match_keys dictionary.   i.e. the algorithm uses</span>
<span class="sd">        the row reduction operation of a dataframe one key at a time.</span>
<span class="sd">        An implementation detail is that there may be a more clever way</span>
<span class="sd">        instead create a single conditional clause to pass to the</span>
<span class="sd">        DataFrame operator [] combining the key matches with &quot;and&quot;.</span>
<span class="sd">        That would likely improve performance, particulary on large tables.</span>
<span class="sd">        Note the alias is applied using the self.match_keys.  i.e. one</span>
<span class="sd">        can have different keys on the left (mspass_data side is the</span>
<span class="sd">        match_keys dictionary key) than the right (dataframe column name).</span>

<span class="sd">        :param mspass_object:  Any valid mspass data object with a</span>
<span class="sd">        Metadata container.  The container must contain all the</span>
<span class="sd">        required match keys or the function will return an error condition</span>
<span class="sd">        (see below)</span>
<span class="sd">        :type mspass_object:  TimeSeries, Seismogram, TimeSeriesEnsemble</span>
<span class="sd">          or SeismogramEnsemble object</span>

<span class="sd">        :return:  DataFrame containing all data satisying the match</span>
<span class="sd">           series of match conditions defined on construction.  Silently</span>
<span class="sd">           returns a zero length DataFrame if is no match.   Be warned</span>
<span class="sd">           two other situations can cause the return to have no data:</span>
<span class="sd">               (1) dead input, and (2) match keys missing from mspass_object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateFrame</span><span class="p">()</span>
        <span class="c1"># I don&#39;t think this can cause a memory problem as in python</span>
        <span class="c1"># this make dfret a temporary alias for self.cache</span>
        <span class="c1"># In the loop it is replaced by subset dataframes</span>
        <span class="n">dfret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">testval</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="c1"># this allows an alias between data and dataframe keys</span>
                <span class="n">dfret</span> <span class="o">=</span> <span class="n">dfret</span><span class="p">[</span><span class="n">dfret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">==</span> <span class="n">testval</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dfret</span></div></div>


<div class="viewcode-block" id="EqualityDBMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.EqualityDBMatcher">[docs]</a><span class="k">class</span> <span class="nc">EqualityDBMatcher</span><span class="p">(</span><span class="n">DatabaseMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Database equivalent of EqualityMatcher.</span>

<span class="sd">    param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried.</span>
<span class="sd">      This arg is required by the constructor and has not default.</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param match_keys:  python dict of keys that are to be used for</span>
<span class="sd">      the equality match.  The dict is used as an alias mechanism allowing</span>
<span class="sd">      different keys to be used for the Metadata container in data to</span>
<span class="sd">      be tested relative to the keys used in the database for the same</span>
<span class="sd">      attribute.  (a typical common example would be something like</span>
<span class="sd">      &quot;source_lat&quot; in the data matching &quot;lat&quot; in the source collection).</span>
<span class="sd">      The key for each entry in this dict is taken as the key for the</span>
<span class="sd">      data side (mspass_object) and the value assigned to that key</span>
<span class="sd">      in this input is taken as the mongoDB/DataFrame key.</span>
<span class="sd">    :type match_keys:  python dictionary</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find will fail.  There is no default for this class</span>
<span class="sd">      and the list must be defined as arg3.</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents.</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is to add load no</span>
<span class="sd">      optional data.</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.  Default is False.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is False)</span>
<span class="sd">    :type require_unique_match:  boolean</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">match_keys</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">match_keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span> <span class="o">=</span> <span class="n">match_keys</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  required arg2 must be a python dictionary - received invalid type.  See docstring&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="EqualityDBMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.EqualityDBMatcher.query_generator">[docs]</a>    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of required method for this class.  It simply</span>
<span class="sd">        applies an equality test for all the keys defined by the values</span>
<span class="sd">        in the self.match_keys dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dkey</span> <span class="ow">in</span> <span class="n">mspass_object</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="n">dkey</span><span class="p">]</span>
                <span class="n">query</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_keys</span><span class="p">[</span><span class="n">dkey</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># API says return none if generator fails</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">query</span></div></div>


<div class="viewcode-block" id="OriginTimeDBMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.OriginTimeDBMatcher">[docs]</a><span class="k">class</span> <span class="nc">OriginTimeDBMatcher</span><span class="p">(</span><span class="n">DatabaseMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class to match data by comparing a time defined in data to an</span>
<span class="sd">    origin time using a database query algorithm.</span>

<span class="sd">    The default behavior of this matcher class is to match data to</span>
<span class="sd">    source documents based on origin time with an optional time offset.</span>
<span class="sd">    Conceptually the data model for this matching is identical to conventional</span>
<span class="sd">    multichannel shot gathers where the start time is usually the origin time.</span>
<span class="sd">    It is also a common model for downloaded source oriented waveform</span>
<span class="sd">    segments from FDSN web services with obspy.  Obspy has an example</span>
<span class="sd">    in their documentation for how to download data defined exactly this way.</span>
<span class="sd">    In that mode we match each source document that matches a projected</span>
<span class="sd">    origin time within a specified tolerance. Specifically, let t0</span>
<span class="sd">    be the start time extracted from the data.  We then compute the</span>
<span class="sd">    projected, test origin time as test_otime = t0 - t0offset.</span>
<span class="sd">    Note the sign convention that a positive offset means the time t0</span>
<span class="sd">    is after the event origin time.   We then select all source</span>
<span class="sd">    records for which the time field satisifies:</span>
<span class="sd">        source.time - tolerance &lt;= test_time &lt;= source.time + tolerance</span>

<span class="sd">    The test_time value for matching from a datum can come through</span>
<span class="sd">    one of two methods driven by the constructor argument &quot;time_key&quot;.</span>
<span class="sd">    When time_key is a None (default) the algorithm assumes all input</span>
<span class="sd">    are mspass atomic data objects that have the start time defined by</span>
<span class="sd">    the attribute &quot;t0&quot; (mspass_object.t0).  If time_key is a string</span>
<span class="sd">    it is assumed to be a Metadata key used to fetch an epoch time</span>
<span class="sd">    to use for the test.   The most likely use of that feature would be</span>
<span class="sd">    for ensemble processing where test_time is set as a field in the</span>
<span class="sd">    ensemble Metadata.  Note that form of associating source data to</span>
<span class="sd">    ensembles that are common source gathers can be much faster than</span>
<span class="sd">    the atomic version because only one query is needed per ensemble.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       (default &quot;source&quot;).</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param t0offset: constant offset from data start time that is expected</span>
<span class="sd">      as origin time.  A positive t0offset means the origin time is before</span>
<span class="sd">      the data start time.  Units are always assumed to be seconds.</span>
<span class="sd">    :type t0offset:  float</span>

<span class="sd">    :param tolerance:   time tolerance to test for match of origin time.</span>
<span class="sd">      (see formula above for exact use)</span>
<span class="sd">      If the source estimates are exactly the same as the ones used to</span>
<span class="sd">      define data start time this number can be a few samples.</span>
<span class="sd">      Otherwise a few seconds is safter for teleseismic data and</span>
<span class="sd">      less for local/regional events.  i.e. the choice depends up on</span>
<span class="sd">      how the source estimates relate to the data.</span>
<span class="sd">    :type tolerance:  float</span>


<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find_one will fail.   Default is</span>
<span class="sd">      [&quot;lat&quot;,&quot;lon&quot;,&quot;depth&quot;,&quot;time&quot;]</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is [&quot;magnitude&quot;]</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is False)</span>
<span class="sd">    :type require_unique_match:  boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="n">t0offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">],</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">data_time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span> <span class="o">=</span> <span class="n">t0offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span> <span class="o">=</span> <span class="n">data_time_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_time_key</span> <span class="o">=</span> <span class="n">source_time_key</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  query argument must define a python dictionary or a None: received invalid type.  See docstring&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>

<div class="viewcode-block" id="OriginTimeDBMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.OriginTimeDBMatcher.query_generator">[docs]</a>    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation of this required method for a subclass of</span>
<span class="sd">        DatabaseMatcher.</span>

<span class="sd">        This algorithm implements the time test described in detail in</span>
<span class="sd">        docstring for this class.  Note the fundamental change in how the</span>
<span class="sd">        test time is computed that depends on the internal (self)</span>
<span class="sd">        attribute time_key.  When None we use the data&#39;s t0 attribute.</span>
<span class="sd">        Otherwise self.time_key is assumed to be a string key to</span>
<span class="sd">        fetch the test time from the object&#39;s Metadata container.</span>

<span class="sd">        :param mspass_object:   MsPASS defined data object that contains</span>
<span class="sd">          data to be used for this match (t0 attribute or content of</span>
<span class="sd">          self.time_key).</span>
<span class="sd">        :type mspass_object:  Any valid MsPASS data object.</span>

<span class="sd">        :return:  query python dictionary on sucess.  Return None if</span>
<span class="sd">          a query could not be constructed.  That happens two ways here.</span>
<span class="sd">          (1) If the input is not a valid mspass data object or marked dead.</span>
<span class="sd">          (2) if the time_key algorithm is used and time_key isn&#39;t defined</span>
<span class="sd">              in the input datum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This could generate mysterious results if a user messes up</span>
        <span class="c1"># badly, but  it makes the code more stable - otherwise</span>
        <span class="c1"># a parallel job could, for example, abort if one of the</span>
        <span class="c1"># components in a bag/rdd got set to None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this maybe should have a test to assure UTC time standard</span>
            <span class="c1"># but will defer for now</span>
            <span class="n">test_time</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span><span class="p">):</span>
                <span class="n">test_time</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># depends upon self.query being initialized by constructor</span>
        <span class="c1"># as python dictionary</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;$gte&quot;</span><span class="p">:</span> <span class="n">test_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="s2">&quot;$lte&quot;</span><span class="p">:</span> <span class="n">test_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">query</span></div></div>


<div class="viewcode-block" id="OriginTimeMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.OriginTimeMatcher">[docs]</a><span class="k">class</span> <span class="nc">OriginTimeMatcher</span><span class="p">(</span><span class="n">DataFrameCacheMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class to match data by comparing a time defined in data to</span>
<span class="sd">    an origin time using a cached DataFrame.</span>

<span class="sd">    The default behavior of this matcher class is to match data to</span>
<span class="sd">    source documents based on origin time with an optional time offset.</span>
<span class="sd">    Conceptually the data model for this matching is identical to conventional</span>
<span class="sd">    multichannel shot gathers where the start time is usually the origin time.</span>
<span class="sd">    It is also a common model for downloaded source oriented waveform</span>
<span class="sd">    segments from FDSN web services with obspy.  Obspy has an example</span>
<span class="sd">    in their documentation for how to download data defined exactly this way.</span>
<span class="sd">    In that mode we match each source document that matches a projected</span>
<span class="sd">    origin time within a specified tolerance. Specifically, let t0</span>
<span class="sd">    be the start time extracted from the data.  We then compute the</span>
<span class="sd">    projected, test origin time as test_otime = t0 - t0offset.</span>
<span class="sd">    Note the sign convention that a positive offset means the time t0</span>
<span class="sd">    is after the event origin time.   We then select all source</span>
<span class="sd">    records for which the time field satisifies:</span>
<span class="sd">        source.time - tolerance &lt;= test_time &lt;= source.time + tolerance</span>

<span class="sd">    The test_time value for matching from a datum can come through</span>
<span class="sd">    one of two methods driven by the constructor argument &quot;time_key&quot;.</span>
<span class="sd">    When time_key is a None (default) the algorithm assumes all input</span>
<span class="sd">    are mspass atomic data objects that have the start time defined by</span>
<span class="sd">    the attribute &quot;t0&quot; (mspass_object.t0).  If time_key is a string</span>
<span class="sd">    it is assumed to be a Metadata key used to fetch an epoch time</span>
<span class="sd">    to use for the test.   The most likely use of that feature would be</span>
<span class="sd">    for ensemble processing where test_time is set as a field in the</span>
<span class="sd">    ensemble Metadata.  Note that form of associating source data to</span>
<span class="sd">    ensembles that are common source gathers can be much faster than</span>
<span class="sd">    the atomic version because only one query is needed per ensemble.</span>

<span class="sd">    This implentation should be used only if the catalog of events</span>
<span class="sd">    is reasonably small.  If the catalog is huge the database version</span>
<span class="sd">    may be more appropriate.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       (default &quot;source&quot;).</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param t0offset: constant offset from data start time that is expected</span>
<span class="sd">      as origin time.  A positive t0offset means the origin time is before</span>
<span class="sd">      the data start time.  Units are always assumed to be seconds.</span>
<span class="sd">    :type t0offset:  float</span>

<span class="sd">    :param tolerance:   time tolerance to test for match of origin time.</span>
<span class="sd">      (see formula above for exact use)</span>
<span class="sd">      If the source estimates are exactly the same as the ones used to</span>
<span class="sd">      define data start time this number can be a few samples.</span>
<span class="sd">      Otherwise a few seconds is safter for teleseismic data and</span>
<span class="sd">      less for local/regional events.  i.e. the choice depends up on</span>
<span class="sd">      how the source estimates relate to the data.</span>
<span class="sd">    :type tolerance:  float</span>


<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find_one will fail.   Default is</span>
<span class="sd">      [&quot;lat&quot;,&quot;lon&quot;,&quot;depth&quot;,&quot;time&quot;]</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is [&quot;magnitude&quot;]</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is False)</span>
<span class="sd">    :type require_unique_match:  boolean</span>

<span class="sd">    :param data_time_key:  data object Metadata key used to fetch</span>
<span class="sd">    time for testing as alternative to data start time.  If set None</span>
<span class="sd">    (default) the test will use the start time of an atomic data object</span>
<span class="sd">    for the time test.  If nonzero it is assumed to be a string used</span>
<span class="sd">    to fetch a time from the data&#39;s Metadata container.  That is the</span>
<span class="sd">    best way to run this matcher on Ensembles.</span>
<span class="sd">    :type data_time_key:  string</span>

<span class="sd">    :param source_time_key:  dataframe column name to use as source</span>
<span class="sd">    origin time field.   Default is None which is translated to</span>
<span class="sd">    collection + &quot;_time&quot;  (default default is &quot;source_time&quot;).</span>
<span class="sd">    :type source_time_key:  string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_or_df</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="n">t0offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;magnitude&quot;</span><span class="p">],</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">data_time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source_time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">custom_null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db_or_df</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">custom_null_values</span><span class="o">=</span><span class="n">custom_null_values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span> <span class="o">=</span> <span class="n">t0offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span> <span class="o">=</span> <span class="n">data_time_key</span>
        <span class="k">if</span> <span class="n">source_time_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_time_key</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_time&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_time_key</span> <span class="o">=</span> <span class="n">source_time_key</span>

<div class="viewcode-block" id="OriginTimeMatcher.subset"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.OriginTimeMatcher.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this maybe should have a test to assure UTC time standard</span>
            <span class="c1"># but will defer for now</span>
            <span class="n">test_time</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span><span class="p">):</span>
                <span class="n">test_time</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="n">tmin</span> <span class="o">=</span> <span class="n">test_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="n">tmax</span> <span class="o">=</span> <span class="n">test_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="c1"># For this matcher we dogmatically use &lt;= equivalent in the between</span>
        <span class="c1"># construct here - inclusive=True.  In this context seems appropriate</span>
        <span class="n">dfquery</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_time_key</span>
            <span class="o">+</span> <span class="s2">&quot;.between(</span><span class="si">{tmin}</span><span class="s2">,</span><span class="si">{tmax}</span><span class="s2">,inclusive=True)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dfret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">dfquery</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dfret</span></div></div>


<div class="viewcode-block" id="ArrivalDBMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ArrivalDBMatcher">[docs]</a><span class="k">class</span> <span class="nc">ArrivalDBMatcher</span><span class="p">(</span><span class="n">DatabaseMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a class for matching a table of arrival times to input</span>
<span class="sd">    waveform data objects.  Use this version if the table of arrivals</span>
<span class="sd">    is huge and database query delays will not create a bottleneck</span>
<span class="sd">    in your workflow.</span>

<span class="sd">    Phase arrival time matching is a common need when waveform segments</span>
<span class="sd">    are downloaded.  When data are assembled as miniseed files or</span>
<span class="sd">    url downloads of miniseed data, the format has no way to hold</span>
<span class="sd">    arrival time data.  This matcher can prove useful for matching</span>
<span class="sd">    waveform segments with an origin as miniseed.</span>

<span class="sd">    The algorithm it uses for matching is a logic and of two tests:</span>
<span class="sd">        1.  We first match all arrival times falling between the</span>
<span class="sd">            sample range of an input MsPASS data object, d.  That is,</span>
<span class="sd">            first component of the query is to find all arrival times,</span>
<span class="sd">            t_a, that obey the relation:  d.t0 &lt;= t_a &lt;= d.endtime().</span>
<span class="sd">        2.  Match only data for which the (fixed) name &quot;sta&quot;</span>
<span class="sd">            in arrival and the data match.   A secondary key match using</span>
<span class="sd">            the &quot;net&quot; attribute is used only if &quot;net&quot; is defined with</span>
<span class="sd">            the data.  That is done to streamline processing of css3.0</span>
<span class="sd">            data where &quot;net&quot;  is not defined.</span>

<span class="sd">    Note the concept of an arrival time is also mixed as in</span>
<span class="sd">    some contexts it means a time computed from an earth model and other</span>
<span class="sd">    time a measured time that is &quot;picked&quot; by a human or computer algorithm.</span>
<span class="sd">    This class does not distinguish model-based from measured times.  It</span>
<span class="sd">    simply uses the time and station tag information with the algorithm</span>
<span class="sd">    noted above to attempt a match.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       (default &quot;arrival&quot;, which is not currently part of the stock</span>
<span class="sd">        mspass schema.   Note it isn&#39;t required to be in the schema</span>
<span class="sd">        and illustrates flexibility&#39;).</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find_one will fail.</span>
<span class="sd">      Default [&quot;phase&quot;,&quot;time&quot;].</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is None</span>
<span class="sd">    :param type:  list of strings defining collection keys</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is False)</span>
<span class="sd">    :type require_unique_match:  boolean</span>

<span class="sd">    :param query:   optional query predicate.  That is, if set the</span>
<span class="sd">      interval query is appended to this query to build a more specific</span>
<span class="sd">      query.   An example might be station code keys to match a</span>
<span class="sd">      specific pick for a specific station like {&quot;sta&quot;:&quot;AAK&quot;}.</span>
<span class="sd">      Another would be to limit arrivals to a specific phase name</span>
<span class="sd">      like {&quot;phase&quot; : &quot;ScS&quot;}.  Default is None which reverts to no</span>
<span class="sd">      query predicate.</span>
<span class="sd">    :type query:  python dictionary or None.  None is equivalewnt to</span>
<span class="sd">      passing an empty dictionary.  A TypeError will be thrown if this</span>
<span class="sd">      argument is not None or a dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;arrival&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;phase&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;ArrivalDBMatcher constructor:  query arg must define a python dictionary&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ArrivalDBMatcher.query_generator"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ArrivalDBMatcher.query_generator">[docs]</a>    <span class="k">def</span> <span class="nf">query_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation of method required by superclass</span>
<span class="sd">        DatabaseMatcher.</span>

<span class="sd">        This generator implements the switching algorithm noted in the</span>
<span class="sd">        class docstring.  That is, for atomic data the time span for</span>
<span class="sd">        the interval query is determined from the range of the waveform</span>
<span class="sd">        data received through mspass_object.   For ensembles the</span>
<span class="sd">        algorithm fetches fields defined by self.startime_key and</span>
<span class="sd">        self.endtime_key to define the time interval.</span>

<span class="sd">        The interval test is overlaid on the self.query input.  i.e.</span>
<span class="sd">        the query dict components derived are added to the self.query.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">_input_is_atomic</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
                <span class="n">stime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
                <span class="n">etime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
                <span class="n">query</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gte&quot;</span><span class="p">:</span> <span class="n">stime</span><span class="p">,</span> <span class="s2">&quot;$lte&quot;</span><span class="p">:</span> <span class="n">etime</span><span class="p">}</span>
                <span class="c1"># these names are frozen</span>
                <span class="n">sta</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">)</span>
                <span class="n">net</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">net</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">query</span><span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span>
                <span class="k">if</span> <span class="n">sta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">query</span><span class="p">[</span><span class="s2">&quot;sta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sta</span>
                <span class="c1"># intentionally ignore loc as option</span>
                <span class="k">return</span> <span class="n">query</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="ArrivalMatcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ArrivalMatcher">[docs]</a><span class="k">class</span> <span class="nc">ArrivalMatcher</span><span class="p">(</span><span class="n">DataFrameCacheMatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a class for matching a table of arrival times to input</span>
<span class="sd">    waveform data objects.  Use this version if the table of arrivals</span>
<span class="sd">    is not huge enough to cause a memory problem.</span>

<span class="sd">    Phase arrival time matching is a common need when waveform segments</span>
<span class="sd">    are downloaded.  When data are assembled as miniseed files or</span>
<span class="sd">    url downloads of miniseed data, the format has no way to hold</span>
<span class="sd">    arrival time data.  This matcher can prove useful for matching</span>
<span class="sd">    waveform segments with an origin as miniseed.</span>

<span class="sd">    The algorithm it uses for matching is a logic and of two tests:</span>
<span class="sd">        1.  We first match all arrival times falling between the</span>
<span class="sd">            sample range of an input MsPASS data object, d.  That is,</span>
<span class="sd">            first component of the query is to find all arrival times,</span>
<span class="sd">            t_a, that obey the relation:  d.t0 &lt;= t_a &lt;= d.endtime().</span>
<span class="sd">        2.  Match only data for which the (fixed) name &quot;sta&quot;</span>
<span class="sd">            in arrival and the data match.   A secondary key match using</span>
<span class="sd">            the &quot;net&quot; attribute is used only if &quot;net&quot; is defined with</span>
<span class="sd">            the data.  That is done to streamline processing of css3.0</span>
<span class="sd">            data where &quot;net&quot;  is not defined.</span>

<span class="sd">    Note the concept of an arrival time is also mixed as in</span>
<span class="sd">    some contexts it means a time computed from an earth model and other</span>
<span class="sd">    time a measured time that is &quot;picked&quot; by a human or computer algorithm.</span>
<span class="sd">    This class does not distinguish model-based from measured times.  It</span>
<span class="sd">    simply uses the time and station tag information with the algorithm</span>
<span class="sd">    noted above to attempt a match.</span>

<span class="sd">    This implementation caches the table of attributes desired to an</span>
<span class="sd">    internal pandas DataFrame.   It is thus most appropriate for</span>
<span class="sd">    arrival tables that are not huge.  Note it may be possible to</span>
<span class="sd">    do appropriate preprocessing to manage the arrival table size.</span>
<span class="sd">    e.g. the table can be grouped by station or in time blocks and</span>
<span class="sd">    then processed in a loop updating waveform database records</span>
<span class="sd">    in multiple passes.  The alternative for large arrival tables</span>
<span class="sd">    is to use the DB version of this matcher.</span>

<span class="sd">    :param db:  MongoDB database handle  (positional - no default)</span>
<span class="sd">    :type db: normally a MsPASS Database class but with this algorithm</span>
<span class="sd">      it can be the superclass from which Database is derived.</span>

<span class="sd">    :param collection:  Name of MongoDB collection that is to be queried</span>
<span class="sd">       (default &quot;arrival&quot;, which is not currently part of the stock</span>
<span class="sd">        mspass schema.   Note it isn&#39;t required to be in the schema</span>
<span class="sd">        and illustrates flexibility&#39;).</span>
<span class="sd">    :type collection: string</span>

<span class="sd">    :param attributes_to_load:  list of keys of required attributes that will</span>
<span class="sd">      be returned in the output of the find method.   The keys listed</span>
<span class="sd">      must ALL have defined values for all documents in the collection or</span>
<span class="sd">      some calls to find_one will fail.</span>
<span class="sd">      Default [&quot;phase&quot;,&quot;time&quot;].</span>
<span class="sd">    :type attributes_to_load:  list of string defining keys in collection</span>
<span class="sd">      documents</span>

<span class="sd">    :param load_if_defined: list of keys of optional attributes to be</span>
<span class="sd">      extracted by find method.  Any data attached to these keys will only</span>
<span class="sd">      be posted in the find return if they are defined in the database</span>
<span class="sd">      document retrieved in the query.  Default is None</span>
<span class="sd">    :param type:  list of strings defining collection keyes</span>

<span class="sd">    :param aliases:  python dictionary defining alias names to apply</span>
<span class="sd">     when fetching from a data object&#39;s Metadata container.   The key sense</span>
<span class="sd">     of the mapping is important to keep straight.  The key of this</span>
<span class="sd">     dictionary should match one  of the attributes in attributes_to_load</span>
<span class="sd">     or load_if_defined.  The value the key defines should be the alias</span>
<span class="sd">     used to fetch the comparable attribute from the data.</span>
<span class="sd">    :type aliaes:  python dictionary</span>

<span class="sd">    :param prepend_collection_name:  when True attributes returned in</span>
<span class="sd">      Metadata containers by the find and find_one method will all have the</span>
<span class="sd">      collection name prepended with a (fixed) separator.  For example, if</span>
<span class="sd">      the collection name is &quot;channel&quot; the &quot;lat&quot; attribute in the channel</span>
<span class="sd">      document would be returned as &quot;channel_lat&quot;.</span>
<span class="sd">    :type prepend_collection_name:  boolean</span>

<span class="sd">    :param require_unique_match:  boolean handling of ambiguous matches.</span>
<span class="sd">      When True find_one will throw an error if an entry is tries to match</span>
<span class="sd">      is not unique.  When False find_one returns the first document</span>
<span class="sd">      found and logs a complaint message.  (default is False)</span>
<span class="sd">    :type require_unique_match:  boolean</span>

<span class="sd">    :param ensemble_starttime_key:  defines the key used to fetch a</span>
<span class="sd">     start time for the interval test when processing with ensemble data.</span>
<span class="sd">     Default is &quot;starttime&quot;.</span>
<span class="sd">    :type ensemble_starttime_key:  string</span>

<span class="sd">    :param ensemble_endtime_key:  defines the key used to fetch a</span>
<span class="sd">     end time for the interval test when processing with ensemble data.</span>
<span class="sd">     Default is &quot;endtime&quot;.</span>
<span class="sd">    :type ensemble_endtime_key:  string</span>

<span class="sd">    :param query:   optional query predicate.  That is, if set the</span>
<span class="sd">      interval query is appended to this query to build a more specific</span>
<span class="sd">      query.   An example might be station code keys to match a</span>
<span class="sd">      specific pick for a specific station like {&quot;sta&quot;:&quot;AAK&quot;}.</span>
<span class="sd">      Default is None.</span>
<span class="sd">    :type query:  python dictionary or None.  None is equivalewnt to</span>
<span class="sd">      passing an empty dictionary.  A TypeError will be thrown if this</span>
<span class="sd">      argument is not None or a dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db_or_df</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;arrival&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;phase&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">],</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">require_unique_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ensemble_starttime_key</span><span class="o">=</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span>
        <span class="n">ensemble_endtime_key</span><span class="o">=</span><span class="s2">&quot;endtime&quot;</span><span class="p">,</span>
        <span class="n">arrival_time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">custom_null_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db_or_df</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="o">=</span><span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">aliases</span><span class="o">=</span><span class="n">aliases</span><span class="p">,</span>
            <span class="n">require_unique_match</span><span class="o">=</span><span class="n">require_unique_match</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">custom_null_values</span><span class="o">=</span><span class="n">custom_null_values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># maybe a bit confusing to shorten the names here but the</span>
        <span class="c1"># argument names are a bit much</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starttime_key</span> <span class="o">=</span> <span class="n">ensemble_starttime_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endtime_key</span> <span class="o">=</span> <span class="n">ensemble_endtime_key</span>
        <span class="k">if</span> <span class="n">arrival_time_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrival_time_key</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_time&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrival_time_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrival_time_key</span> <span class="o">=</span> <span class="n">arrival_time_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;ArrivalDBMatcher constructor: arrival_time_key argument must define a string&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ArrivalMatcher.subset"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ArrivalMatcher.subset">[docs]</a>    <span class="k">def</span> <span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mspass_object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete implementation of method required by superclass</span>
<span class="sd">        DataFramematcher</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_input_is_atomic</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">):</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">t0</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">starttime_key</span>
                    <span class="p">)</span> <span class="ow">and</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endtimekey</span><span class="p">):</span>
                        <span class="n">stime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">starttime_key</span><span class="p">]</span>
                        <span class="n">etime</span> <span class="o">=</span> <span class="n">mspass_object</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endtime_key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="n">sta</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dfret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span>
                        <span class="p">(</span><span class="s2">&quot;sta&quot;</span> <span class="o">==</span> <span class="n">sta</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_time_key</span> <span class="o">&gt;=</span> <span class="n">stime</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrival_time_key</span> <span class="o">&lt;=</span> <span class="n">etime</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dfret</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">net</span> <span class="o">=</span> <span class="n">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">net</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">dfret</span> <span class="o">=</span> <span class="n">dfret</span><span class="p">[</span><span class="s2">&quot;net&quot;</span> <span class="o">==</span> <span class="n">net</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">dfret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.normalize">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic function to do in line normalization with dask/spark map operator.</span>

<span class="sd">    In MsPASS we use the normalized data model for receiver and source</span>
<span class="sd">    metadata.  The normalization can be done during any reads if the</span>
<span class="sd">    data have cross-referencing ids defined as described in the User&#39;s Manual.</span>
<span class="sd">    This function provides a generic interface to link to a normalizing</span>
<span class="sd">    collection within a workflow using a map operator applied to a dask</span>
<span class="sd">    bag or spark rdd containing a dataset of MsPASS data objects.</span>
<span class="sd">    The algorithm is made generic through the matcher argument that must</span>
<span class="sd">    point a concrete implementation of the abstract base class</span>
<span class="sd">    defined in this module as BasicMatcher.</span>

<span class="sd">    For example, suppose we create a concrete implementation of the</span>
<span class="sd">    MiniseedMatcher using all defaults from a database handle db as</span>
<span class="sd">    follows:</span>
<span class="sd">        matcher = MiniseedMatcher()</span>
<span class="sd">    Suppose we then load data from wf_miniseed with read_distributed_data</span>
<span class="sd">    into the dask bag we will call dataset.  We can normalize</span>
<span class="sd">    that data within a workflow as follows:</span>
<span class="sd">        dataset = dataset.map(normalize,matcher)</span>

<span class="sd">    :param mspass_object:  data to be normalized</span>
<span class="sd">    :type mspass_object:  For all mspass matchers this</span>
<span class="sd">      must be one of the mspass data types of TimeSeries, Seismogram,</span>
<span class="sd">      TimeSeriesEnsemble, or SeismogramEnsemble.  Many matchers have</span>
<span class="sd">      further restrictions.  e.g. the normal use of the MiniseedMatcher</span>
<span class="sd">      using the defaults like the example insists the data received are</span>
<span class="sd">      either TimeSeries or Seismogram objects.   Read the docstring</span>
<span class="sd">      carefully for your matcher choice for any limitations.</span>

<span class="sd">    :param matcher:  a generic matching function that is a subclass of</span>
<span class="sd">      BasicMatcher.   This function only calls the find_one method.</span>
<span class="sd">    :type matcher:  must be a concrete subclass of BasicMatcher</span>

<span class="sd">    :param kill_on_failure:  when True if the call to the find_one</span>
<span class="sd">    method of matcher fails the datum returned will be marked dead.</span>
<span class="sd">    :type kill_on_failure:  boolean</span>

<span class="sd">    :return:  copy of mspass_object.  dead data are returned immediately.</span>
<span class="sd">    if kill_on_failure is true the result may be killed on return.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mspass_object</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">mspass_object</span>
    <span class="n">find_output</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">mspass_object</span><span class="p">)</span>
    <span class="c1"># api of BasicMatcher specified a pair return we handle here</span>
    <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># this could be done with operator+= in C++ with appropriate</span>
        <span class="c1"># casting but I think this is the only solution here</span>
        <span class="c1"># we are just copying the return Metadata contents to the data</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">mspass_object</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>

    <span class="c1"># append any error log returns to the data elog</span>
    <span class="c1"># operator += is bound to python by pybind11 so this works</span>
    <span class="k">if</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mspass_object</span><span class="o">.</span><span class="n">elog</span> <span class="o">+=</span> <span class="n">find_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mspass_object</span></div>


<div class="viewcode-block" id="bulk_normalize"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.bulk_normalize">[docs]</a><span class="k">def</span> <span class="nf">bulk_normalize</span><span class="p">(</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wf_col</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="n">blocksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">matcher_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function iterates through the collection specified by db and wf_col,</span>
<span class="sd">    and runs a chain of normalization funtions in serial on each document</span>
<span class="sd">    defined by the cursor returned by wfquery.  It speeds updates by</span>
<span class="sd">    using the bulk methods of MongoDB.  The chain also speeds updates</span>
<span class="sd">    as the all matchers in matcher_list append to the update string</span>
<span class="sd">    for the same wf_col document.   A typical example would be to</span>
<span class="sd">    run this function on wf_miniseed data running a matcher to set</span>
<span class="sd">    channel_id, site_id, and source_id.</span>

<span class="sd">    :param db: should be a MsPASS database handle containing the wf_col</span>
<span class="sd">    and the collections defined by the matcher_list list.</span>
<span class="sd">    :param wf_col: The collection that need to be normalized, default is</span>
<span class="sd">    wf_miniseed</span>
<span class="sd">    :param blockssize:   To speed up updates this function uses the</span>
<span class="sd">    bulk writer/updater methods of MongoDB that can be orders of</span>
<span class="sd">    magnitude faster than one-at-a-time updates. A user should not normally</span>
<span class="sd">    need to alter this parameter.</span>
<span class="sd">    :param wfquery: is an optional query to apply to wf_col.  The output of this</span>
<span class="sd">    query defines the list of documents that the algorithm will attempt</span>
<span class="sd">    to normalize as described above.  The default (None) will process the entire</span>
<span class="sd">    collection (query set to an emtpy dict).</span>
<span class="sd">    :param matcher_list: a list of instances of one or more subclasses of BasicMather.</span>
<span class="sd">      In addition to the required classes all instances passed to through</span>
<span class="sd">      this interface must contain two required attributes:  (1) collection</span>
<span class="sd">      which defines the collection name, and (2) prepend_collection_name is</span>
<span class="sd">      a boolean that determines if the attributes loaded should have</span>
<span class="sd">      the collection name prepended (e.g. channel_id).  In addition,</span>
<span class="sd">      all instances must define the find_doc method which is not required</span>
<span class="sd">      by the BasicMatcher interface.   (find_doc is comparable to find_one</span>
<span class="sd">      but uses a python dictionary as the container instead of referencing</span>
<span class="sd">      a mspass data object.  find_one is the core method for inline normalization)</span>



<span class="sd">    :return: a list with a length of len(matcher_list)+1.  0 is the number of documents</span>
<span class="sd">    processed in the collection (output of query), The rest are the numbers of</span>
<span class="sd">    success normalizations for the corresponding NMF instances, they are mapped</span>
<span class="sd">    one on one (matcher_list[x] -&gt; ret[x+1]).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">matcher_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#   The default value for matcher_list is for wf_miniseed with channel</span>
        <span class="c1"># Assume the defaults are sufficient but we limit the required</span>
        <span class="c1"># attribute list to save memory</span>
        <span class="n">channel_matcher</span> <span class="o">=</span> <span class="n">MiniseedMatcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span> <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">matcher_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_matcher</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="n">matcher_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="n">BasicMatcher</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;bulk_normalize: the component in the matcher list=</span><span class="si">{}</span><span class="s2"> is not a subclass of BasicMatcher&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># check that matcher has the find_doc method  implemented - it is</span>
        <span class="c1"># not defined in the BasicMatcher interface and is required</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="s2">&quot;find_doc&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="s2">&quot;find_doc&quot;</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;matcher_list contains class=</span><span class="si">{classname}</span><span class="s2"> that does not have an implementation of the find_doc method required by this function - try using it in a map operator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">classname</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;bulk_normalize:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
        <span class="c1"># these two attributes are also required and best checked here</span>
        <span class="c1"># for a minor cost</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="s2">&quot;prepend_collection_name&quot;</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;matcher list class=</span><span class="si">{classname}</span><span class="s2"> does not define required attribute prepend_collection_name - trying using it in a map operator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">classname</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;bulk_normalize:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="s2">&quot;collection&quot;</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;matcher list class=</span><span class="si">{classname}</span><span class="s2"> does not define required attribute collection - trying using it in a map operator&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">classname</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="s2">&quot;bulk_normalize:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">)</span>
    <span class="n">ndocs</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndocs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
            <span class="s2">&quot;bulk_normalize: &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;query=</span><span class="si">{wfquery}</span><span class="s2"> of collection=</span><span class="si">{wf_col}</span><span class="s2"> yielded 0 documents</span><span class="se">\n</span><span class="s2">Nothing to process&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">wfquery</span><span class="o">=</span><span class="n">wfquery</span><span class="p">,</span> <span class="n">wf_col</span><span class="o">=</span><span class="n">wf_col</span>
            <span class="p">),</span>
            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># this incantation initializes cnt_list as a list with number of</span>
    <span class="c1"># components set as the size of matcher_list and initialized to 0</span>
    <span class="n">cnt_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">matcher_list</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">cursor</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
    <span class="n">bulk</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
        <span class="n">wf_id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="n">need_update</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">update_doc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matcher_list</span><span class="p">):</span>
            <span class="n">norm_doc</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">find_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># not this silently ignores failures</span>
                <span class="c1"># may want this to count failures for each matcher</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">matcher</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">:</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">if</span> <span class="n">matcher</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                        <span class="n">new_key</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_key</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
                <span class="n">update_doc</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_doc</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span>

            <span class="n">cnt_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">need_update</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">need_update</span><span class="p">:</span>
            <span class="n">bulk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pymongo</span><span class="o">.</span><span class="n">UpdateOne</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wf_id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_doc</span><span class="p">}))</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Tests for counter and len(bulk) are needed because the logic here</span>
        <span class="c1"># allows this block to be entered the first pass and if the pass</span>
        <span class="c1"># after the previous call to bulk_write did not yield a match</span>
        <span class="c1"># either will cause bulk_write to throw an error when it gets an</span>
        <span class="c1"># an empty list.   Should consider a logic  change here</span>
        <span class="c1"># to make this less obscure</span>
        <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">blocksize</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">bulk_write</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
            <span class="n">bulk</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">blocksize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">bulk_write</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">ndocs</span><span class="p">]</span> <span class="o">+</span> <span class="n">cnt_list</span></div>


<div class="viewcode-block" id="normalize_mseed"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.normalize_mseed">[docs]</a><span class="k">def</span> <span class="nf">normalize_mseed</span><span class="p">(</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">blocksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">normalize_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">normalize_site</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In MsPASS the standard support for station information is stored in</span>
<span class="sd">    two collections called &quot;channel&quot; and &quot;site&quot;.   When normalized</span>
<span class="sd">    with channel collection data a miniseed record can be associated with</span>
<span class="sd">    station metadata downloaded by FDSN web services and stored previously</span>
<span class="sd">    with MsPASS database methods.   The default behavior tries to associate</span>
<span class="sd">    each wf_miniseed document with an entry in &quot;site&quot;.  In MsPASS site is a</span>
<span class="sd">    smaller collection intended for use only with data already assembled</span>
<span class="sd">    into three component bundles we call Seismogram objects.</span>


<span class="sd">    For both channel and site the association algorithm used assumes</span>
<span class="sd">    the SEED convention wherein the strings stored with the keys</span>
<span class="sd">    &quot;net&quot;,&quot;sta&quot;,&quot;chan&quot;, and (optionally) &quot;loc&quot; define a unique channel</span>
<span class="sd">    of data registered globally through the FDSN.   The algorithm then</span>
<span class="sd">    need only query for a match of these keys and a time interval</span>
<span class="sd">    match with the start time of the waveform defined by each wf_miniseed</span>
<span class="sd">    document.   The only distinction in the algorithm between site and</span>
<span class="sd">    channel is that &quot;chan&quot; is not used in site since by definition site</span>
<span class="sd">    data refer to common attributes of one seismic observatory (commonly</span>
<span class="sd">    also called a &quot;station&quot;).</span>

<span class="sd">    :param db: should be a MsPASS database handle containing at least</span>
<span class="sd">    wf_miniseed and the collections defined by the norm_collection list.</span>
<span class="sd">    :param blockssize:   To speed up updates this function uses the</span>
<span class="sd">    bulk writer/updater methods of MongoDB that can be orders of</span>
<span class="sd">    magnitude faster than one-at-a-time updates for setting</span>
<span class="sd">    channel_id and site_id.  A user should not normally need to alter this</span>
<span class="sd">    parameter.</span>
<span class="sd">    :param wfquery: is a query to apply to wf_miniseed.  The output of this</span>
<span class="sd">    query defines the list of documents that the algorithm will attempt</span>
<span class="sd">    to normalize as described above.  The default will process the entire</span>
<span class="sd">    wf_miniseed collection (query set to an emtpy dict).</span>
<span class="sd">    :param normalize_channel:  boolean for handling channel collection.</span>
<span class="sd">    When True (default) matches will be attempted with the channel collection</span>
<span class="sd">    and when matches are found the associated channel document id will be</span>
<span class="sd">    set in the associated wf_miniseed document as channel_id.</span>
<span class="sd">    :param normalize_site:  boolean for handling site collection.</span>
<span class="sd">    When True (default) matches will be attempted with the site collection</span>
<span class="sd">    and when matches are found the associated site document id will</span>
<span class="sd">    be set wf_miniseed document as site_id. Note at least one of</span>
<span class="sd">    the two booleans normalize_channel and normalize_site must be set True</span>
<span class="sd">    or the function will immediately abort.</span>


<span class="sd">    :return: list with three integers.  0 is the number of documents processed in</span>
<span class="sd">    wf_miniseed (output of query), 1 is the number with channel ids set,</span>
<span class="sd">    and 2 contains the number of site documents set.  1 or 2 should</span>
<span class="sd">    contain 0 if normalization for that collection was set false.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">normalize_channel</span> <span class="ow">or</span> <span class="n">normalize_site</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
            <span class="s2">&quot;normalize_mseed:  usage error.  normalize_channel and normalize_site cannot both be set False&quot;</span><span class="p">,</span>
            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">matcher_function_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># in the calls to the constructors below starttime and endtime</span>
    <span class="c1"># must be included for the miniseed matcher to work</span>
    <span class="k">if</span> <span class="n">normalize_channel</span><span class="p">:</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">MiniseedMatcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">],</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">matcher_function_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
        <span class="n">sitematcher</span> <span class="o">=</span> <span class="n">MiniseedMatcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">],</span>
            <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">matcher_function_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sitematcher</span><span class="p">)</span>

    <span class="n">bulk_ret</span> <span class="o">=</span> <span class="n">bulk_normalize</span><span class="p">(</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">wfquery</span><span class="o">=</span><span class="n">wfquery</span><span class="p">,</span>
        <span class="n">wf_col</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">blocksize</span><span class="o">=</span><span class="n">blocksize</span><span class="p">,</span>
        <span class="n">matcher_list</span><span class="o">=</span><span class="n">matcher_function_list</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">bulk_ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">normalize_channel</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_ret</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_ret</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_ret</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">def</span> <span class="nf">_get_test_time</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function to get the test time used for searching.</span>
<span class="sd">    If the time is given, we simply use that as the test time.</span>
<span class="sd">    Otherwise (the time is None), we first try to get the start</span>
<span class="sd">    time from d. If start time is not defined in d, None is</span>
<span class="sd">    return to indicate the time field should be ignored.</span>
<span class="sd">        :param d: Data object with a Metadata container to extract the field</span>
<span class="sd">        :param time: the start time used for matching</span>
<span class="sd">        :return: the test_time extracted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">):</span>
                <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use None for test_time as a signal to ignore time field</span>
                <span class="n">test_time</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="n">time</span>
    <span class="k">return</span> <span class="n">test_time</span>


<span class="k">def</span> <span class="nf">_get_with_readonly_recovery</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method for repetitious handling of trying to use the</span>
<span class="sd">    readonly tag to recover if one of net, sta, chan, or loc have</span>
<span class="sd">    been botched with readonly tag.  d is the datum from with key is</span>
<span class="sd">    to be extracted.   Returns a None if recovery failed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ROTAG</span> <span class="o">=</span> <span class="s2">&quot;READONLY_&quot;</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">testkey</span> <span class="o">=</span> <span class="n">ROTAG</span> <span class="o">+</span> <span class="n">key</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">testkey</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">testkey</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_input_is_valid</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This internal function standardizes the test to certify the</span>
<span class="sd">    input datum, d, is or is not a valid MsPASS data object.   Putting it</span>
<span class="sd">    in one place makes extending the code base for other data types much</span>
<span class="sd">    easier.  It uses an isinstance tests of d to standardize the test that</span>
<span class="sd">    the input is valid data.  It returns True if d is one a valid data</span>
<span class="sd">    object known to mspass.  Returns false it not.  Caller must decide</span>
<span class="sd">    what to do if the function returns false.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_input_is_atomic</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A variant of input_is_valid is to test if a data object is atomic</span>
<span class="sd">    by the mspass definition.  In this case, that means a datum is not</span>
<span class="sd">    an ensemble.  This is necessary, for example, to assume something</span>
<span class="sd">    like asking for d.t0 doesn&#39;t generate an exception.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_load_as_df</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">attributes_to_load</span><span class="p">,</span> <span class="n">load_if_defined</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal helper function used to translate all or part of a</span>
<span class="sd">    collection to a DataFrame.  This algorithm should only be used</span>
<span class="sd">    for small collections as it makes an intermediate copy of the</span>
<span class="sd">    collection as a dictionary before calling the DataFrame.from_dict</span>
<span class="sd">    method to create the working dataframe.</span>

<span class="sd">    :param db:  Database handle assumed to contain collection</span>
<span class="sd">    :param collection:  collection from which the data are to be extracted</span>
<span class="sd">    :param query:  python dict defining a query to apply to the collection.</span>
<span class="sd">      If you want the entire collection specify None or an empty dictionary.</span>
<span class="sd">    :type query:  python dict defining a pymongo query or None.</span>
<span class="sd">    :param attributes_to_load: list of keys to extract of required attributes</span>
<span class="sd">    to load from collection.   This function will abort if any document</span>
<span class="sd">    does not contain one of these attributes.</span>
<span class="sd">    :param load_if_defined:  attributes loaded more cautiously.  If the</span>
<span class="sd">    attributes for any of the keys in this list are not found in a document</span>
<span class="sd">    the output dataframe has a Null defined for that cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">ntuples</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ntuples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="c1"># create dictionary with empty array values to initialize</span>
    <span class="n">dict_tmp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attributes_to_load</span><span class="p">:</span>
        <span class="n">dict_tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">load_if_defined</span><span class="p">:</span>
        <span class="n">dict_tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
        <span class="c1"># attributes_to_load list are required.  For now let this</span>
        <span class="c1"># thow an exception if that is not true - may need a handler</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attributes_to_load</span><span class="p">:</span>
            <span class="n">dict_tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">load_if_defined</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">dict_tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dict_tmp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_extractData2Metadata</span><span class="p">(</span>
    <span class="n">doc</span><span class="p">,</span>
    <span class="n">attributes_to_load</span><span class="p">,</span>
    <span class="n">aliases</span><span class="p">,</span>
    <span class="n">prepend_collection_name</span><span class="p">,</span>
    <span class="n">collection</span><span class="p">,</span>
    <span class="n">load_if_defined</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">md</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attributes_to_load</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">aliases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">prepend_collection_name</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                    <span class="n">mdkey</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mdkey</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mdkey</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">md</span><span class="p">[</span><span class="n">mdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Required attribute </span><span class="si">{key}</span><span class="s2"> was not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">key</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;DictionaryCacheMatcher._load_normalization_cache:  &quot;</span> <span class="o">+</span> <span class="n">message</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">load_if_defined</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">aliases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">prepend_collection_name</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                    <span class="n">mdkey</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mdkey</span> <span class="o">=</span> <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mdkey</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">md</span><span class="p">[</span><span class="n">mdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">md</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020-2021, Ian Wang.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>