<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.db.normalize &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_on_HPC.html">Deploy MsPASS on HPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started_overview.html">MsPASS Setup In-Depth Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../../../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>mspasspy.db.normalize</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mspasspy.db.normalize</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.utility</span> <span class="kn">import</span> <span class="n">MsPASSError</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="p">,</span> <span class="n">Metadata</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.seismic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">Seismogram</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span>
<span class="kn">import</span> <span class="nn">pymongo</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">copy</span>


<span class="k">def</span> <span class="nf">_input_is_valid</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This internal function standardizes the test to certify the</span>
<span class="sd">    input datum, d, is or is not a valid MsPASS data object.   Putting it</span>
<span class="sd">    in one place makes extending the code base for other data types much</span>
<span class="sd">    easier.  It uses an isinstance tests of d to standardize the test that</span>
<span class="sd">    the input is valid data.  It returns True if d is one a valid data</span>
<span class="sd">    object known to mspass.  Returns false it not.  Caller must decide</span>
<span class="sd">    what to do if the function returns false.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)</span>
    <span class="p">)</span>


<span class="c1"># We need this for matchers that only work for atomic data (e.g. mseed matching)</span>
<span class="k">def</span> <span class="nf">_input_is_atomic</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">))</span>


<div class="viewcode-block" id="NMF"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.NMF">[docs]</a><span class="k">class</span> <span class="nc">NMF</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for a family of Normalization Match Functions (NMF).</span>
<span class="sd">    This family of object are used in MsPASS to standize the api for</span>
<span class="sd">    generic mongodb match operation for &quot;normalizing&quot; a collection.</span>
<span class="sd">    Normalization is comparable to a relational database join.</span>
<span class="sd">    With MongoDB normalization is most sensible for the case when the</span>
<span class="sd">    collection to be normalized is much smaller than collection that is</span>
<span class="sd">    to be joined (normalized)  i.e. the normalization operation is many</span>
<span class="sd">    to one with many links from the documents in the collection to be</span>
<span class="sd">    normalized to each normalizing document.  The stock normalizing collections</span>
<span class="sd">    in MsPASS are channel, site, and source.</span>

<span class="sd">    The api defines two basic operations any concrete instance of the</span>
<span class="sd">    class must implement:  (1)  a method to fetch the entire document</span>
<span class="sd">    defining a match and (2) a method to fetch and copy specified</span>
<span class="sd">    key-value pairs to a valid MsPASS data object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base class constructor. The implementation requires defaulted parameters</span>
<span class="sd">        that most subclasses can find useful.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:  string defining the collection this object</span>
<span class="sd">          should use for normalization. If this argument is not a valid</span>
<span class="sd">          string the constructor will abort with a TypeError exception.</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method. Default is None here,</span>
<span class="sd">          subclass should set their own default values.</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None here,</span>
<span class="sd">          subclass should set their own default values.</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.  If your data set is time limited and</span>
<span class="sd">          the collection has a time attribute (true of the standard channel,</span>
<span class="sd">          site, and source collections) you can reduce the memory footprint</span>
<span class="sd">          by using a time range query (python dict) for this argument.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.   When True (default)   all normalizing data</span>
<span class="sd">          keys get a collection name prepended to the key to give it a</span>
<span class="sd">          unique key.  e.g. if loading data from &quot;channel&quot; the &quot;lat&quot;</span>
<span class="sd">          (latitude of the instrument&#39;s location) field will be changed on</span>
<span class="sd">           posting to d to &quot;channel_lat&quot;.   Setting this false should be</span>
<span class="sd">           a rare or never used option and should be done only if you deeply</span>
<span class="sd">           understand the consequences.</span>
<span class="sd">        :param kill_on_failure:  when set true (Default) match errors</span>
<span class="sd">          will cause data passed to the normalize method to be killed.</span>
<span class="sd">        :param verbose:  most subclasses will want a verbose option</span>
<span class="sd">          to control what is posted to elog messages or printed</span>
<span class="sd">          (most useful for serial jobs)</span>
<span class="sd">        :param cache_normalization_data:  When set True the specified</span>
<span class="sd">          collection is preloaded in an internal cache on construction and</span>
<span class="sd">          used for all subsequent matching.  This mode is highly recommended</span>
<span class="sd">          as it has been found to speed normalization by an order of magnitude</span>
<span class="sd">          or more relative to a database transaction for each call to normalize,</span>
<span class="sd">          which is what happens when this parameter is set False. Subclasses might</span>
<span class="sd">          not support the caching feature, so the default value is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> constructor:  arg0 must be a collection name - received invalid type&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="n">collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">collection</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span> <span class="o">=</span> <span class="n">prepend_collection_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kill_on_failure</span> <span class="o">=</span> <span class="n">kill_on_failure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># These two lists are always needed for normalize methods.</span>
        <span class="c1"># Subclasses need to specify the default value in their</span>
        <span class="c1"># own init methods before calling super.init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">=</span> <span class="n">attributes_to_load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span> <span class="o">=</span> <span class="n">load_if_defined</span>

        <span class="c1"># Derived classes need to specify the cache_normalization_data, some of them</span>
        <span class="c1"># might don&#39;t have a caching feature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_normalization_data</span> <span class="o">=</span> <span class="n">cache_normalization_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_normalization_data</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_normalization_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This convenience method allows a concrete instance to be</span>
<span class="sd">        called with the simpler syntax with the (implied) principle</span>
<span class="sd">        method &quot;normalize&quot;.   e.g. to normalize d with the</span>
<span class="sd">        channel collection using id_matcher you can use</span>
<span class="sd">        d = id_matcher(d)  instead of d = id_matcher.normalize(d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="NMF.get_document"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.NMF.get_document">[docs]</a>    <span class="k">def</span> <span class="nf">get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a method to fetch the document that matches. The</span>
<span class="sd">        document, in this case, is actually a MsPASS Metadata container.</span>
<span class="sd">        Only attributes defined by the attribute_to_load and load_if_defined</span>
<span class="sd">        lists will be returned in the result.</span>
<span class="sd">        This method works as an entry to two different implementations:</span>
<span class="sd">        1. If caching was enabled, _cached_get_document will be invoked, and</span>
<span class="sd">        data will be returned from the internal cache.</span>
<span class="sd">        2. If caching was turned off, _db_get_document will be invoked, a db</span>
<span class="sd">        query will then be invoked for each call to this method.</span>
<span class="sd">        The subclasses can call this method and extend it with extra arguments</span>
<span class="sd">        (*args, **kwargs), a typical extra argument is time (see composite_key_matcher)</span>
<span class="sd">        Any failures will cause d to be marked dead if kill_on_failure</span>
<span class="sd">        was set in the constructor (the default).</span>

<span class="sd">        :param d:  Data object with a Metadata container to be tested.</span>
<span class="sd">        That means this can be any valid MsPASS data object or even</span>
<span class="sd">        a raw Metadata container.  Only the class defined id key is</span>
<span class="sd">        accessed by d.  That id drives the algorithm as described above.</span>
<span class="sd">        :return:  Metadata container with the matching data. Returns None</span>
<span class="sd">        if there is not match AND posts a message to elog of d.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache_normalization_data</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_normalization_data</span> <span class="o">==</span> <span class="kc">False</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_db_get_document</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_get_document</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_cached_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method looks for the qualified document in the cache constructed</span>
<span class="sd">        before. Subclasses are required to implement this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method looks for the qualified document by sending a new query to</span>
<span class="sd">        the database. Subclasses are required to implement this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_load_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper function that takes a dict input, and return a Metadata</span>
<span class="sd">        that only loads attribues defined in attribute_to_load and load_if_defined.</span>
<span class="sd">        An optional mspass object d can be useful to log the error.  The default is None,</span>
<span class="sd">        meaning that there is no data object related with the document to load, so a</span>
<span class="sd">        MsPassError will be raised when an error occurs.</span>
<span class="sd">        If d is not None, meaning one single data object d is related, a error message will</span>
<span class="sd">        be stored to the elog of d.</span>

<span class="sd">        :param doc:  A dict object from the mongodb</span>
<span class="sd">        :param d: The MsPass data object that invokes this method, default is None, meaning</span>
<span class="sd">        that no data object is related.</span>
<span class="sd">        :return: Metadata container with the matching data. Return None if some keys in</span>
<span class="sd">        attribues_to_load are not defined in the doc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#   d is not given when used in caching method</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Required key=</span><span class="si">{}</span><span class="s2"> not found in normalization collection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span>
                    <span class="n">d</span>
                <span class="p">):</span>  <span class="c1">#   Don&#39;t have an object to save error log</span>
                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_load_normalization_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a function internal to the matcher module used to standardize</span>
<span class="sd">        the loading of normalization data from MongoDB. It returns a python</span>
<span class="sd">        dict with keys defined by the string representation of each document</span>
<span class="sd">        found in the normalizing collection.   The value associated with each</span>
<span class="sd">        key is a Metadata container of a (usually) reduced set of data that</span>
<span class="sd">        is to be merged with the Metadata of a set of mspass data objects</span>
<span class="sd">        to produce the &quot;normalization&quot;.</span>
<span class="sd">        This method use the db[collection] in the class to define the</span>
<span class="sd">        database collection to be indexed to the cache.</span>
<span class="sd">        self.required_attributes is used to indicate list of keys for attributes</span>
<span class="sd">        the function will dogmatically try to extract from each document. If any</span>
<span class="sd">        of these are missing in any document the function will abort with a</span>
<span class="sd">        MsPASSError exception (throwed in _load_doc)</span>
<span class="sd">        self.optional_attributes is used to indicate list of keys, which are</span>
<span class="sd">        are silently ignored if they are missing.</span>
<span class="sd">        self.query is applied before loading the normalizing collection defined by</span>
<span class="sd">        the collection argument.  By default the entire collection is loaded and</span>
<span class="sd">        returned. This can be useful with large collection to reduce memory bloat.</span>
<span class="sd">        e.g. if you have a large collection of channel data but your data set only</span>
<span class="sd">        spans a 1 year period you might set a query to only load data for stations</span>
<span class="sd">        running during that time period.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="n">normcache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="n">mdresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span>  <span class="c1"># always defined for a MongoDB doc</span>
            <span class="n">normcache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdresult</span>
        <span class="k">return</span> <span class="n">normcache</span>

<div class="viewcode-block" id="NMF.normalize"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.NMF.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a method to fetch and copy specified key-value pairs to a valid</span>
<span class="sd">        MsPASS data object.</span>
<span class="sd">        This method first tests if the input is a valid MsPASS data object.  It will</span>
<span class="sd">        silently do nothing if the data are not valid returning a None.</span>
<span class="sd">        It then tests if the datum is marked live. If it is found marked</span>
<span class="sd">        dead it silently returns d with no changes. For live data it calls the get_document</span>
<span class="sd">        method. If that succeeds it extracts the (constructor defined) list of</span>
<span class="sd">        desired attributes and posts them to the data&#39;s Metadata container.</span>
<span class="sd">        If get_document fails a message is posted to elog and if the</span>
<span class="sd">        constructor defined &quot;kill_on_failure&quot; parameter is set True the</span>
<span class="sd">        returned datum will be killed.</span>
<span class="sd">        Note that for most of the subclasses, the functionalities of normalize are</span>
<span class="sd">        the same. So in most cases, we don&#39;t need to override this method.</span>

<span class="sd">        :param d:  data to be normalized.  This must be a MsPASS data object.</span>
<span class="sd">          For this function that means TimeSeries, Seismogram, TimeSeriesEnsemble,</span>
<span class="sd">          or SeismogramEnsemble.  Not for ensembles the normalizing data will</span>
<span class="sd">          be posted to the ensemble metadata container not the members.</span>
<span class="sd">          This can be used, for example, to normalize a parallel container</span>
<span class="sd">          (rdd or bad) of common source gathers more efficiently than</span>
<span class="sd">          at the atomic level.</span>
<span class="sd">        :return: The normalized document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ID_matcher.normalize:  received invalid data type&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_document</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No matching _id found for in collection=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this implementation the contents of doc have been prefiltered</span>
            <span class="c1"># to contain only those in the attributes_to_load or load_if_defined lists</span>
            <span class="c1"># Hence we copy all.</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                    <span class="c1"># Handle &quot;_id&quot; specially or we get double _ for</span>
                    <span class="c1"># common constructs like channel_id</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                        <span class="n">newkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="n">key</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newkey</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">newkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="NMF.log_error"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.NMF.log_error">[docs]</a>    <span class="k">def</span> <span class="nf">log_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">severity</span><span class="o">=</span><span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Informational</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This base class method is used to standardize the error logging</span>
<span class="sd">        functionality of all NMF objects.   It writes a standardized</span>
<span class="sd">        message to simplify writing of subclasses - they only need to</span>
<span class="sd">        format a specific message to be posted.  The caller may optionally</span>
<span class="sd">        kill the datum and specify an alternative severity level to</span>
<span class="sd">        the default warning.</span>

<span class="sd">        Note most subclasses may want to include a verbose option in the constructor</span>
<span class="sd">        (or the reciprocal silent) that provide an option of only writing log messages when</span>
<span class="sd">        verbose is set true. There are possible cases with large data sets where</span>
<span class="sd">        verbose messages can cause bottlenecks and bloated elog collections. If verbose is</span>
<span class="sd">        set true, the datum will still be killed, but the message won&#39;t be written.</span>

<span class="sd">        :param d:  MsPASS data object to which elog message is to be</span>
<span class="sd">          written.</span>
<span class="sd">        :param message:  specialized message to post - this string is added</span>
<span class="sd">        to an internal generic message.</span>
<span class="sd">        :param severity:  ErrorSeverity to assign to elog message</span>
<span class="sd">        (See ErrorLogger docstring).  Default is Informational</span>
<span class="sd">        :param kill:  boolean controlling if the message should cause the</span>
<span class="sd">        datum to be killed. Default None meaning the kill_on_failure boolean of</span>
<span class="sd">        the class will be used. If kill is set, it will be overwritten temporarily.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_valid</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="c1">#   If we can&#39;t log error to the object, simply return</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">kill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill_on_failure</span>

        <span class="k">if</span> <span class="n">kill</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Datum was killed&quot;</span>

        <span class="c1">#   Add class name and caller function name for better locating the error</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">curframe</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="n">calframe</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getouterframes</span><span class="p">(</span><span class="n">curframe</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">caller_name</span> <span class="o">=</span> <span class="n">calframe</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">matchername</span> <span class="o">=</span> <span class="n">class_name</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">caller_name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;verbose&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">matchername</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">severity</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="single_key_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.single_key_matcher">[docs]</a><span class="k">class</span> <span class="nc">single_key_matcher</span><span class="p">(</span><span class="n">NMF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An intermediate class. It extends the NMF by adding a variable: mdkey.</span>
<span class="sd">    mdkey is the field defined for matching a document.</span>
<span class="sd">    The matching logic is as follows:</span>
<span class="sd">        d[mdkey] == DOC_TO_MATCH[&#39;_id&#39;]</span>
<span class="sd">    This class is useful for implementing the ID_matcher (see below). Users</span>
<span class="sd">    may also find it useful for implementing other match classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">mdkey</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The constructor method for this class, basically it calls the</span>
<span class="sd">        constructor of the base class (NMF), and set the mdkey.</span>
<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:  string defining the collection this object</span>
<span class="sd">          should use for normalization.</span>
<span class="sd">        :param mdkey: the field for matching, see class description</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method. Default is None here,</span>
<span class="sd">          subclass should set their own default values.</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None here,</span>
<span class="sd">          subclass should set their own default values.</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.   When True (default)   all normalizing data</span>
<span class="sd">          keys get a collection name prepended to the key to give it a</span>
<span class="sd">          unique key.</span>
<span class="sd">        :param kill_on_failure:  when set true (Default) match errors</span>
<span class="sd">          will cause data passed to the normalize method to be killed.</span>
<span class="sd">        :param verbose:  most subclasses will want a verbose option</span>
<span class="sd">          to control what is posted to elog messages or printed</span>
<span class="sd">          (most useful for serial jobs)</span>
<span class="sd">        :param cache_normalization_data:  When set True the specified</span>
<span class="sd">          collection is preloaded in an internal cache on construction and</span>
<span class="sd">          used for all subsequent matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NMF</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdkey</span> <span class="o">=</span> <span class="n">mdkey</span>

    <span class="k">def</span> <span class="nf">_get_key_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function to get the value of corresponding mdkey of the</span>
<span class="sd">        matcher. If the mdkey is not defined, an error will be stored to the</span>
<span class="sd">        elog.</span>
<span class="sd">        :param d: A MsPass Object</span>
<span class="sd">        :return: None if the mdkey is not defined, otherwise just return the</span>
<span class="sd">        value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdkey</span><span class="p">):</span>
            <span class="n">testid</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mdkey</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Normalizing ID with key=</span><span class="si">{}</span><span class="s2"> is not defined in this object&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mdkey</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">testid</span>

    <span class="k">def</span> <span class="nf">_cached_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">testid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key_id</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">testid</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Key [</span><span class="si">{}</span><span class="s2">] not defined in cache&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">testid</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

        <span class="n">testid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key_id</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">query</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">testid</span>

        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Key [</span><span class="si">{}</span><span class="s2">] not defined in normalization collection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">testid</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="ID_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.ID_matcher">[docs]</a><span class="k">class</span> <span class="nc">ID_matcher</span><span class="p">(</span><span class="n">single_key_matcher</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to match a data object to a normalizing collection</span>
<span class="sd">    using a MongoDB ObjectId and the key naming convention of MsPASS.</span>
<span class="sd">    That is, if the normalizing collection is channel it will look</span>
<span class="sd">    in the data object&#39;s Metadata for an attribute with the key &quot;channel_id&quot;.</span>
<span class="sd">    If that attribute is found it will try to load the document for which</span>
<span class="sd">    the &quot;_id&quot; of that collection == the key constructed (channel_id for the example).</span>

<span class="sd">    By default this class will cache a (usually) reduced image of the</span>
<span class="sd">    normalizing collertion data.  This can improve performance significantly with large</span>
<span class="sd">    data sets at the cost of needing to store and, when the scheduler finds</span>
<span class="sd">    it necessary, to move a copy of the contents to a worker node.  Turn</span>
<span class="sd">    the caching off (set cache_normalization_data False in the constructor)</span>
<span class="sd">    if normalizing collection is large and could cause a memory problem.</span>
<span class="sd">    Note, the size can be computed as the size of the expected return of</span>
<span class="sd">    the (attribute_to_load list + objectid string size)*Ncol where Ncol is</span>
<span class="sd">    the number of documents in the normalizing collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:   string defining the collection this object</span>
<span class="sd">          should use for normalization.   If this argument is not a valid</span>
<span class="sd">          string the constructor will abort with a TypeError exception.</span>
<span class="sd">          Default is &quot;channel&quot;</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method.</span>
<span class="sd">          Note that the Default value is None, but it will then be initialized</span>
<span class="sd">          to a list of common channel attributes:  &quot;lat&quot;, &quot;lon&quot;, &quot;elev&quot;, &quot;hang&quot;,</span>
<span class="sd">          and &quot;vang&quot;. This is necessary because we need to cope with the mutable</span>
<span class="sd">          default argument (see https://stackoverflow.com/questions/1132941/least</span>
<span class="sd">          -astonishment-and-the-mutable-default-argument)</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined.  A type example is the</span>
<span class="sd">          seed &quot;loc&quot; code that isn&#39;t always used.  Default is None (an empty list).</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.</span>
<span class="sd">        :param kill_on_failure:  When True (the default) any data passed</span>
<span class="sd">          processed by the normalize method will be kill if there is no</span>
<span class="sd">          match to the id key requested or if the data lack an id key to</span>
<span class="sd">          do the match.</span>
<span class="sd">        :param verbose: a boolean value to control what is posted to elog messages</span>
<span class="sd">        or printed</span>
<span class="sd">        :param cache_normalization_data:  When set True (the default)</span>
<span class="sd">          the specified collection is preloaded in an internal cache</span>
<span class="sd">          on construction and used for all subsequent matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;elev&quot;</span><span class="p">,</span> <span class="s2">&quot;hang&quot;</span><span class="p">,</span> <span class="s2">&quot;vang&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">single_key_matcher</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">collection</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>

        <span class="n">testid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key_id</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">testid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">testid</span>

        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Key [</span><span class="si">{}</span><span class="s2">] not defined in normalization collection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">testid</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="composite_key_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.composite_key_matcher">[docs]</a><span class="k">class</span> <span class="nc">composite_key_matcher</span><span class="p">(</span><span class="n">NMF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An intermediate class that implements the shared functionalities of</span>
<span class="sd">    mseed_channel_matcher and mseed_site_matcher. Users may also extend this class to</span>
<span class="sd">    define their own matcher.</span>

<span class="sd">    A composite_key_matcher uses a composite key to match the documents, it is created</span>
<span class="sd">    by concatenating all required keys and their values. For example: mseed_channel_matcher&#39;s</span>
<span class="sd">    required keys are [&quot;net&quot;, &quot;sta&quot;, &quot;chan&quot;]. So the composite key will be something like:</span>
<span class="sd">    &quot;cmp_id_net=TA_sta=034A_chan=BHE&quot;. This composite key can identify all the documents</span>
<span class="sd">    that have the same value for [&quot;net&quot;, &quot;sta&quot;, &quot;chan&quot;]. In addition, user can define a list</span>
<span class="sd">    of optional_keys that are not always present in a document. For example, &quot;doc&quot; in</span>
<span class="sd">    the mseed_channel_matcher.</span>

<span class="sd">    It can also be used to normalize data saved in wf_TimeSeries where the mseed tags</span>
<span class="sd">    are often altered by MsPASS to change fields like &quot;net&quot; to &quot;READONLYERROR_net&quot;.</span>
<span class="sd">    There is an automatic fallback for each of the tags where if the proper name is not</span>
<span class="sd">    found we alway try to use the READONLYERROR_ version before giving up.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="n">optional_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">readonly_tag</span><span class="o">=</span><span class="s2">&quot;READONLYERROR_&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class. Most of the arguments are inherited from the base</span>
<span class="sd">        class NMF.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:  string defining the collection this object</span>
<span class="sd">          should use for normalization. If this argument is not a valid</span>
<span class="sd">          string the constructor will abort with a TypeError exception.</span>
<span class="sd">        :param keys: a list of fields that are used to create a composite key,</span>
<span class="sd">        these fields are always cached if caching is enabled</span>
<span class="sd">        :param optional_keys: a list of fields, very similar to keys, the only</span>
<span class="sd">        difference is that optional_keys can be missing in a document.</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method. Default is None here,</span>
<span class="sd">          sublasses should set their own default values.</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None here,</span>
<span class="sd">          subclasses should set their own default values.</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.  If your data set is time limited and</span>
<span class="sd">          the collection has a time attribute (true of the standard channel,</span>
<span class="sd">          site, and source collections) you can reduce the memory footprint</span>
<span class="sd">          by using a time range query (python dict) for this argument.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.   When True (default)   all normalizing data</span>
<span class="sd">          keys get a collection name prepended to the key to give it a</span>
<span class="sd">          unique key.  e.g. if loading data from &quot;channel&quot; the &quot;lat&quot;</span>
<span class="sd">          (latitude of the instrument&#39;s location) field will be changed on</span>
<span class="sd">           posting to d to &quot;channel_lat&quot;.   Setting this false should be</span>
<span class="sd">           a rare or never used option and should be done only if you deeply</span>
<span class="sd">           understand the consequences.</span>
<span class="sd">        :param kill_on_failure:  when set true (Default) match errors</span>
<span class="sd">          will cause data passed to the normalize method to be killed.</span>
<span class="sd">        :param verbose:  most subclasses will want a verbose option</span>
<span class="sd">          to control what is posted to elog messages or printed</span>
<span class="sd">          (most useful for serial jobs)</span>
<span class="sd">        :param cache_normalization_data:  When set True (default) the specified</span>
<span class="sd">          collection is preloaded in an internal cache on construction and</span>
<span class="sd">          used for all subsequent matching.</span>
<span class="sd">        :param readonly_tag:  As noted in the class docstring attributes</span>
<span class="sd">          marked read only in the schema can sometimes be saved with a</span>
<span class="sd">          prefix.  The get_document and normalize methods have an auto</span>
<span class="sd">          recover to look try to match read only parameters.  This</span>
<span class="sd">          argument defines the prefix used to define such attributes.</span>
<span class="sd">          The default is &quot;READONLYERROR_&quot; which is what is used by</span>
<span class="sd">          default in MsPASS.  Few if any users will likely need to</span>
<span class="sd">          ever set this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional_keys</span> <span class="o">=</span> <span class="n">optional_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readonly_tag</span> <span class="o">=</span> <span class="n">readonly_tag</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_readonly_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">error_logging_enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to get some fields from a document and retry by adding</span>
<span class="sd">        a readonly prefix to the field before giving up.</span>
<span class="sd">        :param d: Data object with a Metadata container to extract the field</span>
<span class="sd">        :param field: The name of the field</span>
<span class="sd">        :param error_logging_enabled: a boolean value that indicates whether the error</span>
<span class="sd">        should be logged to the elog. Default is True, user can ignore the error</span>
<span class="sd">        by setting it to False</span>
<span class="sd">        :return: the value of the field in d, if the field is not defined, an error</span>
<span class="sd">        is logged, and None is return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error_logging_allowed</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readonly_tag</span> <span class="o">+</span> <span class="n">field</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">readonly_tag</span> <span class="o">+</span> <span class="n">field</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_logging_allowed</span> <span class="ow">and</span> <span class="n">error_logging_enabled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="s2">&quot;Required match key=</span><span class="si">{key}</span><span class="s2"> or </span><span class="si">{tag}{key}</span><span class="s2"> are not defined for this datum&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">key</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">readonly_tag</span>
                    <span class="p">),</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_create_composite_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a composite key by concatenating the fields in self.keys and</span>
<span class="sd">        their value.</span>
<span class="sd">        A typical composite key is in the following format:</span>
<span class="sd">        &quot;cmp_id_{FIELD1}={VALUE1}__{FIELD2}={VALUE2}_{FIELD3}={VALUE4}...&quot;.</span>
<span class="sd">        :param d: Data object with a Metadata container to extract the field</span>
<span class="sd">        :param separator: Optional, can be used to use a different separator</span>
<span class="sd">        character.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">composite_key</span> <span class="o">=</span> <span class="s2">&quot;cmp_id&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_readonly_field</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">composite_key</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optional_keys</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_readonly_field</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">composite_key</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">composite_key</span>

    <span class="k">def</span> <span class="nf">_load_normalization_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is overriden to add/modify 2 features:</span>
<span class="sd">        (1) Instead of using &quot;_id&quot; field, a composite key is created and</span>
<span class="sd">            used as the index for the document</span>
<span class="sd">        (2) Always caching keys and optional_keys, in order to</span>
<span class="sd">            Make sure (1) can work when attributes_to_load doesn&#39;t</span>
<span class="sd">            contain certain keys needed for a composite key</span>
<span class="sd">        (3) Always caching [&quot;starttime&quot;, &quot;endtime&quot;] because these two</span>
<span class="sd">        fields are essential for the query in get_document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="n">normcache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
            <span class="c1">#   we can&#39;t just simply call _load_result because we need to load</span>
            <span class="c1">#   keys and optional_keys</span>
            <span class="n">mdresult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Required key=</span><span class="si">{}</span><span class="s2"> not found in normalization collection = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mdresult</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optional_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes_to_load</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_defined</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">mdresult</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">composite_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_composite_key</span><span class="p">(</span><span class="n">mdresult</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">composite_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;_build_xref: can&#39;t create composite key for </span><span class="si">{}</span><span class="s2"> because some keys are missing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">mdresult</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">composite_key</span> <span class="ow">in</span> <span class="n">normcache</span><span class="p">:</span>
                <span class="n">normcache</span><span class="p">[</span><span class="n">composite_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mdresult</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">normcache</span><span class="p">[</span><span class="n">composite_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mdresult</span><span class="p">]</span>  <span class="c1"># initializes array of id strings</span>
        <span class="k">return</span> <span class="n">normcache</span>

<div class="viewcode-block" id="composite_key_matcher.get_document"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.composite_key_matcher.get_document">[docs]</a>    <span class="k">def</span> <span class="nf">get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">,</span> <span class="n">Metadata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;mseed_channel_matcher.get_document:  data received as arg0 is not an atomic MsPASS data object&quot;</span>
            <span class="p">)</span>
        <span class="c1"># We need to convert a dict to Metadata to match the api for</span>
        <span class="c1"># data objects.  We need support for dict for interacting</span>
        <span class="c1"># directly with mongodb query results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">d_to_use</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_to_use</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_normalization_data</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_get_document</span><span class="p">(</span><span class="n">d_to_use</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_db_get_document</span><span class="p">(</span><span class="n">d_to_use</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">doc</span></div>

    <span class="k">def</span> <span class="nf">_get_test_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function to get the test time used for searching.</span>
<span class="sd">        If the time is given, we simply use that as the test time.</span>
<span class="sd">        Otherwise (the time is None), we first try to get the start</span>
<span class="sd">        time from d. If start time is not defined in d, None is</span>
<span class="sd">        return to indicate the time field should be ignored.</span>
<span class="sd">        :param d: Data object with a Metadata container to extract the field</span>
<span class="sd">        :param time: the start time used for matching</span>
<span class="sd">        :return: the test_time extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
                <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">):</span>
                    <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Use None for test_time as a signal to ignore time field</span>
                    <span class="n">test_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">return</span> <span class="n">test_time</span>

    <span class="k">def</span> <span class="nf">_cached_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to do the work of the get_document method when channel</span>
<span class="sd">        data have been previously cached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do this test once to avoid repetitious calls later - minimal cost</span>
        <span class="n">error_logging_allowed</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">))</span>

        <span class="n">comp_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_composite_key</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_test_time</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comp_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">doclist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">comp_key</span><span class="p">]</span>
            <span class="c1"># avoid a test and assume this is a match if there is only</span>
            <span class="c1"># one entry in the list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doclist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">doclist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doclist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># When time is not defined (None) just return first entry</span>
                <span class="c1"># but post a warning</span>
                <span class="k">if</span> <span class="n">test_time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># We might never enter this branch, since mspass objects always have a test_time = d.t0</span>
                    <span class="k">if</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Warning - no time specified for match and data has no starttime field defined.  Using first match found in channel collection&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Suspect</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">doclist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">doclist</span><span class="p">:</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">test_time</span> <span class="o">&gt;=</span> <span class="n">stime</span> <span class="ow">and</span> <span class="n">test_time</span> <span class="o">&lt;=</span> <span class="n">etime</span><span class="p">:</span>
                        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1">#   We need to calculate the count of matchs, to decide if we need to log an warning</span>
                        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">doc</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                        <span class="n">d</span><span class="p">,</span>
                        <span class="s2">&quot;Multiple channel docs match net:sta:chan:loc:time for this datum - using first one found&quot;</span><span class="p">,</span>
                        <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                        <span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ret</span>

            <span class="c1"># If there is no qualified doc</span>
            <span class="k">if</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No match for composite key=</span><span class="si">{}</span><span class="s2"> and time=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">comp_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">test_time</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">message</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;No entries are present in channel collection for net_sta_chan_loc = &quot;</span>
                    <span class="o">+</span> <span class="n">comp_key</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">message</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method that does the work of get_document when caching is</span>
<span class="sd">        turned off.   This method does one database transaction per call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do this test once to avoid repetitious calls later - minimal cost</span>
        <span class="n">error_logging_allowed</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">))</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_readonly_field</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_readonly_field</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">query</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="n">querytime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_test_time</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">querytime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$lt&quot;</span><span class="p">:</span> <span class="n">querytime</span><span class="p">}</span>
            <span class="n">query</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gt&quot;</span><span class="p">:</span> <span class="n">querytime</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Warning - no time specified for match and data has no starttime field defined.  Using first match found in channel collection&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Suspect</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">matchsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No match for query = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">message</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">error_logging_allowed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="s2">&quot;Multiple channel docs match net:sta:chan:loc:time for this datum - using first one found&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">match_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">match_doc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

<div class="viewcode-block" id="composite_key_matcher.normalize"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.composite_key_matcher.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the normalize method for this class.</span>

<span class="sd">        :param d:  input data object to be normalized.  Must be a TimeSeries</span>
<span class="sd">          or Seismogram object.  If d is anything else the function will</span>
<span class="sd">          raise a TypeError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_input_is_atomic</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;mseed_channel_matcher.normalize:  received invalid data type&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="mseed_channel_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.mseed_channel_matcher">[docs]</a><span class="k">class</span> <span class="nc">mseed_channel_matcher</span><span class="p">(</span><span class="n">composite_key_matcher</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to match wf_miniseed to the channel collection using</span>
<span class="sd">    the mseed standard channel string tags net, sta, chan, and (optionally) loc.</span>
<span class="sd">    It can also be used to normalize data saved in wf_TimeSeries where the mseed tags</span>
<span class="sd">    are often altered by MsPASS to change fields like &quot;net&quot; to &quot;READONLYERROR_net&quot;.</span>
<span class="sd">    There is an automatic fallback for each of the tags where if the proper</span>
<span class="sd">    name is not found we alway try to use the READONLYERROR_ version before</span>
<span class="sd">    giving up.</span>
<span class="sd">    An issue with this matcher is that it is very common to have redundant</span>
<span class="sd">    entries in the channel collection for the same channel of data.  That</span>
<span class="sd">    can happen for a variety of reasons that are harmless.  When that happens</span>
<span class="sd">    the method of this object will normally post an elog message warning of the</span>
<span class="sd">    potential issue.  Those warnings can be silenced by setting verbose</span>
<span class="sd">    in the constructor to False.</span>
<span class="sd">    The class also has a cache option that can dramatically improve</span>
<span class="sd">    performance for large data sets.  When using the database option</span>
<span class="sd">    (caching turned off) the normalize method issues a database query</span>
<span class="sd">    at each call.  If applied to a data set with a large number of</span>
<span class="sd">    waveforms that can add up.  We have found the cache algorithm is</span>
<span class="sd">    an order of magnitude or more faster than the database algorithm</span>
<span class="sd">    for typical channel collections assembled from FDSN web services.</span>
<span class="sd">    It is recommended unless the memory foot print is excessive.</span>
<span class="sd">    That too can usually be avoided by using a query to weed out unnecessary</span>
<span class="sd">    channel documents or by editing the channel document to reduce the</span>
<span class="sd">    debris from extraneous data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">readonly_tag</span><span class="o">=</span><span class="s2">&quot;READONLYERROR_&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class.</span>
<span class="sd">        It instantiates a composite_key_matcher with default values for collection,</span>
<span class="sd">        attributes_to_load, load_if_defiend, keys, optional_keys.</span>
<span class="sd">        Note that although the default value of attributes_to_load, load_if_defined</span>
<span class="sd">        is None, they are actually initialized in the function body.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:  string defining the collection this object</span>
<span class="sd">          should use for normalization. Default is &quot;channel&quot;</span>
<span class="sd">        :param keys: a list of fields that are used to create a composite key,</span>
<span class="sd">        these fields are always cached if caching is enabled. Default is None, but is</span>
<span class="sd">        initialized with [&quot;net&quot;, &quot;sta&quot;, &quot;chan&quot;].</span>
<span class="sd">        :param optional_keys: a list of fields, very similar to keys, the only</span>
<span class="sd">        difference is that optional_keys can be missing in a document. Default is None,</span>
<span class="sd">        but is initialized with [&quot;loc&quot;].</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method.</span>
<span class="sd">          Note that the Default value is None, but it will then be initialized</span>
<span class="sd">          to a list of common channel attributes: &quot;_id&quot;,&quot;net&quot;,&quot;sta&quot;,&quot;chan&quot;,&quot;lat&quot;,</span>
<span class="sd">          &quot;lon&quot;,&quot;elev&quot;,&quot;hang&quot;,&quot;vang&quot;,&quot;starttime&quot; and &quot;endtime&quot;. This is necessary</span>
<span class="sd">          because we need to cope with the mutable default argument (see https://</span>
<span class="sd">          stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument)</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None, but is initialized</span>
<span class="sd">          with [&quot;loc&quot;].</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.  If your data set is time limited and</span>
<span class="sd">          the collection has a time attribute (true of the standard channel,</span>
<span class="sd">          site, and source collections) you can reduce the memory footprint</span>
<span class="sd">          by using a time range query (python dict) for this argument.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.   When True (default)   all normalizing data</span>
<span class="sd">          keys get a collection name prepended to the key to give it a</span>
<span class="sd">          unique key.</span>
<span class="sd">        :param kill_on_failure:  when set true (Default) match errors</span>
<span class="sd">          will cause data passed to the normalize method to be killed.</span>
<span class="sd">        :param verbose:  most subclasses will want a verbose option</span>
<span class="sd">          to control what is posted to elog messages or printed</span>
<span class="sd">          (most useful for serial jobs)</span>
<span class="sd">        :param cache_normalization_data:  When set True (default) the specified</span>
<span class="sd">          collection is preloaded in an internal cache on construction and</span>
<span class="sd">          used for all subsequent matching.</span>
<span class="sd">        :param readonly_tag: The get_document and normalize methods have an auto</span>
<span class="sd">          recover to try to match read only parameters.  This</span>
<span class="sd">          argument defines the prefix used to define such attributes.</span>
<span class="sd">          The default is &quot;READONLYERROR_&quot; which is what is used by</span>
<span class="sd">          default in MsPASS.  Few if any users will likely need to</span>
<span class="sd">          ever set this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;_id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;net&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sta&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">,</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">,</span>
                <span class="s2">&quot;elev&quot;</span><span class="p">,</span>
                <span class="s2">&quot;hang&quot;</span><span class="p">,</span>
                <span class="s2">&quot;vang&quot;</span><span class="p">,</span>
                <span class="s2">&quot;starttime&quot;</span><span class="p">,</span>
                <span class="s2">&quot;endtime&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">,</span> <span class="s2">&quot;chan&quot;</span><span class="p">]</span>
        <span class="n">optional_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">composite_key_matcher</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">keys</span><span class="p">,</span>
            <span class="n">optional_keys</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
            <span class="n">readonly_tag</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="mseed_site_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.mseed_site_matcher">[docs]</a><span class="k">class</span> <span class="nc">mseed_site_matcher</span><span class="p">(</span><span class="n">composite_key_matcher</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to match derived from seed data to the site collection using</span>
<span class="sd">    the mseed standard site string tags net, sta, and (optionally) loc.</span>
<span class="sd">    It can also be used to data saved in wf_TimeSeries or wf_Seismogram where the mseed tags</span>
<span class="sd">    are often altered by MsPASS to change fields like &quot;net&quot; to &quot;READONLYERROR_net&quot;.</span>
<span class="sd">    There is an automatic fallback for each of the tags where if the proper</span>
<span class="sd">    name is not found we alway try to use the READONLYERROR_ version before</span>
<span class="sd">    giving up.</span>

<span class="sd">    An issue with this matcher is that it is very common to have redundant</span>
<span class="sd">    entries in the site collection for the same site of data.  That</span>
<span class="sd">    can happen for a variety of reasons that are harmless.  When that happens</span>
<span class="sd">    the method of this object will normally post an elog message warning of the</span>
<span class="sd">    potential issue.  Those warnings can be silenced by setting verbose</span>
<span class="sd">    in the constructor to False.</span>

<span class="sd">    The class also has a cache option that can dramatically improve</span>
<span class="sd">    performance for large data sets.  When using the database option</span>
<span class="sd">    (caching turned off) the normalize method issues a database query</span>
<span class="sd">    at each call.  If applied to a data set with a large number of</span>
<span class="sd">    waveforms that can add up.  We have found the cache algorithm is</span>
<span class="sd">    an order of magnitude or more faster than the database algorithm</span>
<span class="sd">    for typical channel collections assembled from FDSN web services.</span>
<span class="sd">    It is recommended unless the memory foot print is excessive.</span>
<span class="sd">    That too can usually be avoided by using a query to weed out unnecessary</span>
<span class="sd">    channel documents or by editing the channel document to reduce the</span>
<span class="sd">    debris from extraneous data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">readonly_tag</span><span class="o">=</span><span class="s2">&quot;READONLYERROR_&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class.</span>
<span class="sd">        It instantiates a composite_key_matcher with default values for collection,</span>
<span class="sd">        attributes_to_load, load_if_defiend, keys, optional_keys.</span>
<span class="sd">        Note that although the default value of attributes_to_load, load_if_defined</span>
<span class="sd">        is None, they are actually initialized in the function body.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection:  string defining the collection this object</span>
<span class="sd">          should use for normalization. Default is &quot;site&quot;</span>
<span class="sd">        :param keys: a list of fields that are used to create a composite key,</span>
<span class="sd">        these fields are always cached if caching is enabled. Default is None, but is</span>
<span class="sd">        initialized with [&quot;net&quot;, &quot;sta&quot;].</span>
<span class="sd">        :param optional_keys: a list of fields, very similar to keys, the only</span>
<span class="sd">        difference is that optional_keys can be missing in a document. Default is None,</span>
<span class="sd">        but is initialized with [&quot;loc&quot;].</span>
<span class="sd">        :param attributes_to_load:  is a list of keys (strings) that are to</span>
<span class="sd">          be loaded with data by the normalize method.</span>
<span class="sd">          Note that the Default value is None, but it will then be initialized</span>
<span class="sd">          to a list of common channel attributes: &quot;_id&quot;,&quot;net&quot;,&quot;sta&quot;,&quot;lat&quot;,&quot;lon&quot;,&quot;elev&quot;,</span>
<span class="sd">          &quot;starttime&quot; and &quot;endtime&quot;. This is necessary because we need to cope with the</span>
<span class="sd">          mutable default argument (see https://stackoverflow.com/questions/1132941/</span>
<span class="sd">          least-astonishment-and-the-mutable-default-argument)</span>
<span class="sd">        :param load_if_defined:   is a secondary list of keys (strings) that</span>
<span class="sd">          should be loaded only if they are defined. Default is None, but is initialized</span>
<span class="sd">          with [&quot;loc&quot;].</span>
<span class="sd">        :param query:  optional query to apply to collection before loading.</span>
<span class="sd">          The default is load all.  If your data set is time limited and</span>
<span class="sd">          the collection has a time attribute (true of the standard channel,</span>
<span class="sd">          site, and source collections) you can reduce the memory footprint</span>
<span class="sd">          by using a time range query (python dict) for this argument.</span>
<span class="sd">        :param prepend_collection_name:  boolean controlling a standard</span>
<span class="sd">          renaming option.   When True (default)   all normalizing data</span>
<span class="sd">          keys get a collection name prepended to the key to give it a</span>
<span class="sd">          unique key.</span>
<span class="sd">        :param kill_on_failure:  when set true (Default) match errors</span>
<span class="sd">          will cause data passed to the normalize method to be killed.</span>
<span class="sd">        :param verbose:  most subclasses will want a verbose option</span>
<span class="sd">          to control what is posted to elog messages or printed</span>
<span class="sd">          (most useful for serial jobs)</span>
<span class="sd">        :param cache_normalization_data:  When set True (default) the specified</span>
<span class="sd">          collection is preloaded in an internal cache on construction and</span>
<span class="sd">          used for all subsequent matching.</span>
<span class="sd">        :param readonly_tag: The get_document and normalize methods have an auto</span>
<span class="sd">          recover to try to match read only parameters.  This</span>
<span class="sd">          argument defines the prefix used to define such attributes.</span>
<span class="sd">          The default is &quot;READONLYERROR_&quot; which is what is used by</span>
<span class="sd">          default in MsPASS.  Few if any users will likely need to</span>
<span class="sd">          ever set this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;_id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;net&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sta&quot;</span><span class="p">,</span>
                <span class="s2">&quot;lat&quot;</span><span class="p">,</span>
                <span class="s2">&quot;lon&quot;</span><span class="p">,</span>
                <span class="s2">&quot;elev&quot;</span><span class="p">,</span>
                <span class="s2">&quot;starttime&quot;</span><span class="p">,</span>
                <span class="s2">&quot;endtime&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">]</span>
        <span class="n">optional_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loc&quot;</span><span class="p">]</span>

        <span class="n">composite_key_matcher</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">keys</span><span class="p">,</span>
            <span class="n">optional_keys</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
            <span class="n">readonly_tag</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="origin_time_source_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.origin_time_source_matcher">[docs]</a><span class="k">class</span> <span class="nc">origin_time_source_matcher</span><span class="p">(</span><span class="n">NMF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One common scheme for fetching seismic data from an FDSN data center</span>
<span class="sd">    is event based with fixed time windows being selected relative to the</span>
<span class="sd">    origin time of each event in a data set.   Standard miniseed data</span>
<span class="sd">    obtained via that mechanism does not keep source data so such data need</span>
<span class="sd">    to be linked to the source collection for any event-based processing.</span>
<span class="sd">    This matcher can be used to do that.</span>

<span class="sd">    The algorithm used here is very simple.   It looks for data with</span>
<span class="sd">    start times in an interval defined by two parameters set in the</span>
<span class="sd">    constructor:  t0offset and tolerance.   If we define t0 as the</span>
<span class="sd">    start time of a given waveform and t_origin as a test origin</span>
<span class="sd">    time, the algorithm looks does a database query to find all</span>
<span class="sd">    events matching this inequality relationship:</span>
<span class="sd">        t_origin + t0offset - tolerance &lt;= t0 &lt;= t_origin + t0offset + tolerance</span>

<span class="sd">    This class uses database queries to find matching source collection</span>
<span class="sd">    documents satisfying the above relation.  It can be slow for</span>
<span class="sd">    large source collection, especially if the source collection time</span>
<span class="sd">    field is not indexed.  A development agenda for MsPASS in the future</span>
<span class="sd">    would be to provide an option to cache the source collection</span>
<span class="sd">    like some of the other implementations of the NMF base class in this</span>
<span class="sd">    module.  Community contributions to implement that are welcome.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="n">t0offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">time_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class. Includes the important boolean</span>
<span class="sd">        that enables or disable caching.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection: the string that represents the name of the source</span>
<span class="sd">          collection, default value is &quot;source&quot;</span>
<span class="sd">        :param t0offset: the offset between t0 and the test origin time, it</span>
<span class="sd">        will be used in the query (see class description)</span>
<span class="sd">        :param tolerance: the tolerance used in the query to form a time</span>
<span class="sd">        range (see class description)</span>
<span class="sd">        :param time_key: the key defining t0.</span>
<span class="sd">        :param attributes_to_load:  list of keys that will always be loaded</span>
<span class="sd">          from each document in the normalization collection satisfying the</span>
<span class="sd">          query. Default is None but is initialized in the function body as</span>
<span class="sd">          [&quot;lat&quot;, &quot;lon&quot;, &quot;depth&quot;, &quot;time&quot;].</span>
<span class="sd">        :param load_if_defined: is like attributes_to_load (a list of</span>
<span class="sd">          key strings) but the key-value pairs are not required. Default is</span>
<span class="sd">          None (an empty list).</span>
<span class="sd">        :param cache_normalization_data:  when True (default) all documents</span>
<span class="sd">          satisfying the query parameter in the channel collection will</span>
<span class="sd">          be loaded into memory in an internal cache.  When False each</span>
<span class="sd">          call to get_document or normalize will invoke a database query</span>
<span class="sd">          (find).  (see class description)</span>
<span class="sd">        :param kill_on_failure:  When True (the default) any data passed</span>
<span class="sd">          processed by the normalize method will be kill if there is no</span>
<span class="sd">          match to the id key requested or if the data lack an id key to</span>
<span class="sd">          do the match.</span>
<span class="sd">        :param query:  (optional) query to pass to find to prefilter the</span>
<span class="sd">          data loaded when cache_normalization_data is True.  This argument</span>
<span class="sd">          is ignore if cache_normalization_data is False.</span>
<span class="sd">        :param prepend_collection_name:   When set True (the default)</span>
<span class="sd">          all data pulled from channel will have the prefix &quot;channel_&quot;</span>
<span class="sd">          added to the key before they are posted to a data object by</span>
<span class="sd">          in the normalize method.  (e.g. &quot;sta&quot; will be posted as &quot;channel_sta&quot;).</span>
<span class="sd">          That is the standard convention used in MsPASS to tag datat that</span>
<span class="sd">          come from normalization like this class does.  Set False only for</span>
<span class="sd">          the special case of wanting to load a set of attributes that will</span>
<span class="sd">          be renamed downstream and saved in some other schema.</span>
<span class="sd">        :param verbose:   when set True (default) the normalize method will</span>
<span class="sd">          post informational warnings about duplicate matches. For large</span>
<span class="sd">          data sets with a lot of duplicate channel records (e.g. from</span>
<span class="sd">          loading errors) consider setting this false to reduce bloat in the</span>
<span class="sd">          elog collection.   Normal use should leave it True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">NMF</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span> <span class="o">=</span> <span class="n">t0offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_key</span> <span class="o">=</span> <span class="n">time_key</span>

<div class="viewcode-block" id="origin_time_source_matcher.get_document"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.origin_time_source_matcher.get_document">[docs]</a>    <span class="k">def</span> <span class="nf">get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">TimeSeries</span><span class="p">,</span>
                <span class="n">Seismogram</span><span class="p">,</span>
                <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
                <span class="n">SeismogramEnsemble</span><span class="p">,</span>
                <span class="n">Metadata</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;origin_time_source_matcher.get_document:  data received as arg0 is not an atomic MsPASS data object&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">d_to_use</span> <span class="o">=</span> <span class="n">Metadata</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_to_use</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">NMF</span><span class="o">.</span><span class="n">get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_to_use</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_test_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_key</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_key</span><span class="p">):</span>
                    <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">time_key</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># matches logic but may not be right approach here</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
                    <span class="n">test_time</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test_time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0offset</span>
        <span class="k">return</span> <span class="n">test_time</span>

    <span class="k">def</span> <span class="nf">_cached_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_test_time</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">_id</span><span class="p">,</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">time</span> <span class="o">&gt;=</span> <span class="n">test_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
                <span class="ow">and</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">test_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">doc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No match for time between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">test_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)),</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">test_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">message</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># this logic allows setting ensemble metadata using a specific</span>
        <span class="c1"># time but if time is not defined we default to using data start time (t0)</span>
        <span class="n">test_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_test_time</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;$gte&quot;</span><span class="p">:</span> <span class="n">test_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="s2">&quot;$lte&quot;</span><span class="p">:</span> <span class="n">test_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">matchsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;No match for query = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">message</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">matchsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="s2">&quot;multiple source documents match the origin time computed from time received - using first found&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">match_doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find_one</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">match_doc</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="css30_arrival_interval_matcher"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.css30_arrival_interval_matcher">[docs]</a><span class="k">class</span> <span class="nc">css30_arrival_interval_matcher</span><span class="p">(</span><span class="n">NMF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This matcher is used to match phase picks stored in the database</span>
<span class="sd">    (default is arrival collection) to waveforms.  The basic algorithm</span>
<span class="sd">    is an interval match.  That is, an arrival with a time between</span>
<span class="sd">    starttime and endtime is considered a match.   If multiple matches</span>
<span class="sd">    are found for same phase name the algorithm uses a time offset test</span>
<span class="sd">    of starttime relative to the phase time.  The data for the arrival</span>
<span class="sd">    doc with time most closely matched to starttime+time_offset is</span>
<span class="sd">    selected.</span>

<span class="sd">    The main use of this class is to match a collection of raw data</span>
<span class="sd">    with arrival time picks made by another source</span>
<span class="sd">    (e.g. the Array Network Facilty of Earthscope css3.0 arrival picks)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">collection</span><span class="o">=</span><span class="s2">&quot;arrival&quot;</span><span class="p">,</span>
        <span class="n">time_offset</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span>
        <span class="n">phasename</span><span class="o">=</span><span class="s2">&quot;P&quot;</span><span class="p">,</span>
        <span class="n">phasename_key</span><span class="o">=</span><span class="s2">&quot;phase&quot;</span><span class="p">,</span>
        <span class="n">attributes_to_load</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">load_if_defined</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prepend_collection_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache_normalization_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for this class.</span>

<span class="sd">        :param db:  MongoDB Database handle</span>
<span class="sd">        :param collection: the string that represents the name of the source</span>
<span class="sd">          collection, default value is &quot;arrival&quot;</span>
<span class="sd">        :param time_offset: the offset between t0 and the test origin time, it</span>
<span class="sd">        will be used in the query (see class description)</span>
<span class="sd">        :param phasename: the phasename used in the query, default is &quot;P&quot;.</span>
<span class="sd">        :param phasename_key: the name of the phasename&#39;s key in the collection,</span>
<span class="sd">        default is &quot;phase&quot;.</span>
<span class="sd">        :param attributes_to_load:  list of keys that will always be loaded</span>
<span class="sd">          from each document in the normalization collection satisfying the</span>
<span class="sd">          query. Default is None but is initialized in the function body as</span>
<span class="sd">          [&quot;time&quot;].</span>
<span class="sd">        :param load_if_defined: is like attributes_to_load (a list of</span>
<span class="sd">          key strings) but the key-value pairs are not required. Default is</span>
<span class="sd">          None but is initialized in the function body as [&quot;evid&quot;, &quot;iphase&quot;, &quot;seaz&quot;,</span>
<span class="sd">          &quot;esaz&quot;, &quot;deltim&quot;, &quot;timeres&quot;].</span>
<span class="sd">        :param kill_on_failure:  When True (the default) any data passed</span>
<span class="sd">          processed by the normalize method will be kill if there is no</span>
<span class="sd">          match to the id key requested or if the data lack an id key to</span>
<span class="sd">          do the match.</span>
<span class="sd">        :param query:  (optional) query to pass to find to prefilter the</span>
<span class="sd">          data loaded when cache_normalization_data is True.  This argument</span>
<span class="sd">          is ignore if cache_normalization_data is False.</span>
<span class="sd">        :param prepend_collection_name:   When set True (the default)</span>
<span class="sd">          all data pulled from channel will have the prefix &quot;channel_&quot;</span>
<span class="sd">          added to the key before they are posted to a data object by</span>
<span class="sd">          in the normalize method.  (e.g. &quot;sta&quot; will be posted as &quot;channel_sta&quot;).</span>
<span class="sd">          That is the standard convention used in MsPASS to tag datat that</span>
<span class="sd">          come from normalization like this class does.  Set False only for</span>
<span class="sd">          the special case of wanting to load a set of attributes that will</span>
<span class="sd">          be renamed downstream and saved in some other schema.</span>
<span class="sd">        :param verbose:   when set True (default) the normalize method will</span>
<span class="sd">          post informational warnings about duplicate matches. For large</span>
<span class="sd">          data sets with a lot of duplicate channel records (e.g. from</span>
<span class="sd">          loading errors) consider setting this false to reduce bloat in the</span>
<span class="sd">          elog collection.   Normal use should leave it True.</span>
<span class="sd">        :param cache_normalization_data:  The argument required by NMF to turn on/off</span>
<span class="sd">          the caching. Currently the caching for this class is not implemented for</span>
<span class="sd">          this class, so the default value is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attributes_to_load</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_load</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">load_if_defined</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_if_defined</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;evid&quot;</span><span class="p">,</span> <span class="s2">&quot;iphase&quot;</span><span class="p">,</span> <span class="s2">&quot;seaz&quot;</span><span class="p">,</span> <span class="s2">&quot;esaz&quot;</span><span class="p">,</span> <span class="s2">&quot;deltim&quot;</span><span class="p">,</span> <span class="s2">&quot;timeres&quot;</span><span class="p">]</span>

        <span class="n">NMF</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">collection</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="p">,</span>
            <span class="n">load_if_defined</span><span class="p">,</span>
            <span class="n">query</span><span class="p">,</span>
            <span class="n">prepend_collection_name</span><span class="p">,</span>
            <span class="n">kill_on_failure</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">,</span>
            <span class="n">cache_normalization_data</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phasename</span> <span class="o">=</span> <span class="n">phasename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phasename_key</span> <span class="o">=</span> <span class="n">phasename_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_offset</span> <span class="o">=</span> <span class="n">time_offset</span>

    <span class="k">def</span> <span class="nf">_get_doc_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">)):</span>
            <span class="n">stime</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span>
            <span class="n">etime</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">):</span>
                <span class="n">stime</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
                <span class="n">etime</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;endtime&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;css30_arrival_interval_matcher._get_doc_time: can&#39;t extract time from input&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_db_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_doc_time</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="n">query</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phasename_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasename</span>
        <span class="n">query</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;$gte&quot;</span><span class="p">:</span> <span class="n">stime</span><span class="p">,</span> <span class="s2">&quot;$lte&quot;</span><span class="p">:</span> <span class="n">etime</span><span class="p">}</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="c1"># the key here perhaps should be set in constructor</span>
            <span class="c1"># for now it is frozen as this constant</span>
            <span class="n">min_doc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">min_abs_dt</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
                <span class="c1"># ignore any docs with the time attribute not set</span>
                <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                    <span class="n">abs_dt</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_offset</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abs_dt</span> <span class="o">&lt;</span> <span class="n">min_abs_dt</span><span class="p">:</span>
                        <span class="n">min_abs_dt</span> <span class="o">=</span> <span class="n">abs_dt</span>
                        <span class="n">min_doc</span> <span class="o">=</span> <span class="n">doc</span>
            <span class="k">if</span> <span class="n">min_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># handle these special cases</span>
                <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                    <span class="s2">&quot;css30_arrival_interval_matcher.get_document:  no arrival docs found with phasename set as&quot;</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasename</span>
                    <span class="o">+</span> <span class="s2">&quot; with a time attribute defined.  This should not happen and indicates a serious database inconsistence.  Aborting&quot;</span><span class="p">,</span>
                    <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cached_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_cached_get_document</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="bulk_normalize"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.bulk_normalize">[docs]</a><span class="k">def</span> <span class="nf">bulk_normalize</span><span class="p">(</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wf_col</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
    <span class="n">blocksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">nmf_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function iterates through the collection specified by db and wf_col,</span>
<span class="sd">    and run a chain of normalization funtions in serial on each document in one</span>
<span class="sd">    single pass.</span>
<span class="sd">    It will save the time of multiple db updating operations, by using the bulk</span>
<span class="sd">    methods of MongoDB.</span>

<span class="sd">    :param db: should be a MsPASS database handle containing the wf_col</span>
<span class="sd">    and the collections defined by the nmf_list list.</span>
<span class="sd">    :param wf_col: The collection that need to be normalized, default is</span>
<span class="sd">    wf_miniseed</span>
<span class="sd">    :param blockssize:   To speed up updates this function uses the</span>
<span class="sd">    bulk writer/updater methods of MongoDB that can be orders of</span>
<span class="sd">    magnitude faster than one-at-a-time updates. A user should not normally</span>
<span class="sd">    need to alter this parameter.</span>
<span class="sd">    :param wfquery: is a query to apply to the collection.  The output of this</span>
<span class="sd">    query defines the list of documents that the algorithm will attempt</span>
<span class="sd">    to normalize as described above.  The default will process the entire</span>
<span class="sd">    collection (query set to an emtpy dict).</span>
<span class="sd">    :param nmf_list: a list of NMF instances. These instances should at least</span>
<span class="sd">    contain a get_document function and a dbhandler. The default will be a simple</span>
<span class="sd">    mseed_channel_matcher.</span>
<span class="sd">    :param verbose: When set true the get_document and normalize functions will</span>
<span class="sd">    be run in verbose mode.  Those methods will print a diagnostic for all</span>
<span class="sd">    ambiguous matches.  Because this function is expected to be run on potentially</span>
<span class="sd">    large raw data sets of miniseed inputs the default is False to reduce the</span>
<span class="sd">    overhead of potentially large log messages created by the all to common</span>
<span class="sd">    duplicate metadata problem. Please note that this function will alter the</span>
<span class="sd">    verbose levels of all NMF instances in nmf_list.</span>

<span class="sd">    :return: a list with a length of len(nmf_list)+1.  0 is the number of documents</span>
<span class="sd">    processed in the collection (output of query), The rest are the numbers of</span>
<span class="sd">    success normalizations for the corresponding NMF instances, they are mapped</span>
<span class="sd">    one on one (nmf_list[x] -&gt; ret[x+1]).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">nmf_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#   The default value for nmf_list is one default</span>
        <span class="n">channel_matcher</span> <span class="o">=</span> <span class="n">mseed_channel_matcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="s2">&quot;net&quot;</span><span class="p">,</span> <span class="s2">&quot;sta&quot;</span><span class="p">,</span> <span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="s2">&quot;endtime&quot;</span><span class="p">],</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nmf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_matcher</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">nmf</span> <span class="ow">in</span> <span class="n">nmf_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nmf</span><span class="p">,</span> <span class="n">NMF</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
                <span class="s2">&quot;bulk_normalize: the function </span><span class="si">{}</span><span class="s2"> is not a NMF function&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">nmf</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">nmf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

    <span class="n">ndocs</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">count_documents</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndocs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MsPASSError</span><span class="p">(</span>
            <span class="s2">&quot;bulk_normalize: &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;query of wf_miniseed yielded 0 documents</span><span class="se">\n</span><span class="s2">Nothing to process&quot;</span><span class="p">,</span>
            <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Fatal</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">cnt_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nmf_list</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">cursor</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">wfquery</span><span class="p">)</span>
    <span class="n">bulk</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">:</span>
        <span class="n">wf_id</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span>
        <span class="n">wf_stime</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;starttime&quot;</span><span class="p">]</span>
        <span class="n">need_update</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">update_doc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">nmf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nmf_list</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">norm_doc</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">get_document</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">wf_stime</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">norm_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nmf</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">:</span>
                    <span class="n">new_key</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="k">if</span> <span class="n">nmf</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                        <span class="c1">#   We assume that every NMF should contain a dbhandler</span>
                        <span class="c1"># handle _id specially to avoid double _</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                            <span class="n">new_key</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">key</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_key</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
                    <span class="n">update_doc</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Some NMF dervied classes don&#39;t accept time argument</span>
                <span class="n">norm_doc</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">get_document</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">norm_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nmf</span><span class="o">.</span><span class="n">attributes_to_load</span><span class="p">:</span>
                    <span class="n">new_key</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="k">if</span> <span class="n">nmf</span><span class="o">.</span><span class="n">prepend_collection_name</span><span class="p">:</span>
                        <span class="c1"># again handle _id specially to avoid double _</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;_id&quot;</span><span class="p">:</span>
                            <span class="n">new_key</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">key</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_key</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">dbhandle</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">key</span>
            <span class="c1">#   If we reach here, we&#39;ve got a norm_doc return</span>
            <span class="n">cnt_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">need_update</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">need_update</span><span class="p">:</span>
            <span class="n">bulk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pymongo</span><span class="o">.</span><span class="n">UpdateOne</span><span class="p">({</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">wf_id</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;$set&quot;</span><span class="p">:</span> <span class="n">update_doc</span><span class="p">}))</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Tests for counter and len(bulk) are needed because the logic here</span>
        <span class="c1"># allows this block to be entered the first pass and if the pass</span>
        <span class="c1"># after the previous call to bulk_write did not yield a match</span>
        <span class="c1"># either will cause bulk_write to throw an error when it gets an</span>
        <span class="c1"># an empty list.   Should consider a logic  change here</span>
        <span class="c1"># to make this less obscure</span>
        <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">blocksize</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">bulk_write</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>
            <span class="n">bulk</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">blocksize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">db</span><span class="p">[</span><span class="n">wf_col</span><span class="p">]</span><span class="o">.</span><span class="n">bulk_write</span><span class="p">(</span><span class="n">bulk</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">ndocs</span><span class="p">]</span> <span class="o">+</span> <span class="n">cnt_list</span></div>


<div class="viewcode-block" id="normalize_mseed"><a class="viewcode-back" href="../../../python_api/mspasspy.db.html#mspasspy.db.normalize.normalize_mseed">[docs]</a><span class="k">def</span> <span class="nf">normalize_mseed</span><span class="p">(</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">wfquery</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">blocksize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">normalize_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">normalize_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In MsPASS the standard support for station information is stored in</span>
<span class="sd">    two collections called &quot;channel&quot; and &quot;site&quot;.   When normalized</span>
<span class="sd">    with channel collection data a miniseed record can be associated with</span>
<span class="sd">    station metadata downloaded by FDSN web services and stored previously</span>
<span class="sd">    with MsPASS database methods.   The default behavior tries to associate</span>
<span class="sd">    each wf_miniseed document with an entry in &quot;site&quot;.  In MsPASS site is a</span>
<span class="sd">    smaller collection intended for use only with data already assembled</span>
<span class="sd">    into three component bundles we call Seismogram objects.</span>


<span class="sd">    For both channel and site the association algorithm used assumes</span>
<span class="sd">    the SEED convention wherein the strings stored with the keys</span>
<span class="sd">    &quot;net&quot;,&quot;sta&quot;,&quot;chan&quot;, and (optionally) &quot;loc&quot; define a unique channel</span>
<span class="sd">    of data registered globally through the FDSN.   The algorithm then</span>
<span class="sd">    need only query for a match of these keys and a time interval</span>
<span class="sd">    match with the start time of the waveform defined by each wf_miniseed</span>
<span class="sd">    document.   The only distinction in the algorithm between site and</span>
<span class="sd">    channel is that &quot;chan&quot; is not used in site since by definition site</span>
<span class="sd">    data refer to common attributes of one seismic observatory (commonly</span>
<span class="sd">    also called a &quot;station&quot;).</span>

<span class="sd">    :param db: should be a MsPASS database handle containing at least</span>
<span class="sd">    wf_miniseed and the collections defined by the norm_collection list.</span>
<span class="sd">    :param blockssize:   To speed up updates this function uses the</span>
<span class="sd">    bulk writer/updater methods of MongoDB that can be orders of</span>
<span class="sd">    magnitude faster than one-at-a-time updates for setting</span>
<span class="sd">    channel_id and site_id.  A user should not normally need to alter this</span>
<span class="sd">    parameter.</span>
<span class="sd">    :param wfquery: is a query to apply to wf_miniseed.  The output of this</span>
<span class="sd">    query defines the list of documents that the algorithm will attempt</span>
<span class="sd">    to normalize as described above.  The default will process the entire</span>
<span class="sd">    wf_miniseed collection (query set to an emtpy dict).</span>
<span class="sd">    :param normalize_channel:  boolean for handling channel collection.</span>
<span class="sd">    When True (default) matches will be attempted with the channel collection</span>
<span class="sd">    and when matches are found the associated channel document id will be</span>
<span class="sd">    set in the associated wf_miniseed document as channel_id.</span>
<span class="sd">    :param normalize_site:  boolean for handling site collection.</span>
<span class="sd">    When True (default) matches will be attempted with the site collection</span>
<span class="sd">    and when matches are found the associated site document id will</span>
<span class="sd">    be set wf_miniseed document as site_id.</span>
<span class="sd">    :param verbose: When set true the database methods for matching the</span>
<span class="sd">    net:sta:chan:loc:time keys will be run in verbose mode.  Those database</span>
<span class="sd">    methods will print a diagnostic for all ambiguous matches.  Because</span>
<span class="sd">    this function is expected to be run on potentially large raw data sets of</span>
<span class="sd">    miniseed inputs the default is False to reduce the overhead of potentially</span>
<span class="sd">    large log messages created by the all to common duplicate metadata problem.</span>
<span class="sd">    Users are encouraged to verify the channel and site collections have</span>
<span class="sd">    no serious problems with ambiguous net:sta:loc(chan) that are truly</span>
<span class="sd">    inconsistent (i.e. have different attributes for the same keys)</span>

<span class="sd">    :return: list with three integers.  0 is the number of documents processed in</span>
<span class="sd">    wf_miniseed (output of query), 1 is the number with channel ids set,</span>
<span class="sd">    and 2 contains the number of site documents set.  1 or 2 should</span>
<span class="sd">    contain 0 if normalization for that collection was set false.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">wfquery</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wfquery</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">nmf_function_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">normalize_channel</span><span class="p">:</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">mseed_channel_matcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;_id&quot;</span>
            <span class="p">],</span>  <span class="c1">#   We only want to add channel_id to the db collection</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nmf_function_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matcher</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
        <span class="n">sitematcher</span> <span class="o">=</span> <span class="n">mseed_site_matcher</span><span class="p">(</span>
            <span class="n">db</span><span class="p">,</span>
            <span class="n">attributes_to_load</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">],</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nmf_function_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sitematcher</span><span class="p">)</span>

    <span class="n">bulk_nml_ret</span> <span class="o">=</span> <span class="n">bulk_normalize</span><span class="p">(</span>
        <span class="n">db</span><span class="p">,</span>
        <span class="n">wfquery</span><span class="o">=</span><span class="n">wfquery</span><span class="p">,</span>
        <span class="n">wf_col</span><span class="o">=</span><span class="s2">&quot;wf_miniseed&quot;</span><span class="p">,</span>
        <span class="n">blocksize</span><span class="o">=</span><span class="n">blocksize</span><span class="p">,</span>
        <span class="n">nmf_list</span><span class="o">=</span><span class="n">nmf_function_list</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">bulk_nml_ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">normalize_channel</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_nml_ret</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_nml_ret</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize_site</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_nml_ret</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>