

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.algorithms.MCXcorStacking &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=f6245a2f"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/quick_start.html">Getting Started in a Nutshell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/run_mspass_with_docker.html">Run MsPASS with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_docker_compose.html">Deploy MsPASS with Docker Compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda.html">Deploy MsPASS with Conda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda.html#advanced-setup-considerations">Advanced Setup Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_on_HPC.html">Deploying MsPASS on an HPC cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda_and_coiled.html">Deploy MsPASS with Conda and Coiled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started_overview.html">MsPASS Virtual Cluster Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/mongodb_and_mspass.html">Using MongoDB with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_tabular_data.html">Importing Tabular Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Seismic Data Objects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/numpy_scipy_interface.html">Using numpy/scipy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/continuous_data.html">Continuous Data Handling with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/schema_choices.html">What database schema should I use?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Processing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/cleaning_metadata.html">Cleaning Inconsistent Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/signal_to_noise.html">Signal to Noise Ratio Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System Tuning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/memory_management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/io.html">I/O in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_io.html">Parallel IO in MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/FAQ.html">Frequency Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/development_strategies.html">How do I develop a new workflow from scratch?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../../../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mspasspy.algorithms.MCXcorStacking</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mspasspy.algorithms.MCXcorStacking</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module implementing a similar algorithm to dbxcor in python.  </span>

<span class="sd">Created on Tue Jul  9 05:37:40 2024</span>

<span class="sd">@author: pavlis</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.algorithms.amplitudes</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MADAmplitude</span><span class="p">,</span>
    <span class="n">RMSAmplitude</span><span class="p">,</span>
    <span class="n">PeakAmplitude</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.algorithms.window</span> <span class="kn">import</span> <span class="n">WindowData</span>
<span class="kn">from</span> <span class="nn">obspy.geodetics.base</span> <span class="kn">import</span> <span class="n">gps2dist_azimuth</span><span class="p">,</span> <span class="n">kilometers2degrees</span>
<span class="kn">from</span> <span class="nn">obspy.taup</span> <span class="kn">import</span> <span class="n">TauPyModel</span>


<span class="kn">from</span> <span class="nn">mspasspy.ccore.utility</span> <span class="kn">import</span> <span class="n">ErrorLogger</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="p">,</span> <span class="n">Metadata</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.seismic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
    <span class="n">TimeReferenceType</span><span class="p">,</span>
    <span class="n">DoubleVector</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">mspasspy.util.seismic</span> <span class="kn">import</span> <span class="n">number_live</span><span class="p">,</span> <span class="n">regularize_sampling</span><span class="p">,</span> <span class="n">ensemble_time_range</span>
<span class="kn">from</span> <span class="nn">mspasspy.ccore.algorithms.basic</span> <span class="kn">import</span> <span class="n">TimeWindow</span>
<span class="kn">from</span> <span class="nn">mspasspy.algorithms.signals</span> <span class="kn">import</span> <span class="nb">filter</span>
<span class="kn">from</span> <span class="nn">mspasspy.algorithms.window</span> <span class="kn">import</span> <span class="n">WindowData</span><span class="p">,</span> <span class="n">WindowData_autopad</span>


<div class="viewcode-block" id="extract_initial_beam_estimate"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.extract_initial_beam_estimate">[docs]</a><span class="k">def</span> <span class="nf">extract_initial_beam_estimate</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">,</span>
    <span class="n">subdoc_key</span><span class="o">=</span><span class="s2">&quot;Parrival&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The robust stacking method used in the `align_and_stack`</span>
<span class="sd">    function in this module requires an initial signal estimate</span>
<span class="sd">    for first-order alignment of signals in the input ensemble.</span>
<span class="sd">    In the original dbxcor implementation of that algorithm the</span>
<span class="sd">    user was required to select that initial signal interactively</span>
<span class="sd">    in a graphical user interface.   This function provides one</span>
<span class="sd">    possible algorithm to accomplish that task automatically.  It does</span>
<span class="sd">    so by scanning the ensemble to extract a member with the largest</span>
<span class="sd">    value of some quality control metric.   This implementation is</span>
<span class="sd">    limited to metrics computed by the MsPASS function called</span>
<span class="sd">    `broadband_snr_QC`.   The algorithm, however, would be easy</span>
<span class="sd">    to modify to produce a custom operator using some other</span>
<span class="sd">    metric posted to the Metadata container of each ensemble member.</span>
<span class="sd">    An oddity of the `broadband_snr_QC` is that it posts its</span>
<span class="sd">    output to a python dictionary (subdocument in pymongo jargon)</span>
<span class="sd">    fetched with a single key.  That key can be changed from</span>
<span class="sd">    the default &quot;Parrival&quot; (default of `broadband_snr_QC`) to</span>
<span class="sd">    something else via the &quot;subdoc_key&quot; argument.  This list of</span>
<span class="sd">    keys inside that subdocument that can be used to set what metric</span>
<span class="sd">    will be used are:  bandwidth, filtered_envelope, filtered_L2,</span>
<span class="sd">    filtered_Linf, or filtered_perc.  See the docstring for</span>
<span class="sd">    `broadband_snr_QC` for an explanation of each metric.</span>

<span class="sd">    :param ensemble:   ensemble to be scanned</span>
<span class="sd">    :type ensemble:  `TimeSeriesEnsemble`</span>
<span class="sd">    :param metric:   quality metric to use for selecting member to use</span>
<span class="sd">    as return.  Always scans for the maximum of specified value as it</span>
<span class="sd">    assume the value is some norm measure.   Accepted values at present</span>
<span class="sd">    are all those computed by `broadband_snr_QC`:  bandwidth,</span>
<span class="sd">    filtered_envelope, filtered_L2, filtered_Linf, or filtered_perc.</span>
<span class="sd">    Default is &quot;bandwidth&quot;.   A ValueError exception will be thrown</span>
<span class="sd">    if not one of those values.</span>
<span class="sd">    :type metric:  string</span>
<span class="sd">    :param subdoc_key:   `broadband_snr_QC` normally posts output to</span>
<span class="sd">    a subdocument (dictionary).  This is the key that is used to</span>
<span class="sd">    extract that subdocument from each member.   Default is &quot;Parrival&quot;</span>
<span class="sd">    which is the default of `broadband_snr_QC`.</span>
<span class="sd">    :type subdoc_key:  string</span>
<span class="sd">    :return:  `TimeSeries` that is a copy of the ensemble member with</span>
<span class="sd">    the largest value of the requested member.   A default constructed, dead datum</span>
<span class="sd">    is returned if the algorithm failed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;bandwidth&quot;</span><span class="p">:</span>
        <span class="n">key2use</span> <span class="o">=</span> <span class="s2">&quot;bandwidth&quot;</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;filtered_envelope&quot;</span><span class="p">:</span>
        <span class="n">key2use</span> <span class="o">=</span> <span class="s2">&quot;filtered_envelope&quot;</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;filtered_L2&quot;</span><span class="p">:</span>
        <span class="n">key2use</span> <span class="o">=</span> <span class="s2">&quot;filtered_L2&quot;</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;filtered_perc&quot;</span><span class="p">:</span>
        <span class="n">key2use</span> <span class="o">=</span> <span class="s2">&quot;filtered_perc&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;extract_initial_beam_estimate:  illegal value for argument metric=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">metric</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must one of:  bandwidth, filtered_envelope, filtered_L2, filtered_MAD, filtered_Linf, or filtered_perc&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="c1"># this holds metric values - use the index of to associate with correct member</span>
    <span class="c1"># works because zero is never the maximum unless none are defined</span>
    <span class="n">mvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">n_set</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">subdoc_key</span><span class="p">):</span>
            <span class="n">subdoc</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">subdoc_key</span><span class="p">]</span>
            <span class="n">mvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdoc</span><span class="p">[</span><span class="n">key2use</span><span class="p">]</span>
            <span class="n">n_set</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n_set</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">mvals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">imax</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">()</span></div>


<div class="viewcode-block" id="estimate_ensemble_bandwidth"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.estimate_ensemble_bandwidth">[docs]</a><span class="k">def</span> <span class="nf">estimate_ensemble_bandwidth</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">snr_doc_key</span><span class="o">=</span><span class="s2">&quot;Parrival&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate average bandwidth of an ensemble of data using the output of</span>
<span class="sd">    broadband_snr_QC.</span>

<span class="sd">    The original dbxcor program used a GUI that allowed the user to select one of</span>
<span class="sd">    a set of predefined filters to be used to set the frequency band of the signal</span>
<span class="sd">    to be processed by the equivalent of the `align_and_stack` function of this module.</span>
<span class="sd">    The purpose of this function is to automate that process to defined an</span>
<span class="sd">    optimal bandwidth for processing of the input ensemble.</span>

<span class="sd">    This function only works on ensembles processed previously with the</span>
<span class="sd">    mspass function `broadband_snr_QC`.   That function computes a series of</span>
<span class="sd">    metrics for signal-to-noise ratio.  The only one this one uses is</span>
<span class="sd">    the two values defined by &quot;low_f_band_edge&quot; and &quot;high_f_band_edge&quot;.</span>
<span class="sd">    The verbose names should make their definition obvious.   This</span>
<span class="sd">    function returns the median of the values of all values of those</span>
<span class="sd">    two attributes extracted from all live members of the input ensemble.</span>
<span class="sd">    The result is returned as a tuple with the low frequency edge as 0</span>
<span class="sd">    and the high frequency edge as 1.    The expectation is that the</span>
<span class="sd">    data will be bandpass filtered between the low and high edges before</span>
<span class="sd">    running the `align_and_stack` function.</span>

<span class="sd">    :param ensemble:  ensemble of data to be scanned</span>
<span class="sd">    :type ensemble:  `TimeSeriesEnsemble`</span>
<span class="sd">    :param srn_doc_key:  subdocument key of attributes computed by</span>
<span class="sd">    `broadband_snr_QC` to fetch as estimates of low and high frequency</span>
<span class="sd">    edges.</span>
<span class="sd">    :type snr_doc_key:  string (default &quot;Parrival&quot; = default of</span>
<span class="sd">    `broadband_snr_QC`)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">f_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">f_h</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">snr_doc_key</span><span class="p">):</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">snr_doc_key</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;low_f_band_edge&quot;</span><span class="p">]</span>
                <span class="n">f_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;high_f_band_edge&quot;</span><span class="p">]</span>
                <span class="n">f_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_h</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">f_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">f_l</span><span class="p">)</span>
        <span class="n">f_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">f_h</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_h</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_compute_default_robust_window</span><span class="p">(</span>
    <span class="n">f_low</span><span class="p">,</span>
    <span class="n">ncycles</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">starttime</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="n">min_endtime_multiplier</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeWindow</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small function to encapsulate the algorithm used to define the</span>
<span class="sd">    default robust window set by MCXcorPrepP.  Returns a time</span>
<span class="sd">    window with the starttime frozen as the function default</span>
<span class="sd">    argument.   endtime is the thing computed.  It is computed</span>
<span class="sd">    as ncycle times the period defined by the low frequency</span>
<span class="sd">    band edge f_low passed as arg0.   There is a safety</span>
<span class="sd">    called min_endtime_multiplier that would only be used if</span>
<span class="sd">    f_low is larger than 1 Hz - which for teleseismic P wave</span>
<span class="sd">    data means f_low is not reasonable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">f_low</span>
    <span class="n">endtime</span> <span class="o">=</span> <span class="n">ncycles</span> <span class="o">*</span> <span class="n">T</span>
    <span class="k">if</span> <span class="n">endtime</span> <span class="o">&lt;</span> <span class="n">min_endtime_multiplier</span><span class="p">:</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="n">starttime</span> <span class="o">*</span> <span class="n">min_endtime_multiplier</span>
    <span class="k">return</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">)</span>


<div class="viewcode-block" id="MCXcorPrepP"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.MCXcorPrepP">[docs]</a><span class="k">def</span> <span class="nf">MCXcorPrepP</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">noise_window</span><span class="p">,</span>
    <span class="n">noise_metric</span><span class="o">=</span><span class="s2">&quot;mad&quot;</span><span class="p">,</span>
    <span class="n">initial_beam_metric</span><span class="o">=</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">,</span>
    <span class="n">snr_doc_key</span><span class="o">=</span><span class="s2">&quot;Parrival&quot;</span><span class="p">,</span>
    <span class="n">low_f_corner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">high_f_corner</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">npoles</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">filter_parameter_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;MCXcor_f_low&quot;</span><span class="p">,</span> <span class="s2">&quot;MCXcor_f_high&quot;</span><span class="p">,</span> <span class="s2">&quot;MCXcor_npoles&quot;</span><span class="p">],</span>
    <span class="n">coda_level_factor</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
    <span class="n">set_phases</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Ptime_key</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span>
    <span class="n">pPtime_key</span><span class="o">=</span><span class="s2">&quot;pPtime&quot;</span><span class="p">,</span>
    <span class="n">PPtime_key</span><span class="o">=</span><span class="s2">&quot;PPtime&quot;</span><span class="p">,</span>
    <span class="n">station_collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
    <span class="n">search_window_fraction</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="n">minimum_coda_duration</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
    <span class="n">correlation_window_start</span><span class="o">=-</span><span class="mf">3.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeriesEnsemble</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function used to preprocess an ensemble  to prepare input for</span>
<span class="sd">    running multichannel cross-correlation and stacking method</span>
<span class="sd">    (automated dbxcor algorithm) of P phase data.  This function should</span>
<span class="sd">    not be used for anything but teleseismic P data.</span>

<span class="sd">    The multichannel correlation and stacking function in this module called</span>
<span class="sd">    `align_and_stack` requires one to define a number of parameters that</span>
<span class="sd">    in the original dbxcor implementation were input through a graphical</span>
<span class="sd">    user interface.   This function can be thought of a robot that will</span>
<span class="sd">    attempt to set all the required parameters automatically using signal processing.</span>
<span class="sd">    It will attempt to produce two inputs required by the `align_and_stack`:</span>
<span class="sd">    1.  What I call a &quot;correlation window&quot;.</span>
<span class="sd">    2.  The ensemble member that is to be used as the initial estimate of the</span>
<span class="sd">        beam (stack of the data aligned by cross correlation).</span>

<span class="sd">    A CRITICAL assumption of this function is that the input ensemble&#39;s data</span>
<span class="sd">    have been processed with the snr module function `broadband_snr_QC`.</span>
<span class="sd">    That function computes and posts multiple snr metrics to a subdocument</span>
<span class="sd">    (dictionary) accessed with a single key.   This function requires that</span>
<span class="sd">    data exist and be accessible with the key defined by the argument</span>
<span class="sd">    &quot;snr_doc_key&quot;.   The data in that dictionary are used in the following</span>
<span class="sd">    algorithms run within this function:</span>
<span class="sd">    1.  The working bandwidth of the data is established by computing the median</span>
<span class="sd">        of the attributes &quot;low_f_band_edge&quot; and &quot;high_f_band_edge&quot; extracted from</span>
<span class="sd">        each live member.  Those frequencies are computed using the function in this module</span>
<span class="sd">        called `estimate_ensemble_bandwidth`.  The working ensemble</span>
<span class="sd">        (which is what is returned on success) will be filtered in the band defined</span>
<span class="sd">        by the output of `estimate_ensemble_bandwidth` using a Butterworth,</span>
<span class="sd">        bandpass filter with the number of poles defined by the &quot;npoles&quot; argument.</span>
<span class="sd">    2.  What I call the correlation window is estimated by a complex recipe</span>
<span class="sd">        best understood from the user manual page and example jupyter notebooks</span>
<span class="sd">        related to this module.   Briefly, the correlation window is defined by</span>
<span class="sd">        applying an envelope function to each signal and defining the coda</span>
<span class="sd">        end using a common recipe for coda magnitudes where the end of the coda is</span>
<span class="sd">        defined by where the coda level (envelope) first falls below a</span>
<span class="sd">        level specified as a multiple of measured background noise.</span>
<span class="sd">        This function REQUIRES the input for each member to have a section</span>
<span class="sd">        that it can treat as background noise.  For most uses that means some</span>
<span class="sd">        section of data immediately before the P wave arrival time.  The</span>
<span class="sd">        noise level is estimated by the metric defined by the &quot;noise_metric&quot;</span>
<span class="sd">        argument and the coda level cutoff is computed as</span>
<span class="sd">        `noise_level*coda_level_factor` where `coda_level_factor` is the</span>
<span class="sd">        valued passed via the function argument with that key.</span>
<span class="sd">        Because this function is designed strictly for P phases it has to</span>
<span class="sd">        handle the complexity of interference by secondary P phases.   For</span>
<span class="sd">        that reason it compute arrival times for pP and PP and will always</span>
<span class="sd">        start the coda search before time of the smaller of pP or PP.</span>
<span class="sd">        Note, however, that pP is not used a constraint if the source depth is</span>
<span class="sd">        less than 100 km.   The justification for that number can be found in</span>
<span class="sd">        jupyter notebooks that should be part of the MsPASS documentation.</span>
<span class="sd">    3.  It then extracts one member from the ensemble the algorithm judges to</span>
<span class="sd">        be the best choice for an initial beam estimate.   That is, in</span>
<span class="sd">        align_and_stack the first step  is to align the data with a reference</span>
<span class="sd">        signal using cross-correlation of the &quot;beam&quot; with each member.  The</span>
<span class="sd">        aligned data are then summed with a robust stack to refine the beam.</span>
<span class="sd">        That is repeated until the stack does not change significantly.</span>
<span class="sd">        That algorithm requires a seed for the initial beam estimate.   That</span>
<span class="sd">        initial signal is extracted as the ensemble member with the largest</span>
<span class="sd">        value of the snr metric defined with the `initial_beam_metric` argument.</span>
<span class="sd">        The correlation window parameters computed earlier are then posted</span>
<span class="sd">        to the `Metadata` of that `TimeSeries` where `align_and_stack`</span>
<span class="sd">        can parse them to set the correlation time window.</span>

<span class="sd">    The function returns a copy of the input ensemble filtered to the</span>
<span class="sd">    average bandwidth and the initial beam estimate.  They are return</span>
<span class="sd">    as a tuple with 0 the ensemble and 1 the initial beam estimate.</span>
<span class="sd">    Callers should verify the beam signal is marked live.  A dead</span>
<span class="sd">    beam signal indicates the algorithm failed in one way or another.</span>
<span class="sd">    Errors at the level will result in errors being posted to the</span>
<span class="sd">    `ErrorLogger` container of the beam output.  Note also this</span>
<span class="sd">    algorithm can kill some ensemble members in the output that</span>
<span class="sd">    were marked live in the input.</span>

<span class="sd">    :param ensemble:   input ensemble of data to use.  As noted above it</span>
<span class="sd">    must have been processed with `broadband_snr_QC` or this function will</span>
<span class="sd">    return a null result.  The function makes a tacit assumption that all</span>
<span class="sd">    the members of this ensemble are in relative time with 0 of each member</span>
<span class="sd">    being an estimate of the P wave arrival time.  It does no tests to</span>
<span class="sd">    validate this assumption so the assumption is wrong you will, at best,</span>
<span class="sd">    get junk as output.</span>
<span class="sd">    :type ensemble: `TimeSeriesEnsemble`  Note for most uses this is the</span>
<span class="sd">    output of ExtractComponent of a `SeismogramEnsemble` processed with</span>
<span class="sd">    `broadband_snr_QC` that is the longitudinal component for the P phase.</span>
<span class="sd">    :param noise_window:  time window defining the section of each</span>
<span class="sd">    ensemble member that is to be treated as &quot;noise&quot; for estimating</span>
<span class="sd">    a relative noise level.</span>
<span class="sd">    :type noise_window:  `TimeWindow` tacitly expected to be time relative</span>
<span class="sd">    to a measure of the P wave arrival time.</span>
<span class="sd">    :param noise_metric:  vector norm metric to use for measuring the</span>
<span class="sd">    amplitude of the noise extracted from the data in the range defined by</span>
<span class="sd">    noise_window.</span>
<span class="sd">    :type noise_metric: string (Must be one of:  &quot;mad&quot; (default), &quot;rms&quot;,</span>
<span class="sd">    or &quot;peak&quot;).  Any other string will cause the function to throw a ValueError</span>
<span class="sd">    exception.</span>
<span class="sd">    :param initial_beam_metric:  key of attribute to extract from the</span>
<span class="sd">    output of `broadband_snr_QC` used to select initial beam signal.</span>
<span class="sd">    This argument is passed to the `extract_initial_beam_estimate` function for</span>
<span class="sd">    as the &quot;metric&quot; argument of that function.</span>
<span class="sd">    :param initial_beam_metric:  string (default &quot;bandwidth&quot;).  For a list of</span>
<span class="sd">    allowed values see the docstring of `extract_initial_beam_estimate`.</span>
<span class="sd">    :param snr_doc_key:  key to use to fetch the subdocument containing the</span>
<span class="sd">    output of `broadband_snr_QC`.</span>
<span class="sd">    :type snr_doc_key:  string (default &quot;Parrival&quot; which is the default of</span>
<span class="sd">    `broadband_snr_QC`).</span>
<span class="sd">    :param low_f_corner: force the low frequency corner for the output data</span>
<span class="sd">    bandwidth to this value.   When defined, the internal call to</span>
<span class="sd">    `estimate_ensemble_bandwidth` is bypassed and the output data are filtered</span>
<span class="sd">    between the value defined by low_f_corner and high_f_corner.</span>
<span class="sd">    :type low_f_corner:  float (default None which is interpreted to mean</span>
<span class="sd">    scan ensemble to estimate the frequency range)</span>
<span class="sd">    :param high_f_corner: force the high frequency corner for the output data</span>
<span class="sd">    bandwidth to this value.   When defined, the internal call to</span>
<span class="sd">    `estimate_ensemble_bandwidth` is bypassed and the output data are filtered</span>
<span class="sd">    between the value defined by low_f_corner and high_f_corner.</span>
<span class="sd">    :type high_f_corner:  float (default None which is interpreted to mean</span>
<span class="sd">    scan ensemble to estimate the frequency range)</span>
<span class="sd">    :param npoles:  number of poles to use for the Butterworth bandpass</span>
<span class="sd">    filter.</span>
<span class="sd">    :type npoles:  integer (default 4)</span>
<span class="sd">    :param set_phases: boolean that if set True (default) the P phase time s</span>
<span class="sd">    P, pP (if defined), and PP (if defined) are computed and posted to the</span>
<span class="sd">    output of each ensemble member.  If False the algorith assumes the</span>
<span class="sd">    same quantities were previously calculated and can be fetched from the</span>
<span class="sd">    member TimeSeries Metadata container using keys defined by Ptime_key,</span>
<span class="sd">    pPtimme_key, and PPtime_key.</span>
<span class="sd">    :param Ptime_key:</span>
<span class="sd">    :param pPtime_key:</span>
<span class="sd">    :param PPtime_key:  These three arguments define alternative keys that</span>
<span class="sd">    will be used to fetch (if set_phases is false) or post (if set_phases is True)</span>
<span class="sd">    computed P, pP, and PP times to each member&#39;s Metadata container.</span>
<span class="sd">    Changing any of these values not really advised when set_phases is True.</span>
<span class="sd">    These are most useful if the phase arrival times were previously</span>
<span class="sd">    computed or measured and posted with different keys.</span>
<span class="sd">    :param station_collection:   MonogDB collection name used to fetch</span>
<span class="sd">    receiver coordinate data.   Normal practice in MsPASS is to save</span>
<span class="sd">    receiver Metadata in two channels called &quot;channel&quot; and &quot;site&quot; and</span>
<span class="sd">    to load the coordinate data through normalization when the data are</span>
<span class="sd">    loaded.  The MsPASS convention defines data loaded by normalization</span>
<span class="sd">    with a leading collection name.  e.g. the &quot;lat&quot; value extracted from a</span>
<span class="sd">    &quot;channel&quot; document would be posted to the data as &quot;channel_lat&quot;.</span>
<span class="sd">    The same value, however, loaded from &quot;site&quot; would be tagged &quot;site_lat&quot;.</span>
<span class="sd">    The default for this argument is &quot;channel&quot; which means the algorithm</span>
<span class="sd">    will require the attributes &quot;channel_lat&quot; and &quot;channel_lon&quot; as the</span>
<span class="sd">    receiver coordinates (in degrees).  The standard alternative is to</span>
<span class="sd">    define `station_collection=&quot;site&quot;`, in which case the function will</span>
<span class="sd">    use &quot;site_lat&quot; and &quot;site_lon&quot;.</span>
<span class="sd">    :type station_collection:  string (default &quot;channel&quot;)</span>
<span class="sd">    :param search_window_fraction:   The window for defining the</span>
<span class="sd">    correlation window is determined by running the internal</span>
<span class="sd">    `_coda_duration` function on each ensemble member and computing the</span>
<span class="sd">    range from the median of the ranges computed from all the ensemble</span>
<span class="sd">    members.  Each coda search, however, is constrained by the time so f</span>
<span class="sd">    pP and/or PP.   As noted above the function uses the pP time for</span>
<span class="sd">    events with depths greater than 100 km but PP for shallow sources.</span>
<span class="sd">    To allow for hypocenter errors  the duration defined by</span>
<span class="sd">    P to pP or P to PP is multiplied by this factor to define the</span>
<span class="sd">    search start for the coda estimation.</span>
<span class="sd">    :type search_window_fraction: float (default 0.9)</span>
<span class="sd">    :param minimum_coda_duration:   if the estimate of coda duration</span>
<span class="sd">    computed internally is less than this value the correlation window</span>
<span class="sd">    is set to this value - relative time from P.</span>
<span class="sd">    :type minimum_coda_duration:  float (5.0 seconds)</span>
<span class="sd">    :param correlation_window_start:  the time of the correlation window</span>
<span class="sd">    set in the output &quot;beam&quot; is fixed as this value.   It is normally</span>
<span class="sd">    a negative number defining a time before P that no signal is likely to</span>
<span class="sd">    have an arrival before this relative time.</span>
<span class="sd">    :type correlation_window_start:  float (default -3.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;MCXcorPrepP&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  Illegal type=</span><span class="si">{}</span><span class="s2"> for arg0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ensemble</span><span class="p">))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a TimeSeriesEnsemble object&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">()]</span>

    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">TauPyModel</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;iasp91&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_window</span><span class="p">,</span> <span class="n">TimeWindow</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  Illegal type=</span><span class="si">{}</span><span class="s2"> for arg1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">noise_window</span><span class="p">))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a TimeWindow object&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># first sort out the issue of the passband to use for this</span>
    <span class="c1"># analysis.   Use kwargs if they are defined but otherwise assume</span>
    <span class="c1"># we extract what we need from the output of `broadband_snr_QC`.</span>
    <span class="c1"># effectively a declaration to keep these from going away when they</span>
    <span class="c1"># go out of scope</span>
    <span class="n">f_low</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">f_high</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">low_f_corner</span> <span class="ow">or</span> <span class="n">high_f_corner</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">low_f_corner</span> <span class="ow">and</span> <span class="n">high_f_corner</span><span class="p">:</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">low_f_corner</span>
            <span class="n">f_high</span> <span class="o">=</span> <span class="n">high_f_corner</span>
            <span class="k">if</span> <span class="n">f_high</span> <span class="o">&lt;=</span> <span class="n">f_low</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">alg</span>
                    <span class="o">+</span> <span class="s2">&quot;:  Inconsistent input.  low_f_corner=</span><span class="si">{}</span><span class="s2"> and high_f_corner=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">low_f_corner</span><span class="p">,</span> <span class="n">high_f_corner</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;low_f_corner value is greater than high_f_corner value&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">alg</span>
                <span class="o">+</span> <span class="s2">&quot;:  Inconsistent input.  low_f_corner=</span><span class="si">{}</span><span class="s2"> and high_f_corner=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">low_f_corner</span><span class="p">,</span> <span class="n">high_f_corner</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;If you specify one you must specify the other&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="p">[</span><span class="n">f_low</span><span class="p">,</span> <span class="n">f_high</span><span class="p">,</span> <span class="n">nused</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimate_ensemble_bandwidth</span><span class="p">(</span>
            <span class="n">ensemble</span><span class="p">,</span>
            <span class="n">snr_doc_key</span><span class="o">=</span><span class="n">snr_doc_key</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f_low</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">f_high</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;estimate_ensemble_bandwidth failed</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Either all members are dead or data were not previously processed with broadband_snr_QC&quot;</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">()]</span>

    <span class="n">enswork</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
        <span class="n">ensemble</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span>
        <span class="n">freqmin</span><span class="o">=</span><span class="n">f_low</span><span class="p">,</span>
        <span class="n">freqmax</span><span class="o">=</span><span class="n">f_high</span><span class="p">,</span>
        <span class="n">corners</span><span class="o">=</span><span class="n">npoles</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># using a list like this creates this odd construct but docstring (should at least) advise againtst</span>
    <span class="c1"># changing these</span>
    <span class="n">enswork</span><span class="p">[</span><span class="n">filter_parameter_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">f_low</span>
    <span class="n">enswork</span><span class="p">[</span><span class="n">filter_parameter_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">f_high</span>
    <span class="n">enswork</span><span class="p">[</span><span class="n">filter_parameter_keys</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">npoles</span>
    <span class="k">if</span> <span class="n">set_phases</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># this handles dead data so don&#39;t test for life</span>
            <span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_set_phases</span><span class="p">(</span>
                <span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">model</span><span class="p">,</span>
                <span class="n">Ptime_key</span><span class="o">=</span><span class="n">Ptime_key</span><span class="p">,</span>
                <span class="n">pPtime_key</span><span class="o">=</span><span class="n">pPtime_key</span><span class="p">,</span>
                <span class="n">PPtime_key</span><span class="o">=</span><span class="n">PPtime_key</span><span class="p">,</span>
                <span class="n">station_collection</span><span class="o">=</span><span class="n">station_collection</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">number_live</span><span class="p">(</span><span class="n">enswork</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;_set_phases killed all members of this ensemble</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;station_collection is probably incorrect or the data have not been normalized for source and receiver coordinates&quot;</span>
            <span class="n">enswork</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">enswork</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">enswork</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">()]</span>
    <span class="c1"># if set_phases is False we assume P, pP, and/or PP times were previously</span>
    <span class="c1"># set.   First make sure all data are in relative time with 0 as P time.</span>
    <span class="c1"># kill any datum for which P is not defined</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">Ptime_key</span><span class="p">):</span>
                <span class="n">Ptime</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">Ptime_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">time_is_relative</span><span class="p">():</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">rtoa</span><span class="p">()</span>
                <span class="n">d</span><span class="o">.</span><span class="n">ator</span><span class="p">(</span><span class="n">Ptime</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Required key=</span><span class="si">{}</span><span class="s2"> defining P arrival time is not defined</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">Ptime_key</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Cannot process this datum without a P wave time value&quot;</span>
                <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

    <span class="c1"># now get coda durations and set the correlation window as median of</span>
    <span class="c1"># the coda durations</span>
    <span class="n">coda_duration</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># coda estimates are placed here</span>
    <span class="n">search_range</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># use this to set ranges - duration limited to min of these</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">enswork</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">sr</span> <span class="o">=</span> <span class="n">_get_search_range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">sr</span> <span class="o">*=</span> <span class="n">search_window_fraction</span>
            <span class="n">search_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span>
            <span class="c1"># compute a noise estimate without being too dogmatic about</span>
            <span class="c1"># window range</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span> <span class="o">&lt;</span> <span class="n">noise_window</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="n">nw</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">noise_window</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nw</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">noise_window</span><span class="p">)</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nw</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">nw</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span><span class="p">)</span>
            <span class="c1"># silently skip any datum for which the WindowData algorithm fails</span>
            <span class="c1"># can happen if the noise window does not overlap with data</span>
            <span class="k">if</span> <span class="n">nd</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">noise_metric</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
                <span class="n">namp</span> <span class="o">=</span> <span class="n">RMSAmplitude</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">noise_metric</span> <span class="o">==</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span>
                <span class="n">namp</span> <span class="o">=</span> <span class="n">PeakAmplitude</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># silently default to MAD - maybe should log an error to ensemble or throw an exception</span>
                <span class="n">namp</span> <span class="o">=</span> <span class="n">MADAmplitude</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
            <span class="n">coda_window</span> <span class="o">=</span> <span class="n">_coda_duration</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">coda_level_factor</span><span class="p">,</span> <span class="n">search_start</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
            <span class="c1"># silently drop any retun value less than the floor defined</span>
            <span class="c1"># by minimum_coda_duration</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">coda_window</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">coda_window</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">duration</span> <span class="o">&gt;</span> <span class="n">minimum_coda_duration</span><span class="p">:</span>
                <span class="n">coda_duration</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coda_duration</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Calculation of correlation window from the envelop of filtered ensemble members failed</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;No data detected with signal level in the passband above the floor value=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">coda_level_factor</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;noise_window range or value of floor value are likely inconsistent with the data</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Killing this ensemble&quot;</span>
        <span class="n">enswork</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="n">enswork</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">enswork</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">()]</span>
    <span class="n">correlation_window_endtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">coda_duration</span><span class="p">)</span>  <span class="c1"># relative time</span>
    <span class="n">min_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">search_range</span><span class="p">)</span>
    <span class="n">min_range</span> <span class="o">*=</span> <span class="n">search_window_fraction</span>
    <span class="k">if</span> <span class="n">correlation_window_endtime</span> <span class="o">&gt;</span> <span class="n">min_range</span><span class="p">:</span>
        <span class="n">correlation_window_endtime</span> <span class="o">=</span> <span class="n">min_range</span>

    <span class="n">beam0</span> <span class="o">=</span> <span class="n">extract_initial_beam_estimate</span><span class="p">(</span>
        <span class="n">enswork</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="n">initial_beam_metric</span><span class="p">,</span>
        <span class="n">subdoc_key</span><span class="o">=</span><span class="n">snr_doc_key</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">beam0</span><span class="p">[</span><span class="s2">&quot;correlation_window_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_window_start</span>
    <span class="n">beam0</span><span class="p">[</span><span class="s2">&quot;correlation_window_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_window_endtime</span>
    <span class="c1"># finally use the low frequency band limit to set a default range</span>
    <span class="c1"># for the robust window</span>
    <span class="n">rw</span> <span class="o">=</span> <span class="n">_compute_default_robust_window</span><span class="p">(</span><span class="n">f_low</span><span class="p">)</span>
    <span class="c1"># fudge this one sample to avoid a roundoff error on starttime computations</span>
    <span class="n">beam0</span><span class="p">[</span><span class="s2">&quot;robust_window_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_window_start</span> <span class="o">+</span> <span class="n">beam0</span><span class="o">.</span><span class="n">dt</span>
    <span class="c1"># make sure the end isn&#39;t larger than the correlation window end</span>
    <span class="k">if</span> <span class="n">rw</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">correlation_window_endtime</span><span class="p">:</span>
        <span class="n">beam0</span><span class="p">[</span><span class="s2">&quot;robust_window_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rw</span><span class="o">.</span><span class="n">end</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># similar fudge by one sample for endtime</span>
        <span class="n">beam0</span><span class="p">[</span><span class="s2">&quot;robust_window_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correlation_window_endtime</span> <span class="o">-</span> <span class="n">beam0</span><span class="o">.</span><span class="n">dt</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">enswork</span><span class="p">,</span> <span class="n">beam0</span><span class="p">]</span></div>


<div class="viewcode-block" id="dbxcor_weights"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.dbxcor_weights">[docs]</a><span class="k">def</span> <span class="nf">dbxcor_weights</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">residual_norm_floor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the robust weights used originally in dbxcor for each</span>
<span class="sd">    member of ensemble.   Result is returned in a parallel numpy</span>
<span class="sd">    array (i.e. return[i] is computed weight for ensemble.member[i])</span>

<span class="sd">    This function is made for speed and has no safeties.  It assumes</span>
<span class="sd">    all the members of ensemble are the same and it is the same length</span>
<span class="sd">    as stack.  It will throw an exception if that is violated so callers</span>
<span class="sd">    should guarantee that does not happen.</span>

<span class="sd">    This function adds a feature not found in the original Pavlis and Vernon(2011)</span>
<span class="sd">    paper via the `residual_norm_floor` argument.   Experience with this algorithm</span>
<span class="sd">    showed it tends to converge to a state with very high weights on one or two</span>
<span class="sd">    signals and low weights on the rest.   The high weights are given to the</span>
<span class="sd">    one or two signals most closely matching the stack at convergence.  This</span>
<span class="sd">    has the undesirable effect of causing a strong initial value dependence</span>
<span class="sd">    and suboptimal noise reduction.  This argument handles that by not allowing</span>
<span class="sd">    the L2 norm of the residual to fall below a floor computed from the</span>
<span class="sd">    ratio ||r||/||d||.   i.e. if ||r|| &lt; residual_norm_floor*||d|| it is</span>
<span class="sd">    set to the value passed as `residual_norm_floor`.  Note that setting</span>
<span class="sd">    this to 1.0 effectively turns off the residual norm term in the</span>
<span class="sd">    weight equation which I now recognize is the cross-correlation of the</span>
<span class="sd">    beam and datum at zero lag.  That is true, however, only if the</span>
<span class="sd">    ensemble members are all time aligned perfectly.</span>

<span class="sd">    Returns a numpy vector of weights.  Any dead data will have a weight of</span>
<span class="sd">    -1.0 (test for negative is sufficient).  In addition the function has a</span>
<span class="sd">    safety to handle receiving a vector of all zeros.  If the function detects</span>
<span class="sd">    all 0s for a datum marked live it will silently return a weight of 0</span>
<span class="sd">    for that datum.</span>

<span class="sd">    :param ensemble:  `TimeSeriesEnsemble` of data from which weights are to</span>
<span class="sd">    be computed.</span>
<span class="sd">    :type ensemble:  Assumed to be a `TimeSeriesEnsemble`.  No type checking</span>
<span class="sd">    is done so if input is wrong an exception will occur but what is thown</span>
<span class="sd">    will depend on what ensemble actually is.</span>
<span class="sd">    :param stack:  TimeSeries containing stack to be used to compute weights.</span>
<span class="sd">    The method returns robust weights relative to the vector of data in</span>
<span class="sd">    this object.</span>
<span class="sd">    :type stack:  `TimeSeries`.</span>
<span class="sd">    :param residual_norm_floor:  nondimensional floor in the ratio norm2(r)/norm2(d)</span>
<span class="sd">    used as described above.  Default is 0.1 which is reasonable for high snr</span>
<span class="sd">    signals.   Data with irregular quality can profit from smaller values of this parameter.</span>
<span class="sd">    :type residual_norm_floor:  float</span>
<span class="sd">    :return: numpy vector of weights parallel with ensemble.member.  Dead</span>
<span class="sd">    members will have a negative weight in this vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_floor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="n">stack</span><span class="o">.</span><span class="n">npts</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="c1"># Scale the scack vector to be a unit vector</span>
    <span class="n">s_unit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">nrm_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">s_unit</span> <span class="o">/=</span> <span class="n">nrm_s</span>
    <span class="n">N_s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_unit</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N_d</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">npts</span>
            <span class="k">if</span> <span class="n">N_d</span> <span class="o">==</span> <span class="n">N_s</span><span class="p">:</span>
                <span class="n">d_dot_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">s_unit</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">d_dot_stack</span> <span class="o">*</span> <span class="n">s_unit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># handle off by one errors silently</span>
                <span class="c1"># with usage here should that is possible but larger differences are not likely</span>
                <span class="n">N2use</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N_d</span><span class="p">,</span> <span class="n">N_s</span><span class="p">)</span>
                <span class="n">d_dot_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">],</span> <span class="n">s_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">])</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_dot_stack</span> <span class="o">*</span> <span class="n">s_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">]</span>

            <span class="n">nrm_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">nrm_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nrm_d</span> <span class="o">&lt;</span> <span class="n">norm_floor</span><span class="p">:</span>
                <span class="c1"># this is a test for all zeros</span>
                <span class="c1"># Give zero weight in this situation</span>
                <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="n">nrm_r</span> <span class="o">/</span> <span class="n">nrm_d</span> <span class="o">&lt;</span> <span class="n">residual_norm_floor</span><span class="p">:</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">residual_norm_floor</span> <span class="o">*</span> <span class="n">nrm_d</span> <span class="o">*</span> <span class="n">nrm_d</span>
                <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d_dot_stack</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
            <span class="c1"># this attempts to duplicate dbxcor</span>
            <span class="c1"># if nrm_r &lt; norm_floor or nrm_d &lt; norm_floor or abs(d_dot_stack) &lt; norm_floor:</span>
            <span class="c1">#    wts[i] = residual_norm_floor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">nrm_r</span> <span class="o">*</span> <span class="n">nrm_d</span>
                <span class="c1"># dbxcor has logic to avoid an nan from a machine 0</span>
                <span class="c1"># denom.  Not needed her because of conditional chain here</span>
                <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d_dot_stack</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="c1"># rescale weights so largest is 1 - easier to understand</span>
    <span class="n">maxwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wts</span><span class="p">)</span>
    <span class="n">wts</span> <span class="o">/=</span> <span class="n">maxwt</span>
    <span class="k">return</span> <span class="n">wts</span></div>


<div class="viewcode-block" id="regularize_ensemble"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.regularize_ensemble">[docs]</a><span class="k">def</span> <span class="nf">regularize_ensemble</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">pad_fraction_cutoff</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeriesEnsemble</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Secondary function to regularize an ensemble for input to robust</span>
<span class="sd">    stacking algorithm.  ASsumes all data have the same sample rate.</span>
<span class="sd">    Uses WindowData to assumre all data are inside the common</span>
<span class="sd">    range startime:endtime.  Silently drops dead data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ensout</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">(</span><span class="n">Metadata</span><span class="p">(</span><span class="n">ensemble</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ensout</span><span class="o">.</span><span class="n">elog</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">t0</span> <span class="o">-</span> <span class="n">starttime</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">dt</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">endtime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">dt</span>
            <span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">WindowData_autopad</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">starttime</span><span class="p">,</span>
                    <span class="n">endtime</span><span class="p">,</span>
                    <span class="n">pad_fraction_cutoff</span><span class="o">=</span><span class="n">pad_fraction_cutoff</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Dropped member number </span><span class="si">{}</span><span class="s2"> because undefined data range exceeded limit of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">pad_fraction_cutoff</span>
                    <span class="p">)</span>
                    <span class="n">ensout</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ensout</span><span class="o">.</span><span class="n">member</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Dropped member number </span><span class="si">{}</span><span class="s2"> that was marked dead on input&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ensout</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;regularize_ensemble&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensout</span><span class="o">.</span><span class="n">member</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ensout</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ensout</span></div>


<div class="viewcode-block" id="robust_stack"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.robust_stack">[docs]</a><span class="k">def</span> <span class="nf">robust_stack</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dbxcor&quot;</span><span class="p">,</span>
    <span class="n">stack0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stack_md</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">timespan_method</span><span class="o">=</span><span class="s2">&quot;ensemble_inner&quot;</span><span class="p">,</span>
    <span class="n">pad_fraction_cutoff</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
    <span class="n">residual_norm_floor</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic function for robust stacking live members of a `TimeSeriesEnsemble`.</span>
<span class="sd">    An optional initial stack estimate can be used via tha stack0 argument.</span>
<span class="sd">    The function currently supports two methods:  &quot;median&quot; for a median</span>
<span class="sd">    stack and &quot;dbxcor&quot; to implement the robust loss function</span>
<span class="sd">    used in the dbxcor program defined in Pavlis and Vernon (2010).</span>
<span class="sd">    Other algorithms could easily be implemented via this same api</span>
<span class="sd">    by adding an option for the &quot;method&quot; argument.</span>

<span class="sd">    All robust estimators I am aware of that use some form of penalty</span>
<span class="sd">    function (e.g. m-estimators or the dbxcor penalty function) require</span>
<span class="sd">    an initial estimator for the stack.  They do that because the</span>
<span class="sd">    penalty function is defined from a metric of residuals relative to</span>
<span class="sd">    the current estimate of center.   The median, however, does not</span>
<span class="sd">    require an initial estimator which complicates the API for this function.</span>
<span class="sd">    For the current options understand that stack0 is required for</span>
<span class="sd">    the dbxcor algorithm but will be ignored if median is requested.</span>

<span class="sd">    The other complication of this function is handling of potential</span>
<span class="sd">    irregular time ranges of the ensemble input and how to set the</span>
<span class="sd">    time range for the output.   The problem is further complicated by</span>
<span class="sd">    use in an algorithm like `align_and_stack` in this module where</span>
<span class="sd">    the data can get shifted to have undefined data within the</span>
<span class="sd">    time range the data aims to utilize.   The behavior of the</span>
<span class="sd">    algorithm for this issue is controlled by the kwarg values</span>
<span class="sd">    with the keys &quot;timespan_method&quot; and &quot;pad_fraction_cutoff&quot;.</span>
<span class="sd">    As the name imply &quot;timespan_method&quot; defines how the time span</span>
<span class="sd">    for the stack should be defined.   The following options</span>
<span class="sd">    are supported:</span>

<span class="sd">    &quot;stack0&quot; - sets the time span to that of the input</span>
<span class="sd">    `TimeSeries` passed as stack0.  i.e. the range is set to</span>
<span class="sd">    stack0.dt to stack0.endtime().</span>

<span class="sd">    &quot;ensemble_inner&quot; - (default) use the range defined by the &quot;inner&quot; method</span>
<span class="sd">    for computing the range with the function `ensemble_time_range`.</span>
<span class="sd">    (see `ensemble_time_range` docstring for the definition).</span>

<span class="sd">    &quot;ensemble_outer&quot; - use the range defined by the &quot;outer&quot; method</span>
<span class="sd">    for computing the range with the function `ensemble_time_range`.</span>
<span class="sd">    (see `ensemble_time_range` docstring for the definition).</span>

<span class="sd">    &quot;ensemble_median&quot; -  use the range defined by the &quot;median&quot; method</span>
<span class="sd">    for computing the range with the function `ensemble_time_range`.</span>
<span class="sd">    (see `ensemble_time_range` docstring for the definition).</span>

<span class="sd">    These interact with the value passed via &quot;fractional_mismatch_level&quot;.</span>
<span class="sd">    When the time range computed is larger than the range of a particular</span>
<span class="sd">    member of the input ensemble this parameter determines whether or not</span>
<span class="sd">    the member will be used in the stack.  If the fraction of</span>
<span class="sd">    undefined samples (i.e. N_undefined/Nsamp) is greater than this cutoff</span>
<span class="sd">    that datum will be ignored.   Otherwise if there are undefined</span>
<span class="sd">    values they will be zero padded.</span>

<span class="sd">    :param ensemble:   input data to be stacked.   Should all be in</span>
<span class="sd">        relative time with all members having the same relative time span.</span>
<span class="sd">    :type ensemble:  TimeSeriesEnsemble</span>
<span class="sd">    :param method: Defines a name string of the method to be used to</span>
<span class="sd">        compute the stack.</span>
<span class="sd">    :type method:  string.  Currently must be one of two values or the</span>
<span class="sd">        function will abort:   &quot;median&quot; or &quot;dbxcor&quot;.  As the names imply</span>
<span class="sd">        &quot;median&quot; will cause the function to return the median of the sample</span>
<span class="sd">        vectors while &quot;dbxcor&quot; applies the dbxcor method.</span>
<span class="sd">    :param stack0:  optional initial estimate for stack.  Estimators</span>
<span class="sd">        other than median I know of use a loss function for downweighting</span>
<span class="sd">        members of the stack that do not match the stack as defined by</span>
<span class="sd">        some misfit metric.   This argument can be used to input an optional</span>
<span class="sd">        starting estimate of the stack for the dbxcor method.  By default it</span>
<span class="sd">        uses the median as the starting point, but this can be used to</span>
<span class="sd">        input something else.   Note the function will silently ignore this</span>
<span class="sd">        argument if method == &quot;median&quot;.</span>
<span class="sd">    :type stack0:  TimeSeries.   Note the time span of this optional input</span>
<span class="sd">        must be the same or wider than the ensemble member range defined by</span>
<span class="sd">        the (internal to this module) validate_ensemble function or the</span>
<span class="sd">        return will be return as a copy of this TimeSeries marked dead.</span>
<span class="sd">        Default for this argument is None which means the median will be</span>
<span class="sd">        used for the initial stack for dbxcor</span>
<span class="sd">    :param stack_md:   optional Metadata container to define the</span>
<span class="sd">        content of the stack output.  By default the output will have only</span>
<span class="sd">        Metadata that duplicate required internal attributes (e.g. t0 and npts).</span>
<span class="sd">        An exception is if stack0 is used the Metadata of that container will</span>
<span class="sd">        be copied and this argument will be ignored.</span>
<span class="sd">    :type stack_md:  Metadata container or None.  If stack0 is defined</span>
<span class="sd">        this argument is ignored.   Otherwise it should be used to add</span>
<span class="sd">        whatever Metadata is required to provide a tag that can be used to</span>
<span class="sd">        identify the output.  If not specified the stack Metadata</span>
<span class="sd">        will be only those produce from default construction of a</span>
<span class="sd">        TimeSeries.  That is almost never what you want.   Reiterate,</span>
<span class="sd">        however, that if stack0 is defined the output stack will be a</span>
<span class="sd">        clone of stack0 with possible modifications of time and data</span>
<span class="sd">        range attributes and anything the stack algorithm posts.</span>
<span class="sd">    :param residual_norm_floor: floor on residuals used to compute dbxcor weight</span>
<span class="sd">        function.  See docstring for `dbxcor_weights` for details.  Ignored</span>
<span class="sd">        unless method is &quot;dbxcor&quot;</span>
<span class="sd">    :type residual_norm_floor:   float (default 0.01)</span>
<span class="sd">    :return:  tuple containing the requested stack as component 0.  The</span>
<span class="sd">        stack is returned as a `TimeSeries`  with optional Metadata copied</span>
<span class="sd">        from the (optional) stack_md argument.   Component 1 is defined only</span>
<span class="sd">        for the dbxcor method in which case it a numpy array containing th e</span>
<span class="sd">        robust weights returned by the dbxcor algorithm.  If the method is</span>
<span class="sd">        set to &quot;median&quot; component 1 will be returned as a None type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;robust_stack&quot;</span>
    <span class="c1"># if other values for method are added they need to be added here</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;dbxcor&quot;</span><span class="p">]:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  Illegal value for argument method=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Currently must be either median or dbxcor&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="c1"># don&#39;t test type - if we get illegal type let it thro0w an exception</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="n">d_bad</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Received an input ensemble marked dead - cannot compute a stack&quot;</span>
        <span class="n">d_bad</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="c1"># this isn&#39;t currently required by better to be explicit</span>
        <span class="n">d_bad</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d_bad</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">timespan_method</span> <span class="o">==</span> <span class="s2">&quot;stack0&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">stack0</span><span class="p">:</span>
            <span class="c1"># intentionally don&#39;t test type of stack0</span>
            <span class="c1"># if not a TimeSeries this will throw an exception</span>
            <span class="n">timespan</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">stack0</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">stack0</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  usage error</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;timespan_method was set to stack0 but the stack0 argument is None</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;stack0 must be a TimeSeries to use this option&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">timespan_method</span> <span class="o">==</span> <span class="s2">&quot;ensemble_inner&quot;</span><span class="p">:</span>
        <span class="n">timespan</span> <span class="o">=</span> <span class="n">ensemble_time_range</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">timespan_method</span> <span class="o">==</span> <span class="s2">&quot;ensemble_outer&quot;</span><span class="p">:</span>
        <span class="n">timespan</span> <span class="o">=</span> <span class="n">ensemble_time_range</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">timespan_method</span> <span class="o">==</span> <span class="s2">&quot;ensemble_median&quot;</span><span class="p">:</span>
        <span class="n">timespan</span> <span class="o">=</span> <span class="n">ensemble_time_range</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  illegal value for argument timespan_method=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">timespan_method</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># below we clone common stuff form member[0] if ensemble</span>
    <span class="c1"># that is safe only because this function guarantees member 0 is not dead</span>
    <span class="c1"># or irregular</span>
    <span class="c1"># TODO:   removing this for a test - I don&#39;t think this is needed with a</span>
    <span class="c1"># change in the algorithm.  If that proves true remove this function</span>
    <span class="c1"># from this module and remove this comment and the call to regularize_ensemble</span>
    <span class="c1"># ensemble = regularize_ensemble(</span>
    <span class="c1">#    ensemble, timespan.start, timespan.end, pad_fraction_cutoff</span>
    <span class="c1"># )</span>
    <span class="c1"># the above can remove some members</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">number_live</span><span class="p">(</span><span class="n">ensemble</span><span class="p">)</span>
    <span class="n">M_e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="c1"># can now assume they are all the same length and don&#39;t need to worry about empty ensembles</span>
    <span class="c1"># N = ensemble.member[0].npts</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">timespan</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">stack0</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">WindowData_autopad</span><span class="p">(</span>
            <span class="n">stack0</span><span class="p">,</span>
            <span class="n">timespan</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">timespan</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
            <span class="n">pad_fraction_cutoff</span><span class="o">=</span><span class="n">pad_fraction_cutoff</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">stack</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Received an initial stack estimate with time range inconsistent with data</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Recovery not implemented - stack returned is invalid&quot;</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;robust_stack&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">stack</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># bit of a weird logic here - needed because we need option for</span>
        <span class="c1"># dbxcor method to use median stack as starting point or use</span>
        <span class="c1"># the input via stack0.  This does that in what is admittedly a confusing way</span>
        <span class="c1">#</span>
        <span class="c1"># Also this is a bit of a weird trick using inheritance to construct a</span>
        <span class="c1"># TimeSeries object for stack using an uncommon constructor.</span>
        <span class="c1"># The actual constructor wants a BasicTimeSeries and Metadata as</span>
        <span class="c1"># arg0 and arg1.   A TimeSeries is a sublass of BasicTimeSeries so this</span>
        <span class="c1"># resolves.  Note the conditional is needed as None default for</span>
        <span class="c1"># stack_md would abort</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stack_md</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">stack_md</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start</span>
            <span class="c1"># this works because we can assume ensemble is not empty and clean</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span>
        <span class="c1"># Make sure the stack has the same time base as the input</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">tref</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tref</span>
        <span class="c1"># Always compute the median stack as a starting point</span>
        <span class="c1"># that was the algorithm of dbxcor and there are good reasons for it</span>
        <span class="n">data_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">])</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M_e</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">timespan</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                    <span class="n">timespan</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># this makes this bombproof.  Subject otherwise to</span>
                <span class="c1"># subsample t0 rounding ambiguity</span>
                <span class="n">N2use</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
                <span class="n">data_matrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N2use</span><span class="p">])</span>
                <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stack_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">stack_vector</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">set_live</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">stack</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># since method can only be median or dbxcor at this point this</span>
        <span class="c1"># block is exectuted only when method==&quot;dbxcor&quot;</span>
        <span class="c1"># this works because _dbxcor returns a tuple of the right form</span>
        <span class="k">return</span> <span class="n">_dbxcor_stacker</span><span class="p">(</span>
            <span class="n">ensemble</span><span class="p">,</span>
            <span class="n">stack</span><span class="p">,</span>
            <span class="n">residual_norm_floor</span><span class="o">=</span><span class="n">residual_norm_floor</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_dbxcor_stacker</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">stack0</span><span class="p">,</span>
    <span class="n">eps</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="n">maxiterations</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">residual_norm_floor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs the dbxcor robust stacking algorithm on `enemble` with initial</span>
<span class="sd">    stack estimate stack0.</span>
<span class="sd">    Returns a tuple with the stack as component 0 and a numpy vector</span>
<span class="sd">    of the final robust weights as component 1.</span>

<span class="sd">    This function is intended to be used only internally in this module</span>
<span class="sd">    as it has no safties and assumes ensemble and stack0 are what it expects.</span>

<span class="sd">    :param ensemble:  TimeSeriesEnsemble assumed to have constant data</span>
<span class="sd">    range and sample interval and not contain any dead data.</span>
<span class="sd">    :param stack0:  TimeSeries of initial stack estimate - assumed to have</span>
<span class="sd">    same data vector length as all ensemble members.</span>
<span class="sd">    :param eps:  relative norm convergence criteria.  Stop iteration when</span>
<span class="sd">    norm(delta stack data)/norm(stack.data)&lt;eps.</span>
<span class="sd">    :param maxiterations:  maximum number of iterations (default 20)</span>
<span class="sd">    :param residual_norm_floor: floor on residuals used to compute dbxcor weight</span>
<span class="sd">    function.  See docstring for `dbxcor_weights` for details.</span>
<span class="sd">    :type residual_norm_floor:   float (default 0.01)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">stack0</span><span class="p">)</span>
    <span class="c1"># useful shorthands</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">stack0</span><span class="o">.</span><span class="n">npts</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="n">wts</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># needed to keep this symbol from going out of scope before return</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiterations</span><span class="p">):</span>
        <span class="c1"># this requires stack0 not be altered in this function</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">dbxcor_weights</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">stack0</span><span class="p">,</span> <span class="n">residual_norm_floor</span><span class="o">=</span><span class="n">residual_norm_floor</span><span class="p">)</span>
        <span class="c1"># newstack = np.zeros(N)</span>
        <span class="c1"># this is just a fast way to initalize to 0s</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">set_npts</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">sumwts</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">wts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">*=</span> <span class="n">wts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">stack</span> <span class="o">+=</span> <span class="n">d</span>
                <span class="n">sumwts</span> <span class="o">+=</span> <span class="n">wts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sumwts</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sumwts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;all ensemble members are dead - cannot compute a stack&quot;</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;_dbxcor_stacker&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">stack</span><span class="p">,</span> <span class="n">wts</span><span class="p">]</span>
        <span class="c1"># newstack /= sumwts</span>
        <span class="c1"># order may matter here.  In this case delta becomes a numpy</span>
        <span class="c1"># array which is cleaner in this context</span>
        <span class="c1"># delta = newstack - stack.data</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">stack</span> <span class="o">-</span> <span class="n">stack0</span>
        <span class="n">relative_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">stack0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># normalize by sample size or there is a window length dependency</span>
        <span class="n">relative_delta</span> <span class="o">/=</span> <span class="n">N</span>
        <span class="c1"># update stack here so if we break loop we don&#39;t have to repeat</span>
        <span class="c1"># this copying.  Force one iteration to make this a do-while loop</span>
        <span class="c1"># newstack is a numpy vector so this cast is necesary</span>
        <span class="n">stack0</span> <span class="o">=</span> <span class="n">stack</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">relative_delta</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">stack</span><span class="p">,</span> <span class="n">wts</span><span class="p">]</span>


<div class="viewcode-block" id="beam_align"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.beam_align">[docs]</a><span class="k">def</span> <span class="nf">beam_align</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_shift_limit</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aligns ensemble members using signal defined by beam (arg1) argument.</span>

<span class="sd">    Computes cross correlation between each ensemble member and the beam.</span>
<span class="sd">    An optional window can be specified that is applied to each ensemble</span>
<span class="sd">    member before computing the cross correlation function.</span>
<span class="sd">    All live ensemble members are shifted to align with time base of the</span>
<span class="sd">    beam.   Note that can be a huge shift if the beam is relative and</span>
<span class="sd">    the ensemble members are absolute time.  It should work in that context</span>
<span class="sd">    but the original context was aligning common-source gathers for</span>
<span class="sd">    teleseismic phase alignment where the expectation is all the ensemble</span>
<span class="sd">    members and the beam are in relative time with 0 defined by some</span>
<span class="sd">    estimate of the phase arrival time.   Will correctly handle irregular</span>
<span class="sd">    window sizes between ensemble members and beam signal.</span>

<span class="sd">    It is important to recognize that if the window option is used</span>
<span class="sd">    it is applied only internally.   In that situation the output</span>
<span class="sd">    will be time shifted but the number of samples of each member</span>
<span class="sd">    will be the same.</span>

<span class="sd">    :param ensemble:  ensemble of data to be correlated with</span>
<span class="sd">        beam data.</span>
<span class="sd">    :type ensemble:  assumed to be a TimeSeriesEnsemble</span>
<span class="sd">    :param beam:  common signal to correlate with ensemble members.</span>
<span class="sd">    :type beam:  assumed to be a TimeSeries object</span>
<span class="sd">    :param window:  optional window to apply to ensemble members</span>
<span class="sd">        before computing cross correlation.</span>
<span class="sd">    :type window:  :py:class:`mspasspy.ccore.algorithms.basic.TimeWindow`</span>
<span class="sd">    :param time_shift_limit:  ceiling on allowed time shift for</span>
<span class="sd">        ensemble members.   Any computed shift with absolute value</span>
<span class="sd">        larger than this value will be reset to this value with the</span>
<span class="sd">        sign of the shift preserved.   (i.e. a negative lag will</span>
<span class="sd">        be set to the negative of this number).  The default is 10.0</span>
<span class="sd">        which is large for most data more or less making this an optional</span>
<span class="sd">        parameter.</span>
<span class="sd">    :type time_shift_limit: float (may abort if you use an int</span>
<span class="sd">        because the value can to sent to a C++ method that it type</span>
<span class="sd">        sensitive)</span>
<span class="sd">    :return:   copy of ensemble with the members time shifted to align with</span>
<span class="sd">        the time base of beam.   Note if a window is defined it is not</span>
<span class="sd">        applied to the ensemble members.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this may not be necessary for internal use but if used</span>
    <span class="c1"># externally it is necessary to avoid mysterious results</span>
    <span class="c1"># we don&#39;t test ensemble or beam because exceptions are</span>
    <span class="c1"># guaranteed in that case that should allow problem solving</span>
    <span class="k">if</span> <span class="n">time_shift_limit</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;beam_align:  illegal value time_shift_limit=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">time_shift_limit</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;value must be positive&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># in this context not needed but tiny cost for robustness</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
                    <span class="c1"># this should rarely if ever happen but safety prudent</span>
                    <span class="c1"># in this case the return will have  truncated length for this datum</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="k">continue</span>
            <span class="n">timelag</span> <span class="o">=</span> <span class="n">_xcor_shift</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">)</span>
            <span class="c1"># apply a ceiling/floor to allowed time shift via</span>
            <span class="c1"># the time_shift_limit arg</span>
            <span class="k">if</span> <span class="n">timelag</span> <span class="o">&gt;</span> <span class="n">time_shift_limit</span><span class="p">:</span>
                <span class="n">timelag</span> <span class="o">=</span> <span class="n">time_shift_limit</span>
            <span class="k">elif</span> <span class="n">timelag</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="n">time_shift_limit</span><span class="p">):</span>
                <span class="n">timelag</span> <span class="o">=</span> <span class="o">-</span><span class="n">time_shift_limit</span>
            <span class="c1"># We MUST use this method instead of dithering t0 to keep</span>
            <span class="c1"># absolute time right.  This will fail if the inputs were</span>
            <span class="c1"># not shifted from UTC times</span>
            <span class="c1"># also note a +lag requires a - shift</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">timelag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ensemble</span></div>


<div class="viewcode-block" id="align_and_stack"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.align_and_stack">[docs]</a><span class="k">def</span> <span class="nf">align_and_stack</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">beam</span><span class="p">,</span>
    <span class="n">correlation_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">correlation_window_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;correlation_window_start&quot;</span><span class="p">,</span> <span class="s2">&quot;correlation_window_end&quot;</span><span class="p">],</span>
    <span class="n">window_beam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">robust_stack_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">robust_stack_window_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;robust_window_start&quot;</span><span class="p">,</span> <span class="s2">&quot;robust_window_end&quot;</span><span class="p">],</span>
    <span class="n">robust_stack_method</span><span class="o">=</span><span class="s2">&quot;dbxcor&quot;</span><span class="p">,</span>
    <span class="n">use_median_initial_stack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">output_stack_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">robust_weight_key</span><span class="o">=</span><span class="s2">&quot;robust_stack_weight&quot;</span><span class="p">,</span>
    <span class="n">time_shift_key</span><span class="o">=</span><span class="s2">&quot;arrival_time_correction&quot;</span><span class="p">,</span>
    <span class="n">time_shift_limit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
    <span class="n">abort_irregular_sampling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">convergence</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">residual_norm_floor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">demean_residuals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function uses an initial estimate of the array stack passed as</span>
<span class="sd">    the `beam` argument as a seed to a robust algorithm that will</span>
<span class="sd">    align all the data in the input ensemble by cross-correlation with</span>
<span class="sd">    the beam, apply a robust stack to the aligned signals, update the</span>
<span class="sd">    beam with the robust stack, and repeat until the changes to the</span>
<span class="sd">    beam signal are small.   Returns a copy of the ensemble time</span>
<span class="sd">    shifted to be aligned with beam time base and an updated beam</span>
<span class="sd">    estimate crated by the robust stack.  The shifts and the weights</span>
<span class="sd">    of each input signal are stored in the Metadata of each live ensemble</span>
<span class="sd">    member returned with keys defined by `robust_weight_key` and</span>
<span class="sd">    `time_shift_key`.</span>

<span class="sd">    This function is a python implementation of the same basic</span>
<span class="sd">    algorithm used in the dbxcor program described by</span>
<span class="sd">    Pavlis and Vernon(2010) Array Processing of teleseismic body waves</span>
<span class="sd">    with the USArray, Computers and Geosciences,15, 910-920.</span>
<span class="sd">    It has additional options made possible by the python interface</span>
<span class="sd">    and integration into MsPASS.  In particular, the original algorithm</span>
<span class="sd">    was designed to work as part of a GUI where the user had to pick</span>
<span class="sd">    a set of required parameters for the algorithm.   In this function</span>
<span class="sd">    those are supplied through Metadata key-value pairs and/or arguments.</span>
<span class="sd">    This function uses a pythonic approach aimed to allow this function</span>
<span class="sd">    to be run in batch without user intervention.  The original dbxcor</span>
<span class="sd">    algorithm required four interactive picks to set the input.</span>
<span class="sd">    The way we set them for this automated algorithm is described in the</span>
<span class="sd">    following four itemize paragraphs:</span>

<span class="sd">        1.  The &quot;correlation window&quot;, which is the waveform segment</span>
<span class="sd">            used to compute cross-correlations between the beam and all</span>
<span class="sd">            ensmebled members, is set one of three ways.  The default</span>
<span class="sd">            uses the time window defined by the starttime and endtime of</span>
<span class="sd">            the `beam` signal as the cross-correlation window.</span>
<span class="sd">            Alternative, this window can be specified either by</span>
<span class="sd">            fetching values from the `Metadata` container of beam</span>
<span class="sd">            or via the `correlation_window` argument.   The algorithm</span>
<span class="sd">            first tests if `correlation_window` is set and is an</span>
<span class="sd">            instance of a `TimeWindow` object.   If the type of</span>
<span class="sd">            the argument is not a `TimeWindow` object an error is logged</span>
<span class="sd">            and the program reverts to using the span of the beam</span>
<span class="sd">            signal as the correlation window.   If `correlation_window`</span>
<span class="sd">            is a None (default) the algorithm then checks for a valid</span>
<span class="sd">            input via the `correlation_window_keys` argument.  If</span>
<span class="sd">            defined that argument is assumed to contain a pair of strings</span>
<span class="sd">            that can be used as keys to fetch start (component 0)</span>
<span class="sd">            and end times (component 1) from the Metadata container of</span>
<span class="sd">            the TimeSeries objct passed via beam. For example,</span>
<span class="sd">            ```</span>
<span class="sd">               correlation_window_keys = [&#39;correlation_start&#39;,&#39;correlation_end&#39;]</span>
<span class="sd">            ```</span>
<span class="sd">            would cause the function to attempt to fetch the</span>
<span class="sd">            start time with &quot;correlation_start&quot; and end time with</span>
<span class="sd">            &quot;correlation_end&quot;.  In the default both `correlation_window`</span>
<span class="sd">            and `correlation_window_keys` are None which cause the</span>
<span class="sd">            function to silently use the window defined as</span>
<span class="sd">            [beam.t0, beam.endtime()] as the correlation winow.</span>
<span class="sd">            If the optional boolean `window_beam` argument is set True</span>
<span class="sd">            the function will attempt to window the beam using a range</span>
<span class="sd">            input via either of the optional methods of setting the</span>
<span class="sd">            correlation window.  An error is logged and nothing happens if</span>
<span class="sd">            `window_beam` is set True and the default use of the beam</span>
<span class="sd">            window is being used.</span>
<span class="sd">        2.  The &quot;robust window&quot; is a concept used in dbxcor to</span>
<span class="sd">            implement a special robust stacking algorithm that is a novel</span>
<span class="sd">            feature of the dbxcor algorithm.   It uses a very aggresssive</span>
<span class="sd">            weighting scheme to downweight signals that do not match the</span>
<span class="sd">            beam.  The Pavlis and Vernon paper shows examples of how this</span>
<span class="sd">            algorithm can cleanly handle ensembles with a mix of high</span>
<span class="sd">            signal-to-noise data with pure junk and produce a clean</span>
<span class="sd">            stack that is defined.   Note recent experience has shown</span>
<span class="sd">            that with large, consistent ensembles the dbxcor robust</span>
<span class="sd">            estimate tends to converge to the focus on the signal closestbeam_correlation</span>
<span class="sd">            to the median stack.  The reason is that the median stack</span>
<span class="sd">            is always used as the initial estimator.   Hence, it can</span>
<span class="sd">            be thought of as a median stack that uses the full data</span>
<span class="sd">            set more completely.</span>
<span class="sd">        3.  dbxcor required the user to pick a seed signal to use as</span>
<span class="sd">            the initial beam estimate.  That approach is NOT used here</span>
<span class="sd">            but idea is to have some estimate passed to the algorithm</span>
<span class="sd">            via the beam (arg1) argument.  In MsPASS the working model</span>
<span class="sd">            is to apply the  broadband_snr_QC function to the data before</span>
<span class="sd">            running this function and select the initial seed (beam) from</span>
<span class="sd">            one or more of the computed snr metrics.   In addition,</span>
<span class="sd">            with this approach I envision a two-stage computation where</span>
<span class="sd">            the some initial seed is used for a first pass.   The</span>
<span class="sd">            return is then used to revise the correlation window by</span>
<span class="sd">            examining stack coherence metrics and then rerunning the</span>
<span class="sd">            algorithm.   The point is it is a research problem for</span>
<span class="sd">            different types of data to know how to best handle the</span>
<span class="sd">            align and stack problem.</span>
<span class="sd">        4.  dbxcor had a final stage that required picking the arrival time</span>
<span class="sd">            to use as the reference from the computed beam trace.  That is</span>
<span class="sd">            actually necessary if absolute times are needed because the</span>
<span class="sd">            method used will be biased by the time shift of the beam</span>
<span class="sd">            relative to the reference time.   See the Pavlis and Vernon</span>
<span class="sd">            paper for more on this topic.   The idea here is that if</span>
<span class="sd">            absolute times are needed some secondary processing will be used</span>
<span class="sd">            to manually or automatically pick an arrival time from the</span>
<span class="sd">            beam output.</span>

<span class="sd">    This function does some consistency checking of arguments to handle</span>
<span class="sd">    the different modes for handling the correlation and robust windows</span>
<span class="sd">    noted above.  It also applies a series of validation tests on the</span>
<span class="sd">    input ensemble before attempting to run.  Any of the following will</span>
<span class="sd">    cause the return to be a dead ensemble with an explanation in the</span>
<span class="sd">    elog container of the ensemble (in these situation the stack is an</span>
<span class="sd">    empty `TimeSeries` container):</span>
<span class="sd">        1.  Irregular sample intervals of live data.</span>
<span class="sd">        2.  Any live data with the time reference set to UTC</span>
<span class="sd">        3.  Inconsistency of the time range of the data and the</span>
<span class="sd">            time windows parsed for the correlation and robust windows.</span>
<span class="sd">            That is, it checks the time span of all member functions and</span>
<span class="sd">            if the time range of all members (min of start time and maximum end times).</span>
<span class="sd">            is not outside (inclusive) the range of the correlation and robust</span>
<span class="sd">            windows it is viewed as invalid.</span>
<span class="sd">        4.  What we called the &quot;robust window&quot; in the dbxcor paper isextract_input_beam_estimate</span>
<span class="sd">            required to be inside (inclusive of endpoints) the cross-correlation window</span>
<span class="sd">            time window.   That could be relaxed but is a useful constraint because</span>
<span class="sd">            in my (glp) experience the most coherent part of phase arrivals is the</span>
<span class="sd">            first few cycles of the phase that is also the part cross-correlation</span>
<span class="sd">            needs to contain if it is to be stable.   The &quot;robust window&quot; should</span>
<span class="sd">            be set to focus on the section of the signal that will have the most</span>
<span class="sd">            coherent stack.</span>
<span class="sd">    There is a further complexity in the iteration sequence used by this algorithm</span>
<span class="sd">    for any robust stack method.  That is, time shifts computed by cross-correlation</span>
<span class="sd">    can potentially move the correlation window outside the bounds of the</span>
<span class="sd">    data received as input.   To reduce the impact of that potential problem</span>
<span class="sd">    the function has an optional argument called `time_shift_limit`</span>
<span class="sd">    that is validated against other inputs.   In particular, the function</span>
<span class="sd">    computes the average start and end time (keep in mind the assumption is the</span>
<span class="sd">    time base is time relative to the arrival time a particular phase)</span>
<span class="sd">    of the input ensemble.   If the difference between the average start time</span>
<span class="sd">    and the correlation window start time is less than `time_shift_limit`</span>
<span class="sd">    the input is viewed as problematic.   How that is handled depends on how</span>
<span class="sd">    the correlation window is set.  If it is received as constant</span>
<span class="sd">    (`correlation_window` argument) an exception will be thrown to abort</span>
<span class="sd">    the entire job.   It that window is extracted from the beam TimeSeries</span>
<span class="sd">    Metadata container a complaint is logged to the outputs.  An</span>
<span class="sd">    endtime inconsistency is treated the same way.  i.e. it is treated as</span>
<span class="sd">    a problem if the average ensemble endtime - the correlation window</span>
<span class="sd">    endtime is less than the `time_shift_limit`.</span>

<span class="sd">    A related issue is that arrival times estimated by this algorithm</span>
<span class="sd">    will be biased by the model mismatch with whatever signal was used</span>
<span class="sd">    as the initial beam estimae.  In dbxcor that was handled by forcing</span>
<span class="sd">    the user to manually pick the first arrival of the computed stack.</span>
<span class="sd">    That could be done if desired but would require you to devise a scheme</span>
<span class="sd">    to do that picking.   The default here is handled by the boolean</span>
<span class="sd">    parameter demean_residuals.  When True (the default) the vector</span>
<span class="sd">    of computed time shifts is corrected by the mean value of the group.</span>
<span class="sd">    Note that is common practice in regional tomography inversion anyway.</span>
<span class="sd">    For reasonable sized ensembles it will tend to yield data that when</span>
<span class="sd">    aligned by arrival time are all close to 0 relative time.</span>

<span class="sd">    Note the output stack normally spans a different time range than</span>
<span class="sd">    either the correlation or robust windows.   That property is defined</span>
<span class="sd">    by the `output_stack_window` argument.  See below for details.</span>

<span class="sd">    :param ensemble:   ensemble of data to be aligned and stacked.</span>
<span class="sd">        This function requires all data to be on a relative time base.</span>
<span class="sd">        It will throw a MsPASSError exception if any live datum has a UTC time base.</span>
<span class="sd">        The assumption is all data have a time span that have the correlation</span>
<span class="sd">        and robust windows inside the data time range.   Both windows are</span>
<span class="sd">        carved from the inputs using the WindowData function which will kill</span>
<span class="sd">        any members that do not satisfy this requirement.</span>
<span class="sd">    :type ensemble:  `TimeSeriesEnsemble` with some fairly rigid requirements.</span>
<span class="sd">        (see above)</span>
<span class="sd">    :param beam:  Estimate of stack (may be just one representative member)</span>
<span class="sd">        used as the seed for initial alignment and stacking.</span>
<span class="sd">    :type beam:  `TimeSeries`.  Must have a length consistent with window</span>
<span class="sd">        parameters.</span>
<span class="sd">    :param correlation_window: Used to specify the time window for</span>
<span class="sd">        computing cross-correlations with the beam signal.   Closely linked to</span>
<span class="sd">        `correlation_window_keys` as described above.</span>
<span class="sd">    :type correlation_window:  `TimeWindow` to define explicitly.  If None</span>
<span class="sd">        (default) uses the recipe driven by `correlation_window_keys` (see above)</span>
<span class="sd">    :param correlation_window_keys:   optional pair of Metadata keys used to</span>
<span class="sd">        extract cross-correlation window attributes from beam Metadata container.</span>
<span class="sd">        If defined component 0 is taken as the key for the start time of the window and</span>
<span class="sd">        component 1 the key for the end time.</span>
<span class="sd">    :type correlation_window_key:  iterable list containing two strings.</span>
<span class="sd">        Default is None which is taken to mean the span of the beam signal defines</span>
<span class="sd">        the cross-correlation window.</span>
<span class="sd">    :param window_beam:  if True (default) the parsed cross-correlation window attributes</span>
<span class="sd">        are applied to the beam signal as well as the data before starting</span>
<span class="sd">        processing.   If False the beam signal is used directly in all cross-correlations.</span>
<span class="sd">        Set False only if you can be sure secondary phases are not present in the</span>
<span class="sd">        unwindowed input.</span>
<span class="sd">    :param robust_stack_window: Provide an explicity `TimeWindow` used for</span>
<span class="sd">        extracting the robust window for this algorithm.   Interacts with the</span>
<span class="sd">        robust_stack_window_keys argument as described above.</span>
<span class="sd">    :type robust_stack_window:  If defined must be a `TimeWindow` object.</span>
<span class="sd">        If a None type (default) use the logic defined above to set this time window.</span>
<span class="sd">    :param robust_stack_window_keys: specifies a pair of strings to be used</span>
<span class="sd">        as keys to extract the strart time (component 0) and end time (component 1)</span>
<span class="sd">        of the robust time window to use from the beam `TimeSeries.</span>
<span class="sd">    :type robust_stack_window_keys: iterable list of two strings</span>
<span class="sd">    :param output_stack_window:  optional `TimeWindow` to apply to the</span>
<span class="sd">        computed robust stack output.   Default returns a stack spanning the</span>
<span class="sd">        inner range of all live members of the ensemble.</span>
<span class="sd">    :type output_stack_window:  `TimeWindow` object.  If None (default) the range</span>
<span class="sd">        is derived from the ensemble member time ranges.</span>
<span class="sd">    :param robust_weight_key:  The robust weight used for each member to</span>
<span class="sd">        compute the robust stack output is posted to the Metadata container of</span>
<span class="sd">        each live member with this key.</span>
<span class="sd">    :type robust_weight_key:  string</span>
<span class="sd">    :param robust_stack_method:   keyword defining the method textract_input_beam_estimateo use for</span>
<span class="sd">        computing the robust stack.  Currently accepted value are:</span>
<span class="sd">        &quot;dbxcor&quot; (default) and &quot;median&quot;.</span>
<span class="sd">    :type robust_stack_method:  string  - must be one of options listed above.</span>
<span class="sd">    :param use_median_initial_stack:  If True (default) use the median stack as the initial</span>
<span class="sd">        estimate of the stack in the first iterative pass.  When False the signal in the</span>
<span class="sd">        `TimeSeries` passed via the &quot;beam&quot; argument is used for the initial estimate.</span>
<span class="sd">    :param time_shift_key:  the time shift applied relative to the starting</span>
<span class="sd">        point is posted to each live member with this key.  It is</span>
<span class="sd">        IMPORTANT to realize this is the time for this pass.  If thisextract_input_beam_estimatefunctions</span>
<span class="sd">        is applied more than once and you reuse this key the shift from the</span>
<span class="sd">        previous run will be overwritten.  If you need to accumulate shifts</span>
<span class="sd">        it needs to be handled outside this function.</span>
<span class="sd">    :type time_shift_key:  string  (default &quot;arrival_time_correction&quot;)</span>
<span class="sd">    :param convergence:   fractional change in robust stack estimates in</span>
<span class="sd">        iterative loop to define convergence.  This should not be changed</span>
<span class="sd">        unless you deeply understand the algorithm.</span>
<span class="sd">    :type convergence:  real number (default 0.001)</span>
<span class="sd">    :param time_shift_limit: when time shifting data with the cross</span>
<span class="sd">        correlation algorithm any estimated time shift larger than</span>
<span class="sd">        this value will be truncated to this value with the sign</span>
<span class="sd">        of th shift preserved.</span>
<span class="sd">    :type time_shift_limit:  float</span>
<span class="sd">    :param  abort_irregular_sampling: boolean that controls error</span>
<span class="sd">        handling of data with irregular sample rates.  This function uses</span>
<span class="sd">        a generous test for sample rate mismatch.  A mismatch is</span>
<span class="sd">        detected only if the computed time skew over the time span of</span>
<span class="sd">        the input beam signal is more than 1/2 of the beam sample interval</span>
<span class="sd">        (beam.dt).  When set true the function will</span>
<span class="sd">        abort with a ValueError exception if any ensemble member fails the</span>
<span class="sd">        sample interval test.  If False (the default) offending ensemble</span>
<span class="sd">        members are killed and a message is posted.  Note the actual</span>
<span class="sd">        ensemble is modified so the return may have fewer data live</span>
<span class="sd">        than the input when this mode is enabled.</span>
<span class="sd">    :type abort_irregular_sampling:  boolean</span>
<span class="sd">    :param residual_norm_floor: floor on residuals used to compute dbxcor weight</span>
<span class="sd">        function.  See docstring for `dbxcor_weights` for details.</span>
<span class="sd">    :type residual_norm_floor:   float (default 0.01)</span>
<span class="sd">    :param demean_residuals: boolean controlling if the computed shifts</span>
<span class="sd">        are corrected with a demean operation.   Default is True which</span>
<span class="sd">        means the set of all time shifts computed by this function will</span>
<span class="sd">        have zero mean.</span>

<span class="sd">    :return: tuple with 0 containing the original ensemble but time</span>
<span class="sd">        shifted by cross-correlation.   Failed/discarded signals for the</span>
<span class="sd">        stack are not killed but should be detected by not having the</span>
<span class="sd">        time shift Metadata value set.   component 1 is the computed</span>
<span class="sd">        stack windowed to the range defined by `stack_time_window`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;align_and_stack&quot;</span>
    <span class="c1"># xcor ensemble has the initial start time posted to each</span>
    <span class="c1"># member using this key - that content goes away because</span>
    <span class="c1"># xcorens has function scope</span>
    <span class="n">it0_key</span> <span class="o">=</span> <span class="s2">&quot;_initial_t0_value_&quot;</span>
    <span class="n">ensemble_index_key</span> <span class="o">=</span> <span class="s2">&quot;_ensemble_i0_&quot;</span>
    <span class="c1"># maximum iterations.  could be passed as an argument but I have</span>
    <span class="c1"># never seen this algorithm not converge in 20 interation</span>
    <span class="n">MAXITERATION</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="c1"># Enformce types of ensemble and beam</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">TimeSeriesEnsemble</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  illegal type for arg0 (ensemble) = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ensemble</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a TimeSeriesEnsemble&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  illegal type for arg1 (beam) = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">beam</span><span class="p">)))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be a TimeSeries&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;ensemble was marked live but beam input was marked dead - cannot process this ensemble&quot;</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
    <span class="n">ensemble</span> <span class="o">=</span> <span class="n">regularize_sampling</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nsamp</span><span class="o">=</span><span class="n">beam</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
    <span class="c1"># we need to make sure this is part of a valid set of algorithms</span>
    <span class="k">if</span> <span class="n">robust_stack_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;dbxcor&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Invalid value for robust_stack_method=</span><span class="si">{}</span><span class="s2">.  See docstring&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">robust_stack_method</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="c1"># This section implements the somewhat complex chain of options for</span>
    <span class="c1"># setting the correlation window</span>
    <span class="n">xcor_window_is_defined</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># needed for parsing logic below</span>
    <span class="c1"># when this value is True window constraint errors cause the beam returned to be killed</span>
    <span class="c1"># with error messages.   If set in parsers to False an exception is thrown</span>
    <span class="c1"># as in that situation both windows would be set as arguments and the function would</span>
    <span class="c1"># always fail</span>
    <span class="n">windows_extracted_from_metadata</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">correlation_window</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correlation_window</span><span class="p">,</span> <span class="n">TimeWindow</span><span class="p">):</span>
            <span class="n">xcorwin</span> <span class="o">=</span> <span class="n">correlation_window</span>
            <span class="n">xcor_window_is_defined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">windows_extracted_from_metadata</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal type for correlation_window=</span><span class="si">{}</span><span class="s2">\m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">correlation_window</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;For this option must be a TimeWindow object&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">correlation_window_keys</span><span class="p">:</span>
        <span class="c1"># this is a bit dogmatic - I know there is a less restrictive</span>
        <span class="c1"># test than this</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">correlation_window_keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">skey</span> <span class="o">=</span> <span class="n">correlation_window_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ekey</span> <span class="o">=</span> <span class="n">correlation_window_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">skey</span><span class="p">)</span> <span class="ow">and</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ekey</span><span class="p">):</span>
                <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">skey</span><span class="p">]</span>
                <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">ekey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message0</span> <span class="o">=</span> <span class="s2">&quot;missing one or both of correlation_window_keys</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">skey</span><span class="p">):</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">skey</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">message0</span>
                        <span class="o">+</span> <span class="s2">&quot;start time key=</span><span class="si">{}</span><span class="s2"> is not set in beam signal</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">skey</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;reverting to beam signal start time&quot;</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ekey</span><span class="p">):</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">ekey</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">message0</span>
                        <span class="o">+</span> <span class="s2">&quot;end time key=</span><span class="si">{}</span><span class="s2"> is not set in beam signal</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ekey</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;reverting to beam signal endtime() method output&quot;</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
            <span class="n">xcorwin</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
            <span class="n">xcor_window_is_defined</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal type=</span><span class="si">{}</span><span class="s2"> for correlation_window_keys argument</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">correlation_window_keys</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;If defined must be a list with 2 component string used as keys&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># it isn&#39;t considered an error to land here as this is actually the default</span>
        <span class="c1"># note it is important in the logic that xcor_window_is_defined be</span>
        <span class="c1"># left false</span>
        <span class="n">xcorwin</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
        <span class="n">windows_extracted_from_metadata</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">xcor_window_is_defined</span> <span class="ow">and</span> <span class="n">window_beam</span><span class="p">:</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
            <span class="n">beam</span><span class="p">,</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;truncate&quot;</span>
        <span class="p">)</span>
        <span class="c1"># this shouldn&#39;t happen but requires an exit if it did</span>
        <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
    <span class="c1"># now a simpler logic to handle robust window</span>
    <span class="k">if</span> <span class="n">robust_stack_window</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">robust_stack_window</span><span class="p">,</span> <span class="n">TimeWindow</span><span class="p">):</span>
            <span class="n">rwin</span> <span class="o">=</span> <span class="n">robust_stack_window</span>
            <span class="n">windows_extracted_from_metadata</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal type for robust_stack_window=</span><span class="si">{}</span><span class="s2">\m&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">robust_stack_window</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;when using robust_stack_window option value passed must be a TimeWindow object&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">robust_stack_window_keys</span><span class="p">:</span>
        <span class="c1"># this is a bit dogmatic - I know there is a less restrictive</span>
        <span class="c1"># test than this</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">robust_stack_window_keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">skey</span> <span class="o">=</span> <span class="n">robust_stack_window_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ekey</span> <span class="o">=</span> <span class="n">robust_stack_window_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">skey</span><span class="p">)</span> <span class="ow">and</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ekey</span><span class="p">):</span>
                <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">skey</span><span class="p">]</span>
                <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">ekey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;missing one or both of robust_stack_window_keys</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">skey</span><span class="p">):</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">skey</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;start time key=</span><span class="si">{}</span><span class="s2"> is not set in beam signal</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">skey</span>
                    <span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;reverting to beam signal start time&quot;</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
                    <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span>
                <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ekey</span><span class="p">):</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">ekey</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;endtime key=</span><span class="si">{}</span><span class="s2"> is not set in beam signal</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ekey</span><span class="p">)</span>
                    <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;reverting to beam signal endtime() method output&quot;</span>
                    <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
                    <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
            <span class="n">rwin</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal type=</span><span class="si">{}</span><span class="s2"> for robust_stack_window_keys argument</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">robust_stack_window_keys</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;If defined must be a list with 2 component string used as keys&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Must specify either a value for robust_stack_window or robust_stack_window_keys - both were None&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># Validate the ensemble</span>
    <span class="c1">#  First verify the robust window is inside the correlation window (inclusive of edges)</span>
    <span class="c1"># reset to xcor range limits if wrong</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rwin</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Cross correlation window and robust window intervals are not consistent</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="s2">&quot;Cross-correlation window:  </span><span class="si">{}</span><span class="s2">-&gt;</span><span class="si">{}</span><span class="s2">.   Robust window:  </span><span class="si">{}</span><span class="s2">-&gt;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="s2">&quot;Robust window interval should be within bounds of correlation window</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">rwin</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="n">rwin</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span>
        <span class="k">if</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="n">rwin</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Robust window set to range </span><span class="si">{}</span><span class="s2">-&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

        <span class="n">beam</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
    <span class="n">ensemble_timespan</span> <span class="o">=</span> <span class="n">ensemble_time_range</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ensemble_timespan</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="n">ensemble_timespan</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Correlation window defined is not consistent with input ensemble</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Estimated ensemble time span is </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">ensemble_timespan</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ensemble_timespan</span><span class="o">.</span><span class="n">end</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Correlation window time span is </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">xcorwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">xcorwin</span><span class="o">.</span><span class="n">end</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Correlation window range must be inside the data range&quot;</span>
        <span class="c1"># we don&#39;t use the windows_extracted_from_metadata boolean and never throw</span>
        <span class="c1"># an exception in this case because data range depends upon each ensemble</span>
        <span class="c1"># so there is not always fail case</span>
        <span class="n">beam</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="n">beam</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
    <span class="c1"># need this repeatedly so set it</span>
    <span class="n">N_members</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="c1"># We need this Metadata posted to sort out total time</span>
    <span class="c1"># shifts needed for arrival time estimates</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_members</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_double</span><span class="p">(</span><span class="n">it0_key</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>

    <span class="c1"># above guarantees this cannot return a dead datum</span>
    <span class="n">rbeam0</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
    <span class="n">nrm_rbeam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rbeam0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAXITERATION</span><span class="p">):</span>
        <span class="n">ensemble</span> <span class="o">=</span> <span class="n">beam_align</span><span class="p">(</span>
            <span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">xcorwin</span><span class="p">,</span> <span class="n">time_shift_limit</span><span class="o">=</span><span class="n">time_shift_limit</span>
        <span class="p">)</span>
        <span class="n">rens</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rwin</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
        <span class="c1"># this clones the Metadata of beam for the output using the stack_md</span>
        <span class="c1"># parameter - this won&#39;t work without that because of how robust stack</span>
        <span class="c1"># is implemented.  Note also that not passing an initial stack value</span>
        <span class="c1"># with the dbxcor method forces a median stack as the starting point</span>
        <span class="n">rbeam</span><span class="p">,</span> <span class="n">wts</span> <span class="o">=</span> <span class="n">robust_stack</span><span class="p">(</span>
            <span class="n">rens</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">robust_stack_method</span><span class="p">,</span>
            <span class="n">residual_norm_floor</span><span class="o">=</span><span class="n">residual_norm_floor</span><span class="p">,</span>
            <span class="n">timespan_method</span><span class="o">=</span><span class="s2">&quot;ensemble_median&quot;</span><span class="p">,</span>
            <span class="n">stack_md</span><span class="o">=</span><span class="n">Metadata</span><span class="p">(</span><span class="n">rbeam0</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">delta_rbeam</span> <span class="o">=</span> <span class="n">rbeam</span> <span class="o">-</span> <span class="n">rbeam0</span>
        <span class="n">nrm_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta_rbeam</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrm_delta</span> <span class="o">/</span> <span class="n">nrm_rbeam</span> <span class="o">&lt;</span> <span class="n">convergence</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># this updates the always longer beam signal for correlation</span>
        <span class="c1"># use rbeam is used for convergence testing</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">_update_xcor_beam</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">robust_stack_method</span><span class="p">,</span> <span class="n">wts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;all members were killed in robust stack estimation loop</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Stack estimation failed&quot;</span>
            <span class="n">beam</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>
        <span class="n">rbeam0</span> <span class="o">=</span> <span class="n">rbeam</span>
        <span class="n">nrm_rbeam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rbeam0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">MAXITERATION</span><span class="p">:</span>
        <span class="n">beam</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;robust_stack iterative loop did not converge&quot;</span>
        <span class="n">beam</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">beam</span><span class="p">]</span>

    <span class="c1"># apply time shifts to original ensemble that we will return</span>
    <span class="c1"># and set the value for the attribute defined by &quot;time_shift_key&quot;</span>
    <span class="c1"># argument.   This has to be done here so we can properly cut the</span>
    <span class="c1"># window to be stacked</span>
    <span class="c1">#</span>
    <span class="c1"># first remove the average time shift if requested to get more</span>
    <span class="c1"># rational arrival times - otherwise will be biased by initial beam time</span>
    <span class="k">if</span> <span class="n">demean_residuals</span><span class="p">:</span>
        <span class="n">allshifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="n">initial_starttime</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">it0_key</span><span class="p">]</span>
                <span class="n">tshift</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t0</span> <span class="o">-</span> <span class="n">initial_starttime</span>
                <span class="n">allshifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tshift</span><span class="p">)</span>
        <span class="n">tshift_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">allshifts</span><span class="p">)</span>
        <span class="c1"># debug</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying average time shift of &quot;</span><span class="p">,</span> <span class="n">tshift_mean</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="c1"># this method alters the t0 values of the ensemble members</span>
                <span class="c1"># when used plots will tend to be aligned with 0 relative time</span>
                <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">tshift_mean</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="c1"># in this context it0_key should always be defined</span>
            <span class="c1"># intentionally let it throw and exception if that assumption</span>
            <span class="c1"># is wrong as it implies a bug</span>
            <span class="n">initial_starttime</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">it0_key</span><span class="p">]</span>
            <span class="n">tshift</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t0</span> <span class="o">-</span> <span class="n">initial_starttime</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put_double</span><span class="p">(</span><span class="n">time_shift_key</span><span class="p">,</span> <span class="n">tshift</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">output_stack_window</span><span class="p">:</span>
        <span class="c1"># this will clone the beam trace metadata automaticallyextract_input_beam_estimate</span>
        <span class="c1"># using pad option assures t0 will be output_stack_window.start</span>
        <span class="c1"># and npts is consistent with window requested</span>
        <span class="n">output_stack</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
            <span class="n">beam</span><span class="p">,</span>
            <span class="n">output_stack_window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">output_stack_window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
            <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># this is an obscure but fast way to initialize the data vector to all 0s</span>
        <span class="n">output_stack</span><span class="o">.</span><span class="n">set_npts</span><span class="p">(</span><span class="n">output_stack</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># also clones beam metadata but in this case we get the size from the ensemble time span</span>
        <span class="n">output_stack</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
        <span class="n">output_stack_window</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">ensemble_timespan</span><span class="p">)</span>
        <span class="n">output_stack</span><span class="o">.</span><span class="n">set_t0</span><span class="p">(</span><span class="n">output_stack_window</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">output_stack_window</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">output_stack_window</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">beam</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">output_stack</span><span class="o">.</span><span class="n">set_npts</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">robust_stack_method</span> <span class="o">==</span> <span class="s2">&quot;dbxcor&quot;</span><span class="p">:</span>
        <span class="c1"># We need to post the final weights to all live members</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="n">dbxcor_weights</span><span class="p">(</span><span class="n">rens</span><span class="p">,</span> <span class="n">rbeam</span><span class="p">,</span> <span class="n">residual_norm_floor</span><span class="o">=</span><span class="n">residual_norm_floor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">robust_weight_key</span><span class="p">,</span> <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">wts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># this private function is used for forming the longer xcor beam but it works in this</span>
    <span class="c1"># context the same way.  The only difference is the output_stack will normally be longer</span>
    <span class="c1"># than the signal used for cross-correlation</span>
    <span class="n">output_stack</span> <span class="o">=</span> <span class="n">_update_xcor_beam</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">output_stack</span><span class="p">,</span> <span class="n">robust_stack_method</span><span class="p">,</span> <span class="n">wts</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ensemble</span><span class="p">,</span> <span class="n">output_stack</span><span class="p">]</span></div>


<span class="c1"># these are intended to use only on the output from align_and stack</span>
<div class="viewcode-block" id="beam_correlation"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.beam_correlation">[docs]</a><span class="k">def</span> <span class="nf">beam_correlation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes normalized peak cross-correlation value a datum with an array stack.</span>

<span class="sd">    Cross-correlation is a heavily used concept in seismology.   This function</span>
<span class="sd">    is a specialized version designed to compute a peak cross correlation</span>
<span class="sd">    value between a datum and an array stack.  The normal use is to call this</span>
<span class="sd">    function in a loop and post the results to each live member of the</span>
<span class="sd">    ensemble used to compute the beam.   Note it is assumed beam and d</span>
<span class="sd">    are filtered in the same passband.   Windowing is bombproof</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="n">beam_correlation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;:  arg0 must be a TimeSeries. Actual type=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;:  arg0 must be a TimeSeries. Actual type=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">beam</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="c1"># assume beam is live but don&#39;t assume d is</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">window</span><span class="p">:</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
    <span class="n">nrm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">d1</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">nrm1</span>
    <span class="n">nrm2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">d2</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">nrm2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">aligned</span><span class="p">:</span>
        <span class="n">timelag</span> <span class="o">=</span> <span class="n">_xcor_shift</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
        <span class="n">d1</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">timelag</span><span class="p">)</span>
    <span class="n">t0max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">d2</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
    <span class="n">etmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">endtime</span><span class="p">(),</span> <span class="n">d2</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
    <span class="n">d1s</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">t0max</span><span class="p">)</span>
    <span class="n">d2s</span> <span class="o">=</span> <span class="n">d2</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">t0max</span><span class="p">)</span>
    <span class="n">d1e</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">etmin</span><span class="p">)</span>
    <span class="n">d2e</span> <span class="o">=</span> <span class="n">d2</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">etmin</span><span class="p">)</span>
    <span class="c1"># this may not be necessary but with rounding errors it could be needed</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1e</span> <span class="o">-</span> <span class="n">d1s</span><span class="p">,</span> <span class="n">d2e</span> <span class="o">-</span> <span class="n">d2s</span><span class="p">)</span>
    <span class="n">xcor_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">],</span> <span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xcor_0</span><span class="p">)</span></div>


<div class="viewcode-block" id="beam_coherence"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.beam_coherence">[docs]</a><span class="k">def</span> <span class="nf">beam_coherence</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute time-domain coherence of a datum relative to the stack.</span>

<span class="sd">    Time domain coherence is a measure of misfit between a signal and a</span>
<span class="sd">    a reference signal (normally a stack).   The formula is</span>
<span class="sd">    1.0 - norm(residual)/norm(beam) where residual=d-beam.</span>

<span class="sd">    This function has an optional window parameter that computes the</span>
<span class="sd">    coherence with a specified time window.  By default the entire</span>
<span class="sd">    d and beam signals are used.   The default is done cautiously by</span>
<span class="sd">    using windowing to the mininum overlap of the two signals (if they differ)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="n">beam_correlation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;:  arg0 must be a TimeSeries. Actual type=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;:  arg0 must be a TimeSeries. Actual type=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">beam</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="c1"># assume beam is live but don&#39;t assume d is</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">()</span> <span class="ow">or</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">et</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">endtime</span><span class="p">(),</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
    <span class="c1"># Making a blatant assumption d and beam are on the same time base here</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
    <span class="c1"># return 0 immediately if the data vector is all zeros</span>
    <span class="n">nrmd1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nrmd1</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="c1"># make d2 a unit vector</span>
    <span class="n">nrmd2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nrmd2</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nrmd2</span>
    <span class="c1"># this may not be necessary but more robust - assumes window can</span>
    <span class="c1"># return inconsistent lengths due to subsample rounding issue</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">d2</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">],</span> <span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">*=</span> <span class="n">amp</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>
    <span class="n">coh</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">nrmd1</span>
    <span class="k">if</span> <span class="n">coh</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">coh</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">coh</span></div>


<div class="viewcode-block" id="amplitude_relative_to_beam"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.amplitude_relative_to_beam">[docs]</a><span class="k">def</span> <span class="nf">amplitude_relative_to_beam</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">normalize_beam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute and return amplitude relative to the stack (beam).</span>

<span class="sd">    dbxcor computed a useful metric of amplitude relative to the beam</span>
<span class="sd">    (stack) as `(d dot beam)/N` where &quot;dot&quot; means vector dot product with</span>
<span class="sd">    between the sample vectbeam_coherence(d,beam,window=None,filter=True)ors of b and beam and N is vector size.   The formula</span>
<span class="sd">    requires the beam to be normalized so its L2 norm is 1.  By default it assumes</span>
<span class="sd">    that but that can be overriden with the normalize_beam argument.</span>
<span class="sd">    Default assumes d and beam cover the same time span.  If they aren&#39;t</span>
<span class="sd">    the minimum overlap of the two signals is used.</span>

<span class="sd">    :param d:  datum for which the relative amplitude is to be computed.</span>
<span class="sd">    :type d:  `TimeSeries` assumed - will throw an exception if it isn&#39;t</span>
<span class="sd">    :param beam:  stack with which it is to be compared.</span>
<span class="sd">    :type beam:  `TimeSeries` assumed  - will throw an exception if it isn&#39;t</span>
<span class="sd">    :param normalize_beam:   If True (default) the windowed beam vector</span>
<span class="sd">       will be normalized to be a unit vector (i.e. L2 norm of 1.0) for</span>
<span class="sd">       the calculation.  If False that will not be done and the vector</span>
<span class="sd">       in beam will be used directly.   Use False ONLY if windowing is off</span>
<span class="sd">       and beam is already normalized.   A minor efficiency gain is possible</span>
<span class="sd">       if beam is already normalized.</span>
<span class="sd">    :type normalize_beam:  boolean</span>

<span class="sd">    :return:  float value of amplitude.  A negative number indicates an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">()</span> <span class="ow">or</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="n">et</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">endtime</span><span class="p">(),</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
    <span class="c1"># Making a blatant assumption d and beam are on the same time base here</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize_beam</span><span class="p">:</span>
        <span class="n">nrm_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nrm_beam</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">d2</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nrm_beam</span>

    <span class="c1"># careful of subsample t0 value causing an off by one roundoff problem</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">d2</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">],</span> <span class="n">d2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_time"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.phase_time">[docs]</a><span class="k">def</span> <span class="nf">phase_time</span><span class="p">(</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">phase_time_key</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span> <span class="n">time_shift_key</span><span class="o">=</span><span class="s2">&quot;arrival_time_correction&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small generic function to return a UTC arrival time combining an initial arrival</span>
<span class="sd">    time estimate (normally a model based time) defined by the &quot;phase_time_key&quot;</span>
<span class="sd">    metadata value extracted from d and the time shift computed by align_and_stack</span>
<span class="sd">    (or any other algorithm that computes relative time shifts) and set with the</span>
<span class="sd">    Metadata key defined by the &quot;time_shift_key&quot; argment.  The defaults work for</span>
<span class="sd">    P phase times computed by `MCXcorPrepP` and shifts computed by</span>
<span class="sd">    `align_and_stack`.   The computation here is trivial (just a difference) but</span>
<span class="sd">    the fluff is all the safeties in handling missing values.  Returns -1.0</span>
<span class="sd">    if any of the requried keys are missing.  Returns -2.0 if d is not defined</span>
<span class="sd">    as UTC.  That is basically a reminder this function only makes sense for</span>
<span class="sd">    data with a UTC time standard.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">phase_time</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">t0</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">phase_time_key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">time_shift_key</span><span class="p">):</span>
        <span class="n">phase_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">phase_time_key</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">time_shift_key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">phase_time</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span></div>


<div class="viewcode-block" id="post_MCXcor_metrics"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.post_MCXcor_metrics">[docs]</a><span class="k">def</span> <span class="nf">post_MCXcor_metrics</span><span class="p">(</span>
    <span class="n">d</span><span class="p">,</span>
    <span class="n">beam</span><span class="p">,</span>
    <span class="n">metrics</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;arrival_time&quot;</span><span class="p">:</span> <span class="s2">&quot;Ptime_xcor&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cross_correlation&quot;</span><span class="p">:</span> <span class="s2">&quot;beam_correlation&quot;</span><span class="p">,</span>
        <span class="s2">&quot;coherence&quot;</span><span class="p">:</span> <span class="s2">&quot;beam_coherence&quot;</span><span class="p">,</span>
        <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span> <span class="s2">&quot;beam_relative_amplitude&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">phase_time_key</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span>
    <span class="n">time_shift_key</span><span class="o">=</span><span class="s2">&quot;arrival_time_correction&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes and posts a set of standard QC metrics for result of multichannel cross-correlation</span>
<span class="sd">    algorithm.</span>

<span class="sd">    This function should be thought of as a post-processing function to standardize a set of</span>
<span class="sd">    useful calculations from the output of the multichannel cross-correlation algorithm.</span>
<span class="sd">    The default is set up for post processing teleseismic P wave data but with changes to the</span>
<span class="sd">    arguments it should be possible to use it for any teleseismic body wave phase.</span>

<span class="sd">    What is computed is controlled by the input parameter &quot;metrics&quot;.   &quot;metrics&quot; is</span>
<span class="sd">    expected to be a dictionary with the keys defining the concept of what is to be</span>
<span class="sd">    computed and posted and a &quot;value&quot; being the actual key to use for posting the</span>
<span class="sd">    computed value.  Defaults for &quot;metrics&quot; are as follows the dictionary key</span>
<span class="sd">    in quotes at the start of each paragraph:</span>

<span class="sd">    -  &quot;arrival_time&quot;  - compute arrival time from posted initial time estimate and</span>
<span class="sd">       correlation time shift computed by `align_and_stack`.  Uses the &quot;phase_time_key&quot;</span>
<span class="sd">       and &quot;time_shift_key&quot; to fetch required values.  Default works for Pwave</span>
<span class="sd">       data processed with `align_and_stack`.  Changes needed for other phases.</span>
<span class="sd">    -  &quot;cross_correlation&quot; - compute cross correlation with respect to beam</span>
<span class="sd">    -  &quot;coherence&quot; - compute time domain coherence with respect to beam</span>
<span class="sd">    -  &quot;amplitude&quot; - compute amplitude of d relative to the beam.</span>

<span class="sd">    :param d:  datum to be processed</span>
<span class="sd">    :type d:  `TimeSeries`</span>
<span class="sd">    :param beam: array stack (beam) output of `align_and_stack`</span>
<span class="sd">    :type beam:  `TimeSeries`</span>
<span class="sd">    :param metrics:  defines what metrics should be computed ans posted</span>
<span class="sd">       (see above for options)</span>
<span class="sd">    :type metrics:  python dictionary with one or more of the keys defined above.</span>
<span class="sd">    :param window:  optional time window to use for computing specified metric(s).</span>
<span class="sd">       Windowing is normally applied for cross-correlation, coherence, and amplitude</span>
<span class="sd">       calculations (it is ignored for the time computation).  If it is not</span>
<span class="sd">       defined behavior depends on the algorithm as the object is passed directly</span>
<span class="sd">       to functions used to compute correlation, coherence, and amplitude metrics.</span>
<span class="sd">    :type window:  `TimeWindow` or None (default)</span>
<span class="sd">    :param phase_time_key: key used to fetch the initial phase time used for</span>
<span class="sd">       initial alignment for `align_and_stack` input.   The assumption is the</span>
<span class="sd">       content is defined in d and when fetch is an epoch time defining the</span>
<span class="sd">       initial time shift for the given phase.  Note it could be either a measured</span>
<span class="sd">       or model-based arrival time.</span>
<span class="sd">    :type phase_time_key: string (default &quot;Ptime&quot; which is default expectation used</span>
<span class="sd">       in `align_and_stack`)</span>
<span class="sd">    :param time_shift_key:  key used to store the relative time shifts computed</span>
<span class="sd">       by `align_and_stack`.</span>
<span class="sd">    :type time_shift_key: string (default &quot;arrival_time_correction&quot; is the key</span>
<span class="sd">       used to post the cross-correlation shifts in `align_and_stack`)</span>
<span class="sd">    :return:  copy of d `TimeSeries` with the requested metrics posted to the</span>
<span class="sd">       Metadata container of the output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># no safeties for d and beam type in this function because of stock use.</span>
    <span class="c1"># that maybe should be changed</span>
    <span class="k">if</span> <span class="s2">&quot;arrival_time&quot;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">atime</span> <span class="o">=</span> <span class="n">phase_time</span><span class="p">(</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">time_shift_key</span><span class="o">=</span><span class="n">time_shift_key</span><span class="p">,</span> <span class="n">phase_time_key</span><span class="o">=</span><span class="n">phase_time_key</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">atime</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;arrival_time&quot;</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">atime</span>
    <span class="k">if</span> <span class="s2">&quot;cross_correlation&quot;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">xcor</span> <span class="o">=</span> <span class="n">beam_correlation</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;cross_correlation&quot;</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcor</span>
    <span class="k">if</span> <span class="s2">&quot;coherence&quot;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">coh</span> <span class="o">=</span> <span class="n">beam_coherence</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;coherence&quot;</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coh</span>
    <span class="k">if</span> <span class="s2">&quot;amplitude&quot;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">amplitude_relative_to_beam</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">normalize_beam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;amplitude&quot;</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp</span>
    <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="demean_residuals"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.demean_residuals">[docs]</a><span class="k">def</span> <span class="nf">demean_residuals</span><span class="p">(</span>
    <span class="n">ensemble</span><span class="p">,</span>
    <span class="n">measured_time_key</span><span class="o">=</span><span class="s2">&quot;Ptime_xcor&quot;</span><span class="p">,</span>
    <span class="n">model_time_key</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span>
    <span class="n">residual_time_key</span><span class="o">=</span><span class="s2">&quot;Presidual&quot;</span><span class="p">,</span>
    <span class="n">corrected_measured_time_key</span><span class="o">=</span><span class="s2">&quot;Pmeasured&quot;</span><span class="p">,</span>
    <span class="n">center_method</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
    <span class="n">center_estimate_key</span><span class="o">=</span><span class="s2">&quot;Presidual_bias&quot;</span><span class="p">,</span>
    <span class="n">kill_on_failure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Residuals measured by any method are always subject to a bias</span>
<span class="sd">    from Earth structure and earthquake location errors.   With the</span>
<span class="sd">    MsPASS multichannel xcor algorithm there is an additional bias</span>
<span class="sd">    inherited from the choice of the initial beam estimate that can</span>
<span class="sd">    produce an even larger bias.   This algorithm id designed to</span>
<span class="sd">    process an ensemble to remove and estimate of center from the</span>
<span class="sd">    residuals stored in the Metadata containers of the ensemble members.</span>

<span class="sd">    The arguments can be used to change the keys used to access</span>
<span class="sd">    attributes needed to compute the residual and store the result.</span>
<span class="sd">    The formula is trivial an with kwarg symbols is:</span>

<span class="sd">        residual_time_key = measured_time_key - model_time_key - bias</span>

<span class="sd">    where bias is the estimate of center computed from the vector</span>
<span class="sd">    of (uncorrected) residual extracted from the ensemble members.</span>
<span class="sd">    Each member of the ensemble where the measured and model times</span>
<span class="sd">    are defined will have a value set for the residual_time_key in</span>
<span class="sd">    the output.  The actual estimate of bias will be posted to the</span>
<span class="sd">    output in the ensemble&#39;s Mewtadata container with the key</span>
<span class="sd">    defined by the argument &quot;center_estimate_key&quot;.</span>

<span class="sd">    Note the corrected (by estimate of center that is) measured</span>
<span class="sd">    phase arrival time will be stored in each member with the key</span>
<span class="sd">    defined by the &quot;corrected_measured_time_key&quot; argument.  By default</span>
<span class="sd">    that is a different key than measured_time_key but some many want</span>
<span class="sd">    to make measured_time_key==corrected_measured_time_key to reduce</span>
<span class="sd">    complexity.  That is allowed but is a choice not a requirement.</span>
<span class="sd">    Again, default will make a new entry for the corrected value.</span>

<span class="sd">    :param ensemble:  ensemble object to be processed.   Assumes</span>
<span class="sd">       the members have defined values for the keys defined by</span>
<span class="sd">       the &quot;measured_time_key&quot; and &quot;model_time_key&quot;.</span>
<span class="sd">    :type ensemble:  :py:class:`mspasspy.ccore.seismic.TimeSeriesEnsemble`</span>
<span class="sd">       or :py:class:`mspasspy.ccore.seismic.SeismogramEnsemble`.  The function</span>
<span class="sd">       will throw a ValueError exception if this require arg is any other</span>
<span class="sd">       type.</span>
<span class="sd">    :param measured_time_key:  key to use to fetch the measured arrival</span>
<span class="sd">       time of interest from member Metadata containers.</span>
<span class="sd">    :type measured_time_key: string (default &quot;Ptime_xcor&quot;)</span>
<span class="sd">    :param model_time_key:  key to use to fetch the arrival time computed</span>
<span class="sd">       from an earth model and location estimate.  Each member is assumed</span>
<span class="sd">       to have this value defined.</span>
<span class="sd">    :type model_time_key:  string (default &quot;Ptime&quot;)</span>
<span class="sd">    :param residual_time_key:   key use to store the output demeaned</span>
<span class="sd">       residual.   Be warned that this will overwrite a previously stored value</span>
<span class="sd">       if the key was previously defined for something else.  That can,</span>
<span class="sd">       however, be a useful feature if the same data are reprocessed.</span>
<span class="sd">    :type residual_time_key:  string (default &quot;Presidual&quot;)</span>
<span class="sd">    :param corrected_mesured_time_key:   key to use to save the bias</span>
<span class="sd">       corrected measured time estimate.   This value is just the</span>
<span class="sd">       input measured time value minus the computed bias.</span>
<span class="sd">    :type corrected_measured_time_key:  string (default &quot;Pmeasured&quot;)</span>
<span class="sd">    :param center_method:  method of center method to use to compute</span>
<span class="sd">       bias correction from vector of residuals.  Valid values are: &quot;median&quot;</span>
<span class="sd">       to use the median and &quot;mean&quot; (&quot;average&quot; is also accepted an is treated as &quot;mean&quot;)</span>
<span class="sd">       to use the average/mean value operator.</span>
<span class="sd">    :type center_method: string (default &quot;median&quot;)</span>
<span class="sd">    :param center_estimate_key:  key to use to post the estimated center of</span>
<span class="sd">       the vector of residuals.  Note that value is posted to the ensemble&#39;s</span>
<span class="sd">       Metadata container, not the members.  Be warned, however, that</span>
<span class="sd">       currentlyh when ensemble data are saved this value will be posted to</span>
<span class="sd">       all members before saving. Be sure this name does not overwrite</span>
<span class="sd">       some other desired member Metdata when that happens.</span>
<span class="sd">    :type center_estimate_key:  string (default &quot;Presidual_bias&quot;)</span>
<span class="sd">    :param kill_on_failure:  boolean controlling what the function does</span>
<span class="sd">       to the output ensemble if the algorithm totally fails.  &quot;totally fails&quot;</span>
<span class="sd">       in this case means it the number of residuals it could compute was</span>
<span class="sd">       less than or equal 1.  If set True the output will be killed.</span>
<span class="sd">       When False it will be returned with no values set for the</span>
<span class="sd">       keys defined by &quot;residual_time_key&quot; and &quot;center_estimate_key&quot;.</span>
<span class="sd">       Default is False.</span>

<span class="sd">    :return:  edited copy of input ensemble altering only Metadata containers</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;demean_residuals&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ensemble</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeriesEnsemble</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">)):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">+</span> <span class="s2">&quot;:  arg0 has invalid type=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ensemble</span><span class="p">)))</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be TimeSeriesEnsemble or SeismogramEnsemble&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">ensemble</span>
    <span class="n">valid_center_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">center_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_center_methods</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;center_method=</span><span class="si">{}</span><span class="s2"> is not a valid - defaulting to median&quot;</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
        <span class="n">center_method</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">r_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">number_problem_members</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="c1"># use d as shorthand to reduce complexity of expressions</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">measured_time_key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">model_time_key</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">measured_time_key</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">model_time_key</span><span class="p">]</span>
                <span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;member </span><span class="si">{}</span><span class="s2"> is missing one or both of keys </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">measured_time_key</span><span class="p">,</span> <span class="n">model_time_key</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">number_problem_members</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">number_problem_members</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ensemble_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Could not compute residuals for all live members - list problems:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">ensemble_message</span> <span class="o">+=</span> <span class="n">message</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">ensemble_message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Number of residuals computed = </span><span class="si">{}</span><span class="s2"> - demean is not feasible&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kill_on_failure</span><span class="p">:</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ensemble</span>
    <span class="k">if</span> <span class="n">center_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
        <span class="n">r_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># for now this means median - if more methods are added they</span>
        <span class="c1"># should appear in elif blocks above this</span>
        <span class="n">r_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>

    <span class="c1"># drive the setting of computed output with the residuals dictionary</span>
    <span class="c1"># that is a clean mechanism to guarantee</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r_index</span><span class="p">:</span>
        <span class="c1"># we can assume these will resolve or i would not have been set</span>
        <span class="c1"># in the r_index list</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">measured_time_key</span><span class="p">]</span> <span class="o">-</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">model_time_key</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">r_mean</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">residual_time_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">corrected_measured_time_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ensemble</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">measured_time_key</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_mean</span>
        <span class="p">)</span>
    <span class="n">ensemble</span><span class="p">[</span><span class="n">center_estimate_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_mean</span>
    <span class="k">return</span> <span class="n">ensemble</span></div>


<div class="viewcode-block" id="remove_incident_wavefield"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.MCXcorStacking.remove_incident_wavefield">[docs]</a><span class="k">def</span> <span class="nf">remove_incident_wavefield</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove incident wavefield for teleseismic P wave data using a beam estimate.</span>

<span class="sd">    In imaging of S to P conversion with teleseimic P wave data a critical step</span>
<span class="sd">    is removing the incident wavefield.   The theoretical reason is described in</span>
<span class="sd">    multiple publications on S to P imaging theory.  This function implements</span>
<span class="sd">    a novel method using the output of `align_and_stack` to remove the</span>
<span class="sd">    incident wavefield.   The approach make sense ONLY IF d is a member of the</span>
<span class="sd">    ensemble used to compute beam and is the longitudinal component estimate</span>
<span class="sd">    for a P phase.  The best choice for that is the free surface transformation</span>
<span class="sd">    operator but in could be used for LQT or even the very crude RTZ</span>
<span class="sd">    transformation.</span>

<span class="sd">    The actual operation is very simple:  the overlaping section of beam</span>
<span class="sd">    and d is determined.  The algorthm then computes a scaling factor for</span>
<span class="sd">    beam as the dot product of beam and d in the common time range.</span>
<span class="sd">    That number is used to scale the beam which is then subtracted</span>
<span class="sd">    (in the overlapping time range) from d.  There are several key</span>
<span class="sd">    assumptions this algorithm makes about the input that should be</span>
<span class="sd">    kept in mind before using it:</span>

<span class="sd">    1.  d is implicitly expected to span a longer or a least</span>
<span class="sd">        equal span to the beam time range.</span>
<span class="sd">    2.  beam should always be tapered to prevent an offset at the</span>
<span class="sd">        front and end when it is subtracted from d.</span>
<span class="sd">    3.  beam should be normalized so it L2 norm is 1.0.  Note that</span>
<span class="sd">        should be the taper beam not the beam cut with WindowData.</span>
<span class="sd">        That is not computed in this function for efficiency as normal</span>
<span class="sd">        use would apply the same beam estimate to all live ensemble</span>
<span class="sd">        members.</span>
<span class="sd">    4.  Because this is assumed to be used at deep in a processing</span>
<span class="sd">        chain it has no safties.   d and beam and assumped to</span>
<span class="sd">        be TimeSeries objects.  The only safety is that if d or</span>
<span class="sd">        beam are marked dead it does nothing but return d.</span>

<span class="sd">    :param d:  datum from which beam is to be subtracted</span>
<span class="sd">        (Assumed to have a time span containing the time span of beam)</span>
<span class="sd">    :type d:  `TimeSeries`</span>
<span class="sd">    :param beam:   windowed and tapered output stack from</span>
<span class="sd">        `align_and_stack`.  Assumed to have L2 norm of 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">beam</span><span class="o">.</span><span class="n">dead</span><span class="p">()</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">d</span>
    <span class="n">st</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
    <span class="n">et</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">endtime</span><span class="p">(),</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">())</span>
    <span class="n">isd</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="n">isb</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="n">ied</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
    <span class="n">ieb</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
    <span class="c1"># necessary to use : notation to prevent subsample t0 value rounding</span>
    <span class="c1"># from causing an indexing error</span>
    <span class="n">Nd</span> <span class="o">=</span> <span class="n">ied</span> <span class="o">-</span> <span class="n">isd</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">Nb</span> <span class="o">=</span> <span class="n">ieb</span> <span class="o">-</span> <span class="n">isb</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">Nd</span> <span class="o">&lt;</span> <span class="n">Nb</span><span class="p">:</span>
        <span class="n">ieb</span> <span class="o">=</span> <span class="n">Nd</span> <span class="o">+</span> <span class="n">isb</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">Nd</span> <span class="o">&gt;</span> <span class="n">Nb</span><span class="p">:</span>
        <span class="n">ied</span> <span class="o">=</span> <span class="n">Nb</span> <span class="o">+</span> <span class="n">isd</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ied</span><span class="p">:</span><span class="n">ieb</span><span class="p">],</span> <span class="n">beam</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ieb</span><span class="p">:</span><span class="n">ied</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ieb</span><span class="p">:</span><span class="n">ied</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="n">amp</span>
    <span class="n">d</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ied</span><span class="p">:</span><span class="n">ieb</span><span class="p">]</span> <span class="o">-=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">d</span></div>


<span class="c1"># private functions - should be used only internally.  Use with care if imported</span>
<span class="k">def</span> <span class="nf">_coda_duration</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">search_start</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeWindow</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Low-level function to estimate the range of the &quot;coda&quot; of a particular</span>
<span class="sd">    seismic phase. This function first computes the envelope of the</span>
<span class="sd">    input signal passed via arg0 as a `TimeSeries` object.   The function</span>
<span class="sd">    then searches backward in time from `search_start` to the first</span>
<span class="sd">    sample of the envelop function that exceeds the value defined by</span>
<span class="sd">    `level`.  It returns a `TimeWindow` object with a `start` set as the</span>
<span class="sd">    value passed as t0 and the `end` attribute set to the time stamp</span>
<span class="sd">    of the estimated coda end time.   Normal use by processing functions</span>
<span class="sd">    inside this module assume the input has a relative time standard</span>
<span class="sd">    but the function could work with UTC data you treat `t0` and</span>
<span class="sd">    `search_start` as required, not optional, arguments.</span>

<span class="sd">    The function return a zero length `TimeWindow` (start == end) if the</span>
<span class="sd">    level of the envelope never exceeds the value defined by the level</span>
<span class="sd">    argument.</span>

<span class="sd">    :param ts:  Datum to be processed.   The function will return a null</span>
<span class="sd">    result (zero length window) if ts.t0&gt; t0 (argument value).  The sample</span>
<span class="sd">    data is assumed filtered to an appropriate band where the envelope will</span>
<span class="sd">    properly define the coda.</span>
<span class="sd">    :type ts: `TimeSeries` is assumed.  There is not explicit type checking</span>
<span class="sd">    but a type mismatch will always cause an error.</span>
<span class="sd">    :param level:  amplitude of where the backward time search will be</span>
<span class="sd">    terminated.   This value should normally be computed from a background</span>
<span class="sd">    noise estimate.</span>
<span class="sd">    :type level:   float</span>
<span class="sd">    :param t0:  beginning of coda search interval.  This time is mainly used</span>
<span class="sd">    as the failed search.  That is, if the level never rises above the</span>
<span class="sd">    value defined by the `level` argument a zero length window will be</span>
<span class="sd">    returned with start and end both set to this value.   If the value</span>
<span class="sd">    is inconsistent with the start time of the data it is reset to the</span>
<span class="sd">    time of the first data sample.</span>
<span class="sd">    :type t0:  float (default 0.0 - appropriate for normal use with data</span>
<span class="sd">    time shifted so 0 is a P or S phase arrival time)</span>
<span class="sd">    :param search_start:  optional time to start backward search.</span>
<span class="sd">    The default, which is defined with a None type, is to start the search</span>
<span class="sd">    at ts.endtime().  If a value is given and it exceeds ts.endtime()</span>
<span class="sd">    the search will silently be truncated to start at ts.endtime().</span>
<span class="sd">    Similarly if `search_start` is less than ts.t0 the search will also</span>
<span class="sd">    be silently reset to the ts.endtime().</span>
<span class="sd">    :type search_start:  float (time - either relative time or an epoch time)</span>
<span class="sd">    :return:  `TimeWindow` object with window `end` value defining the</span>
<span class="sd">    end of the coda.  window.end-window.start is a measure of coda duration.</span>
<span class="sd">    Returns a zero length window if the amplitude never exceeds the</span>
<span class="sd">    valued defined by the `level` parameter.   Not the start value may</span>
<span class="sd">    be different from the input t0 value if the data start time (ts.t0) is</span>
<span class="sd">    greater than the value defined by the `t0` argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># silently handle inconsistencies in t0 and search_start</span>
    <span class="c1"># perhaps should have these issue an elog complaint</span>
    <span class="n">it0</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
    <span class="c1"># silently reset to 0 if t0 is not valid for</span>
    <span class="k">if</span> <span class="n">it0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">it0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t0used</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t0used</span> <span class="o">=</span> <span class="n">t0</span>
    <span class="k">if</span> <span class="n">search_start</span><span class="p">:</span>
        <span class="n">itss</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">search_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">itss</span> <span class="o">&gt;=</span> <span class="n">ts</span><span class="o">.</span><span class="n">npts</span> <span class="ow">or</span> <span class="n">itss</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">itss</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">itss</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">npts</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">itss</span> <span class="o">&lt;=</span> <span class="n">it0</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;_coda_durations:   values for inferred search range </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> do not overlap data range&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">httsd</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">envelope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">httsd</span><span class="p">)</span>
    <span class="n">it0</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sample_number</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">itss</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">it0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">envelope</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1"># A failed search will have start and end the same</span>
    <span class="k">return</span> <span class="n">TimeWindow</span><span class="p">(</span><span class="n">t0used</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_set_phases</span><span class="p">(</span>
    <span class="n">d</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">Ptime_key</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span>
    <span class="n">pPtime_key</span><span class="o">=</span><span class="s2">&quot;pPtime&quot;</span><span class="p">,</span>
    <span class="n">PPtime_key</span><span class="o">=</span><span class="s2">&quot;PPtime&quot;</span><span class="p">,</span>
    <span class="n">station_collection</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
    <span class="n">default_depth</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cautiously sets model-based arrival times in Metadata of input</span>
<span class="sd">    d for first arrival of the phases P pP, and PP.   pP and PP</span>
<span class="sd">    do not exist at all distances and depths so the times may be</span>
<span class="sd">    left undefined.   A value for P should always be set unless that</span>
<span class="sd">    datum was marked dead on input.</span>

<span class="sd">    The input datum must contain Metadata entries required to compute the</span>
<span class="sd">    travel times.  That can be in one of two forms:</span>
<span class="sd">        (1)  The normal expectation is to source coordinates are defined with</span>
<span class="sd">             keys &quot;source_iat&quot; , &quot;source_lon&quot;, and &quot;source_time&quot;, and</span>
<span class="sd">             &quot;source_depth&quot; while receiver coordinates are defined with</span>
<span class="sd">             &quot;channel_lat&quot; and &quot;channel_lon&quot;.   A common variant is possible</span>
<span class="sd">             if the `station_collection` argument is set to &quot;site&quot;.  Then</span>
<span class="sd">             the function will try to fetch &quot;site_lat&quot; and &quot;site_lon&quot;.</span>
<span class="sd">             A special case is source depth.  If &quot;source_depth&quot; is not</span>
<span class="sd">             defined the value defined with the `default_depth` argument is</span>
<span class="sd">             used.</span>
<span class="sd">        (2)  If the key &quot;dist&quot; is defined in d it is assumed to contain</span>
<span class="sd">             a previously computed distance in degrees from source to this</span>
<span class="sd">             receiver.  In that case the only other required source property</span>
<span class="sd">             is &quot;source_time&quot; - event origin time.</span>
<span class="sd">    :param d:  seismic datum to process.   This datum requires source and</span>
<span class="sd">    receiver metadata attributes as noted above</span>
<span class="sd">    :type d:   Assumed to be a `TimeSeries`.   That is not tested as this is</span>
<span class="sd">    an internal function.  Use outside the module should assure input is</span>
<span class="sd">    a `TimeSeries` or create an error handler for exceptions.</span>
<span class="sd">    :param model:   an instance of an obspy TauPyModel object used to</span>
<span class="sd">    compute times.</span>
<span class="sd">    :type model:   obspy TauPyModel object</span>
<span class="sd">    :param Ptime_key:  key used to set the pP arrival time.</span>
<span class="sd">    :type pPtime_key:  string (default &quot;pPtime&quot;)</span>
<span class="sd">    :param pPtime_key:  key used to set the P arrival time.</span>
<span class="sd">    :type PPtime_key:  string (default &quot;PPtime&quot;)</span>
<span class="sd">    :param PPtime_key:  key used to set the PP arrival time.</span>
<span class="sd">    :type PPtime_key:  string (default &quot;PPtime&quot;)</span>
<span class="sd">    :param station_collection:   normalizing collection used to define</span>
<span class="sd">    receiver coordinates.   Used only to create names for coordinates.</span>
<span class="sd">    e.g. if set to &quot;site&quot; expects to find &quot;site_lat&quot; while if set to</span>
<span class="sd">    default &quot;channel&quot; would expect to find &quot;channel_lat&quot;.</span>
<span class="sd">    :type station_collection:  string (default &quot;channel&quot;)</span>
<span class="sd">    :param default_depth:   source depth to use if the attribute &quot;source_depth&quot;</span>
<span class="sd">    is not defined.   This is a rare recovery to handle the case where</span>
<span class="sd">    the epicenter and origin time are defined but the depth is not.</span>
<span class="sd">    :type default_depth:  float</span>
<span class="sd">    :return:  `TimeSeries` copy of input with model-based arrival times posted</span>
<span class="sd">    to Metadata container with the specified keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">d</span>
    <span class="n">alg</span> <span class="o">=</span> <span class="s2">&quot;_set_phases&quot;</span>
    <span class="c1"># these symbols need to be effectively declared here or the go out of scope</span>
    <span class="c1"># before being used as arguments for the get_travel_time method of the taup calculator</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span>
        <span class="n">origin_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_time&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;source_lat&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;source_lon&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;source_time&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">srclat</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_lat&quot;</span><span class="p">]</span>
            <span class="n">srclon</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_lon&quot;</span><span class="p">]</span>
            <span class="n">origin_time</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_time&quot;</span><span class="p">]</span>
            <span class="c1"># compute dist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Missing required source coordinates:  source_lat,source_lon, and/or source_time values</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Cannot handle this datum&quot;</span>
            <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="n">lat_key</span> <span class="o">=</span> <span class="n">station_collection</span> <span class="o">+</span> <span class="s2">&quot;_lat&quot;</span>
        <span class="n">lon_key</span> <span class="o">=</span> <span class="n">station_collection</span> <span class="o">+</span> <span class="s2">&quot;_lon&quot;</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">lat_key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">lon_key</span><span class="p">):</span>
            <span class="n">stalat</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">lat_key</span><span class="p">]</span>
            <span class="n">stalon</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">lon_key</span><span class="p">]</span>
            <span class="p">[</span><span class="n">dist</span><span class="p">,</span> <span class="n">seaz</span><span class="p">,</span> <span class="n">esaz</span><span class="p">]</span> <span class="o">=</span> <span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="n">stalat</span><span class="p">,</span> <span class="n">stalon</span><span class="p">,</span> <span class="n">srclat</span><span class="p">,</span> <span class="n">srclon</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">kilometers2degrees</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span>
            <span class="c1"># always post these - warning produces a state dependency as there is no guarantee these</span>
            <span class="c1"># get posted if &quot;dist&quot; was defined on input</span>
            <span class="c1"># keys are frozen and based on standard mspass schema</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;seaz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seaz</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;esaz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">esaz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Missing required receiver coordinates defined with keys: </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">lat_key</span><span class="p">,</span> <span class="n">lon_key</span>
            <span class="p">)</span>
            <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Cannot handle this datum&quot;</span>
            <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">d</span>

    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="s2">&quot;source_depth&quot;</span><span class="p">):</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_depth&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">default_depth</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;source_depth value was not defined - using default value=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">depth</span>
        <span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">alg</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span><span class="p">)</span>
    <span class="n">arrivals</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_travel_times</span><span class="p">(</span>
        <span class="n">source_depth_in_km</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">distance_in_degree</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">phase_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;pP&quot;</span><span class="p">,</span> <span class="s2">&quot;PP&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># from all I can tell with the list above arrivals always has entries for at least one of</span>
    <span class="c1"># the phases in phase_list.   If depth is invalid it throws an exception and it seems to</span>
    <span class="c1"># handle dist for anything.   Hence, this assumes arrivals is not empty.  An earlier</span>
    <span class="c1"># had an unnecessary error handler for that case.</span>
    <span class="c1"># only set first arrival for multivalued arrivals</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pP</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">PP</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrivals</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>
            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;pP&quot;</span><span class="p">:</span>
            <span class="n">pP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;PP&quot;</span><span class="p">:</span>
            <span class="n">PP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">Ptime_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">+</span> <span class="n">origin_time</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">pPtime_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pP</span><span class="p">)</span> <span class="o">+</span> <span class="n">origin_time</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">PP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">PPtime_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">PP</span><span class="p">)</span> <span class="o">+</span> <span class="n">origin_time</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_get_search_range</span><span class="p">(</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">Pkey</span><span class="o">=</span><span class="s2">&quot;Ptime&quot;</span><span class="p">,</span> <span class="n">pPkey</span><span class="o">=</span><span class="s2">&quot;pPtime&quot;</span><span class="p">,</span> <span class="n">PPkey</span><span class="o">=</span><span class="s2">&quot;PPtime&quot;</span><span class="p">,</span> <span class="n">duration_undefined</span><span class="o">=</span><span class="mf">20.0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small internal function used to standardize the handling of the search</span>
<span class="sd">    range for P coda.   It returns a time duration to use as the search</span>
<span class="sd">    range relative to 0 (P time) based on a simple recipe to avoid interference</span>
<span class="sd">    from pP and PP phases.   Specifically, if the source depth is greater than</span>
<span class="sd">    100 km the pP phase is used as the maximum duration of the coda.</span>
<span class="sd">    For shallower sources PP is used.</span>

<span class="sd">    This function should not normally be used except as a component of the</span>
<span class="sd">    MCXcorPrepP function.   It has no safeties and is pretty simple.</span>
<span class="sd">    That simple recipe, however, took some work to establish that is documented</span>
<span class="sd">    a notebook in the distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;source_depth&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">pPkey</span><span class="p">):</span>
                <span class="n">tend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">pPkey</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">PPkey</span><span class="p">):</span>
                <span class="n">tend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">PPkey</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">Pkey</span><span class="p">]</span> <span class="o">+</span> <span class="n">duration_undefined</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">PPkey</span><span class="p">]</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">tend</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">Pkey</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">duration</span>


<span class="k">def</span> <span class="nf">_xcor_shift</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function with no safeties to compute a time shift in</span>
<span class="sd">    seconds for beam correlation.   The shift is computed by</span>
<span class="sd">    using the scipy correlate function.  The computed shift is the</span>
<span class="sd">    time shift that would need to be applied to ts to align with</span>
<span class="sd">    that of beam.   Note that number can be enormous if using UTC</span>
<span class="sd">    times and it will still work.   The expected use, however,</span>
<span class="sd">    in this function is with data prealigned by an phase arrival</span>
<span class="sd">    time (predicted from a mdoel of an estimate).</span>
<span class="sd">    :param ts:  TimeSeries datum to correlate with beam</span>
<span class="sd">    :param beam:  TimeSeries defining the common signal (beam) for</span>
<span class="sd">      correlation - the b argument to correlation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># note this assumed default mode of &quot;full&quot;</span>
    <span class="n">xcor</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">correlation_lags</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">beam</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="c1"># numpy/scipy treat sample 0 as time 0</span>
    <span class="c1"># with TimeSeries we have to correct with the t0 values to get timing right</span>
    <span class="n">lag_of_max_in_samples</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xcor</span><span class="p">)]</span>
    <span class="n">lagtime</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="n">lag_of_max_in_samples</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">t0</span> <span class="o">-</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span>
    <span class="k">return</span> <span class="n">lagtime</span>


<span class="k">def</span> <span class="nf">_update_xcor_beam</span><span class="p">(</span><span class="n">xcorens</span><span class="p">,</span> <span class="n">beam0</span><span class="p">,</span> <span class="n">robust_stack_method</span><span class="p">,</span> <span class="n">wts</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal method used to update the beam signal used for cross correlation</span>
<span class="sd">    to the current best stack estimate.   Note the algorithm assumes</span>
<span class="sd">    xcorens members have a larger time range than beam0.   To compute the</span>
<span class="sd">    beam stack each member is windowed in the range beam0.t0 to beam0.endtime()</span>
<span class="sd">    before use.</span>

<span class="sd">    :param xcorens:   ensemble data being used for cross-correlation</span>
<span class="sd">    :type xcorens:  TimeSeriesEnsemble</span>
<span class="sd">    :param rens:  ensemble returned by robust_stack (Ignored for median stack)</span>
<span class="sd">    :type rens:  TimeSeriesEnsemble</span>
<span class="sd">    :param beam0: current beam estimate.   The output will have size</span>
<span class="sd">        determined by beam.t0 and beam.endtime()</span>
<span class="sd">    :type beam0:  TimeSeries</span>
<span class="sd">    :param robust_stack_method:  name of robust stacking method to use.</span>
<span class="sd">        Currently must either &quot;dbxcor&quot; or &quot;median&quot;.</span>
<span class="sd">    :type robust_stack_method:  string</span>
<span class="sd">    :param robust_weight_key:  key needed to extract robust stack weight</span>
<span class="sd">        from rens when running an estimator like dbxcor that uses a weighted</span>
<span class="sd">        stack.   ignored for median stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">beam</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">beam0</span><span class="p">)</span>
    <span class="c1"># A tricky but fast way to initialize the data vector to all zeros</span>
    <span class="c1"># warning this depends upon a special property of the C++ implementation</span>
    <span class="n">beam</span><span class="o">.</span><span class="n">set_npts</span><span class="p">(</span><span class="n">beam0</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>
    <span class="c1"># Cautioniously copy these to beam.   Maybe should log an error if they</span>
    <span class="c1"># aren&#39;t defined but for now do this silently.   Possible</span>
    <span class="c1"># maintenace issue if these keys ever change in MCXcorPPrep.</span>
    <span class="c1"># at present it sets these in ensemble&#39;s Metadata container</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;MCXcor_f_low&quot;</span><span class="p">,</span> <span class="s2">&quot;MCXcor_f_high&quot;</span><span class="p">,</span> <span class="s2">&quot;MCXcor_npoles&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">xcorens</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">beam</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xcorens</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">stime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">t0</span>
    <span class="n">etime</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">endtime</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xcorens</span><span class="o">.</span><span class="n">member</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">robust_stack_method</span> <span class="o">==</span> <span class="s2">&quot;dbxcor&quot;</span><span class="p">:</span>
        <span class="c1"># we can assume for internal use that xcorens and rens are the</span>
        <span class="c1"># same size. We don&#39;t assume all are live though to allow</span>
        <span class="c1"># flexibility in the algorithm</span>

        <span class="n">sumwt</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="c1"># the dbxcor stacking function weight is set negative if</span>
            <span class="c1"># a datum was marked dead</span>
            <span class="k">if</span> <span class="n">xcorens</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">live</span> <span class="ow">and</span> <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">wts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
                    <span class="n">xcorens</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stime</span><span class="p">,</span> <span class="n">etime</span><span class="p">,</span> <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span>
                <span class="p">)</span>
                <span class="n">d</span> <span class="o">*=</span> <span class="n">wt</span>
                <span class="c1"># TimeSeries::operator+= handles time correctly so indexing is not needed here</span>
                <span class="n">beam</span> <span class="o">+=</span> <span class="n">d</span>
                <span class="n">sumwt</span> <span class="o">+=</span> <span class="n">wt</span>
        <span class="k">if</span> <span class="n">sumwt</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># TimeSeries does not have operator /= defined but it does have *= defined</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sumwt</span>
            <span class="n">beam</span> <span class="o">*=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beam</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;_update_xcor_beam&quot;</span><span class="p">,</span>
                <span class="s2">&quot;dbxcor weights are all 0.0 - all ensemble members were probably killed&quot;</span><span class="p">,</span>
                <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">beam</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># for now landing here means median stack - change if new algorithms addede</span>
        <span class="n">nlive</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># note sizes passed to shape are set above when validating inputs and are assumed to not have changed</span>
        <span class="n">Npts</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">npts</span>
        <span class="n">gather_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">Npts</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">xcorens</span><span class="o">.</span><span class="n">member</span><span class="p">:</span>
            <span class="c1"># always use the zero padding method of WindowData</span>
            <span class="c1"># run silently for median stack.  Maybe should allow</span>
            <span class="c1"># options for this case</span>
            <span class="n">dcut</span> <span class="o">=</span> <span class="n">WindowData</span><span class="p">(</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">stime</span><span class="p">,</span>
                <span class="n">etime</span><span class="p">,</span>
                <span class="n">short_segment_handling</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span>
                <span class="n">log_recoverable_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">dcut</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
                <span class="c1"># rounding effects with a window time range</span>
                <span class="c1"># iteractions with t0 can cause the size of</span>
                <span class="c1"># dcut to differ from beam.npts</span>
                <span class="c1"># logic handles that</span>
                <span class="k">if</span> <span class="n">dcut</span><span class="o">.</span><span class="n">npts</span> <span class="o">==</span> <span class="n">Npts</span><span class="p">:</span>
                    <span class="n">gather_matrix</span><span class="p">[</span><span class="n">nlive</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dcut</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">dcut</span><span class="o">.</span><span class="n">npts</span> <span class="o">&lt;</span> <span class="n">Npts</span><span class="p">:</span>
                    <span class="n">gather_matrix</span><span class="p">[</span><span class="n">nlive</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">dcut</span><span class="o">.</span><span class="n">npts</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dcut</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gather_matrix</span><span class="p">[</span><span class="n">nlive</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dcut</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Npts</span><span class="p">])</span>
                <span class="n">nlive</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stack_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">gather_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nlive</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># this matrix could be huge so we release it as quickly as possible</span>
        <span class="k">del</span> <span class="n">gather_matrix</span>
        <span class="c1"># logic above guarantees stack_vector is beam.npts in size</span>
        <span class="n">beam</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">stack_vector</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">beam</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>