

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.algorithms.basic &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=f6245a2f"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Desktop Operation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/mspass_desktop.html">Running MsPASS on a Desktop Computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/command_line_desktop.html">Command Line Docker Desktop Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda.html">Deploy MsPASS with Conda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/advanced_setup_considerations.html">Advanced Setup Considerations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Cluster Operations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_on_HPC.html">Deploying MsPASS on an HPC cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/deploy_mspass_with_conda_and_coiled.html">Deploy MsPASS with Conda and Coiled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started_overview.html">MsPASS Virtual Cluster Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/introduction.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/mongodb_and_mspass.html">Using MongoDB with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_tabular_data.html">Importing Tabular Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Seismic Data Objects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/numpy_scipy_interface.html">Using numpy/scipy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/continuous_data.html">Continuous Data Handling with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/schema_choices.html">What database schema should I use?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Processing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/cleaning_metadata.html">Cleaning Inconsistent Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/signal_to_noise.html">Signal to Noise Ratio Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/arrival_time_measurement.html">Arrival Time Measurement Techniques in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System Tuning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/memory_management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/io.html">I/O in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/parallel_io.html">Parallel IO in MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/FAQ.html">Frequency Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_manual/development_strategies.html">How do I develop a new workflow from scratch?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../../../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">mspasspy.algorithms.basic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mspasspy.algorithms.basic</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.util.decorators</span><span class="w"> </span><span class="kn">import</span> <span class="n">mspass_func_wrapper</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.ccore.algorithms.basic</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearTaper</span><span class="p">,</span> <span class="n">CosineTaper</span><span class="p">,</span> <span class="n">VectorTaper</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.ccore.utility</span><span class="w"> </span><span class="kn">import</span> <span class="n">MsPASSError</span><span class="p">,</span> <span class="n">ErrorSeverity</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">logging_helper</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mspasspy.ccore.algorithms.basic</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">bsc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.ccore.seismic</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">TimeSeriesEnsemble</span><span class="p">,</span>
    <span class="n">Seismogram</span><span class="p">,</span>
    <span class="n">SeismogramEnsemble</span><span class="p">,</span>
    <span class="n">SlownessVector</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mspasspy.ccore.utility</span><span class="w"> </span><span class="kn">import</span> <span class="n">SphericalCoordinate</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>


<div class="viewcode-block" id="ExtractComponent"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.ExtractComponent">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ExtractComponent</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">component</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract single component from three-component data.</span>

<span class="sd">    The function creates a scalar TimeSeries object from a three component Seismogram object</span>
<span class="sd">    Or a TimeSeriesEnsemble object from a SeismogramEnsemble object</span>

<span class="sd">    :param data: data object to extract from.</span>
<span class="sd">    :type data: either :class:`~mspasspy.ccore.seismic.Seismogram or :class:`~mspasspy.ccore.seismic.SeismogramEnsemble`</span>
<span class="sd">    :param component: the index of component that will be extracted, it can only be 0, 1, or 2</span>
<span class="sd">    :type component: :class:`int`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is set false to</span>
<span class="sd">        handle exception directly in the function, without passing it to mspass_func_wrapper.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">bsc</span><span class="o">.</span><span class="n">_ExtractComponent</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;ExtractComponent&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">()</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">load_history</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">empty</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dead</span><span class="p">():</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">()</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">elog</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">elog</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">empty</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">(</span><span class="n">bsc</span><span class="o">.</span><span class="n">_ExtractComponent</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">component</span><span class="p">))</span>
            <span class="c1"># second copy to convert type from CoreTimeSeriesEnsemble to TimeSeriesEnsemble</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">logging_helper</span><span class="o">.</span><span class="n">ensemble_error</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="s2">&quot;ExtractComponent&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
            <span class="p">)</span>
            <span class="n">empty</span> <span class="o">=</span> <span class="n">TimeSeriesEnsemble</span><span class="p">()</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">elog</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">elog</span>
            <span class="n">empty</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">empty</span></div>


<div class="viewcode-block" id="ator"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.ator">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ator</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">tshift</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absolute to relative time conversion.</span>

<span class="sd">    Sometimes we want to convert data from absolute time (epoch times)</span>
<span class="sd">    to a relative time standard.  Examples are conversions to travel</span>
<span class="sd">    time using an event origin time or shifting to an arrival time</span>
<span class="sd">    reference frame. This operation simply switches the tref</span>
<span class="sd">    variable and alters t0 by tshift.  Note the special feature</span>
<span class="sd">    of how arg0 is handled.   If it is a string it assumed to be a</span>
<span class="sd">    Metadata key to use to fetch the time shift value from the data object&#39;s</span>
<span class="sd">    Metadata container.   If it is number it is used directly.&#39;</span>

<span class="sd">    :param data: data object to be converted.</span>
<span class="sd">    :type data: either :class:`mspasspy.ccore.seismic.TimeSeries` or :class:`mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param tshift: used to define time shift to apply.   If value is string</span>
<span class="sd">        the function assumes it is a metadata key it can use to extract the</span>
<span class="sd">        requred value from the data&#39;s metadata container.  If it is a floating</span>
<span class="sd">        point number it is used directly.   Anything else will result in a</span>
<span class="sd">        TypeError exception.  If a string is used but the key is not defined</span>
<span class="sd">        the datum will be killed with an elog message.</span>
<span class="sd">    :type tshift: :class:`float` or a string to use as a metdata key (see above)</span>
<span class="sd">    :param object_history: set True to preserve the processing history.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tshift</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ator</span><span class="p">(</span><span class="n">tshift</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tshift</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tshift</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">timeshift</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">tshift</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">ator</span><span class="p">(</span><span class="n">timeshift</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;arg0 string defines key=</span><span class="si">{}</span><span class="s2"> not defined in Metadata container of this datum</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">tshift</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;ator&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;ator:  usage error</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Invalid type for arg0=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tshift</span><span class="p">)))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span></div>


<div class="viewcode-block" id="rtoa"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.rtoa">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rtoa</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relative to absolute time conversion.</span>

<span class="sd">    Sometimes we want to convert data from relative time to</span>
<span class="sd">    to an UTC time standard.  An example would be converting</span>
<span class="sd">    segy shot data to something that could be processed like earthquake</span>
<span class="sd">    data in a css3.0 database. This function returns data</span>
<span class="sd">    previously converted to relative back to UTC using the</span>
<span class="sd">    internally stored time shift attribute.</span>

<span class="sd">    :param data: data object to be converted.</span>
<span class="sd">    :type data: either :class:`~mspasspy.ccore.seismic.TimeSeries` or :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">rtoa</span><span class="p">()</span></div>


<div class="viewcode-block" id="rotate"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.rotate">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">rotate_param</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate data using a P wave type coordinate definition.</span>

<span class="sd">    This function can apply three different types of rotation depending on the type of parameter given.</span>
<span class="sd">    If a :class:`~mspasspy.ccore.utility.SphericalCoordinate` is given, it will rotate the data</span>
<span class="sd">    into a coordinate system defined by the direction defined by the spherical coordinate.  That is, the data are</span>
<span class="sd">    rotated such that x1 becomes the transverse component, x2 becomes radial, and x3 becomes longitudinal.</span>

<span class="sd">    A variant is that the :code:`rotate_parameter` can be defined as a</span>
<span class="sd">    three-component unit vector (i.e. assumed normalized so L2 norm is 1.0).</span>
<span class="sd">    In that case the unit vector is treated as the expected P ray emergence</span>
<span class="sd">    angle used to define the equivalent class:`~mspasspy.ccore.utility.SphericalCoordinate`</span>
<span class="sd">    object as described above.  An important limitation at the present is if</span>
<span class="sd">    used this way the vector must be defined as a</span>
<span class="sd">    :class:`~mspasspy.ccore.seismic.DoubleVector`.  Numpy or python array</span>
<span class="sd">    objects will not work but cause a TypeError exception to be thrown.</span>

<span class="sd">    If a :class:`float` number is given for `rotate_parameter`, this function</span>
<span class="sd">    will rotate the horizontal components by this angle in radians.  Note the</span>
<span class="sd">    polarity is geographic convention as clockwise angle from north.</span>

<span class="sd">    :param data: data object to be rotated.</span>
<span class="sd">    :type data: :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param rotate_param: the parameter that defines the rotation.</span>
<span class="sd">    :type rotate_param: see above for details.</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        thing that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotate_param</span><span class="p">)</span></div>


<div class="viewcode-block" id="rotate_to_standard"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.rotate_to_standard">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rotate_to_standard</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply inverse transformation matrix to return data to cardinal direction components.</span>

<span class="sd">    It is frequently necessary to make certain a set of three component data are oriented</span>
<span class="sd">    to the standard reference frame (EW, NS, Vertical).  This function does this.</span>
<span class="sd">    For efficiency it checks the components_are_cardinal variable and does nothing if</span>
<span class="sd">    it is set true.  Otherwise, it applies the inverse transformation and then sets this variable true.</span>
<span class="sd">    Note even if the current transformation matrix is not orthogonal it will be put back into</span>
<span class="sd">    cardinal coordinates.</span>

<span class="sd">    If inversion of the transformation matrix is not possible (e.g. two components are colinear)</span>
<span class="sd">    an error thrown by the C++ function is caught, posted to elog, and the</span>
<span class="sd">    datum return will be marked dead.</span>

<span class="sd">    :param data: data object to be rotated.</span>
<span class="sd">    :type data: :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">       to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    :exception: :class:`~mspasspy.ccore.utility.MsPASSError` thrown if the an inversion of the</span>
<span class="sd">        transformation matrix is required and that matrix is singular.  This can happen if the</span>
<span class="sd">        transformation matrix is incorrectly defined or the actual data are coplanar.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">rotate_to_standard</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span></div>


<div class="viewcode-block" id="free_surface_transformation"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.free_surface_transformation">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">free_surface_transformation</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">uvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">vp0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">vs0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ux_key</span><span class="o">=</span><span class="s2">&quot;ux&quot;</span><span class="p">,</span>
    <span class="n">uy_key</span><span class="o">=</span><span class="s2">&quot;uy&quot;</span><span class="p">,</span>
    <span class="n">vp0_key</span><span class="o">=</span><span class="s2">&quot;vp0&quot;</span><span class="p">,</span>
    <span class="n">vs0_key</span><span class="o">=</span><span class="s2">&quot;vs0&quot;</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes and applies the Kennett [1991] free surface transformation matrix.</span>

<span class="sd">    Kennett [1991] gives the form for a free surface transformation operator</span>
<span class="sd">    that defines a transformation matrix that provides optimal separation</span>
<span class="sd">    of P, SV, and SH for a receiver at the free surface of an isotropic medium</span>
<span class="sd">    with constant P and S velocity.   The transformation is only valid if the</span>
<span class="sd">    incident wavefield is not evanescent (i.e. at or past the SV critical angle).</span>
<span class="sd">    It is important to realize the tranformation matrix does not define</span>
<span class="sd">    an orthogonal transformation.  It is also, of course, only an approximation</span>
<span class="sd">    since it is strictly correct only for a constant velocity medium.</span>
<span class="sd">    The tranformation operator requires: (1) a slowness vector, (2) an</span>
<span class="sd">    estimate of surface P wave velocity, and (3) an estimate of surface</span>
<span class="sd">    shear wave velocity.   In all cases the input for the slowness</span>
<span class="sd">    vector uses a local cartesian system with the vector specified as</span>
<span class="sd">    component ux and uy.  ux is the component of the slowness of</span>
<span class="sd">    an incident wavefield in the geographic x direction, which means</span>
<span class="sd">    positive at local east.  uy is the complementary component for the</span>
<span class="sd">    y direction defined by local north.  The components of the slowness</span>
<span class="sd">    vector are assumed to be in units of s/km.   (Warning:  obspy&#39;s and</span>
<span class="sd">    other implementations of the commonly used tau-p calculator return</span>
<span class="sd">    slowness (ray parameter) in spherical units of s/radian - r sin(theta)/v)</span>

<span class="sd">    The required parameters (slowness vector and velocities) can be</span>
<span class="sd">    passed to the function one of two ways.   Because it is much simpler</span>
<span class="sd">    to implement in a map operator the default expect those parameters to</span>
<span class="sd">    be set in the data object&#39;s Metadata container.  The default keys for</span>
<span class="sd">    fetching each attribute are defined by the four arguments</span>
<span class="sd">    &quot;ux_key&quot;, &quot;uy_key&quot;, &quot;vp0_key&quot;, and &quot;vs0_key&quot;.   All four have</span>
<span class="sd">    standard defaults defined in the function signature and below.</span>
<span class="sd">    The Metadata fetching algorithm can be overridden by defining</span>
<span class="sd">    the same data through the three optional arguments with the key</span>
<span class="sd">    names &quot;uvec&quot;, &quot;vp0&quot;, and &quot;vs0&quot;.   (see below for detailed descriptions)</span>

<span class="sd">    The switching between Metadata fetching and a constant arguments</span>
<span class="sd">    is not all or none.   If a slowness vector is defined through uvec</span>
<span class="sd">    it will always override metadata.  Handing of vp0 and vs0 is independent.</span>
<span class="sd">    i.e. you can define uvec and not define vp0 and vs0 or conversely</span>
<span class="sd">    you can (more commonly) define vp0 and vs0 but not define uvec.</span>
<span class="sd">    In all cases not defining an arg is a signal to fetch it from</span>
<span class="sd">    Metadata.</span>

<span class="sd">    When this function is applied to ensembles and the Metadata fetch</span>
<span class="sd">    approach is used (default) the function assumes all ensemble members</span>
<span class="sd">    have the required metadata keys defined.  Any that do not are killed.</span>
<span class="sd">    The same happens for atomic data passed to this function if any of</span>
<span class="sd">    the required keys are missing.  In fact, you should realize the</span>
<span class="sd">    ensemble algorithm simply applies this function in a recursion over all</span>
<span class="sd">    the members.</span>

<span class="sd">    The output components are in the order defined in Kennett&#39;s original</span>
<span class="sd">    paper.  The order is 0=SH, 1=SV, 2=L.</span>

<span class="sd">    :param data: data object to be transformed.  For ensembles the transformation</span>
<span class="sd">        is applied to all members.  Note the Metadata fetch mechanism is the only</span>
<span class="sd">        recommended way to handle ensembles.  An elog message will be posted</span>
<span class="sd">        to the ensemble&#39;s elog container if you try to use a constant slowness</span>
<span class="sd">        vector passed via uvec. It will not warn about constant vp0 and vs0</span>
<span class="sd">        as that case is common.</span>
<span class="sd">    :type data: :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">        or :class:`~mspasspy.ccore.seismic.SeismogramEnsemble`</span>
<span class="sd">    :param ux_key:  key to use to fetch EW component of slowness vector</span>
<span class="sd">        from Metadata container.  Default is &quot;ux&quot;.</span>
<span class="sd">    :type ux_key:  string</span>
<span class="sd">    :param uy_key:  key to use to fetch NS component of slowness vector</span>
<span class="sd">        from Metadata container.  Default is &quot;uy&quot;.</span>
<span class="sd">    :type uy_key:  string</span>
<span class="sd">    :param vp0_key:  key to use to fetch free surface P wave velocity</span>
<span class="sd">        from Metadata container.  Default is &quot;vp0&quot;.</span>
<span class="sd">    :type vp0_key:  string</span>
<span class="sd">    :param vs0_key: key to use to fetch free surface S wave velocity</span>
<span class="sd">        from Metadata container.  Default is &quot;vs0&quot;.</span>
<span class="sd">    :type vs0_key:  string</span>
<span class="sd">    :param uvec: slowness vector of the incident wavefield defined via</span>
<span class="sd">        custom C++ class :class:`~mspasspy.ccore.seismic.SlownessVector`.</span>
<span class="sd">        Default is None which is taken as a signal to fetch the slowness vector</span>
<span class="sd">        components from Metadata using ux_key and uy_key.</span>
<span class="sd">    :type uvec: :class:`~mspasspy.ccore.seismic.SlownessVector`</span>
<span class="sd">    :param vp0: Surface P wave velocity.  Default is None which is taken</span>
<span class="sd">        as a signal to fetch this quantity from Metadata using the vp0_key.</span>
<span class="sd">    :type vp0: :class:`float`</span>
<span class="sd">    :param vs0: Surface S wave velocity.  Default is None which is taken</span>
<span class="sd">        as a signal to fetch this quantity from Metadata using the vs0_key.</span>
<span class="sd">    :type vs0: :class:`float`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">uvec</span><span class="p">:</span>
            <span class="n">slowness_vector</span> <span class="o">=</span> <span class="n">uvec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ux_key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">uy_key</span><span class="p">):</span>
                <span class="n">ux</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ux_key</span><span class="p">]</span>
                <span class="n">uy</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">uy_key</span><span class="p">]</span>
                <span class="n">slowness_vector</span> <span class="o">=</span> <span class="n">SlownessVector</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;required Metadata with keys =&quot;</span> <span class="o">+</span> <span class="n">ux_key</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">uy_key</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; are not defined - datum killed&quot;</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;free_surface_transformation&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vp0</span><span class="p">:</span>
            <span class="n">P_fs</span> <span class="o">=</span> <span class="n">vp0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">vp0_key</span><span class="p">):</span>
                <span class="n">P_fs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">vp0_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;required Metadata attribute &quot;</span>
                    <span class="o">+</span> <span class="n">vp0_key</span>
                    <span class="o">+</span> <span class="s2">&quot; is not defined - datum killed&quot;</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;free_surface_transformation&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vs0</span><span class="p">:</span>
            <span class="n">S_fs</span> <span class="o">=</span> <span class="n">vs0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">vs0_key</span><span class="p">):</span>
                <span class="n">S_fs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">vs0_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;required Metadata attribute &quot;</span>
                    <span class="o">+</span> <span class="n">vs0_key</span>
                    <span class="o">+</span> <span class="s2">&quot; is not defined - datum killed&quot;</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;free_surface_transformation&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">live</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">free_surface_transformation</span><span class="p">(</span><span class="n">slowness_vector</span><span class="p">,</span> <span class="n">P_fs</span><span class="p">,</span> <span class="n">S_fs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">uvec</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Using a constant slowness vector and surface velocities for all ensemble members</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;That is ill advised unless this is an event gather for a small aperture array&quot;</span>
            <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                <span class="s2">&quot;free_surface_transformation&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># this is a recursion so be aware</span>
            <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">free_surface_transformation</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">ux_key</span><span class="o">=</span><span class="n">ux_key</span><span class="p">,</span>
                <span class="n">uy_key</span><span class="o">=</span><span class="n">uy_key</span><span class="p">,</span>
                <span class="n">vp0_key</span><span class="o">=</span><span class="n">vp0_key</span><span class="p">,</span>
                <span class="n">vs0_key</span><span class="o">=</span><span class="n">vs0_key</span><span class="p">,</span>
                <span class="n">uvec</span><span class="o">=</span><span class="n">uvec</span><span class="p">,</span>
                <span class="n">vp0</span><span class="o">=</span><span class="n">vp0</span><span class="p">,</span>
                <span class="n">vs0</span><span class="o">=</span><span class="n">vs0</span><span class="p">,</span>
                <span class="n">object_history</span><span class="o">=</span><span class="n">object_history</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                <span class="n">dryrun</span><span class="o">=</span><span class="n">dryrun</span><span class="p">,</span>
                <span class="n">inplace_return</span><span class="o">=</span><span class="n">inplace_return</span><span class="p">,</span>
                <span class="n">function_return_key</span><span class="o">=</span><span class="n">function_return_key</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;free_surface_transform received invalid type for arg0 of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be either a Seismogram or SeismogramEnsemble&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="transform"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.transform">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">matrix</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies an arbitrary transformation matrix to the data.</span>

<span class="sd">    i.e. after calling this function the data will have been multiplied by the matrix</span>
<span class="sd">    and the transformation matrix will be updated.  The later allows cascaded</span>
<span class="sd">    transformations to data.</span>

<span class="sd">    :param data: data object to be transformed.</span>
<span class="sd">    :type data: :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param matrix: a 3x3 matrix that defines the transformation.</span>
<span class="sd">    :type matrix: :class:`numpy.array`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="transform_to_RTZ"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.transform_to_RTZ">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_to_RTZ</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;seaz&quot;</span><span class="p">,</span>
    <span class="n">phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">angle_units</span><span class="o">=</span><span class="s2">&quot;degrees&quot;</span><span class="p">,</span>
    <span class="n">key_is_backazimuth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies coordinate transform to RTZ version of ray coordinates.</span>

<span class="sd">    RTZ is the simplest transformation for three component data to</span>
<span class="sd">    what is commonly called ray coordinates.  R-radial (SV), T-transverse</span>
<span class="sd">    (SH). and Z=vertical (bad measure of longitudinal).  The function</span>
<span class="sd">    first forces the data to cardinal direction using rotate_to_standard</span>
<span class="sd">    and then rotates the coordinates around the vertical axis.   The</span>
<span class="sd">    rotation can be defined in one of two ways.  The default behavior</span>
<span class="sd">    is to attempt to extract the back azimuth from the station to the</span>
<span class="sd">    source with the key defined by the &quot;key&quot; argument (defaults to &#39;seaz&#39;).</span>
<span class="sd">    That behavior will be overriden if the &quot;phi&quot; kwarg value is set.</span>
<span class="sd">    Phi is assumed to be the angle to rotate the coordinates using the</span>
<span class="sd">    math convention for the phi angle with positive anticlockwise.</span>
<span class="sd">    The units of the value retrieved with the key argument or the value</span>
<span class="sd">    passed via the phi argument are by default assumed to be in degrees.</span>
<span class="sd">    If using the phi argument you specify the angle in radians if you</span>
<span class="sd">    also set the &quot;angle_units&quot; argument to &quot;radians&quot;.</span>

<span class="sd">    :param data:   data object to be transformed</span>
<span class="sd">    :type data:  :class:`~mspasspy.ccore.seismic.Seismogram` or :class:`~mspass.ccore.seismic.SeismogramEnsemble`.</span>
<span class="sd">    :param key:  key to use to fetch back azimuth value (assumed degrees always)</span>
<span class="sd">    :type key:  string</span>
<span class="sd">    :param phi:   angle to rotate around vertical to define the transformation</span>
<span class="sd">        (positive anticlockwise convention NOT azimuth convention)  Default is None</span>
<span class="sd">        which means ignore this parameter and use key.  Setting this value to</span>
<span class="sd">        something other than None causes the key method to be overridden.</span>
<span class="sd">    :type phi:  float</span>
<span class="sd">    :param angle_units:  should be either &#39;degrees&#39; (default) or &#39;radians&#39;.</span>
<span class="sd">        An invalid value will be treated as an attempt to switch to radians</span>
<span class="sd">        but will generate an elog warning message.  This argument is ignored unless</span>
<span class="sd">        phi is not null (None type)</span>
<span class="sd">    :type angle_units: string</span>
<span class="sd">    :param key_is_backazimuth: boolean that when True (default) assumes the</span>
<span class="sd">        angle extrated with the key argument value is a backazimuth in degrees.</span>
<span class="sd">        If set False, the angle will be assumed to be a rotation angle in</span>
<span class="sd">        with the anticlockwise positive convention.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>

<span class="sd">    :return:  transformed version of input.  For ensembles the entire ensemble</span>
<span class="sd">        is transformed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">phi</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">angle_units</span> <span class="o">==</span> <span class="s2">&quot;degrees&quot;</span><span class="p">:</span>
            <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">angle_units</span> <span class="o">!=</span> <span class="s2">&quot;radians&quot;</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal value for angle_units argument=&quot;</span> <span class="o">+</span> <span class="n">angle_units</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; assuming radians&quot;</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;transform_to_RTZ&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                <span class="p">)</span>
            <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">phi</span>
        <span class="n">use_metadata</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_metadata</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_metadata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">phi_deg</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">key_is_backazimuth</span><span class="p">:</span>
                    <span class="n">az</span> <span class="o">=</span> <span class="n">phi_deg</span> <span class="o">+</span> <span class="mf">180.0</span>
                    <span class="n">phi_deg</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">az</span>
                <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi_deg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;required Metadata key=&quot;</span>
                    <span class="o">+</span> <span class="n">key</span>
                    <span class="o">+</span> <span class="s2">&quot; not defined for this datum - killed&quot;</span>
                <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;transform_to_RTZ&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">data</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">rotate_to_standard</span><span class="p">()</span>
            <span class="n">data</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">phi_rad</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># this is a recursion so be aware</span>
            <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform_to_RTZ</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span>
                <span class="n">angle_units</span><span class="o">=</span><span class="n">angle_units</span><span class="p">,</span>
                <span class="n">object_history</span><span class="o">=</span><span class="n">object_history</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                <span class="n">dryrun</span><span class="o">=</span><span class="n">dryrun</span><span class="p">,</span>
                <span class="n">inplace_return</span><span class="o">=</span><span class="n">inplace_return</span><span class="p">,</span>
                <span class="n">function_return_key</span><span class="o">=</span><span class="n">function_return_key</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;transform_to_RTZ received invalid type for arg0 of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be either a Seismogram or SeismogramEnsemble&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="transform_to_LQT"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.transform_to_LQT">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_to_LQT</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">seaz_key</span><span class="o">=</span><span class="s2">&quot;seaz&quot;</span><span class="p">,</span>
    <span class="n">ema_key</span><span class="o">=</span><span class="s2">&quot;ema&quot;</span><span class="p">,</span>
    <span class="n">phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">angle_units</span><span class="o">=</span><span class="s2">&quot;degrees&quot;</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies coordinate transform to LQT version of ray coordinates.</span>

<span class="sd">    LQT is an orthogonal coordinate transformation for Seismogram</span>
<span class="sd">    objects that cause the output data to have x1-Longitudinal (positive up</span>
<span class="sd">    normally set to the predicted emergence angle of P particle motion),</span>
<span class="sd">    x2 - Q a rotated radial direction (in propagation direction but tilted by theta).</span>
<span class="sd">    and x3 - transverse (T) in direction to define a right handed coordinate</span>
<span class="sd">    system.  The function produces this transformation</span>
<span class="sd">    by the product f three transformation:</span>

<span class="sd">        1.  Uses rotate_to_standard to assure we start from cardinal directions.</span>
<span class="sd">        2.  Transformation to what might be called TQL using the Seismogram</span>
<span class="sd">            C++ method rotate using a SphericalCoordinate definition.</span>
<span class="sd">        3.  Transformation to LQT to rearrange the order of the Seismogram</span>
<span class="sd">            data matrix (also requires a sign change on T to keep the output</span>
<span class="sd">            right handed)</span>

<span class="sd">    The form of the transformation can be specified in one of two</span>
<span class="sd">    completely different ways.   By default the function attempts to</span>
<span class="sd">    extract the back azimuth from station to event with using the</span>
<span class="sd">    metadata key defined by &#39;seaz_key&#39; (default &#39;seaz&#39;) and the P</span>
<span class="sd">    emergence angle with the metadata key defined by the &#39;ema_key&#39;</span>
<span class="sd">    argument (default &#39;ema&#39;).   If the arguments &#39;phi&#39; and &#39;theta&#39; are</span>
<span class="sd">    defined they are assumed angles to be used to defined the</span>
<span class="sd">    transformation and no attempt will be made to fetch the value from</span>
<span class="sd">    Metaata (Rarely a good idea with ensemble but can be useful for atomic data.</span>
<span class="sd">    Using Metadata is strongly preferred because it also preserves what</span>
<span class="sd">    the angles used where.  They are not if the argument approach is used.)</span>
<span class="sd">    Metadata values are required to be in degree units.  If the argument</span>
<span class="sd">    approach is used radian values can to used if you also set</span>
<span class="sd">    the argument &quot;angle_units&quot; to &quot;radians&quot;.</span>

<span class="sd">    Note the operation handles the singular case of theta==0.0 where it</span>
<span class="sd">    simply uses the phi value and rotates the coordinates in a variant of</span>
<span class="sd">    RTZ (variant because order is different).</span>

<span class="sd">    :param seaz_key:  key to use to fetch back azimuth value (assumed degrees always)</span>
<span class="sd">    :type key:  string (default &quot;seaz&quot;)</span>
<span class="sd">    :param ema_key:  key to use to fetch emergence angle defining L direction</span>
<span class="sd">        relative to local vertical.</span>
<span class="sd">    :type ema_key:  string (defautl &quot;ema&quot;)</span>
<span class="sd">    :param phi:   angle to rotate around vertical to define the transformation</span>
<span class="sd">        (positive anticlockwise convention NOT azimuth convention)  Default is None</span>
<span class="sd">        which means ignore this parameter and use key.  Setting this value to</span>
<span class="sd">        something other than None causes the Metadata fetch method to be overridden.</span>
<span class="sd">        WARNING:  this is not backazimuth but angle relative to E direction.</span>
<span class="sd">        Note that is not at all what is expected when using a Metadata key</span>
<span class="sd">    :type phi:  float</span>
<span class="sd">    :param theta:   angle relative to local vertical for defining the L</span>
<span class="sd">        coordinate direction.  It is the same as theta in spherical coordinates</span>
<span class="sd">        with emergence angle pointing upward.  Default is None which causes the</span>
<span class="sd">        algorithm to automatically assume the Metadata key method should be used.</span>
<span class="sd">    :type theta:  float</span>
<span class="sd">    :param angle_units:  should be either &#39;degrees&#39; (default) or &#39;radians&#39;.</span>
<span class="sd">        An invalid value will be treated as an attempt to switch to radians</span>
<span class="sd">        but will generate an elog warning message.  This argument is ignored unless</span>
<span class="sd">        phi is not null (None type)</span>
<span class="sd">    :type angle_units: string</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>

<span class="sd">     :return:  transformed version of input.  For ensembles the entire ensemble</span>
<span class="sd">         is transformed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">phi</span> <span class="ow">and</span> <span class="n">theta</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">angle_units</span> <span class="o">==</span> <span class="s2">&quot;degrees&quot;</span><span class="p">:</span>
            <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">theta_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">angle_units</span> <span class="o">!=</span> <span class="s2">&quot;radians&quot;</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Illegal value for angle_units argument=&quot;</span> <span class="o">+</span> <span class="n">angle_units</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; assuming radians&quot;</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span>
                    <span class="s2">&quot;transform_to_LQT&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Complaint</span>
                <span class="p">)</span>
            <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">phi</span>
            <span class="n">theta_rad</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="n">use_metadata</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_metadata</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Seismogram</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_metadata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">seaz_key</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ema_key</span><span class="p">):</span>
                <span class="n">seaz</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">seaz_key</span><span class="p">]</span>
                <span class="c1"># need azimuth not back azimuth</span>
                <span class="n">az</span> <span class="o">=</span> <span class="n">seaz</span> <span class="o">-</span> <span class="mf">180.0</span>
                <span class="n">phi_deg</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">-</span> <span class="n">az</span>
                <span class="c1"># trig funtions work the same if angle wraps so no neeed to test</span>
                <span class="c1"># for fixed range</span>
                <span class="n">phi_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi_deg</span><span class="p">)</span>
                <span class="n">ema_deg</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ema_key</span><span class="p">]</span>
                <span class="n">theta_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ema_deg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;At least one of required metadata keys=&quot;</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="n">seaz_key</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="n">ema_key</span>
                <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot; are not defined in this datume - killed&quot;</span>
                <span class="n">data</span><span class="o">.</span><span class="n">elog</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="s2">&quot;transform_to_LQT&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">ErrorSeverity</span><span class="o">.</span><span class="n">Invalid</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">data</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">rotate_to_standard</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SphericalCoordinate</span><span class="p">()</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">phi_rad</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta_rad</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># not strictly necessary but prudent</span>
            <span class="c1"># rotate method is overloaded allowing this type of input</span>
            <span class="n">data</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
            <span class="c1"># The rotate method returns the data in TQL order.</span>
            <span class="c1"># Standard convention is LQT so we reorder the data</span>
            <span class="c1"># This could be done more efficiently with vector operators</span>
            <span class="c1"># but we need to use the transform method to assure the</span>
            <span class="c1"># internal tranformation matrix is properly updated</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
            <span class="n">data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># x = np.array(data.data[0,:])</span>
            <span class="c1"># data.data[0,:] = data.data[2,:]</span>
            <span class="c1"># change the sign of T to keep coordinates right handed == LQT</span>
            <span class="c1"># data.data[2,:] = -x</span>
        <span class="k">except</span> <span class="n">MsPASSError</span> <span class="k">as</span> <span class="n">merr</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">log_error</span><span class="p">(</span><span class="n">merr</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SeismogramEnsemble</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">)):</span>
            <span class="c1"># this is a recursion so be aware</span>
            <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform_to_LQT</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">seaz_key</span><span class="o">=</span><span class="n">seaz_key</span><span class="p">,</span>
                <span class="n">ema_key</span><span class="o">=</span><span class="n">ema_key</span><span class="p">,</span>
                <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span>
                <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                <span class="n">angle_units</span><span class="o">=</span><span class="n">angle_units</span><span class="p">,</span>
                <span class="n">object_history</span><span class="o">=</span><span class="n">object_history</span><span class="p">,</span>
                <span class="n">alg_name</span><span class="o">=</span><span class="n">alg_name</span><span class="p">,</span>
                <span class="n">alg_id</span><span class="o">=</span><span class="n">alg_id</span><span class="p">,</span>
                <span class="n">dryrun</span><span class="o">=</span><span class="n">dryrun</span><span class="p">,</span>
                <span class="n">inplace_return</span><span class="o">=</span><span class="n">inplace_return</span><span class="p">,</span>
                <span class="n">function_return_key</span><span class="o">=</span><span class="n">function_return_key</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;transform_to_LQT received invalid type for arg0 of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="s2">&quot;Must be either a Seismogram or SeismogramEnsemble&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="linear_taper"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.linear_taper">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">linear_taper</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">t0head</span><span class="p">,</span>
    <span class="n">t1head</span><span class="p">,</span>
    <span class="n">t1tail</span><span class="p">,</span>
    <span class="n">t0tail</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Taper front and/or end of a data object with a linear taper.</span>

<span class="sd">    Linear tapers are defined here as a time spanning a ramp running from 0 to 1.</span>
<span class="sd">    Data will be zeroed on each end of a 0 mark and a linear weight applied between</span>
<span class="sd">    0 points and 1 points.  Postive ramp slope on left and negative slope ramp on</span>
<span class="sd">    right. Setting t0 == t1 will disable the taper on the specified end (e.g., t0head == t1head).</span>

<span class="sd">    :param data: data object to be processed.</span>
<span class="sd">    :type data: either :class:`~mspasspy.ccore.seismic.TimeSeries` or :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param t0head: t0 of the head taper</span>
<span class="sd">    :type t0head: :class:`float`</span>
<span class="sd">    :param t1head: t1 of the head taper</span>
<span class="sd">    :type t1head: :class:`float`</span>
<span class="sd">    :param t1tail: t1 of the tail taper</span>
<span class="sd">    :type t1tail: :class:`float`</span>
<span class="sd">    :param t0tail: t0 of the tail taper</span>
<span class="sd">    :type t0tail: :class:`float`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">LinearTaper</span><span class="p">(</span><span class="n">t0head</span><span class="p">,</span> <span class="n">t1head</span><span class="p">,</span> <span class="n">t1tail</span><span class="p">,</span> <span class="n">t0tail</span><span class="p">)</span>
    <span class="n">taper</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="cosine_taper"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.cosine_taper">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">cosine_taper</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">t0head</span><span class="p">,</span>
    <span class="n">t1head</span><span class="p">,</span>
    <span class="n">t1tail</span><span class="p">,</span>
    <span class="n">t0tail</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Taper front and/or end of a data object with a half cosine function.</span>

<span class="sd">    A cosine taper is a common, simple approach to taper data.  When applied at the</span>
<span class="sd">    front it defnes a half cycle of a cosine curve +1.0 in range -pi to 0.  On</span>
<span class="sd">    the right it defines the same function for the range 0 to pi.  The period</span>
<span class="sd">    of the left and right operator can be different.  Turn off left or right by</span>
<span class="sd">    giving illegal start and end points and the operator will silently be</span>
<span class="sd">    only one sided.</span>

<span class="sd">    :param data: data object to be processed.</span>
<span class="sd">    :type data: either :class:`~mspasspy.ccore.seismic.TimeSeries` or :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param t0head: t0 of the head taper</span>
<span class="sd">    :type t0head: :class:`float`</span>
<span class="sd">    :param t1head: t1 of the head taper</span>
<span class="sd">    :type t1head: :class:`float`</span>
<span class="sd">    :param t1tail: t1 of the tail taper</span>
<span class="sd">    :type t1tail: :class:`float`</span>
<span class="sd">    :param t0tail: t0 of the tail taper</span>
<span class="sd">    :type t0tail: :class:`float`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">CosineTaper</span><span class="p">(</span><span class="n">t0head</span><span class="p">,</span> <span class="n">t1head</span><span class="p">,</span> <span class="n">t1tail</span><span class="p">,</span> <span class="n">t0tail</span><span class="p">)</span>
    <span class="n">taper</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="vector_taper"><a class="viewcode-back" href="../../../python_api/mspasspy.algorithms.html#mspasspy.algorithms.basic.vector_taper">[docs]</a><span class="nd">@mspass_func_wrapper</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vector_taper</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">taper_array</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">object_history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">alg_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">alg_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dryrun</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">function_return_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">handles_ensembles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">checks_arg0_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">handles_dead_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a general taper defined by a vector to the data object.</span>

<span class="sd">    This method provides a simple way to build a taper from a set of uniformly</span>
<span class="sd">    spaced points. The apply methods will dogmatically only accept input</span>
<span class="sd">    data of the same length as the taper defined in the operator.</span>

<span class="sd">    :param data: data object to be processed.</span>
<span class="sd">    :type data: either :class:`~mspasspy.ccore.seismic.TimeSeries` or :class:`~mspasspy.ccore.seismic.Seismogram`</span>
<span class="sd">    :param taper_array: the array that defines the taper</span>
<span class="sd">    :type taper_array: :class:`numpy.array`</span>
<span class="sd">    :param object_history: True to preserve the processing history. For details, refer</span>
<span class="sd">        to :class:`~mspasspy.util.decorators.mspass_func_wrapper`.</span>
<span class="sd">    :param alg_name: alg_name is the name the func we are gonna save while preserving the history.</span>
<span class="sd">    :type alg_name: :class:`str`</span>
<span class="sd">    :param alg_id: alg_id is a unique id to record the usage of func while preserving the history.</span>
<span class="sd">    :type alg_id: :class:`bson.objectid.ObjectId`</span>
<span class="sd">    :param dryrun: True for dry-run, which return &quot;OK&quot;. Used in the mspass_func_wrapper.</span>
<span class="sd">    :param inplace_return: True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</span>
<span class="sd">    :param function_return_key:  Some functions one might want to wrap with this decorator</span>
<span class="sd">        return something that is appropriate to save as Metadata.  If so, use this argument to</span>
<span class="sd">        define the key used to set that field in the data that is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">taper</span> <span class="o">=</span> <span class="n">VectorTaper</span><span class="p">(</span><span class="n">taper_array</span><span class="p">)</span>
    <span class="n">taper</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>