

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mspasspy.algorithms &mdash; MsPASS 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=f6245a2f"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="mspasspy.ccore" href="mspasspy.ccore.html" />
    <link rel="prev" title="Python API" href="index.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MsPASS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Desktop Operation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/mspass_desktop.html">Running MsPASS on a Desktop Computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/command_line_desktop.html">Command Line Docker Desktop Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_with_conda.html">Deploy MsPASS with Conda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_with_conda.html#advanced-setup-considerations">Advanced Setup Considerations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Cluster Operations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_on_HPC.html">Deploying MsPASS on an HPC cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/deploy_mspass_with_conda_and_coiled.html">Deploy MsPASS with Conda and Coiled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started_overview.html">MsPASS Virtual Cluster Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/introduction.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/database_concepts.html">Database Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/CRUD_operations.html">CRUD Operations in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/mongodb_and_mspass.html">Using MongoDB with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/normalization.html">Normalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/importing_tabular_data.html">Importing Tabular Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Seismic Data Objects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/numpy_scipy_interface.html">Using numpy/scipy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/obspy_interface.html">Using ObsPy with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/time_standard_constraints.html">Time Standard Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/processing_history_concepts.html">Processing History Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/continuous_data.html">Continuous Data Handling with MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/schema_choices.html">What database schema should I use?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Processing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/importing_data.html">Importing Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/handling_errors.html">Handling Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/data_editing.html">Data Editing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/cleaning_metadata.html">Cleaning Inconsistent Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/header_math.html">Header (Metadata) Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/graphics.html">Graphics in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/signal_to_noise.html">Signal to Noise Ratio Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/arrival_time_measurement.html">Arrival Time Measurement Techniques in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/adapting_algorithms.html">Adapting an Existing Algorithm to MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">System Tuning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/parallel_processing.html">Parallel Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/memory_management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/io.html">I/O in MsPASS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/parallel_io.html">Parallel IO in MsPASS</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/FAQ.html">Frequency Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_manual/development_strategies.html">How do I develop a new workflow from scratch?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Python API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">mspasspy.algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.MCXcorStacking">MCXcorStacking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.MCXcorPrepP"><code class="docutils literal notranslate"><span class="pre">MCXcorPrepP()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.align_and_stack"><code class="docutils literal notranslate"><span class="pre">align_and_stack()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.amplitude_relative_to_beam"><code class="docutils literal notranslate"><span class="pre">amplitude_relative_to_beam()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.beam_align"><code class="docutils literal notranslate"><span class="pre">beam_align()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.beam_coherence"><code class="docutils literal notranslate"><span class="pre">beam_coherence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.beam_correlation"><code class="docutils literal notranslate"><span class="pre">beam_correlation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.dbxcor_weights"><code class="docutils literal notranslate"><span class="pre">dbxcor_weights()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.demean_residuals"><code class="docutils literal notranslate"><span class="pre">demean_residuals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.estimate_ensemble_bandwidth"><code class="docutils literal notranslate"><span class="pre">estimate_ensemble_bandwidth()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.extract_initial_beam_estimate"><code class="docutils literal notranslate"><span class="pre">extract_initial_beam_estimate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.phase_time"><code class="docutils literal notranslate"><span class="pre">phase_time()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.post_MCXcor_metrics"><code class="docutils literal notranslate"><span class="pre">post_MCXcor_metrics()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.regularize_ensemble"><code class="docutils literal notranslate"><span class="pre">regularize_ensemble()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.remove_incident_wavefield"><code class="docutils literal notranslate"><span class="pre">remove_incident_wavefield()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MCXcorStacking.robust_stack"><code class="docutils literal notranslate"><span class="pre">robust_stack()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.MTPowerSpectrumEngine">MTPowerSpectrumEngine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine"><code class="docutils literal notranslate"><span class="pre">MTPowerSpectrumEngine</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.RFdeconProcessor">RFdeconProcessor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.RFdeconProcessor.RFdecon"><code class="docutils literal notranslate"><span class="pre">RFdecon()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor"><code class="docutils literal notranslate"><span class="pre">RFdeconProcessor</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.basic">basic</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.ExtractComponent"><code class="docutils literal notranslate"><span class="pre">ExtractComponent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.ator"><code class="docutils literal notranslate"><span class="pre">ator()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.cosine_taper"><code class="docutils literal notranslate"><span class="pre">cosine_taper()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.free_surface_transformation"><code class="docutils literal notranslate"><span class="pre">free_surface_transformation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.linear_taper"><code class="docutils literal notranslate"><span class="pre">linear_taper()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.rotate"><code class="docutils literal notranslate"><span class="pre">rotate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.rotate_to_standard"><code class="docutils literal notranslate"><span class="pre">rotate_to_standard()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.rtoa"><code class="docutils literal notranslate"><span class="pre">rtoa()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.transform"><code class="docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.transform_to_LQT"><code class="docutils literal notranslate"><span class="pre">transform_to_LQT()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.transform_to_RTZ"><code class="docutils literal notranslate"><span class="pre">transform_to_RTZ()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.basic.vector_taper"><code class="docutils literal notranslate"><span class="pre">vector_taper()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.bundle">bundle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.bundle.BundleSEEDGroup"><code class="docutils literal notranslate"><span class="pre">BundleSEEDGroup()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.bundle.bundle_seed_data"><code class="docutils literal notranslate"><span class="pre">bundle_seed_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.calib">calib</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.calib.ApplyCalibEngine"><code class="docutils literal notranslate"><span class="pre">ApplyCalibEngine</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.edit">edit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Add"><code class="docutils literal notranslate"><span class="pre">Add</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Add2"><code class="docutils literal notranslate"><span class="pre">Add2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.ChangeKey"><code class="docutils literal notranslate"><span class="pre">ChangeKey</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Divide"><code class="docutils literal notranslate"><span class="pre">Divide</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Divide2"><code class="docutils literal notranslate"><span class="pre">Divide2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Executioner"><code class="docutils literal notranslate"><span class="pre">Executioner</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.FiringSquad"><code class="docutils literal notranslate"><span class="pre">FiringSquad</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.IntegerDivide"><code class="docutils literal notranslate"><span class="pre">IntegerDivide</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.IntegerDivide2"><code class="docutils literal notranslate"><span class="pre">IntegerDivide2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataDefined"><code class="docutils literal notranslate"><span class="pre">MetadataDefined</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataEQ"><code class="docutils literal notranslate"><span class="pre">MetadataEQ</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataGE"><code class="docutils literal notranslate"><span class="pre">MetadataGE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataGT"><code class="docutils literal notranslate"><span class="pre">MetadataGT</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataInterval"><code class="docutils literal notranslate"><span class="pre">MetadataInterval</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataLE"><code class="docutils literal notranslate"><span class="pre">MetadataLE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataLT"><code class="docutils literal notranslate"><span class="pre">MetadataLT</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataNE"><code class="docutils literal notranslate"><span class="pre">MetadataNE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator"><code class="docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperatorChain"><code class="docutils literal notranslate"><span class="pre">MetadataOperatorChain</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.MetadataUndefined"><code class="docutils literal notranslate"><span class="pre">MetadataUndefined</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Mod"><code class="docutils literal notranslate"><span class="pre">Mod</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Mod2"><code class="docutils literal notranslate"><span class="pre">Mod2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Multiply"><code class="docutils literal notranslate"><span class="pre">Multiply</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Multiply2"><code class="docutils literal notranslate"><span class="pre">Multiply2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.SetValue"><code class="docutils literal notranslate"><span class="pre">SetValue</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Subtract"><code class="docutils literal notranslate"><span class="pre">Subtract</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.Subtract2"><code class="docutils literal notranslate"><span class="pre">Subtract2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.edit.erase_metadata"><code class="docutils literal notranslate"><span class="pre">erase_metadata()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.resample">resample</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.resample.BasicResampler"><code class="docutils literal notranslate"><span class="pre">BasicResampler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.resample.ScipyDecimator"><code class="docutils literal notranslate"><span class="pre">ScipyDecimator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.resample.ScipyResampler"><code class="docutils literal notranslate"><span class="pre">ScipyResampler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.resample.resample"><code class="docutils literal notranslate"><span class="pre">resample()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.signals">signals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.correlate"><code class="docutils literal notranslate"><span class="pre">correlate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.correlate_stream_template"><code class="docutils literal notranslate"><span class="pre">correlate_stream_template()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.correlate_template"><code class="docutils literal notranslate"><span class="pre">correlate_template()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.correlation_detector"><code class="docutils literal notranslate"><span class="pre">correlation_detector()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.detrend"><code class="docutils literal notranslate"><span class="pre">detrend()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.filter"><code class="docutils literal notranslate"><span class="pre">filter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.interpolate"><code class="docutils literal notranslate"><span class="pre">interpolate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.templates_max_similarity"><code class="docutils literal notranslate"><span class="pre">templates_max_similarity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.xcorr_3c"><code class="docutils literal notranslate"><span class="pre">xcorr_3c()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.xcorr_max"><code class="docutils literal notranslate"><span class="pre">xcorr_max()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.signals.xcorr_pick_correction"><code class="docutils literal notranslate"><span class="pre">xcorr_pick_correction()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.snr">snr</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.EstimateBandwidth"><code class="docutils literal notranslate"><span class="pre">EstimateBandwidth()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.FD_snr_estimator"><code class="docutils literal notranslate"><span class="pre">FD_snr_estimator()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.arrival_snr"><code class="docutils literal notranslate"><span class="pre">arrival_snr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.broadband_snr_QC"><code class="docutils literal notranslate"><span class="pre">broadband_snr_QC()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.filter_by_snr_bandwidth"><code class="docutils literal notranslate"><span class="pre">filter_by_snr_bandwidth()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.save_snr_arrival"><code class="docutils literal notranslate"><span class="pre">save_snr_arrival()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.snr"><code class="docutils literal notranslate"><span class="pre">snr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.snr.visualize_qcdata"><code class="docutils literal notranslate"><span class="pre">visualize_qcdata()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-mspasspy.algorithms.window">window</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.TopMute"><code class="docutils literal notranslate"><span class="pre">TopMute</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.WindowData"><code class="docutils literal notranslate"><span class="pre">WindowData()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.WindowDataAtomic"><code class="docutils literal notranslate"><span class="pre">WindowDataAtomic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.WindowData_autopad"><code class="docutils literal notranslate"><span class="pre">WindowData_autopad()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.ensemble_error_post"><code class="docutils literal notranslate"><span class="pre">ensemble_error_post()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mspasspy.algorithms.window.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.ccore.html">mspasspy.ccore</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.client.html">mspasspy.client</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.db.html">mspasspy.db</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.global_history.html">mspasspy.global_history</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.graphics.html">mspasspy.graphics</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.history.html">mspasspy.history</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.io.html">mspasspy.io</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.preprocessing.html">mspasspy.preprocessing</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.reduce.html">mspasspy.reduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="mspasspy.util.html">mspasspy.util</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cxx_api/index.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mspass_schema/mspass_schema.html">MsPASS Schema</a></li>
</ul>

    <a href= "../genindex.html">Index</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MsPASS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Python API</a></li>
      <li class="breadcrumb-item active">mspasspy.algorithms</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/mspass-team/mspass/blob/master/docs/source/python_api/mspasspy.algorithms.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mspasspy-algorithms">
<h1>mspasspy.algorithms<a class="headerlink" href="#mspasspy-algorithms" title="Permalink to this heading"></a></h1>
<section id="module-mspasspy.algorithms.MCXcorStacking">
<span id="mcxcorstacking"></span><h2>MCXcorStacking<a class="headerlink" href="#module-mspasspy.algorithms.MCXcorStacking" title="Permalink to this heading"></a></h2>
<p>Module implementing a similar algorithm to dbxcor in python.</p>
<p>Created on Tue Jul  9 05:37:40 2024</p>
<p>&#64;author: pavlis</p>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.MCXcorPrepP">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">MCXcorPrepP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_window</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mad'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_beam_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bandwidth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_doc_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Parrival'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_f_corner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_f_corner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_parameter_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['MCXcor_f_low',</span> <span class="pre">'MCXcor_f_high',</span> <span class="pre">'MCXcor_npoles']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coda_level_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_phases</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ptime_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Ptime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pPtime_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pPtime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PPtime_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PPtime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">station_collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'channel'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_window_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_coda_duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation_window_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-3.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeriesEnsemble" title="mspasspy.ccore.seismic.TimeSeriesEnsemble"><span class="pre">TimeSeriesEnsemble</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#MCXcorPrepP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.MCXcorPrepP" title="Permalink to this definition"></a></dt>
<dd><p>Function used to preprocess an ensemble  to prepare input for
running multichannel cross-correlation and stacking method
(automated dbxcor algorithm) of P phase data.  This function should
not be used for anything but teleseismic P data.</p>
<p>The multichannel correlation and stacking function in this module called
<cite>align_and_stack</cite> requires one to define a number of parameters that
in the original dbxcor implementation were input through a graphical
user interface.   This function can be thought of a robot that will
attempt to set all the required parameters automatically using signal processing.
It will attempt to produce two inputs required by the <cite>align_and_stack</cite>:
1.  What I call a “correlation window”.
2.  The ensemble member that is to be used as the initial estimate of the</p>
<blockquote>
<div><p>beam (stack of the data aligned by cross correlation).</p>
</div></blockquote>
<p>A CRITICAL assumption of this function is that the input ensemble’s data
have been processed with the snr module function <cite>broadband_snr_QC</cite>.
That function computes and posts multiple snr metrics to a subdocument
(dictionary) accessed with a single key.   This function requires that
data exist and be accessible with the key defined by the argument
“snr_doc_key”.   The data in that dictionary are used in the following
algorithms run within this function:
1.  The working bandwidth of the data is established by computing the median</p>
<blockquote>
<div><p>of the attributes “low_f_band_edge” and “high_f_band_edge” extracted from
each live member.  Those frequencies are computed using the function in this module
called <cite>estimate_ensemble_bandwidth</cite>.  The working ensemble
(which is what is returned on success) will be filtered in the band defined
by the output of <cite>estimate_ensemble_bandwidth</cite> using a Butterworth,
bandpass filter with the number of poles defined by the “npoles” argument.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>What I call the correlation window is estimated by a complex recipe
best understood from the user manual page and example jupyter notebooks
related to this module.   Briefly, the correlation window is defined by
applying an envelope function to each signal and defining the coda
end using a common recipe for coda magnitudes where the end of the coda is
defined by where the coda level (envelope) first falls below a
level specified as a multiple of measured background noise.
This function REQUIRES the input for each member to have a section
that it can treat as background noise.  For most uses that means some
section of data immediately before the P wave arrival time.  The
noise level is estimated by the metric defined by the “noise_metric”
argument and the coda level cutoff is computed as
<cite>noise_level*coda_level_factor</cite> where <cite>coda_level_factor</cite> is the
valued passed via the function argument with that key.
Because this function is designed strictly for P phases it has to
handle the complexity of interference by secondary P phases.   For
that reason it compute arrival times for pP and PP and will always
start the coda search before time of the smaller of pP or PP.
Note, however, that pP is not used a constraint if the source depth is
less than 100 km.   The justification for that number can be found in
jupyter notebooks that should be part of the MsPASS documentation.</p></li>
<li><p>It then extracts one member from the ensemble the algorithm judges to
be the best choice for an initial beam estimate.   That is, in
align_and_stack the first step  is to align the data with a reference
signal using cross-correlation of the “beam” with each member.  The
aligned data are then summed with a robust stack to refine the beam.
That is repeated until the stack does not change significantly.
That algorithm requires a seed for the initial beam estimate.   That
initial signal is extracted as the ensemble member with the largest
value of the snr metric defined with the <cite>initial_beam_metric</cite> argument.
The correlation window parameters computed earlier are then posted
to the <cite>Metadata</cite> of that <cite>TimeSeries</cite> where <cite>align_and_stack</cite>
can parse them to set the correlation time window.</p></li>
</ol>
<p>The function returns a copy of the input ensemble filtered to the
average bandwidth and the initial beam estimate.  They are return
as a tuple with 0 the ensemble and 1 the initial beam estimate.
Callers should verify the beam signal is marked live.  A dead
beam signal indicates the algorithm failed in one way or another.
Errors at the level will result in errors being posted to the
<cite>ErrorLogger</cite> container of the beam output.  Note also this
algorithm can kill some ensemble members in the output that
were marked live in the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ensemble</strong> – input ensemble of data to use.  As noted above it</p>
</dd>
</dl>
<p>must have been processed with <cite>broadband_snr_QC</cite> or this function will
return a null result.  The function makes a tacit assumption that all
the members of this ensemble are in relative time with 0 of each member
being an estimate of the P wave arrival time.  It does no tests to
validate this assumption so the assumption is wrong you will, at best,
get junk as output.
:type ensemble: <cite>TimeSeriesEnsemble</cite>  Note for most uses this is the
output of ExtractComponent of a <cite>SeismogramEnsemble</cite> processed with
<cite>broadband_snr_QC</cite> that is the longitudinal component for the P phase.
:param noise_window:  time window defining the section of each
ensemble member that is to be treated as “noise” for estimating
a relative noise level.
:type noise_window:  <cite>TimeWindow</cite> tacitly expected to be time relative
to a measure of the P wave arrival time.
:param noise_metric:  vector norm metric to use for measuring the
amplitude of the noise extracted from the data in the range defined by
noise_window.
:type noise_metric: string (Must be one of:  “mad” (default), “rms”,
or “peak”).  Any other string will cause the function to throw a ValueError
exception.
:param initial_beam_metric:  key of attribute to extract from the
output of <cite>broadband_snr_QC</cite> used to select initial beam signal.
This argument is passed to the <cite>extract_initial_beam_estimate</cite> function for
as the “metric” argument of that function.
:param initial_beam_metric:  string (default “bandwidth”).  For a list of
allowed values see the docstring of <cite>extract_initial_beam_estimate</cite>.
:param snr_doc_key:  key to use to fetch the subdocument containing the
output of <cite>broadband_snr_QC</cite>.
:type snr_doc_key:  string (default “Parrival” which is the default of
<cite>broadband_snr_QC</cite>).
:param low_f_corner: force the low frequency corner for the output data
bandwidth to this value.   When defined, the internal call to
<cite>estimate_ensemble_bandwidth</cite> is bypassed and the output data are filtered
between the value defined by low_f_corner and high_f_corner.
:type low_f_corner:  float (default None which is interpreted to mean
scan ensemble to estimate the frequency range)
:param high_f_corner: force the high frequency corner for the output data
bandwidth to this value.   When defined, the internal call to
<cite>estimate_ensemble_bandwidth</cite> is bypassed and the output data are filtered
between the value defined by low_f_corner and high_f_corner.
:type high_f_corner:  float (default None which is interpreted to mean
scan ensemble to estimate the frequency range)
:param npoles:  number of poles to use for the Butterworth bandpass
filter.
:type npoles:  integer (default 4)
:param set_phases: boolean that if set True (default) the P phase time s
P, pP (if defined), and PP (if defined) are computed and posted to the
output of each ensemble member.  If False the algorith assumes the
same quantities were previously calculated and can be fetched from the
member TimeSeries Metadata container using keys defined by Ptime_key,
pPtimme_key, and PPtime_key.
:param Ptime_key:
:param pPtime_key:
:param PPtime_key:  These three arguments define alternative keys that
will be used to fetch (if set_phases is false) or post (if set_phases is True)
computed P, pP, and PP times to each member’s Metadata container.
Changing any of these values not really advised when set_phases is True.
These are most useful if the phase arrival times were previously
computed or measured and posted with different keys.
:param station_collection:   MonogDB collection name used to fetch
receiver coordinate data.   Normal practice in MsPASS is to save
receiver Metadata in two channels called “channel” and “site” and
to load the coordinate data through normalization when the data are
loaded.  The MsPASS convention defines data loaded by normalization
with a leading collection name.  e.g. the “lat” value extracted from a
“channel” document would be posted to the data as “channel_lat”.
The same value, however, loaded from “site” would be tagged “site_lat”.
The default for this argument is “channel” which means the algorithm
will require the attributes “channel_lat” and “channel_lon” as the
receiver coordinates (in degrees).  The standard alternative is to
define <cite>station_collection=”site”</cite>, in which case the function will
use “site_lat” and “site_lon”.
:type station_collection:  string (default “channel”)
:param search_window_fraction:   The window for defining the
correlation window is determined by running the internal
<cite>_coda_duration</cite> function on each ensemble member and computing the
range from the median of the ranges computed from all the ensemble
members.  Each coda search, however, is constrained by the time so f
pP and/or PP.   As noted above the function uses the pP time for
events with depths greater than 100 km but PP for shallow sources.
To allow for hypocenter errors  the duration defined by
P to pP or P to PP is multiplied by this factor to define the
search start for the coda estimation.
:type search_window_fraction: float (default 0.9)
:param minimum_coda_duration:   if the estimate of coda duration
computed internally is less than this value the correlation window
is set to this value - relative time from P.
:type minimum_coda_duration:  float (5.0 seconds)
:param correlation_window_start:  the time of the correlation window
set in the output “beam” is fixed as this value.   It is normally
a negative number defining a time before P that no signal is likely to
have an arrival before this relative time.
:type correlation_window_start:  float (default -3.0)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.align_and_stack">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">align_and_stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation_window_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['correlation_window_start',</span> <span class="pre">'correlation_window_end']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_stack_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_stack_window_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['robust_window_start',</span> <span class="pre">'robust_window_end']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_stack_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dbxcor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_median_initial_stack</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_stack_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust_weight_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'robust_stack_weight'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arrival_time_correction'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abort_irregular_sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_norm_floor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demean_residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#align_and_stack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.align_and_stack" title="Permalink to this definition"></a></dt>
<dd><p>This function uses an initial estimate of the array stack passed as
the <cite>beam</cite> argument as a seed to a robust algorithm that will
align all the data in the input ensemble by cross-correlation with
the beam, apply a robust stack to the aligned signals, update the
beam with the robust stack, and repeat until the changes to the
beam signal are small.   Returns a copy of the ensemble time
shifted to be aligned with beam time base and an updated beam
estimate crated by the robust stack.  The shifts and the weights
of each input signal are stored in the Metadata of each live ensemble
member returned with keys defined by <cite>robust_weight_key</cite> and
<cite>time_shift_key</cite>.</p>
<p>This function is a python implementation of the same basic
algorithm used in the dbxcor program described by
Pavlis and Vernon(2010) Array Processing of teleseismic body waves
with the USArray, Computers and Geosciences,15, 910-920.
It has additional options made possible by the python interface
and integration into MsPASS.  In particular, the original algorithm
was designed to work as part of a GUI where the user had to pick
a set of required parameters for the algorithm.   In this function
those are supplied through Metadata key-value pairs and/or arguments.
This function uses a pythonic approach aimed to allow this function
to be run in batch without user intervention.  The original dbxcor
algorithm required four interactive picks to set the input.
The way we set them for this automated algorithm is described in the
following four itemize paragraphs:</p>
<blockquote>
<div><ol class="arabic">
<li><p>The “correlation window”, which is the waveform segment
used to compute cross-correlations between the beam and all
ensmebled members, is set one of three ways.  The default
uses the time window defined by the starttime and endtime of
the <cite>beam</cite> signal as the cross-correlation window.
Alternative, this window can be specified either by
fetching values from the <cite>Metadata</cite> container of beam
or via the <cite>correlation_window</cite> argument.   The algorithm
first tests if <cite>correlation_window</cite> is set and is an
instance of a <cite>TimeWindow</cite> object.   If the type of
the argument is not a <cite>TimeWindow</cite> object an error is logged
and the program reverts to using the span of the beam
signal as the correlation window.   If <cite>correlation_window</cite>
is a None (default) the algorithm then checks for a valid
input via the <cite>correlation_window_keys</cite> argument.  If
defined that argument is assumed to contain a pair of strings
that can be used as keys to fetch start (component 0)
and end times (component 1) from the Metadata container of
the TimeSeries objct passed via beam. For example,
<a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a></p>
<blockquote>
<div><p>correlation_window_keys = [‘correlation_start’,’correlation_end’]</p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a>`
would cause the function to attempt to fetch the
start time with “correlation_start” and end time with
“correlation_end”.  In the default both <cite>correlation_window</cite>
and <cite>correlation_window_keys</cite> are None which cause the
function to silently use the window defined as
[beam.t0, beam.endtime()] as the correlation winow.
If the optional boolean <cite>window_beam</cite> argument is set True
the function will attempt to window the beam using a range
input via either of the optional methods of setting the
correlation window.  An error is logged and nothing happens if
<cite>window_beam</cite> is set True and the default use of the beam
window is being used.</p>
</li>
<li><p>The “robust window” is a concept used in dbxcor to
implement a special robust stacking algorithm that is a novel
feature of the dbxcor algorithm.   It uses a very aggresssive
weighting scheme to downweight signals that do not match the
beam.  The Pavlis and Vernon paper shows examples of how this
algorithm can cleanly handle ensembles with a mix of high
signal-to-noise data with pure junk and produce a clean
stack that is defined.   Note recent experience has shown
that with large, consistent ensembles the dbxcor robust
estimate tends to converge to the focus on the signal closestbeam_correlation
to the median stack.  The reason is that the median stack
is always used as the initial estimator.   Hence, it can
be thought of as a median stack that uses the full data
set more completely.</p></li>
<li><p>dbxcor required the user to pick a seed signal to use as
the initial beam estimate.  That approach is NOT used here
but idea is to have some estimate passed to the algorithm
via the beam (arg1) argument.  In MsPASS the working model
is to apply the  broadband_snr_QC function to the data before
running this function and select the initial seed (beam) from
one or more of the computed snr metrics.   In addition,
with this approach I envision a two-stage computation where
the some initial seed is used for a first pass.   The
return is then used to revise the correlation window by
examining stack coherence metrics and then rerunning the
algorithm.   The point is it is a research problem for
different types of data to know how to best handle the
align and stack problem.</p></li>
<li><p>dbxcor had a final stage that required picking the arrival time
to use as the reference from the computed beam trace.  That is
actually necessary if absolute times are needed because the
method used will be biased by the time shift of the beam
relative to the reference time.   See the Pavlis and Vernon
paper for more on this topic.   The idea here is that if
absolute times are needed some secondary processing will be used
to manually or automatically pick an arrival time from the
beam output.</p></li>
</ol>
</div></blockquote>
<p>This function does some consistency checking of arguments to handle
the different modes for handling the correlation and robust windows
noted above.  It also applies a series of validation tests on the
input ensemble before attempting to run.  Any of the following will
cause the return to be a dead ensemble with an explanation in the
elog container of the ensemble (in these situation the stack is an
empty <cite>TimeSeries</cite> container):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Irregular sample intervals of live data.</p></li>
<li><p>Any live data with the time reference set to UTC</p></li>
<li><p>Inconsistency of the time range of the data and the
time windows parsed for the correlation and robust windows.
That is, it checks the time span of all member functions and
if the time range of all members (min of start time and maximum end times).
is not outside (inclusive) the range of the correlation and robust
windows it is viewed as invalid.</p></li>
<li><p>What we called the “robust window” in the dbxcor paper isextract_input_beam_estimate
required to be inside (inclusive of endpoints) the cross-correlation window
time window.   That could be relaxed but is a useful constraint because
in my (glp) experience the most coherent part of phase arrivals is the
first few cycles of the phase that is also the part cross-correlation
needs to contain if it is to be stable.   The “robust window” should
be set to focus on the section of the signal that will have the most
coherent stack.</p></li>
</ol>
</div></blockquote>
<p>There is a further complexity in the iteration sequence used by this algorithm
for any robust stack method.  That is, time shifts computed by cross-correlation
can potentially move the correlation window outside the bounds of the
data received as input.   To reduce the impact of that potential problem
the function has an optional argument called <cite>time_shift_limit</cite>
that is validated against other inputs.   In particular, the function
computes the average start and end time (keep in mind the assumption is the
time base is time relative to the arrival time a particular phase)
of the input ensemble.   If the difference between the average start time
and the correlation window start time is less than <cite>time_shift_limit</cite>
the input is viewed as problematic.   How that is handled depends on how
the correlation window is set.  If it is received as constant
(<cite>correlation_window</cite> argument) an exception will be thrown to abort
the entire job.   It that window is extracted from the beam TimeSeries
Metadata container a complaint is logged to the outputs.  An
endtime inconsistency is treated the same way.  i.e. it is treated as
a problem if the average ensemble endtime - the correlation window
endtime is less than the <cite>time_shift_limit</cite>.</p>
<p>A related issue is that arrival times estimated by this algorithm
will be biased by the model mismatch with whatever signal was used
as the initial beam estimae.  In dbxcor that was handled by forcing
the user to manually pick the first arrival of the computed stack.
That could be done if desired but would require you to devise a scheme
to do that picking.   The default here is handled by the boolean
parameter demean_residuals.  When True (the default) the vector
of computed time shifts is corrected by the mean value of the group.
Note that is common practice in regional tomography inversion anyway.
For reasonable sized ensembles it will tend to yield data that when
aligned by arrival time are all close to 0 relative time.</p>
<p>Note the output stack normally spans a different time range than
either the correlation or robust windows.   That property is defined
by the <cite>output_stack_window</cite> argument.  See below for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<cite>TimeSeriesEnsemble</cite> with some fairly rigid requirements.
(see above)) – ensemble of data to be aligned and stacked.
This function requires all data to be on a relative time base.
It will throw a MsPASSError exception if any live datum has a UTC time base.
The assumption is all data have a time span that have the correlation
and robust windows inside the data time range.   Both windows are
carved from the inputs using the WindowData function which will kill
any members that do not satisfy this requirement.</p></li>
<li><p><strong>beam</strong> (<cite>TimeSeries</cite>.  Must have a length consistent with window
parameters.) – Estimate of stack (may be just one representative member)
used as the seed for initial alignment and stacking.</p></li>
<li><p><strong>correlation_window</strong> (<cite>TimeWindow</cite> to define explicitly.  If None
(default) uses the recipe driven by <cite>correlation_window_keys</cite> (see above)) – Used to specify the time window for
computing cross-correlations with the beam signal.   Closely linked to
<cite>correlation_window_keys</cite> as described above.</p></li>
<li><p><strong>correlation_window_keys</strong> – optional pair of Metadata keys used to
extract cross-correlation window attributes from beam Metadata container.
If defined component 0 is taken as the key for the start time of the window and
component 1 the key for the end time.</p></li>
<li><p><strong>window_beam</strong> – if True (default) the parsed cross-correlation window attributes
are applied to the beam signal as well as the data before starting
processing.   If False the beam signal is used directly in all cross-correlations.
Set False only if you can be sure secondary phases are not present in the
unwindowed input.</p></li>
<li><p><strong>robust_stack_window</strong> (If defined must be a <cite>TimeWindow</cite> object.
If a None type (default) use the logic defined above to set this time window.) – Provide an explicity <cite>TimeWindow</cite> used for
extracting the robust window for this algorithm.   Interacts with the
robust_stack_window_keys argument as described above.</p></li>
<li><p><strong>robust_stack_window_keys</strong> (<em>iterable list</em><em> of </em><em>two strings</em>) – specifies a pair of strings to be used
as keys to extract the strart time (component 0) and end time (component 1)
of the robust time window to use from the beam <a href="#id7"><span class="problematic" id="id8">`</span></a>TimeSeries.</p></li>
<li><p><strong>output_stack_window</strong> (<cite>TimeWindow</cite> object.  If None (default) the range
is derived from the ensemble member time ranges.) – optional <cite>TimeWindow</cite> to apply to the
computed robust stack output.   Default returns a stack spanning the
inner range of all live members of the ensemble.</p></li>
<li><p><strong>robust_weight_key</strong> (<em>string</em>) – The robust weight used for each member to
compute the robust stack output is posted to the Metadata container of
each live member with this key.</p></li>
<li><p><strong>robust_stack_method</strong> (<em>string  - must be one</em><em> of </em><em>options listed above.</em>) – keyword defining the method textract_input_beam_estimateo use for
computing the robust stack.  Currently accepted value are:
“dbxcor” (default) and “median”.</p></li>
<li><p><strong>use_median_initial_stack</strong> – If True (default) use the median stack as the initial
estimate of the stack in the first iterative pass.  When False the signal in the
<cite>TimeSeries</cite> passed via the “beam” argument is used for the initial estimate.</p></li>
<li><p><strong>time_shift_key</strong> (<em>string</em><em>  (</em><em>default &quot;arrival_time_correction&quot;</em><em>)</em>) – the time shift applied relative to the starting
point is posted to each live member with this key.  It is
IMPORTANT to realize this is the time for this pass.  If thisextract_input_beam_estimatefunctions
is applied more than once and you reuse this key the shift from the
previous run will be overwritten.  If you need to accumulate shifts
it needs to be handled outside this function.</p></li>
<li><p><strong>convergence</strong> (<em>real number</em><em> (</em><em>default 0.001</em><em>)</em>) – fractional change in robust stack estimates in
iterative loop to define convergence.  This should not be changed
unless you deeply understand the algorithm.</p></li>
<li><p><strong>time_shift_limit</strong> (<em>float</em>) – when time shifting data with the cross
correlation algorithm any estimated time shift larger than
this value will be truncated to this value with the sign
of th shift preserved.</p></li>
<li><p><strong>abort_irregular_sampling</strong> (<em>boolean</em>) – boolean that controls error
handling of data with irregular sample rates.  This function uses
a generous test for sample rate mismatch.  A mismatch is
detected only if the computed time skew over the time span of
the input beam signal is more than 1/2 of the beam sample interval
(beam.dt).  When set true the function will
abort with a ValueError exception if any ensemble member fails the
sample interval test.  If False (the default) offending ensemble
members are killed and a message is posted.  Note the actual
ensemble is modified so the return may have fewer data live
than the input when this mode is enabled.</p></li>
<li><p><strong>residual_norm_floor</strong> (<em>float</em><em> (</em><em>default 0.01</em><em>)</em>) – floor on residuals used to compute dbxcor weight
function.  See docstring for <cite>dbxcor_weights</cite> for details.</p></li>
<li><p><strong>demean_residuals</strong> – boolean controlling if the computed shifts
are corrected with a demean operation.   Default is True which
means the set of all time shifts computed by this function will
have zero mean.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple with 0 containing the original ensemble but time
shifted by cross-correlation.   Failed/discarded signals for the
stack are not killed but should be detected by not having the
time shift Metadata value set.   component 1 is the computed
stack windowed to the range defined by <cite>stack_time_window</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.amplitude_relative_to_beam">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">amplitude_relative_to_beam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_beam</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#amplitude_relative_to_beam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.amplitude_relative_to_beam" title="Permalink to this definition"></a></dt>
<dd><p>Compute and return amplitude relative to the stack (beam).</p>
<p>dbxcor computed a useful metric of amplitude relative to the beam
(stack) as <cite>(d dot beam)/N</cite> where “dot” means vector dot product with
between the sample vectbeam_coherence(d,beam,window=None,filter=True)ors of b and beam and N is vector size.   The formula
requires the beam to be normalized so its L2 norm is 1.  By default it assumes
that but that can be overriden with the normalize_beam argument.
Default assumes d and beam cover the same time span.  If they aren’t
the minimum overlap of the two signals is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<cite>TimeSeries</cite> assumed - will throw an exception if it isn’t) – datum for which the relative amplitude is to be computed.</p></li>
<li><p><strong>beam</strong> (<cite>TimeSeries</cite> assumed  - will throw an exception if it isn’t) – stack with which it is to be compared.</p></li>
<li><p><strong>normalize_beam</strong> (<em>boolean</em>) – If True (default) the windowed beam vector
will be normalized to be a unit vector (i.e. L2 norm of 1.0) for
the calculation.  If False that will not be done and the vector
in beam will be used directly.   Use False ONLY if windowing is off
and beam is already normalized.   A minor efficiency gain is possible
if beam is already normalized.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>float value of amplitude.  A negative number indicates an error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.beam_align">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">beam_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#beam_align"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.beam_align" title="Permalink to this definition"></a></dt>
<dd><p>Aligns ensemble members using signal defined by beam (arg1) argument.</p>
<p>Computes cross correlation between each ensemble member and the beam.
An optional window can be specified that is applied to each ensemble
member before computing the cross correlation function.
All live ensemble members are shifted to align with time base of the
beam.   Note that can be a huge shift if the beam is relative and
the ensemble members are absolute time.  It should work in that context
but the original context was aligning common-source gathers for
teleseismic phase alignment where the expectation is all the ensemble
members and the beam are in relative time with 0 defined by some
estimate of the phase arrival time.   Will correctly handle irregular
window sizes between ensemble members and beam signal.</p>
<p>It is important to recognize that if the window option is used
it is applied only internally.   In that situation the output
will be time shifted but the number of samples of each member
will be the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<em>assumed to be a TimeSeriesEnsemble</em>) – ensemble of data to be correlated with
beam data.</p></li>
<li><p><strong>beam</strong> (<em>assumed to be a TimeSeries object</em>) – common signal to correlate with ensemble members.</p></li>
<li><p><strong>window</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.algorithms.basic.TimeWindow" title="mspasspy.ccore.algorithms.basic.TimeWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.algorithms.basic.TimeWindow</span></code></a>) – optional window to apply to ensemble members
before computing cross correlation.</p></li>
<li><p><strong>time_shift_limit</strong> (<em>float</em><em> (</em><em>may abort if you use an int
because the value can to sent to a C++ method that it type
sensitive</em><em>)</em>) – ceiling on allowed time shift for
ensemble members.   Any computed shift with absolute value
larger than this value will be reset to this value with the
sign of the shift preserved.   (i.e. a negative lag will
be set to the negative of this number).  The default is 10.0
which is large for most data more or less making this an optional
parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>copy of ensemble with the members time shifted to align with
the time base of beam.   Note if a window is defined it is not
applied to the ensemble members.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.beam_coherence">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">beam_coherence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#beam_coherence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.beam_coherence" title="Permalink to this definition"></a></dt>
<dd><p>Compute time-domain coherence of a datum relative to the stack.</p>
<p>Time domain coherence is a measure of misfit between a signal and a
a reference signal (normally a stack).   The formula is
1.0 - norm(residual)/norm(beam) where residual=d-beam.</p>
<p>This function has an optional window parameter that computes the
coherence with a specified time window.  By default the entire
d and beam signals are used.   The default is done cautiously by
using windowing to the mininum overlap of the two signals (if they differ)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.beam_correlation">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">beam_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aligned</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#beam_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.beam_correlation" title="Permalink to this definition"></a></dt>
<dd><p>Computes normalized peak cross-correlation value a datum with an array stack.</p>
<p>Cross-correlation is a heavily used concept in seismology.   This function
is a specialized version designed to compute a peak cross correlation
value between a datum and an array stack.  The normal use is to call this
function in a loop and post the results to each live member of the
ensemble used to compute the beam.   Note it is assumed beam and d
are filtered in the same passband.   Windowing is bombproof</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.dbxcor_weights">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">dbxcor_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_norm_floor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#dbxcor_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.dbxcor_weights" title="Permalink to this definition"></a></dt>
<dd><p>Computes the robust weights used originally in dbxcor for each
member of ensemble.   Result is returned in a parallel numpy
array (i.e. return[i] is computed weight for ensemble.member[i])</p>
<p>This function is made for speed and has no safeties.  It assumes
all the members of ensemble are the same and it is the same length
as stack.  It will throw an exception if that is violated so callers
should guarantee that does not happen.</p>
<p>This function adds a feature not found in the original Pavlis and Vernon(2011)
paper via the <cite>residual_norm_floor</cite> argument.   Experience with this algorithm
showed it tends to converge to a state with very high weights on one or two
signals and low weights on the rest.   The high weights are given to the
one or two signals most closely matching the stack at convergence.  This
has the undesirable effect of causing a strong initial value dependence
and suboptimal noise reduction.  This argument handles that by not allowing
the L2 norm of the residual to fall below a floor computed from the
ratio ||r||/||d||.   i.e. if ||r|| &lt; residual_norm_floor*||d|| it is
set to the value passed as <cite>residual_norm_floor</cite>.  Note that setting
this to 1.0 effectively turns off the residual norm term in the
weight equation which I now recognize is the cross-correlation of the
beam and datum at zero lag.  That is true, however, only if the
ensemble members are all time aligned perfectly.</p>
<p>Returns a numpy vector of weights.  Any dead data will have a weight of
-1.0 (test for negative is sufficient).  In addition the function has a
safety to handle receiving a vector of all zeros.  If the function detects
all 0s for a datum marked live it will silently return a weight of 0
for that datum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ensemble</strong> – <cite>TimeSeriesEnsemble</cite> of data from which weights are to</p>
</dd>
</dl>
<p>be computed.
:type ensemble:  Assumed to be a <cite>TimeSeriesEnsemble</cite>.  No type checking
is done so if input is wrong an exception will occur but what is thown
will depend on what ensemble actually is.
:param stack:  TimeSeries containing stack to be used to compute weights.
The method returns robust weights relative to the vector of data in
this object.
:type stack:  <cite>TimeSeries</cite>.
:param residual_norm_floor:  nondimensional floor in the ratio norm2(r)/norm2(d)
used as described above.  Default is 0.1 which is reasonable for high snr
signals.   Data with irregular quality can profit from smaller values of this parameter.
:type residual_norm_floor:  float
:return: numpy vector of weights parallel with ensemble.member.  Dead
members will have a negative weight in this vector.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.demean_residuals">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">demean_residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measured_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Ptime_xcor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Ptime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Presidual'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corrected_measured_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Pmeasured'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_estimate_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Presidual_bias'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kill_on_failure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#demean_residuals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.demean_residuals" title="Permalink to this definition"></a></dt>
<dd><p>Residuals measured by any method are always subject to a bias
from Earth structure and earthquake location errors.   With the
MsPASS multichannel xcor algorithm there is an additional bias
inherited from the choice of the initial beam estimate that can
produce an even larger bias.   This algorithm id designed to
process an ensemble to remove and estimate of center from the
residuals stored in the Metadata containers of the ensemble members.</p>
<p>The arguments can be used to change the keys used to access
attributes needed to compute the residual and store the result.
The formula is trivial an with kwarg symbols is:</p>
<blockquote>
<div><p>residual_time_key = measured_time_key - model_time_key - bias</p>
</div></blockquote>
<p>where bias is the estimate of center computed from the vector
of (uncorrected) residual extracted from the ensemble members.
Each member of the ensemble where the measured and model times
are defined will have a value set for the residual_time_key in
the output.  The actual estimate of bias will be posted to the
output in the ensemble’s Mewtadata container with the key
defined by the argument “center_estimate_key”.</p>
<p>Note the corrected (by estimate of center that is) measured
phase arrival time will be stored in each member with the key
defined by the “corrected_measured_time_key” argument.  By default
that is a different key than measured_time_key but some many want
to make measured_time_key==corrected_measured_time_key to reduce
complexity.  That is allowed but is a choice not a requirement.
Again, default will make a new entry for the corrected value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeriesEnsemble" title="mspasspy.ccore.seismic.TimeSeriesEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeriesEnsemble</span></code></a>
or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.SeismogramEnsemble" title="mspasspy.ccore.seismic.SeismogramEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.SeismogramEnsemble</span></code></a>.  The function
will throw a ValueError exception if this require arg is any other
type.) – ensemble object to be processed.   Assumes
the members have defined values for the keys defined by
the “measured_time_key” and “model_time_key”.</p></li>
<li><p><strong>measured_time_key</strong> (<em>string</em><em> (</em><em>default &quot;Ptime_xcor&quot;</em><em>)</em>) – key to use to fetch the measured arrival
time of interest from member Metadata containers.</p></li>
<li><p><strong>model_time_key</strong> (<em>string</em><em> (</em><em>default &quot;Ptime&quot;</em><em>)</em>) – key to use to fetch the arrival time computed
from an earth model and location estimate.  Each member is assumed
to have this value defined.</p></li>
<li><p><strong>residual_time_key</strong> (<em>string</em><em> (</em><em>default &quot;Presidual&quot;</em><em>)</em>) – key use to store the output demeaned
residual.   Be warned that this will overwrite a previously stored value
if the key was previously defined for something else.  That can,
however, be a useful feature if the same data are reprocessed.</p></li>
<li><p><strong>corrected_mesured_time_key</strong> – key to use to save the bias
corrected measured time estimate.   This value is just the
input measured time value minus the computed bias.</p></li>
<li><p><strong>center_method</strong> (<em>string</em><em> (</em><em>default &quot;median&quot;</em><em>)</em>) – method of center method to use to compute
bias correction from vector of residuals.  Valid values are: “median”
to use the median and “mean” (“average” is also accepted an is treated as “mean”)
to use the average/mean value operator.</p></li>
<li><p><strong>center_estimate_key</strong> (<em>string</em><em> (</em><em>default &quot;Presidual_bias&quot;</em><em>)</em>) – key to use to post the estimated center of
the vector of residuals.  Note that value is posted to the ensemble’s
Metadata container, not the members.  Be warned, however, that
currentlyh when ensemble data are saved this value will be posted to
all members before saving. Be sure this name does not overwrite
some other desired member Metdata when that happens.</p></li>
<li><p><strong>kill_on_failure</strong> – boolean controlling what the function does
to the output ensemble if the algorithm totally fails.  “totally fails”
in this case means it the number of residuals it could compute was
less than or equal 1.  If set True the output will be killed.
When False it will be returned with no values set for the
keys defined by “residual_time_key” and “center_estimate_key”.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>edited copy of input ensemble altering only Metadata containers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.estimate_ensemble_bandwidth">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">estimate_ensemble_bandwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_doc_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Parrival'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#estimate_ensemble_bandwidth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.estimate_ensemble_bandwidth" title="Permalink to this definition"></a></dt>
<dd><p>Estimate average bandwidth of an ensemble of data using the output of
broadband_snr_QC.</p>
<p>The original dbxcor program used a GUI that allowed the user to select one of
a set of predefined filters to be used to set the frequency band of the signal
to be processed by the equivalent of the <cite>align_and_stack</cite> function of this module.
The purpose of this function is to automate that process to defined an
optimal bandwidth for processing of the input ensemble.</p>
<p>This function only works on ensembles processed previously with the
mspass function <cite>broadband_snr_QC</cite>.   That function computes a series of
metrics for signal-to-noise ratio.  The only one this one uses is
the two values defined by “low_f_band_edge” and “high_f_band_edge”.
The verbose names should make their definition obvious.   This
function returns the median of the values of all values of those
two attributes extracted from all live members of the input ensemble.
The result is returned as a tuple with the low frequency edge as 0
and the high frequency edge as 1.    The expectation is that the
data will be bandpass filtered between the low and high edges before
running the <cite>align_and_stack</cite> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<cite>TimeSeriesEnsemble</cite>) – ensemble of data to be scanned</p></li>
<li><p><strong>srn_doc_key</strong> – subdocument key of attributes computed by</p></li>
</ul>
</dd>
</dl>
<p><cite>broadband_snr_QC</cite> to fetch as estimates of low and high frequency
edges.
:type snr_doc_key:  string (default “Parrival” = default of
<cite>broadband_snr_QC</cite>)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.extract_initial_beam_estimate">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">extract_initial_beam_estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bandwidth'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdoc_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Parrival'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><span class="pre">TimeSeries</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#extract_initial_beam_estimate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.extract_initial_beam_estimate" title="Permalink to this definition"></a></dt>
<dd><p>The robust stacking method used in the <cite>align_and_stack</cite>
function in this module requires an initial signal estimate
for first-order alignment of signals in the input ensemble.
In the original dbxcor implementation of that algorithm the
user was required to select that initial signal interactively
in a graphical user interface.   This function provides one
possible algorithm to accomplish that task automatically.  It does
so by scanning the ensemble to extract a member with the largest
value of some quality control metric.   This implementation is
limited to metrics computed by the MsPASS function called
<cite>broadband_snr_QC</cite>.   The algorithm, however, would be easy
to modify to produce a custom operator using some other
metric posted to the Metadata container of each ensemble member.
An oddity of the <cite>broadband_snr_QC</cite> is that it posts its
output to a python dictionary (subdocument in pymongo jargon)
fetched with a single key.  That key can be changed from
the default “Parrival” (default of <cite>broadband_snr_QC</cite>) to
something else via the “subdoc_key” argument.  This list of
keys inside that subdocument that can be used to set what metric
will be used are:  bandwidth, filtered_envelope, filtered_L2,
filtered_Linf, or filtered_perc.  See the docstring for
<cite>broadband_snr_QC</cite> for an explanation of each metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<cite>TimeSeriesEnsemble</cite>) – ensemble to be scanned</p></li>
<li><p><strong>metric</strong> – quality metric to use for selecting member to use</p></li>
</ul>
</dd>
</dl>
<p>as return.  Always scans for the maximum of specified value as it
assume the value is some norm measure.   Accepted values at present
are all those computed by <cite>broadband_snr_QC</cite>:  bandwidth,
filtered_envelope, filtered_L2, filtered_Linf, or filtered_perc.
Default is “bandwidth”.   A ValueError exception will be thrown
if not one of those values.
:type metric:  string
:param subdoc_key:   <cite>broadband_snr_QC</cite> normally posts output to
a subdocument (dictionary).  This is the key that is used to
extract that subdocument from each member.   Default is “Parrival”
which is the default of <cite>broadband_snr_QC</cite>.
:type subdoc_key:  string
:return:  <cite>TimeSeries</cite> that is a copy of the ensemble member with
the largest value of the requested member.   A default constructed, dead datum
is returned if the algorithm failed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.phase_time">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">phase_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Ptime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arrival_time_correction'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#phase_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.phase_time" title="Permalink to this definition"></a></dt>
<dd><p>Small generic function to return a UTC arrival time combining an initial arrival
time estimate (normally a model based time) defined by the “phase_time_key”
metadata value extracted from d and the time shift computed by align_and_stack
(or any other algorithm that computes relative time shifts) and set with the
Metadata key defined by the “time_shift_key” argment.  The defaults work for
P phase times computed by <cite>MCXcorPrepP</cite> and shifts computed by
<cite>align_and_stack</cite>.   The computation here is trivial (just a difference) but
the fluff is all the safeties in handling missing values.  Returns -1.0
if any of the requried keys are missing.  Returns -2.0 if d is not defined
as UTC.  That is basically a reminder this function only makes sense for
data with a UTC time standard.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.post_MCXcor_metrics">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">post_MCXcor_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'amplitude':</span> <span class="pre">'beam_relative_amplitude',</span> <span class="pre">'arrival_time':</span> <span class="pre">'Ptime_xcor',</span> <span class="pre">'coherence':</span> <span class="pre">'beam_coherence',</span> <span class="pre">'cross_correlation':</span> <span class="pre">'beam_correlation'}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_time_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Ptime'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arrival_time_correction'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><span class="pre">TimeSeries</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#post_MCXcor_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.post_MCXcor_metrics" title="Permalink to this definition"></a></dt>
<dd><p>Computes and posts a set of standard QC metrics for result of multichannel cross-correlation
algorithm.</p>
<p>This function should be thought of as a post-processing function to standardize a set of
useful calculations from the output of the multichannel cross-correlation algorithm.
The default is set up for post processing teleseismic P wave data but with changes to the
arguments it should be possible to use it for any teleseismic body wave phase.</p>
<p>What is computed is controlled by the input parameter “metrics”.   “metrics” is
expected to be a dictionary with the keys defining the concept of what is to be
computed and posted and a “value” being the actual key to use for posting the
computed value.  Defaults for “metrics” are as follows the dictionary key
in quotes at the start of each paragraph:</p>
<ul class="simple">
<li><p>“arrival_time”  - compute arrival time from posted initial time estimate and
correlation time shift computed by <cite>align_and_stack</cite>.  Uses the “phase_time_key”
and “time_shift_key” to fetch required values.  Default works for Pwave
data processed with <cite>align_and_stack</cite>.  Changes needed for other phases.</p></li>
<li><p>“cross_correlation” - compute cross correlation with respect to beam</p></li>
<li><p>“coherence” - compute time domain coherence with respect to beam</p></li>
<li><p>“amplitude” - compute amplitude of d relative to the beam.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<cite>TimeSeries</cite>) – datum to be processed</p></li>
<li><p><strong>beam</strong> (<cite>TimeSeries</cite>) – array stack (beam) output of <cite>align_and_stack</cite></p></li>
<li><p><strong>metrics</strong> (<em>python dictionary with one</em><em> or </em><em>more</em><em> of </em><em>the keys defined above.</em>) – defines what metrics should be computed ans posted
(see above for options)</p></li>
<li><p><strong>window</strong> (<cite>TimeWindow</cite> or None (default)) – optional time window to use for computing specified metric(s).
Windowing is normally applied for cross-correlation, coherence, and amplitude
calculations (it is ignored for the time computation).  If it is not
defined behavior depends on the algorithm as the object is passed directly
to functions used to compute correlation, coherence, and amplitude metrics.</p></li>
<li><p><strong>phase_time_key</strong> (string (default “Ptime” which is default expectation used
in <cite>align_and_stack</cite>)) – key used to fetch the initial phase time used for
initial alignment for <cite>align_and_stack</cite> input.   The assumption is the
content is defined in d and when fetch is an epoch time defining the
initial time shift for the given phase.  Note it could be either a measured
or model-based arrival time.</p></li>
<li><p><strong>time_shift_key</strong> (string (default “arrival_time_correction” is the key
used to post the cross-correlation shifts in <cite>align_and_stack</cite>)) – key used to store the relative time shifts computed
by <cite>align_and_stack</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>copy of d <cite>TimeSeries</cite> with the requested metrics posted to the
Metadata container of the output.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.regularize_ensemble">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">regularize_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starttime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endtime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_fraction_cutoff</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeriesEnsemble" title="mspasspy.ccore.seismic.TimeSeriesEnsemble"><span class="pre">TimeSeriesEnsemble</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#regularize_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.regularize_ensemble" title="Permalink to this definition"></a></dt>
<dd><p>Secondary function to regularize an ensemble for input to robust
stacking algorithm.  ASsumes all data have the same sample rate.
Uses WindowData to assumre all data are inside the common
range startime:endtime.  Silently drops dead data.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.remove_incident_wavefield">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">remove_incident_wavefield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#remove_incident_wavefield"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.remove_incident_wavefield" title="Permalink to this definition"></a></dt>
<dd><p>Remove incident wavefield for teleseismic P wave data using a beam estimate.</p>
<p>In imaging of S to P conversion with teleseimic P wave data a critical step
is removing the incident wavefield.   The theoretical reason is described in
multiple publications on S to P imaging theory.  This function implements
a novel method using the output of <cite>align_and_stack</cite> to remove the
incident wavefield.   The approach make sense ONLY IF d is a member of the
ensemble used to compute beam and is the longitudinal component estimate
for a P phase.  The best choice for that is the free surface transformation
operator but in could be used for LQT or even the very crude RTZ
transformation.</p>
<p>The actual operation is very simple:  the overlaping section of beam
and d is determined.  The algorthm then computes a scaling factor for
beam as the dot product of beam and d in the common time range.
That number is used to scale the beam which is then subtracted
(in the overlapping time range) from d.  There are several key
assumptions this algorithm makes about the input that should be
kept in mind before using it:</p>
<ol class="arabic simple">
<li><p>d is implicitly expected to span a longer or a least
equal span to the beam time range.</p></li>
<li><p>beam should always be tapered to prevent an offset at the
front and end when it is subtracted from d.</p></li>
<li><p>beam should be normalized so it L2 norm is 1.0.  Note that
should be the taper beam not the beam cut with WindowData.
That is not computed in this function for efficiency as normal
use would apply the same beam estimate to all live ensemble
members.</p></li>
<li><p>Because this is assumed to be used at deep in a processing
chain it has no safties.   d and beam and assumped to
be TimeSeries objects.  The only safety is that if d or
beam are marked dead it does nothing but return d.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<cite>TimeSeries</cite>) – datum from which beam is to be subtracted
(Assumed to have a time span containing the time span of beam)</p></li>
<li><p><strong>beam</strong> – windowed and tapered output stack from
<cite>align_and_stack</cite>.  Assumed to have L2 norm of 1.0.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.MCXcorStacking.robust_stack">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MCXcorStacking.</span></span><span class="sig-name descname"><span class="pre">robust_stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dbxcor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack_md</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timespan_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ensemble_inner'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_fraction_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_norm_floor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MCXcorStacking.html#robust_stack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MCXcorStacking.robust_stack" title="Permalink to this definition"></a></dt>
<dd><p>Generic function for robust stacking live members of a <cite>TimeSeriesEnsemble</cite>.
An optional initial stack estimate can be used via tha stack0 argument.
The function currently supports two methods:  “median” for a median
stack and “dbxcor” to implement the robust loss function
used in the dbxcor program defined in Pavlis and Vernon (2010).
Other algorithms could easily be implemented via this same api
by adding an option for the “method” argument.</p>
<p>All robust estimators I am aware of that use some form of penalty
function (e.g. m-estimators or the dbxcor penalty function) require
an initial estimator for the stack.  They do that because the
penalty function is defined from a metric of residuals relative to
the current estimate of center.   The median, however, does not
require an initial estimator which complicates the API for this function.
For the current options understand that stack0 is required for
the dbxcor algorithm but will be ignored if median is requested.</p>
<p>The other complication of this function is handling of potential
irregular time ranges of the ensemble input and how to set the
time range for the output.   The problem is further complicated by
use in an algorithm like <cite>align_and_stack</cite> in this module where
the data can get shifted to have undefined data within the
time range the data aims to utilize.   The behavior of the
algorithm for this issue is controlled by the kwarg values
with the keys “timespan_method” and “pad_fraction_cutoff”.
As the name imply “timespan_method” defines how the time span
for the stack should be defined.   The following options
are supported:</p>
<p>“stack0” - sets the time span to that of the input
<cite>TimeSeries</cite> passed as stack0.  i.e. the range is set to
stack0.dt to stack0.endtime().</p>
<p>“ensemble_inner” - (default) use the range defined by the “inner” method
for computing the range with the function <cite>ensemble_time_range</cite>.
(see <cite>ensemble_time_range</cite> docstring for the definition).</p>
<p>“ensemble_outer” - use the range defined by the “outer” method
for computing the range with the function <cite>ensemble_time_range</cite>.
(see <cite>ensemble_time_range</cite> docstring for the definition).</p>
<p>“ensemble_median” -  use the range defined by the “median” method
for computing the range with the function <cite>ensemble_time_range</cite>.
(see <cite>ensemble_time_range</cite> docstring for the definition).</p>
<p>These interact with the value passed via “fractional_mismatch_level”.
When the time range computed is larger than the range of a particular
member of the input ensemble this parameter determines whether or not
the member will be used in the stack.  If the fraction of
undefined samples (i.e. N_undefined/Nsamp) is greater than this cutoff
that datum will be ignored.   Otherwise if there are undefined
values they will be zero padded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ensemble</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeriesEnsemble" title="mspasspy.ccore.seismic.TimeSeriesEnsemble"><em>TimeSeriesEnsemble</em></a>) – input data to be stacked.   Should all be in
relative time with all members having the same relative time span.</p></li>
<li><p><strong>method</strong> (<em>string.  Currently must be one</em><em> of </em><em>two values</em><em> or </em><em>the
function will abort:   &quot;median&quot;</em><em> or </em><em>&quot;dbxcor&quot;.  As the names imply
&quot;median&quot; will cause the function to return the median</em><em> of </em><em>the sample
vectors while &quot;dbxcor&quot; applies the dbxcor method.</em>) – Defines a name string of the method to be used to
compute the stack.</p></li>
<li><p><strong>stack0</strong> (<em>TimeSeries.   Note the time span</em><em> of </em><em>this optional input
must be the same</em><em> or </em><em>wider than the ensemble member range defined by
the</em><em> (</em><em>internal to this module</em><em>) </em><em>validate_ensemble function</em><em> or </em><em>the
return will be return as a copy</em><em> of </em><em>this TimeSeries marked dead.
Default for this argument is None which means the median will be
used for the initial stack for dbxcor</em>) – optional initial estimate for stack.  Estimators
other than median I know of use a loss function for downweighting
members of the stack that do not match the stack as defined by
some misfit metric.   This argument can be used to input an optional
starting estimate of the stack for the dbxcor method.  By default it
uses the median as the starting point, but this can be used to
input something else.   Note the function will silently ignore this
argument if method == “median”.</p></li>
<li><p><strong>stack_md</strong> (<em>Metadata container</em><em> or </em><em>None.  If stack0 is defined
this argument is ignored.   Otherwise it should be used to add
whatever Metadata is required to provide a tag that can be used to
identify the output.  If not specified the stack Metadata
will be only those produce from default construction</em><em> of </em><em>a
TimeSeries.  That is almost never what you want.   Reiterate</em><em>,
</em><em>however</em><em>, </em><em>that if stack0 is defined the output stack will be a
clone</em><em> of </em><em>stack0 with possible modifications</em><em> of </em><em>time and data
range attributes and anything the stack algorithm posts.</em>) – optional Metadata container to define the
content of the stack output.  By default the output will have only
Metadata that duplicate required internal attributes (e.g. t0 and npts).
An exception is if stack0 is used the Metadata of that container will
be copied and this argument will be ignored.</p></li>
<li><p><strong>residual_norm_floor</strong> (<em>float</em><em> (</em><em>default 0.01</em><em>)</em>) – floor on residuals used to compute dbxcor weight
function.  See docstring for <cite>dbxcor_weights</cite> for details.  Ignored
unless method is “dbxcor”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple containing the requested stack as component 0.  The
stack is returned as a <cite>TimeSeries</cite>  with optional Metadata copied
from the (optional) stack_md argument.   Component 1 is defined only
for the dbxcor method in which case it a numpy array containing th e
robust weights returned by the dbxcor algorithm.  If the method is
set to “median” component 1 will be returned as a None type.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.MTPowerSpectrumEngine">
<span id="mtpowerspectrumengine"></span><h2>MTPowerSpectrumEngine<a class="headerlink" href="#module-mspasspy.algorithms.MTPowerSpectrumEngine" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.MTPowerSpectrumEngine.</span></span><span class="sig-name descname"><span class="pre">MTPowerSpectrumEngine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">winsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tbp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_tapers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iadapt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Wrapper class to use German Prieto’s multitaper package as a plug
in replacement for the MsPASS class of the same name.   The MsPASS
version is in C++ and there are some collisions in concept.  It should
be used only in a python script where it might be useful to use
features of Prieto’s library not available in the cruder implementation
in MsPASS.   (e.g. adaptive weights in multitaper power spectrum estimation).
The biggest collision in concept is that the MsPASS version with this class
name was designed to be created and moved around to avoid the overhead of
recreating the Slepian tapers on each use.  Prieto’s class creates these
in the constructor but caches a number of things when first created that
allows secondary calls to run faster.  The implementation attempts
to overcome this collision by caching an instance of Prieto’s mstspec class
on the first call to the apply method.   Secondary calls to apply test
for consistency with the previous call and only recreate the mtspec
instance if something that invalidates the previous call has changed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>winsize</strong> – Number of samples expected for data window.  Note this
argument defines the size of the eigentapers so it defines the size of
input time series the object expect to process.</p></li>
<li><p><strong>tbp</strong> – multitaper time-bandwidth product</p></li>
<li><p><strong>number_tapers</strong> – number of tapers to use for estimators (See Prieto’s
documentation for details)</p></li>
<li><p><strong>nfft</strong> – optional size of the fft work arrays to use.  nfft should be
greater than or equal winsize.  When greater zero padding is used in the
usual way.  Default is 0 which sets nfft to 2*winsize.  If nfft&lt;winsize
a diagnostic message will be printed and nfft will be set equal to winsize.</p></li>
<li><p><strong>iadapt</strong> – integer argument passed to Prieto’s MTspec that sets the
eigentaper weighting scheme.  See Prieto’s MTspect class documentation
for options.  Default is 0 which enables the adaptive weighting scheme.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.apply" title="Permalink to this definition"></a></dt>
<dd><p>needs to support vector input or a TimeSeries - returns a PowerSpectrum
Cannot use mspass decorator because it supports raw data vectors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.frequencies">
<span class="sig-name descname"><span class="pre">frequencies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine.frequencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.frequencies" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array of the frequencies</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.number_tapers">
<span class="sig-name descname"><span class="pre">number_tapers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine.number_tapers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.number_tapers" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of tapers defined for this operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.set_df">
<span class="sig-name descname"><span class="pre">set_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine.set_df"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.set_df" title="Permalink to this definition"></a></dt>
<dd><p>Explicit setter for frequency bin interval.  Needed when
changing sample interval for input data. Rarely of use but
included for compatibility with the C++ class with the
same name.</p>
<p>This maybe should just be pass or throw an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.time_bandwidth_product">
<span class="sig-name descname"><span class="pre">time_bandwidth_product</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/MTPowerSpectrumEngine.html#MTPowerSpectrumEngine.time_bandwidth_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.MTPowerSpectrumEngine.MTPowerSpectrumEngine.time_bandwidth_product" title="Permalink to this definition"></a></dt>
<dd><p>Return time bandwidth product for this operator.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-mspasspy.algorithms.RFdeconProcessor">
<span id="rfdeconprocessor"></span><h2>RFdeconProcessor<a class="headerlink" href="#module-mspasspy.algorithms.RFdeconProcessor" title="Permalink to this heading"></a></h2>
<p>This file contains a class definition for a wrapper for
the suite of scalar deconvolution methods supported by mspass.
It demonstrates the concept of a processing object created
by wrapping C code.  It also contains a top-level function
that is a pythonic interface that meshes with MsPASS schedulers
for parallel processing called <cite>RFdecon</cite>.   <cite>RFdecon</cite> is a
wrapper for all single-station methods.   It cannot be used for
array methods.</p>
<p>Created on Fri Jul 31 06:24:10 2020</p>
<p>&#64;author: Gary Pavlis</p>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdecon">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.RFdeconProcessor.</span></span><span class="sig-name descname"><span class="pre">RFdecon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LeastSquares'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFdeconProcessor.pf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noisedata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wcomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">QCdocument_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFdecon_properties'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFdecon'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdecon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdecon" title="Permalink to this definition"></a></dt>
<dd><p>Use this function to compute conventional receiver functions
from a single three component seismogram. In this function,
an instance of wrapper class RFdeconProcessor will be built and
initialized with alg and pf.</p>
<p>Default assumes d contains all data sections required to do
the deconvolution with the wavelet in component 2 (3 for matlab
and FORTRAN people).  By default the data and noise
(if required by the algorithm) sections will be extracted from
the (assumed larger) data section using time windows defined
internally in the processor pf definition.   For variations (e.g.
adding tapering to one or more of the time series inputs)
use the d, wavelet, and (if required) noise arguments to load
each component separately.  Note d is dogmatically required
to be three component data while optional wavelet and noisedata
series are passed as plain numpy vectors (i.e. without the
decoration of a TimeSeries).</p>
<p>To make use of the extended outputs from RFdeconProcessor
algorithms (e.g. actual output of the computed operator)
call those methods after this function returns successfully
with a three-component seismogram output.  That is possible
because the processor object caches the most recent wavelet
and inverse used for the deconvolution.   An exception is
that all algorithms call their QCmetrics method of processor
and push them to the headers of the deconvolved output.
QCmetric attributes are algorithm dependent.</p>
<p>The ProcessingHistory feature can optionally be enabled by
setting the save_history argument to True.   When enabled one should
normally set a unique id for the algid argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>Must be a Seismogram object</em><em> or </em><em>the function will throw a TypeError exception.</em>) – Seismogram input data.See notes above about time span of thesedata.</p></li>
<li><p><strong>engine</strong> (<em>None</em><em> or </em><em>an instance</em><em> of </em><em>RFdeconProcessor.
When None</em><em> (</em><em>default</em><em>) </em><em>an instance</em><em> of </em><em>an RFdeconProcessor is
created on entry based on the keyword defined by the alg
argument.   The algorithm built into the instance</em><em> of
</em><em>RFdeconProcessor is used if engine is not null.</em>) – optional instance of a RFdeconProcessor
object.   By default the function instantiates an instance of
a processor for each call to the function.   For algorithms
like the multitaper based algorithms with a high initialization
cost performance will improve by sending an instance to the
function via this argument.</p></li>
<li><p><strong>alg</strong> – The algorithm to be applied, used for initializing
a RFdeconProcessor object.  Ignored if engine is used.</p></li>
<li><p><strong>pf</strong> (<em>string defining an absolute path for the file name</em><em>
or </em><em>a path relative to a directory defined by PFPATH.</em>) – The pf file to be parsed, used for inititalizing a
RFdeconProcessor.  Ignored if engine is used.</p></li>
<li><p><strong>wavelet</strong> (<em>None</em><em> or </em><em>an iterable vector container</em><em>
(</em><em>in MsPASS that means a python array</em><em>, </em><em>a numpy array</em><em>, or </em><em>a DoubleVector</em><em>)</em>) – vector of doubles (numpy array or the
std::vector container internal to TimeSeries object) defining
the wavelet to use to compute deconvolution operator.
Default is None which assumes processor was set up to use
a component of d as the wavelet estimate.</p></li>
<li><p><strong>noisedata</strong> (<em>None</em><em> or </em><em>an iterable vector container</em><em>
(</em><em>in MsPASS that means a python array</em><em>, </em><em>a numpy array</em><em>, or </em><em>a DoubleVector</em><em>)</em>) – vector of doubles (numpy array or the
std::vector container internal to TimeSeries object) defining
noise data to use for computing regularization.  Not all RF
estimation algorithms use noise estimators so this parameter
is optional.   It can also be extracted from d depending on
parameter file options.</p></li>
<li><p><strong>wcomp</strong> (<em>int</em><em> (</em><em>must 0</em><em>, </em><em>1</em><em>, or </em><em>2</em><em>)</em>) – When defined from Seismogram d the wavelet
estimate in conventional RFs is one of the components that
are most P wave dominated. That is always one of three
things:  Z, L of LQT, or the L component from the output of
Kennett’s free surface transformation operator.  The
default is 2, which for ccore.Seismogram is always one of
the above.   This parameter would be changed only if the
data has undergone some novel transformation not yet invented
and the best wavelet estimate was on in 2 (3 with FORTRAN
and matlab numbering).</p></li>
<li><p><strong>ncomp</strong> (<em>int</em><em> (</em><em>must be 0</em><em>, </em><em>1</em><em>, or </em><em>2</em><em>)</em>) – component number to use to compute noise.  This is used
only if the algorithm in processor requires a noise estimate.
Normally it should be the same as wcomp and is by default (2).</p></li>
<li><p><strong>QCdocument_key</strong> (<em>string</em><em> (</em><em>default is &quot;RFdecon_properties&quot;</em><em>)</em>) – A summary of the parameters defining the
deconvolution operator (really a dump of the pf content used for
creating the engine) and computed QC attributes are posted to a
python dictionary.   That content is posted to the outputs
Metadata container with the key defined by this argument.
In MongoDB lingo that means when saved to the database the
dictionary content associated with this key becomes a “subdocument”.</p></li>
<li><p><strong>object_history</strong> – boolean to enable or disable saving object
level history.  Default is False.  Note this functionality is
implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>alg_name</strong> – When history is enabled this is the algorithm name
assigned to the stamp for applying this algorithm.
Default (“WindowData”) should normally be just used.
Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>ald_id</strong> – algorithm id to assign to history record (used only if
object_history is set True.)
Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>dryrun</strong> – When true only the arguments are checked for validity.
When true nothing is calculated and the original data are returned.
Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normally returns Seismogram object containing the RF estimates.
The orientations are always the same as the input.  If <cite>return-wavelets</cite> is set
True returns a tuple with three components:  0 - <cite>Seismogram</cite> returned as with
default, 1 - ideal output wavelet <cite>TimeSeries</cite>, 2 - actual output wavelet
stored as a <cite>TimeSeries</cite> object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.RFdeconProcessor.</span></span><span class="sig-name descname"><span class="pre">RFdeconProcessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LeastSquares'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RFdeconProcessor.pf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is a wrapper for the suite of receiver function deconvolution
methods we call scalar methods.  That is, the operation is reducable to
two time series:   wavelet signal and the data (TimeSeries) signal.
That is in contrast to three component methods that always treat the
data as vector samples.   The class should be created as a global
processor object to be used in a spark job.  The design assumes the
processor object will be passed as an argument to the RFdecon
function that should appear as a function in a spark map call.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.QCMetrics">
<span class="sig-name descname"><span class="pre">QCMetrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prediction_error_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prediction_error'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.QCMetrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.QCMetrics" title="Permalink to this definition"></a></dt>
<dd><p>All decon algorithms compute a set of algorithm dependent quality
control metrics.  The return is a Metadata container.
All this wrapper really does is translate that return into
a python dictionary that can be used as the base of a subdocument
posting to outputs.  This method MUST ONLY BE CALLED after
calling the process method of the C++ engine.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.actual_output">
<span class="sig-name descname"><span class="pre">actual_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.actual_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.actual_output" title="Permalink to this definition"></a></dt>
<dd><p>The actual output of a decon operator is the inverse filter applied to
the wavelet.  By design it is an approximation of the shaping wavelet
defined for this operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Actual output of the operator as a ccore.TimeSeries object.
The Metadata of the return is bare bones.  The most important factor
about this result is that because actual output waveforms are normally
a zero phase wavelet of some kind the result is time shifted to be
centered (i.e. t0 is rounded n/2 where n is the length of the vector
returned).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.apply" title="Permalink to this definition"></a></dt>
<dd><p>Compute the RF estimate using the algorithm defined internally.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>vector of data that are the RF estimate computed from previously loaded data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.change_parameters">
<span class="sig-name descname"><span class="pre">change_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">md</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.change_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.change_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Use this method to change the internal parameter setting of the
processor.  It can only change the parameters for a particular
algorithm.   A new instance of this class needs to be created if
you need to switch to a different algorithm.   It does little
more than call the read_metadata of the already loaded processor.
All the scalar decon methods implement that method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>md</strong> – is a mspass.Metadata object containing required parameters
for the alternative algorithm.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.dwin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dwin</span></span><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.dwin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.ideal_output">
<span class="sig-name descname"><span class="pre">ideal_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.ideal_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.ideal_output" title="Permalink to this definition"></a></dt>
<dd><p>The ideal output of a decon operator is the same thing we call a
shaping wavelet.  This method returns the ideal output=shaping wavelet
as a TimeSeries object.   Like the actual output method the return
function is circular shifted so the function peaks at 0 time located
at n/2 samples from the start sample.  Graphic displays will then show
the wavelet centered and peaked at time 0.   The prediction error
can be computed as the difference between the actual_output and
ideal_output TimeSeries objects.   The norm of the prediction error
is a helpful metric to display the stability and accuracy of the
inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.inverse_filter">
<span class="sig-name descname"><span class="pre">inverse_filter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.inverse_filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.inverse_filter" title="Permalink to this definition"></a></dt>
<dd><p>This method returns the actual inverse filter that if convolved with
he original data will produce the RF estimate.  Note the filter is
meaningful only if the source wavelet is minimum phase.  A standard
theorem from time series analysis shows that the inverse of mixed
phase wavelet is usually unstable and a maximum phase wavelet is always
unstable.   Fourier-based methods can still compute a stable solution
even with a mixed phase wavelet because of the implied circular
convolution.</p>
<p>The result is returned as  TimeSeries object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loaddata">
<span class="sig-name descname"><span class="pre">loaddata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.loaddata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loaddata" title="Permalink to this definition"></a></dt>
<dd><p>Loads data for processing.  When window is set true
use the internal pf definition of data time window
and window the data.  The dtype parameter changes the
behavior of this algorithm significantly depending on
the setting.   It can be one of the following:
Seismogram, TimeSeries, or raw_vector.   For the first
two the data to process will be extracted in a
pf specfied window if window is True.  If window is
False TimeSeries data will be passed directly and
Seismogram data will have the data defined by the
component parameter copied to the internal data
vector workspace.   If dtype is set to raw_vector
d is assumed to be a raw numpy vector of doubles or
an the aliased std::vector used in ccore, for example,
in the TimeSeries object s vector.  Setting dtype
to raw_vector and window True will result in this
method throwing a RuntimeError exception as the
combination is not possible since raw_vector data
have no time base.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – input data (contents expected depend upon
value of dtype parameter).</p></li>
<li><p><strong>dtype</strong> – string defining the form d is expected
to be (see details above)</p></li>
<li><p><strong>component</strong> – component of Seismogram data to
load as data vector.  Ignored if dtype is raw_vector
or TimeSeries.</p></li>
<li><p><strong>window</strong> – boolean controlling internally
defined windowing.  (see details above)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Nothing (not None nothing) is returned</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loadnoise">
<span class="sig-name descname"><span class="pre">loadnoise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.loadnoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loadnoise" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loadwavelet">
<span class="sig-name descname"><span class="pre">loadwavelet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/RFdeconProcessor.html#RFdeconProcessor.loadwavelet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.loadwavelet" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.nwin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nwin</span></span><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.nwin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.uses_noise">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">uses_noise</span></span><a class="headerlink" href="#mspasspy.algorithms.RFdeconProcessor.RFdeconProcessor.uses_noise" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-mspasspy.algorithms.basic">
<span id="basic"></span><h2>basic<a class="headerlink" href="#module-mspasspy.algorithms.basic" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.ExtractComponent">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">ExtractComponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#ExtractComponent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.ExtractComponent" title="Permalink to this definition"></a></dt>
<dd><p>Extract single component from three-component data.</p>
<p>The function creates a scalar TimeSeries object from a three component Seismogram object
Or a TimeSeriesEnsemble object from a SeismogramEnsemble object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <code class="xref py py-class docutils literal notranslate"><span class="pre">SeismogramEnsemble</span></code>) – data object to extract from.</p></li>
<li><p><strong>component</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – the index of component that will be extracted, it can only be 0, 1, or 2</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is set false to
handle exception directly in the function, without passing it to mspass_func_wrapper.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.ator">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">ator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tshift</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#ator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.ator" title="Permalink to this definition"></a></dt>
<dd><p>Absolute to relative time conversion.</p>
<p>Sometimes we want to convert data from absolute time (epoch times)
to a relative time standard.  Examples are conversions to travel
time using an event origin time or shifting to an arrival time
reference frame. This operation simply switches the tref
variable and alters t0 by tshift.  Note the special feature
of how arg0 is handled.   If it is a string it assumed to be a
Metadata key to use to fetch the time shift value from the data object’s
Metadata container.   If it is number it is used directly.’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.Seismogram</span></code></a>) – data object to be converted.</p></li>
<li><p><strong>tshift</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or a string to use as a metdata key (see above)) – used to define time shift to apply.   If value is string
the function assumes it is a metadata key it can use to extract the
requred value from the data’s metadata container.  If it is a floating
point number it is used directly.   Anything else will result in a
TypeError exception.  If a string is used but the key is not defined
the datum will be killed with an elog message.</p></li>
<li><p><strong>object_history</strong> – set True to preserve the processing history.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.cosine_taper">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">cosine_taper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0head</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1head</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1tail</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0tail</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#cosine_taper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.cosine_taper" title="Permalink to this definition"></a></dt>
<dd><p>Taper front and/or end of a data object with a half cosine function.</p>
<p>A cosine taper is a common, simple approach to taper data.  When applied at the
front it defnes a half cycle of a cosine curve +1.0 in range -pi to 0.  On
the right it defines the same function for the range 0 to pi.  The period
of the left and right operator can be different.  Turn off left or right by
giving illegal start and end points and the operator will silently be
only one sided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be processed.</p></li>
<li><p><strong>t0head</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t0 of the head taper</p></li>
<li><p><strong>t1head</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t1 of the head taper</p></li>
<li><p><strong>t1tail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t1 of the tail taper</p></li>
<li><p><strong>t0tail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t0 of the tail taper</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.free_surface_transformation">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">free_surface_transformation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uvec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vp0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vs0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ux_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ux'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uy_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'uy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vp0_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vp0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vs0_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vs0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#free_surface_transformation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.free_surface_transformation" title="Permalink to this definition"></a></dt>
<dd><p>Computes and applies the Kennett [1991] free surface transformation matrix.</p>
<p>Kennett [1991] gives the form for a free surface transformation operator
that defines a transformation matrix that provides optimal separation
of P, SV, and SH for a receiver at the free surface of an isotropic medium
with constant P and S velocity.   The transformation is only valid if the
incident wavefield is not evanescent (i.e. at or past the SV critical angle).
It is important to realize the tranformation matrix does not define
an orthogonal transformation.  It is also, of course, only an approximation
since it is strictly correct only for a constant velocity medium.
The tranformation operator requires: (1) a slowness vector, (2) an
estimate of surface P wave velocity, and (3) an estimate of surface
shear wave velocity.   In all cases the input for the slowness
vector uses a local cartesian system with the vector specified as
component ux and uy.  ux is the component of the slowness of
an incident wavefield in the geographic x direction, which means
positive at local east.  uy is the complementary component for the
y direction defined by local north.  The components of the slowness
vector are assumed to be in units of s/km.   (Warning:  obspy’s and
other implementations of the commonly used tau-p calculator return
slowness (ray parameter) in spherical units of s/radian - r sin(theta)/v)</p>
<p>The required parameters (slowness vector and velocities) can be
passed to the function one of two ways.   Because it is much simpler
to implement in a map operator the default expect those parameters to
be set in the data object’s Metadata container.  The default keys for
fetching each attribute are defined by the four arguments
“ux_key”, “uy_key”, “vp0_key”, and “vs0_key”.   All four have
standard defaults defined in the function signature and below.
The Metadata fetching algorithm can be overridden by defining
the same data through the three optional arguments with the key
names “uvec”, “vp0”, and “vs0”.   (see below for detailed descriptions)</p>
<p>The switching between Metadata fetching and a constant arguments
is not all or none.   If a slowness vector is defined through uvec
it will always override metadata.  Handing of vp0 and vs0 is independent.
i.e. you can define uvec and not define vp0 and vs0 or conversely
you can (more commonly) define vp0 and vs0 but not define uvec.
In all cases not defining an arg is a signal to fetch it from
Metadata.</p>
<p>When this function is applied to ensembles and the Metadata fetch
approach is used (default) the function assumes all ensemble members
have the required metadata keys defined.  Any that do not are killed.
The same happens for atomic data passed to this function if any of
the required keys are missing.  In fact, you should realize the
ensemble algorithm simply applies this function in a recursion over all
the members.</p>
<p>The output components are in the order defined in Kennett’s original
paper.  The order is 0=SH, 1=SV, 2=L.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>
or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.SeismogramEnsemble" title="mspasspy.ccore.seismic.SeismogramEnsemble"><code class="xref py py-class docutils literal notranslate"><span class="pre">SeismogramEnsemble</span></code></a>) – data object to be transformed.  For ensembles the transformation
is applied to all members.  Note the Metadata fetch mechanism is the only
recommended way to handle ensembles.  An elog message will be posted
to the ensemble’s elog container if you try to use a constant slowness
vector passed via uvec. It will not warn about constant vp0 and vs0
as that case is common.</p></li>
<li><p><strong>ux_key</strong> (<em>string</em>) – key to use to fetch EW component of slowness vector
from Metadata container.  Default is “ux”.</p></li>
<li><p><strong>uy_key</strong> (<em>string</em>) – key to use to fetch NS component of slowness vector
from Metadata container.  Default is “uy”.</p></li>
<li><p><strong>vp0_key</strong> (<em>string</em>) – key to use to fetch free surface P wave velocity
from Metadata container.  Default is “vp0”.</p></li>
<li><p><strong>vs0_key</strong> (<em>string</em>) – key to use to fetch free surface S wave velocity
from Metadata container.  Default is “vs0”.</p></li>
<li><p><strong>uvec</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.SlownessVector" title="mspasspy.ccore.seismic.SlownessVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">SlownessVector</span></code></a>) – slowness vector of the incident wavefield defined via
custom C++ class <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.SlownessVector" title="mspasspy.ccore.seismic.SlownessVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">SlownessVector</span></code></a>.
Default is None which is taken as a signal to fetch the slowness vector
components from Metadata using ux_key and uy_key.</p></li>
<li><p><strong>vp0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Surface P wave velocity.  Default is None which is taken
as a signal to fetch this quantity from Metadata using the vp0_key.</p></li>
<li><p><strong>vs0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Surface S wave velocity.  Default is None which is taken
as a signal to fetch this quantity from Metadata using the vs0_key.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.linear_taper">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">linear_taper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0head</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1head</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1tail</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0tail</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#linear_taper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.linear_taper" title="Permalink to this definition"></a></dt>
<dd><p>Taper front and/or end of a data object with a linear taper.</p>
<p>Linear tapers are defined here as a time spanning a ramp running from 0 to 1.
Data will be zeroed on each end of a 0 mark and a linear weight applied between
0 points and 1 points.  Postive ramp slope on left and negative slope ramp on
right. Setting t0 == t1 will disable the taper on the specified end (e.g., t0head == t1head).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be processed.</p></li>
<li><p><strong>t0head</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t0 of the head taper</p></li>
<li><p><strong>t1head</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t1 of the head taper</p></li>
<li><p><strong>t1tail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t1 of the tail taper</p></li>
<li><p><strong>t0tail</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – t0 of the tail taper</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.rotate">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate_param</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#rotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Rotate data using a P wave type coordinate definition.</p>
<p>This function can apply three different types of rotation depending on the type of parameter given.
If a <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.utility.SphericalCoordinate" title="mspasspy.ccore.utility.SphericalCoordinate"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphericalCoordinate</span></code></a> is given, it will rotate the data
into a coordinate system defined by the direction defined by the spherical coordinate.  The data are
rotated such that x1 becomes the transverse component, x2 becomes radial, and x3 becomes longitudinal.</p>
<p>If an unite vector of three components that defines the direction of x3 direction (longitudinal) is give,
it will turn the vector into a <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.utility.SphericalCoordinate" title="mspasspy.ccore.utility.SphericalCoordinate"><code class="xref py py-class docutils literal notranslate"><span class="pre">SphericalCoordinate</span></code></a> object and calles the
related rotate with it.</p>
<p>If a <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> number is given, it will rotate the horizontal components by this much angle in radians.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be rotated.</p></li>
<li><p><strong>rotate_param</strong> (<em>see above for details.</em>) – the parameter that defines the rotation.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
thing that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.rotate_to_standard">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">rotate_to_standard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#rotate_to_standard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.rotate_to_standard" title="Permalink to this definition"></a></dt>
<dd><p>Apply inverse transformation matrix to return data to cardinal direction components.</p>
<p>It is frequently necessary to make certain a set of three component data are oriented
to the standard reference frame (EW, NS, Vertical).  This function does this.
For efficiency it checks the components_are_cardinal variable and does nothing if
it is set true.  Otherwise, it applies the inverse transformation and then sets this variable true.
Note even if the current transformation matrix is not orthogonal it will be put back into
cardinal coordinates.</p>
<p>If inversion of the transformation matrix is not possible (e.g. two components are colinear)
an error thrown by the C++ function is caught, posted to elog, and the
datum return will be marked dead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be rotated.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Exception<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.utility.MsPASSError" title="mspasspy.ccore.utility.MsPASSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">MsPASSError</span></code></a> thrown if the an inversion of the
transformation matrix is required and that matrix is singular.  This can happen if the
transformation matrix is incorrectly defined or the actual data are coplanar.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.rtoa">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">rtoa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#rtoa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.rtoa" title="Permalink to this definition"></a></dt>
<dd><p>Relative to absolute time conversion.</p>
<p>Sometimes we want to convert data from relative time to
to an UTC time standard.  An example would be converting
segy shot data to something that could be processed like earthquake
data in a css3.0 database. This function returns data
previously converted to relative back to UTC using the
internally stored time shift attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be converted.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.transform">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.transform" title="Permalink to this definition"></a></dt>
<dd><p>Applies an arbitrary transformation matrix to the data.</p>
<p>i.e. after calling this function the data will have been multiplied by the matrix
and the transformation matrix will be updated.  The later allows cascaded
transformations to data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be transformed.</p></li>
<li><p><strong>matrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code>) – a 3x3 matrix that defines the transformation.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.transform_to_LQT">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">transform_to_LQT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seaz_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'seaz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ema_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ema'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle_units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'degrees'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#transform_to_LQT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.transform_to_LQT" title="Permalink to this definition"></a></dt>
<dd><p>Applies coordinate transform to LQT version of ray coordinates.</p>
<p>LQT is an orthogonal coordinate transformation for Seismogram
objects that cause the output data to have x1-Longitudinal (positive up
normally set to the predicted emergence angle of P particle motion),
x2 - Q a rotated radial direction (in propagation direction but tilted by theta).
and x3 - transverse (T) in direction to define a right handed coordinate
system.  The function produces this transformation
by the product f three transformation:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Uses rotate_to_standard to assure we start from cardinal directions.</p></li>
<li><p>Transformation to what might be called TQL using the Seismogram
C++ method rotate using a SphericalCoordinate definition.</p></li>
<li><p>Transformation to LQT to rearrange the order of the Seismogram
data matrix (also requires a sign change on T to keep the output
right handed)</p></li>
</ol>
</div></blockquote>
<p>The form of the transformation can be specified in one of two
completely different ways.   By default the function attempts to
extract the back azimuth from station to event with using the
metadata key defined by ‘seaz_key’ (default ‘seaz’) and the P
emergence angle with the metadata key defined by the ‘ema_key’
argument (default ‘ema’).   If the arguments ‘phi’ and ‘theta’ are
defined they are assumed angles to be used to defined the
transformation and no attempt will be made to fetch the value from
Metaata (Rarely a good idea with ensemble but can be useful for atomic data.
Using Metadata is strongly preferred because it also preserves what
the angles used where.  They are not if the argument approach is used.)
Metadata values are required to be in degree units.  If the argument
approach is used radian values can to used if you also set
the argument “angle_units” to “radians”.</p>
<p>Note the operation handles the singular case of theta==0.0 where it
simply uses the phi value and rotates the coordinates in a variant of
RTZ (variant because order is different).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seaz_key</strong> – key to use to fetch back azimuth value (assumed degrees always)</p></li>
<li><p><strong>ema_key</strong> (<em>string</em><em> (</em><em>defautl &quot;ema&quot;</em><em>)</em>) – key to use to fetch emergence angle defining L direction
relative to local vertical.</p></li>
<li><p><strong>phi</strong> (<em>float</em>) – angle to rotate around vertical to define the transformation
(positive anticlockwise convention NOT azimuth convention)  Default is None
which means ignore this parameter and use key.  Setting this value to
something other than None causes the Metadata fetch method to be overridden.
WARNING:  this is not backazimuth but angle relative to E direction.
Note that is not at all what is expected when using a Metadata key</p></li>
<li><p><strong>theta</strong> (<em>float</em>) – angle relative to local vertical for defining the L
coordinate direction.  It is the same as theta in spherical coordinates
with emergence angle pointing upward.  Default is None which causes the
algorithm to automatically assume the Metadata key method should be used.</p></li>
<li><p><strong>angle_units</strong> (<em>string</em>) – should be either ‘degrees’ (default) or ‘radians’.
An invalid value will be treated as an attempt to switch to radians
but will generate an elog warning message.  This argument is ignored unless
phi is not null (None type)</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – <dl class="simple">
<dt>Some functions one might want to wrap with this decorator</dt><dd><p>return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">return<span class="colon">:</span></dt>
<dd class="field-odd"><p>transformed version of input.  For ensembles the entire ensemble
is transformed.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.transform_to_RTZ">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">transform_to_RTZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'seaz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle_units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'degrees'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_is_backazimuth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#transform_to_RTZ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.transform_to_RTZ" title="Permalink to this definition"></a></dt>
<dd><p>Applies coordinate transform to RTZ version of ray coordinates.</p>
<p>RTZ is the simplest transformation for three component data to
what is commonly called ray coordinates.  R-radial (SV), T-transverse
(SH). and Z=vertical (bad measure of longitudinal).  The function
first forces the data to cardinal direction using rotate_to_standard
and then rotates the coordinates around the vertical axis.   The
rotation can be defined in one of two ways.  The default behavior
is to attempt to extract the back azimuth from the station to the
source with the key defined by the “key” argument (defaults to ‘seaz’).
That behavior will be overriden if the “phi” kwarg value is set.
Phi is assumed to be the angle to rotate the coordinates using the
math convention for the phi angle with positive anticlockwise.
The units of the value retrieved with the key argument or the value
passed via the phi argument are by default assumed to be in degrees.
If using the phi argument you specify the angle in radians if you
also set the “angle_units” argument to “radians”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">SeismogramEnsemble</span></code>.) – data object to be transformed</p></li>
<li><p><strong>key</strong> (<em>string</em>) – key to use to fetch back azimuth value (assumed degrees always)</p></li>
<li><p><strong>phi</strong> (<em>float</em>) – angle to rotate around vertical to define the transformation
(positive anticlockwise convention NOT azimuth convention)  Default is None
which means ignore this parameter and use key.  Setting this value to
something other than None causes the key method to be overridden.</p></li>
<li><p><strong>angle_units</strong> (<em>string</em>) – should be either ‘degrees’ (default) or ‘radians’.
An invalid value will be treated as an attempt to switch to radians
but will generate an elog warning message.  This argument is ignored unless
phi is not null (None type)</p></li>
<li><p><strong>key_is_backazimuth</strong> – boolean that when True (default) assumes the
angle extrated with the key argument value is a backazimuth in degrees.
If set False, the angle will be assumed to be a rotation angle in
with the anticlockwise positive convention.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>transformed version of input.  For ensembles the entire ensemble
is transformed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.basic.vector_taper">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.basic.</span></span><span class="sig-name descname"><span class="pre">vector_taper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taper_array</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/basic.html#vector_taper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.basic.vector_taper" title="Permalink to this definition"></a></dt>
<dd><p>Apply a general taper defined by a vector to the data object.</p>
<p>This method provides a simple way to build a taper from a set of uniformly
spaced points. The apply methods will dogmatically only accept input
data of the same length as the taper defined in the operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (either <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Seismogram</span></code></a>) – data object to be processed.</p></li>
<li><p><strong>taper_array</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code>) – the array that defines the taper</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer
to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper. This is necessary to be used in mapreduce.</p></li>
<li><p><strong>function_return_key</strong> – Some functions one might want to wrap with this decorator
return something that is appropriate to save as Metadata.  If so, use this argument to
define the key used to set that field in the data that is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.bundle">
<span id="bundle"></span><h2>bundle<a class="headerlink" href="#module-mspasspy.algorithms.bundle" title="Permalink to this heading"></a></h2>
<p>This is a set of thin wrappers for C++ code to do a process we call
“bundling”.   That is, a Seismogram object can be constructed from
3 TimeSeries objects spanning a common time period and having the
same sample rate but with orientation pointing in 3 linearly
independent directions.   There are a lot of complexities to assembling
such data and manipulating the data objects, which is why the
process was implemented in C++.   The algorithms here are not completely
generic and will likely need additions at some future data for nonstandard
data.  “standard” in this context means passive array data archived in
the SEED (Standard Earthquake Exchange Data) format (aka miniseed which is
a standard subset of seed used for archives).  The algorithms here
depend upon seismic channels being uniquely defined by four metadata keys:
net, sta, chan, and loc.   Bundles are formed by sorting data in the
following key order:  net, sta, loc, chan.   The algorithms here are
further limited to applications to ensembles that are the generalization
of a reflection seismology “shot gather”.   That means an implict assumption
is the ensembles contain data assembled from one and only one event so
there is a one-to-one relationship between each channel and an event tag.
if data from multiple events or something other than a shot gather
are to be handled used the BundleGroup function station by station
sorting the inputs by some other method to create triples of channels
that can be merged into one Seismogram object.</p>
<p>Created on Mon Jan 11 05:34:10 2021</p>
<p>&#64;author: pavlis</p>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.bundle.BundleSEEDGroup">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.bundle.</span></span><span class="sig-name descname"><span class="pre">BundleSEEDGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/bundle.html#BundleSEEDGroup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.bundle.BundleSEEDGroup" title="Permalink to this definition"></a></dt>
<dd><p>Combine a grouped set of TimeSeries into one Seismogram.</p>
<p>A Seismogram object is a bundle of TimeSeries objects that define a
nonsingular tranformation matrix that can be used to reconstruct vector
group motion.   That requires three TimeSeries objects that have
define directions that are linearly independent.   This function does not
directly test for linear independence but depends upon channel codes
to assemble one or more bundles needed to build a Seismogram.  The
algorithm used here is simple and ONLY works if the inputs have been
sorted so the channels define a group of three unique channel codes.
For example, HHE, HHN, HHZ, would form a typical seed channel grouping.</p>
<p>The function will attempt to handle duplicates.  By that I mean
if the group has two of the same channel code like these sequences:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>HHE, HHE, HHN, HHZ  or HHE, HHN, HHN, HHZ, HHZ
</pre></div>
</div>
<p>If the duplicates are pure duplicates there is no complication and
the result will be clean.   If the time spans of the duplicate
channels are different the decision of which to use keys on a simple
idea that is most appropriate for data assembled by event with
mistakes in associations.  That is, it attempts to scans the group for
the earliest start time.  When duplicates are found it uses the one
with a start time closest to the minimum as the one merged to make the
output Seismogram.</p>
<p>The output will be marked as dead data with no valid data in one of
two conditions:  (1)  less than 3 unique channel names or (2) more than
three inputs with an inconsistent set of SEED names.   That “inconsistent”
test is obscure and yet another example that SEED is a four letter word.
Commentary aside, the rules are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The net code must be defined and the same in all TimeSeries passed</p></li>
<li><p>The station (sta) code must also be the same for all inputs</p></li>
<li><p>Similarly the loc code must be the same in all inputs.</p></li>
<li><p>Finally, there is a more obscure test on channel names.  They must</p></li>
</ol>
</div></blockquote>
<p>all have the same first two characters.   That is, BHE, BHN, BHN, BHZ
is ok but BHE, BHN, BHZ, HHE will cause an immediate exit with no
attempt to resolve the ambiguity - that is viewed a usage error in
defining the range of the bundle.</p>
<p>In all cases where the bundling is not possible the function does not
throw an exception but does four things:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Merges the Metadata of all inputs (uses the += operator so only the
last values of duplicate keys will be preserved in the return)</p></li>
<li><p>If ProcessingHistory is defined in the input they history records  are
posted to the returned Seismogram using as if the data were live but the
number of input will always be a number different from 3.</p></li>
<li><p>The return is marked dead.</p></li>
<li><p>The function posts a (hopefully) informative message to elog of the
returned Seismogram.</p></li>
</ol>
</div></blockquote>
<p>ProcessingHistory is handled internally by this function.  If all the
components in a group have a nonempty ProcessingHistory the data to link
the outputs to the inputs will be posted to ProcessingHistory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – This is assumed to be an array like object of TimeSeries data
that are to be used to build the Seismogram objects.  They must be
sorted as described above or the algorithm will fail.   Two typical
array like objects to use are the member attribute of a TimeSeriesEnsemble
or a python array constructed from a (sorted) collection of TimeSeries
objects.</p></li>
<li><p><strong>i0</strong> – starting array position for constructing output(s).
The default is 0 which would be the normal request for an full ensemble
or a single grouping assembled by some other mechanism.  A nonzero is
useful to work through a larger container one Seismogram at a time.</p></li>
<li><p><strong>iend</strong> – end array position.   The function will attempt to
assemble one or more Seismograms from TimeSeries in the range
d[i0] to d[iend].  Default is 2 for a single Seismogram without
duplicates.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.bundle.bundle_seed_data">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.bundle.</span></span><span class="sig-name descname"><span class="pre">bundle_seed_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/bundle.html#bundle_seed_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.bundle.bundle_seed_data" title="Permalink to this definition"></a></dt>
<dd><p>This function can be used to take an (unordered) input ensemble of
TimeSeries objects generated from miniseed data and produce an output
ensemble of Seismograms produced by bundles linked to the seed name
codes net, sta, chan, and loc.   An implicit assumption of the algorithm
used here is that the data are a variant of a shot gather and the
input ensemble defines one net:sta:chan:loc:time_interval for each
record that is to be bundled.   It can only properly handle pure
duplicates for a given net:sta:chan:loc combination.  (i.e. if
the input has the same TimeSeries defined by net:sta:chan:loc AND
a common start and end time).   Data with gaps broken into multiple
net:sta:chan:loc TimeSeries with different start and end times
will produce incomplete results.   That is, Seismograms in the output
associated with such inputs will either be killed with an associated
error log entry or in the best case truncated to the overlap range of
one of the segments with the gap(s) between.</p>
<p>Irregular start times of any set of TimeSeries forming a single
bundle are subject to the same truncation or discard rules described
in the related function Bundle3C.</p>
<p>Note there is not guarantee the Seismogram objects returned
will be in standard coordinates.  In fact, they will never be
with standard channel names because of the internal sorting.
It would normally be highly recommended the user call the
rotate_to_standard method on each Seismogram before any use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ensemble</strong> – is the input ensemble of TimeSeries to be processed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ensemble of Seismogram objects made by bundling input data</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.SeismogramEnsemble" title="mspasspy.ccore.seismic.SeismogramEnsemble">SeismogramEnsemble</a></p>
</dd>
<dt class="field-even">Exception<span class="colon">:</span></dt>
<dd class="field-even"><p>Can throw a MsPASSError for a number of conditions.
Caller should be enclosed in a handler if run on a large data set.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.calib">
<span id="calib"></span><h2>calib<a class="headerlink" href="#module-mspasspy.algorithms.calib" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.calib.ApplyCalibEngine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.calib.</span></span><span class="sig-name descname"><span class="pre">ApplyCalibEngine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">db</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'channel'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ounits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['counts',</span> <span class="pre">'COUNTS',</span> <span class="pre">'count',</span> <span class="pre">'COUNT']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iunits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['m/s',</span> <span class="pre">'M/S']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response_data_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'serialized_channel_data'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/calib.html#ApplyCalibEngine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.calib.ApplyCalibEngine" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A special case of response correction is a simple scalar multiply by a
constant used to convert data from raw counts to the (now) standard units
of nm/s.  For many applications using broadband data that correction
is sufficient to assure ensembles of signals are on a common amplitude
scale.  A basic rule if the passband of the processing is inside the
instrument passband a full response correction is not alway necessary.
A case in point is reeiver function processing where the passband of
actual data is inside the passband of most “broadband sensors”.</p>
<p>This class can be used to process TimeSeries or TimeSeriesEnsemble
objects to convert data from raw counts to units of nm/s.</p>
<p>The effort required to extract the conversion factor from the
archain response format of seed and station xml is not trivial.
We rely here on the conversion of downloaded station metadata from
fdsn sources via web services and obspy’s downloading methods.
Obspy converts that archain data to what they call an Inventory
object.  In MsPASS we disaggregate the complicated Inventory object
into a set of MongoDB documents with one entry for each
seed time period fr each channel of data.   Inside that document is a
an attibute with the tag “serialized_channel_data” that contains
the detailed response data serialized with pickle.   The
constructor for this object runs pickle.loads on that data to yield
an obspy Response object.  We only extract the “sensitivity” value from
Response.   A major complication is unit restrictions and invalid
Response objects.  These are handled by the constructor as described
below.   The current implementation can only handle Response objects
with “input units” of meters per second and “output units” of counts.
Note input and output is because the Response object uses
sensitivity = 1/calib.  i.e. sensitivity is the scale to convert
physical units to counts which backward from what this class is
designed for - converting counts to physical units of nm/s.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.calib.ApplyCalibEngine.apply_calib">
<span class="sig-name descname"><span class="pre">apply_calib</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'channel_id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kill_if_undefined</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/calib.html#ApplyCalibEngine.apply_calib"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.calib.ApplyCalibEngine.apply_calib" title="Permalink to this definition"></a></dt>
<dd><p>Use this method to apply a calib value to a TimeSeries or all the
live members of a TimeSeriesEnsemble.</p>
<p>This is the processing function used for applying calibration.
It is a method instead of a function because the class allows the
calib values to be cached inside the object.   The input(s) must
contain a MongoDB ObjectId that can be matched with the ids
loaded in the cache by the constructor.   By default the key
used is “channel_id”.  That can be changed with the “id_key”
argument.  If a match is found all
the sample valued are multiplied by calib AND the calib attribute is
set.   Note a complaint will be issued if calib was found to already
be defined in  AND is not 1.0 (a default sometimes appropriate)</p>
<p>This method can easily become a mass murderer.   By default any
datum with an undefined calib value in the cache of this object will
be marked dead on return with a error message posted to its elog
container.  If the <cite>kill_if_undefined</cite> argument is set False
such data will not be killed but an elog message will be posted
marked complaint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<cite>TimeSeries</cite> or <cite>TimeSeriesEnsemle</cite>  This method will
raise a ValueError exception if d is anything else.) – input data to process</p></li>
<li><p><strong>kill_if_undefined</strong> – bolean that when True (default) will
cause any datum for which a matching calib cannot be found to be
killed.   Note this operation is atomic so for ensembles only
members that fail the match will be killed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>copy of input with amplitudes multiplied by calib factor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.calib.ApplyCalibEngine.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/calib.html#ApplyCalibEngine.size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.calib.ApplyCalibEngine.size" title="Permalink to this definition"></a></dt>
<dd><p>Return size of the cache of calib values stored in the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-mspasspy.algorithms.edit">
<span id="edit"></span><h2>edit<a class="headerlink" href="#module-mspasspy.algorithms.edit" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement += operator on a specified Metadata key.
Example:  to add 2 to data, d, with key=’icdp’ could use this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="s1">&#39;icdp&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Add2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement + operator that adds two Metadata attributes
together.  The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a+b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a+b)
i.e. d[key0] = d[key1] + d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] + d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Add2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Add2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Add2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Add2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.ChangeKey">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">ChangeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oldkey</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newkey</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">erase_old</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#ChangeKey"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.ChangeKey" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.ChangeKey.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_enembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#ChangeKey.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.ChangeKey.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.ChangeKey.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#ChangeKey.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.ChangeKey.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>All implementation should implement this checker even if all it contains
is a pass.  It should validate the keys are defined in data to be
handled in the apply method.   An early call in apply should always
be to call this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.ChangeKey.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#ChangeKey.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.ChangeKey.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>there is no operation on a ChangeKey so this method does nothing.
Because it is an abstract base we have to have this stub.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_divide</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement /= operator on a specified Metadata key.
Example:  to divide metadata in, d, with key=’Pamp’ by 2.0
you could use this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Divide</span><span class="p">(</span><span class="s1">&#39;Pamp&#39;</span><span class="p">,</span><span class="mf">2.</span><span class="o">-</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Divide2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement / operator that divides two Metadata attributes.
The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a/b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a/b)
i.e. d[key0] = d[key1] / d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] / d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Divide2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Divide2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Divide2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Divide2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Executioner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Executioner</span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Executioner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Executioner" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for family of python classes used for killing
mspass data objects failing to pass a particular metric.
It is made abstract to define required methods a particular instance
must create.  As in any good OOP that also means subclasses can
add additional methods.   This class should be used only as base
class as it has no functionality by itself.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Executioner.edit_ensemble_members">
<span class="sig-name descname"><span class="pre">edit_ensemble_members</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Executioner.edit_ensemble_members"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Executioner.edit_ensemble_members" title="Permalink to this definition"></a></dt>
<dd><p>Subclasses should call this method if the input data are an
ensemble.   A trick of inheritance allows the algorithm of self
to then be applied to whole ensemble.  Putting this in the
base class avoids the duplication of duplicate code in all
subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Executioner.kill_if_true">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Executioner.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Executioner.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>This method should run a test on d that will call the kill method
on MsPASS atomic object d if the test defined by the implementation
fails.  This is the main working method of this class of function
objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Executioner.log_kill">
<span class="sig-name descname"><span class="pre">log_kill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">severity=&lt;ErrorSeverity.Informational:</span> <span class="pre">5&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Executioner.log_kill"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Executioner.log_kill" title="Permalink to this definition"></a></dt>
<dd><p>This base class method is used to standardize the error logging
functionality of all Executioners.   It writes a standardized
message to simplify writing of subclasses - they need only
define the testname (normally the name of the subclass) and
format a specific message to be posted.</p>
<p>Note most subclasses will may want to include a verbose option
(or the reciprocal silent) and only write log messages when
verbose is set true.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – MsPASS data object to which elog message is to be
written.</p></li>
<li><p><strong>testname</strong> – is the string assigned to the “algorithm” field
of the message posted to d.elog.</p></li>
<li><p><strong>message</strong> – specialized message to post - this string is added
to an internal generic message.</p></li>
<li><p><strong>severity</strong> – ErrorSeverity to assign to elog message
(See ErrorLogger docstring).  Default is Informational</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.FiringSquad">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">FiringSquad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executioner_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#FiringSquad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.FiringSquad" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Used to apply multiple Executioners in a single pass - hence the name
FiringSquare image; facing more than one thing that could kill you.
The implementation in kill_if_true iterates through a list of
Executioners.  Once the datum is killed it is immediately returned.
If the Executions are running in verbose mode that means some tests
can shadow others.   It is like a firing squad where the guns are fired
in sequence and the body is removed as soon as there is a hit.  The
victim walks away only if all the guns miss.</p>
<p>Note the class has a += operator to allow appending additional
tests to the chain.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.FiringSquad.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#FiringSquad.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.FiringSquad.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of base class method.  In this case failure is
defined as not passing one of the set of tests loaded  when
the object was created.  As noted earlier the tests are performed
in the same order they were passed to the constructor of added on
with the += operator.
:param d: is a mspass data object to be checked</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">IntegerDivide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement // operator on a specified Metadata key.
The // operator is a bit obscure but it implements the common
need to truncate a division result to an integer.  This will work
on floats but the result will always be close to and integer
value as if the operation were done with integers.  Note
also IntegerDivide is the complement to Mod which returns the remainder
of such a division.</p>
<p>Example:  to apply integer division to metadata in, d, with key=’icdp’ by 5
you could use this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">IntegerDivide</span><span class="p">(</span><span class="s1">&#39;icdp&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">IntegerDivide2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement // operator between two Metadata attributes.
The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a//b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a+b)
i.e. d[key0] = d[key1] // d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] // d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">IntegerDivide2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.IntegerDivide2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#IntegerDivide2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.IntegerDivide2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataDefined">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataDefined</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataDefined"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataDefined" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using an existence test.  The
constructor loads only a key string.   The test for the kill_if_true
method is then simply for the existence of a value associated with
the loaded key.   Data will be killed if the defined key exists
in the Metadata (header).</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataDefined.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataDefined.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataDefined.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if self.key is defined for this datum</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataEQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataEQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataEQ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataEQ" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using an equality test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the == operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &gt;= is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.  It can be used for
booleans even though few would write an if statement testing if two
booleans were equal.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataEQ.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataEQ.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataEQ.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] == value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataGE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataGE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataGE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataGE" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using a greater than or equal test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the &gt;= operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &gt;= is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataGE.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataGE.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataGE.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] &gt;= value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataGT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataGT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataGT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataGT" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using a greater than test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the &gt; operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &gt; is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataGT.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataGT.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataGT.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] &gt; value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataInterval">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_endpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_endpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_lower_edge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_upper_edge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kill_if_outside</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataInterval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataInterval" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner based on a numeric range of values.
i.e. it tests if a metadata value is in a range defined by
an upper and lower value.   Ranges have a minor complication in
handling the edge condition: should or should the test not include
the edge?   Rather than write different functions for the four possible
combinations of &lt;=, &lt;, &gt;=, and &gt; that define a range we use
constructor arguments (use_lower_edge and use_upper_edge) to
turn inclusion of the boundary on and off.</p>
<p>In this context an interval test also has two logical alternatives.
One may want to keep data inside an interval (most common and default)
or delete data within a specified interval.   That logic is controlled by
the kill_if_outside boolean</p>
<p>Intervals mostly make sense only for numeric types (int and float), but
can be used with strings.  In reality this function should work with any
object for which the operators &gt;, &lt;, &gt;=, and &gt;= are defined but that is
adventure land if you try.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataInterval.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataInterval.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataInterval.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] &lt;= value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataLE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataLE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataLE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataLE" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using a less than or equal test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the &lt;= operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &gt;= is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataLE.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataLE.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataLE.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] &lt;= value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataLT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataLT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataLT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataLT" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using a lessthan test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the &lt; operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &lt; is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataLT.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataLT.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataLT.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] &gt; value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataNE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataNE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataNE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataNE" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using an not equal (NE) test of a
Metadata attribute.  Both the metadata key and the threshold
for the kill test are set on creation.  This implementation should
work on any value pairs for which the != operator in python works.
That is true for pairs of numeric types, for example, but will fail
if one of the pair is a string (an error anyway for any rational use of this).
It should also work for any pair of pyobjects for which operator &gt;= is defined,
although anything nonstandard should be tested carefully before using
this class for editing data with such nonstandard types.  This was
mostly intended for simple numeric attributes.  It can be used for
booleans even though few would write an if statement testing if two
booleans were equal.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataNE.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataNE.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataNE.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if the d[self.key] != value stored with the class.</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataOperator</span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Base class for a set of inline Metadata editors. That is, there
are many instances where Metadata attributes need to be altered
during a workflow where it is either unnecessary or inappropriate
to access the database.   e.g. we have found updates in MongoDB
can be very slow if done one transaction at a time so it can
streamline processing to edit metadata on the fly.   This base
class defines the API for a suite of tools for editing metadata
on the fly.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator.apply">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator.check_keys">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>All implementation should implement this checker even if all it contains
is a pass.  It should validate the keys are defined in data to be
handled in the apply method.   An early call in apply should always
be to call this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator.check_operation">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>All implementations should implement this method even if they choose
to ignore it.   It should be used to guarantee the operator the class
defines will succeed on the datum sent to the apply method.
e.g. any standard arithmetic operations will throw a TypeError if
one of the operands is a string.   This method should be used to
make the operator as bombproof as possible logging a message
to the datum rather than aborting if there is an issue.  Some
classes may want to implement this as pass because it makes
no sense - e.g. setting a constant value.   Those are the
exception, however, so the api dogmatically demands these
be implemented even if they do nothing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator.edit_ensemble_members">
<span class="sig-name descname"><span class="pre">edit_ensemble_members</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ensemble</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator.edit_ensemble_members"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator.edit_ensemble_members" title="Permalink to this definition"></a></dt>
<dd><p>Subclasses should call this method if the input data are an
ensemble.   A trick of inheritance allows the algorithm of self
to then be applied to whole ensemble.  Putting this in the
base class avoids the duplication of duplicate code in all         subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperator.log_edit">
<span class="sig-name descname"><span class="pre">log_edit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">testname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">severity=&lt;ErrorSeverity.Informational:</span> <span class="pre">5&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperator.log_edit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperator.log_edit" title="Permalink to this definition"></a></dt>
<dd><p>This base class method is used to standardize the error logging
functionality of all editors.   It writes a standardized
message to simplify writing of subclasses - they need only
define the testname (normally the name of the subclass) and
format a specific message to be posted.</p>
<p>Note most subclasses will may want to include a verbose option
(or the reciprocal silent) and only write log messages when
verbose is set true.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – MsPASS data object to which elog message is to be
written.</p></li>
<li><p><strong>testname</strong> – is the string assigned to the “algorithm” field
of the message posted to d.elog.</p></li>
<li><p><strong>message</strong> – specialized message to post - this string is added
to an internal generic message.</p></li>
<li><p><strong>severity</strong> – ErrorSeverity to assign to elog message
(See ErrorLogger docstring).  Default is Informational</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperatorChain">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataOperatorChain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator_list</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperatorChain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperatorChain" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to apply multiple a chain of arithmetic operators to derive
computed metadata attributes.  Very elaborate calculations can be
done through this class by chaining appropriate atomic operators
defined elsewhere in the module (i.e. Add, Subtract, etc.).
The operation chain is defined by a python list of the atomic operators.
When the apply method of this class is called the list of operators
are applied sequentially in list order.</p>
<p>Note the class has a += operator to allow appending additional
operators to the chain.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperatorChain.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperatorChain.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperatorChain.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of base class method.  In this case failure is
defined as not passing one of the set of tests loaded  when
the object was created.  As noted earlier the tests are performed
in the same order they were passed to the constructor of added on
with the += operator.
:param d: is a mspass data object to be checked</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperatorChain.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperatorChain.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperatorChain.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>All implementation should implement this checker even if all it contains
is a pass.  It should validate the keys are defined in data to be
handled in the apply method.   An early call in apply should always
be to call this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataOperatorChain.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataOperatorChain.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataOperatorChain.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>All implementations should implement this method even if they choose
to ignore it.   It should be used to guarantee the operator the class
defines will succeed on the datum sent to the apply method.
e.g. any standard arithmetic operations will throw a TypeError if
one of the operands is a string.   This method should be used to
make the operator as bombproof as possible logging a message
to the datum rather than aborting if there is an issue.  Some
classes may want to implement this as pass because it makes
no sense - e.g. setting a constant value.   Those are the
exception, however, so the api dogmatically demands these
be implemented even if they do nothing.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataUndefined">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">MetadataUndefined</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataUndefined"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataUndefined" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.Executioner" title="mspasspy.algorithms.edit.Executioner"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executioner</span></code></a></p>
<p>Implementation of Executioner using an nonexistence test.  The
constructor loads only a key string.   The test for the kill_if_true
method is then simply for the existence of a value associated with
the loaded key.   Data will be killed if the defined key does not exists
(Undefined) in the Metadata (header).</p>
<p>This class is a useful prefilter to apply to any algorithm that
requires a particular metadata attribute.  Use FiringSquad to define
a chain of required metadata to prefilter data input to such an algorithm.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.MetadataUndefined.kill_if_true">
<span class="sig-name descname"><span class="pre">kill_if_true</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#MetadataUndefined.kill_if_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.MetadataUndefined.kill_if_true" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of this abstract method for this tester.
Kills d if self.key is not defined for this datum</p>
<p>Returns a (potentially edited) copy of the input to allow use in
a parallel map operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement % operator on a specified Metadata key.
The % operator is a bit obscure but it implements the common
need return the remainder of a divide operation.   It is commonly
used, for example, in cmp processing where survey flag numbers can
often be converted to channel numbers for simple multichannel cable
geometries.</p>
<p>This operator will work any numeric type but it is most commonly used
for integer attributes.</p>
<p>Example:  to convert the metadata associated with the key ‘ichan’ that
are currently counting by 1 to numbers that cycle from 0 to 23 us this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Mod2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement % operator between two Metadata attributes.
The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a+b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a%b)
i.e. d[key0] = d[key1] % d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] % d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Mod2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Mod2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Mod2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Mod2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_multiply</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement <a href="#id9"><span class="problematic" id="id10">*</span></a>= operator on a specified Metadata key.</p>
<p>Example:  to multiple metadata in, d, with key=’Pamp’ by 2.5
you could use this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Multiply</span><span class="p">(</span><span class="s1">&#39;Pamp&#39;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Multiply2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement * operator that multiplies two Metadata attributes
together.  The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a*b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a*b)
i.e. d[key0] = d[key1] * d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] * d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Multiply2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Multiply2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Multiply2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Multiply2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.SetValue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">SetValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#SetValue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.SetValue" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to set a specified metadata key to a constant value.  Note any
existing value of Metadata associated with the key defined in the
operator always be overwritten.</p>
<p>Example:  to set the value of key = ‘a’ to constant 2.0</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">SetValue</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.SetValue.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#SetValue.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.SetValue.apply" title="Permalink to this definition"></a></dt>
<dd><p>Used to apply this operator to Metadata of a MsPASS data object.
Use of decorator adds common MsPASS arguments as call options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – datum to which operator is to be applied.  d must be a
valid MsPASS data object or this method will throw a fatal MsPASSError
exception.  If d is marked dead it will be silently ignored.</p></li>
<li><p><strong>apply_to_members</strong> – when true and d is an ensemble object the
operator is applied to the members.  When false the metadata for the
ensemble will be altered.  This parameter is ignored for atomic
data types.  Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>always returns a (usually) edited copy of the input d.
When the input d is dead the copy will always be unaltered.
Note the copy is a shallow copy which in python means we just return
the equivalent of a pointer to the caller.  Important for efficiency
as d can be very large for some ensembles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.SetValue.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#SetValue.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.SetValue.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>Useless implementation of required abstract base method.  In this
case all it does is test if the stored value of key is a string.
Returns true if the key is a string and false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.SetValue.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#SetValue.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.SetValue.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>All implementations should implement this method even if they choose
to ignore it.   It should be used to guarantee the operator the class
defines will succeed on the datum sent to the apply method.
e.g. any standard arithmetic operations will throw a TypeError if
one of the operands is a string.   This method should be used to
make the operator as bombproof as possible logging a message
to the datum rather than aborting if there is an issue.  Some
classes may want to implement this as pass because it makes
no sense - e.g. setting a constant value.   Those are the
exception, however, so the api dogmatically demands these
be implemented even if they do nothing.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_subtract</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement -= operator on a specified Metadata key.
Example:  to subtract 2 from metadata, d, with key=’icdp’ could use this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Subtract</span><span class="p">(</span><span class="s1">&#39;icdp&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the key defined for the operator is defined for d.
Returns true if is defined and false if not.  the method assumes
d is a valid child of Metadata so the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">Subtract2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract2" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.edit.MetadataOperator" title="mspasspy.algorithms.edit.MetadataOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataOperator</span></code></a></p>
<p>Used to implement - operator that computes the difference of two Metadata
attributes.  The attributes are feteched with two keys set when
the operator is constructed.  Let a be the value in a datum
associated with key2 (arg1 of constructor) and b be the
value associated with key2 (arg2 of constructor).  The apply
method of this class computes a-b and sets the Metadata attribute
defined by key0 (arg0 of constructor) to that value (a-b)
i.e. d[key0] = d[key1] - d[key2]</p>
<p>Note key0 can be the same as either key1 or key2. The contents of the
left hand side (key0) are always set by this operator unless that
input was previously marked dead.  Further key1 and key2 can be the
same although it is hard to conceive how that could be useful.</p>
<p>Example:  to compute ix as the d[‘sx’] - d[‘chan’] use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Subtract2</span><span class="p">(</span><span class="s1">&#39;ix1&#39;</span><span class="p">,</span><span class="s1">&#39;sx&#39;</span><span class="p">,</span><span class="s1">&#39;chan&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract2.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract2.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract2.apply" title="Permalink to this definition"></a></dt>
<dd><p>Implementations are required to implement this method.  It must
accept a MsPASS data object, d, (TimeSeries, Seismogram, TimeSeriesEnsemble,
or SeimogramEnsemble) and apply the operator the implementation defines
to the Metadata of d.   It should throw a MsPASSError exception if
d is not one of the expected data types.  It should, on the other
hand, handle d==None gracefully and do nothing if d is None.
Ensemble handlers need to deal with an ambiguity in which metadata
the operation refers to.  Both the overall ensemble container and
individual members have (normally independent) Metadata containers.
Implementations of this method should have a apply_to_members
argument as in the signature for this base class.   When True
the editing is done by a loop over all members while if
False (which should be the default) the ensemble’s container
should be used.</p>
<p>This method must return an (potentially but not guarnateed) edited
version of d.  That is essential to allow this method to be used
as the function in a parallel map operator.</p>
<p>If a required metadata key is missing this method should do nothing
unless a verbose flag is set.  In that case it should log that as
an error.   Best practice for any use of operators based on this
base class is to apply a kill operator for (MetadataDefined) on
all data before running a calculator.    That way you can guarantee
the data needed for all operations is valid before trying to
do calculations on on required metadata.   There is some overhead
in validating metadata so all implementations should include
use of “fast_mode”.  When set true the safeties will be bypassed
for speed.  That includes at least the two requried methods
“check_keys” and “check_operation”.  Implementations may add
other safties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract2.check_keys">
<span class="sig-name descname"><span class="pre">check_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract2.check_keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract2.check_keys" title="Permalink to this definition"></a></dt>
<dd><p>checks that the keys required for the operator are defined for d.
If either required key are missing from d return False.  Return
True if both are set in d. The method assumes
d is a valid child of Metadata so that the is_defined method will
not generate an exception.  that means this method should ALWAYS
be called after a test with _input_is_valid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.Subtract2.check_operation">
<span class="sig-name descname"><span class="pre">check_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#Subtract2.check_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.Subtract2.check_operation" title="Permalink to this definition"></a></dt>
<dd><p>This method checks to make sure the value works with the operation
required.  It provides a (required by the base class) standardization
of testing for validity of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.edit.erase_metadata">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.edit.</span></span><span class="sig-name descname"><span class="pre">erase_metadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keylist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_to_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/edit.html#erase_metadata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.edit.erase_metadata" title="Permalink to this definition"></a></dt>
<dd><p>This editor clears the contents of any data associated with a list of
Metadata keys.   If there is no data for that key it will silently do
nothing.  If the input is an ensemble and apply_to_members is True
all the algorithm will run on the metadata of each member in a loop.
If false only the ensemble (global) metadata are handled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – must be a valid MsPASS data object. If not the function
will throw an exception.   If the datum is marked dead it will
silently just return the contents.</p></li>
<li><p><strong>keylist</strong> – python list of strings to use as keywords.  Any matching
keys the metadata of d will be cleared.</p></li>
<li><p><strong>apply_to_members</strong> – is a boolean controlling how the function
should handle ensembles.  Then set true the erase algorithm will be
applied in a loop over the member vector of an input ensemble.  When
False (default) only the ensemble’s metadata is checked.  This parameter
is ignored if the input is an atomic data type.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>edited copy of d</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.resample">
<span id="resample"></span><h2>resample<a class="headerlink" href="#module-mspasspy.algorithms.resample" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.BasicResampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.resample.</span></span><span class="sig-name descname"><span class="pre">BasicResampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#BasicResampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.BasicResampler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Base class for family of resampling operators.   All this class really does is
define the interface and standardize the target of the operator.
A key concept of this family of operator is they are intended to
be used in a map operator to regularize the sample rate to a
constant.   Hence, the base class defines that constant output
sample rate (alternatively the sample interval, dt).</p>
<dl class="simple">
<dt>ALL implementations must recognize a couple fundamental concepts:</dt><dd><ol class="arabic simple">
<li><p>This is intended to ONLY be used on waveform segments.
The problem of resampling continuous data requires different
algorithms.  The reason is boundary effects.  All
implementations are subject to edge transients.  How the
implementation does or does not handle that issue is
viewed as an implementation detail,</p></li>
<li><p>Downsampling ALWAYS requires some method to avoid aliasing of
the output.  How that is done is considered an implementation
detail.</p></li>
</ol>
</dd>
</dl>
<p>This is a sketch of an algorithm is pseudopython code showing how
a typical instance of this class (in the example ScipyResampler)
would be used in  parallel workflow sketch:</p>
<p class="rubric">Example</p>
<p>resamp_op = ScipyResampler(10.0)   # target sample rate of 10 sps
cursor = db.TimeSeries.find({})
bag = read_distributed_data(cursor,collection=”wf_TimeSeries”)
bag = bag.map(resamp_op.resample)
bag.map(db.save_data())
bag.compute()</p>
<p>A point to emphasize is the model is to generate the operator
through a constructor (ScipResampler in the example) that defines
the target sample rate.  All data passed through that operator
through the map operator call will be returned to create a bag/rdd
with a uniform sample rate.   All implementations should also
follow the MsPASS rule for parallel algorithms to kill data that
cannot be handled and not throw exceptions unless the whole usage is
wrong.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.BasicResampler.dec_factor">
<span class="sig-name descname"><span class="pre">dec_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#BasicResampler.dec_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.BasicResampler.dec_factor" title="Permalink to this definition"></a></dt>
<dd><p>All implementations of decimation algorithms should use this
method to test if resampling by decimation is feasible.
A decimation operator only works for downsampling with
the restriction that the ouptut sample interval is an integer
multiple of the input sample interval.</p>
<p>The function returns a decimation factor to use for atomic data d
being tested.  The algorithm uses the numpy “isclose”
function to establish if the sample interval is feasible.
If so it returns the decimation factor as an integer that should be
used on d.  Not implementations should handle a return of 1
specially for efficiency.  A return of 1 means no resampling
is needed.  A return of 0 or -1 is used for two slightly different
cases that indicate a decimation operation is not feasible.
A return of 0 should be taken as a signal that the data requires
upsampling to match the target sampling rate (interval).
A return of -1 means the data require downsampling but the
a decimator operator is not feasible.  (e.g. needing to create
10 sps data from 25 sps input.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>d</strong> (<em>assumed to be a MsPASS atomic data object for which the
dt attribute is defined.  This method has no safeties to test
input type.  It will throw an exception if d.dt does not resolve.</em>) – input mspass data object to be tested.   All that is
actually required is d have a “dt” attribute (i.e. d.dt is defined)
that is the sample interval for that datum.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.BasicResampler.resample">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mspass_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#BasicResampler.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.BasicResampler.resample" title="Permalink to this definition"></a></dt>
<dd><p>Main operator a concrete class must implement.  It should accept
any mspass data object and return a clone that has been resampled
to the sample interface defined by this base class.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.BasicResampler.target_dt">
<span class="sig-name descname"><span class="pre">target_dt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#BasicResampler.target_dt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.BasicResampler.target_dt" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.BasicResampler.target_samprate">
<span class="sig-name descname"><span class="pre">target_samprate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#BasicResampler.target_samprate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.BasicResampler.target_samprate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.ScipyDecimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.resample.</span></span><span class="sig-name descname"><span class="pre">ScipyDecimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'iir'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#ScipyDecimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.ScipyDecimator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.resample.BasicResampler" title="mspasspy.algorithms.resample.BasicResampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasicResampler</span></code></a></p>
<p>This class defines a generic operator where a decimator can be used
to downsample any input data to a common sample rate.  A decimator
requires the ratio of the input to output sample rate to be an
integer (equivalently the ratio of the output sample interval to the
input sample interval).  The operator will fail on any data it
receives that are irregular in that sense.   For example, 10 sps
data can be created by downsampling 40 sps data by a factor of 4.
In constract, 10 sps can not be created by decimation of 25 sps
data because the ratio is 2.5 (not an integer).</p>
<p>This operator satisfies the concept defined in BasicResampler.
That is, a particular concrete instance once constructed will
define an operator that will resample any input data to a common sample
rate/interval.  Because of the requirement of this algorithm that
the sample intervals/rates are related by integers the operator
has to be able to handle irregular sample rate data.  The algorithm
is brutal and will kill any datum for which the integer test fails
and post an elog message.</p>
<p>This operator is really little more than a wrapper around a
scipy function with a similar same name (scipy.signal.decimate).
The resample method handles any supported MsPASS data object type
but will fail with a TypeError if it receives any other data type.</p>
<p>Be aware decimators all have unavoidable edge effects.   The anitialias
filter that has to be applied (you can get garbage otherwise) will always
produce an edge transient.  A key to success with any downsampling
operator is to always have a pad zone if possible.  That is, you start
with a longer time window than you will need for final processing and
discard the pad zone when you enter the final stage.   Note that is
actually true of ALL filtering.</p>
<p>The constructor has almost the same arguments defined in the documentation
page for scipy.signal.decimate.   The only exception is the axis
argument.  It needs to be defined internally.
For scalar data we pass 0 while for three component data we sent it 1 which is
means the decimator is applied per channel.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.ScipyDecimator.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mspass_object</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#ScipyDecimator.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.ScipyDecimator.resample" title="Permalink to this definition"></a></dt>
<dd><p>Implementation of required abstract method for this operator.
The only argument is mspass_object.   The operator will downsample
the contents of the sample data container for any valid input.
If the input is not a mspass data object (i.e. atomic TimeSeries
or Seismogram) or one of the enemble objects it will throw a
TypeError exception.</p>
<p>Note for ensembles the algorithm simply applies this method in
a loop over all the members of the ensemble.  Be aware that any
members of the ensemble cannot be resampled to the target sampling
frequency (interval) they will be killed.  For example, if you
are downsampling to 20 sps and you have 25 sps data in the ensemble
the 25 sps data will be killed on output with an elog message
posted.</p>
<p>Returns an edited clone of the input with revised sample data but
no changes to any Metadata.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.ScipyResampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.resample.</span></span><span class="sig-name descname"><span class="pre">ScipyResampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#ScipyResampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.ScipyResampler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#mspasspy.algorithms.resample.BasicResampler" title="mspasspy.algorithms.resample.BasicResampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BasicResampler</span></code></a></p>
<p>This class is a wrapper for the scipy resample algorithm.  Obspy users
should note that the Trace and Stream method called “resample”
is only a light wrapper to apply the scipy resample function.</p>
<p>The algorithm and its limitations are described in the scipy
documentation you can easily find with a web search.   A key point
about this algorithm is that unlike decimate it allows resampling to
something not an integer multiple or division from the input OR
if you need to upsample data to match the rest of the data set
(Note that is not usually a good idea unless the upsampling is followed
by a decimator to get all data to a lower, uniform sample rate.)
A type example where that is essential is some old OBS data from
Scripps instruments that had a sample rate that was a multiple of
one of the more standard rates like 20 or 100.  Such data can be
downsampled immediately too something like 10 sps with this operator
or upsampled to something like 50 and then downsampled to something
like 10 with a factor of 5 decimator.</p>
<p>We emphasize a nice feature of the scipy implementation is that
it automatically applies a rational antialiasing filter when downsampling,
If, however, you need to do something like regularize a data set with
irregular sample rates but preserve a common upper frequency response
controlled at the high frequency end by digizer antialias filters
(e.g. LH channels from Q330 data) you will need to crack the
scipy documentation on setting up a custom antialias filter using
FIR filters defined through the window argument.  All common digitizer
FIR filter coefficients can be found in appropriate response files.
That should, in principle, be feasible but mspass developers have
not tested that hypothesis.</p>
<p>The concept of the window argument in this constructor is idential
to that described in the documentation for scipy.signal.resample.
The value passed, in fact, is used as the argument whenever the scipy
function is called.   Note the other optional arguments to scipy
resample are always defaulted because the current default apply to
all cases we handle.  Be careful if resample changes.</p>
<p>The primary method of this class is a concrete implementation of the
resample method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.ScipyResampler.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mspass_object</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#ScipyResampler.resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.ScipyResampler.resample" title="Permalink to this definition"></a></dt>
<dd><p>Applies the scipy.signal.resample function to all data held in
a mspass container passed through arg0 (mspass_object).
This method will accept all supported MsPASS datat objects:
TimeSeries, Seismogram, TimeSeriesEnsemble, and SeismogramEnsemble.
For Ensembles the method is called recursively on each of the
members.</p>
<p>The method returns mspass_object with the sample data altered
by the operator defined by a particular instance, which is defined
exclusively by the target sample rate for the output.  All metadata
will be clone without checking.  If the metadata have attributes
linked to the sample interval the metadata of the result may not
match the data.</p>
<p>If the input is marked dead it will be returned immediately with
no change.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.resample.resample">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.resample.</span></span><span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mspass_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resampler</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verify_operators</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'resample'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/resample.html#resample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.resample.resample" title="Permalink to this definition"></a></dt>
<dd><p>Resample any valid data object to a common sample rate (sample interval).</p>
<p>This function is a wrapper that automates handling of resampling.
Its main use is in a dask/spark map operator where the input can
be a set of irregularly sampled data and the output is required to be
at a common sample rate (interval).   The problem has some complexity
because decimation is normally the preferred method of resampling
when possible due to speed and more predictable behavior.
The problem is that downsampling by decimation is only possible if
the output sampling interval is an integer multiple of the input
sample interval.   With modern seismology data that is usually
possible, but there are some common exceptions.  For example,
10 sps cannot be created from 25 sps by decimation.   The algorithm
tests the data sample rate and if decimation is possible it
applies a decimation operator passed as the argument “decimator”.
If not, it calls the operator “resampler” that is assumed to be
capable of handling any sample rate change.   The two operators
must have been constructed with the same output target sampling
frequency (interval).  Both must also be a subclass of BasicResampler
to match the api requirements.</p>
<p>The parameters object_history, alg_name, alg_id, dryrun, inplace_return,
and function_return_key are handled by the decorator called
mspass_func_wrapper used by this function.  See the docstring for
mspass_func_wrapper for the generic use of those parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mspass_object</strong> (<em>Must a TimeSeries</em><em>, </em><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><em>Seismogram</em></a><em>, </em><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeriesEnsemble" title="mspasspy.ccore.seismic.TimeSeriesEnsemble"><em>TimeSeriesEnsemble</em></a><em>,
or </em><em>SeismogramEnsemble object.</em>) – mspass datum to be resampled</p></li>
<li><p><strong>decimator</strong> (<em>Must be a subclass</em><em> of </em><a class="reference internal" href="#mspasspy.algorithms.resample.BasicResampler" title="mspasspy.algorithms.resample.BasicResampler"><em>BasicResampler</em></a>) – decimation operator.</p></li>
<li><p><strong>resampler</strong> (<em>Must be a subclass</em><em> of </em><a class="reference internal" href="#mspasspy.algorithms.resample.BasicResampler" title="mspasspy.algorithms.resample.BasicResampler"><em>BasicResampler</em></a>) – resampling operator</p></li>
<li><p><strong>verify_operators</strong> – boolean controlling whether safety checks
are applied to inputs.  When True (default) the contents of
decimator and resampler are verified as subclasses of BasicResampler
and the function tests if the target output sampling frequency (interval)
of both operators are the same.  The function will throw an exception if
any of the verify tests fail.   Standard practice should be to verify
the operators and valid before running a large workflow and running
production with this arg set False for efficiency.  That should
acceptable in any case I can conceive as once the operators are
defined in a parallel workflow they should be invariant for the
entire application in a map operator.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.signals">
<span id="signals"></span><h2>signals<a class="headerlink" href="#module-mspasspy.algorithms.signals" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.correlate">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">correlate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlate'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'naive'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#correlate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.correlate" title="Permalink to this definition"></a></dt>
<dd><p>Cross-correlation of two signals up to a specified maximal shift.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>) – first signal</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>) – second signal</p></li>
<li><p><strong>shift</strong> (<em>int</em>) – Number of samples to shift for cross correlation. The cross-correlation will consist of 2*shift+1 or
2*shift samples. The sample with zero shift will be in the middle.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper_multi</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>demean</strong> (<em>bool</em>) – Demean data beforehand.</p></li>
<li><p><strong>normalize</strong> – Method for normalization of cross-correlation. One of ‘naive’ or None (True and False are
supported for backwards compatibility). ‘naive’ normalizes by the overall standard deviation. None does not normalize.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Method to use to calculate the correlation. ‘direct’: The correlation is determined directly from
sums, the definition of correlation. ‘fft’ The Fast Fourier Transform is used to perform the correlation more
quickly. ‘auto’ Automatically chooses direct or Fourier method based on an estimate of which is faster.
(Only available for SciPy versions &gt;= 0.19. For older Scipy version method defaults to ‘fft’.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>cross-correlation function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.correlate_stream_template">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">correlate_stream_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlate_stream_template'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#correlate_stream_template"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.correlate_stream_template" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.correlate_template">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">correlate_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlate_template'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'valid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">demean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#correlate_template"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.correlate_template" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.correlation_detector">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">correlation_detector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">templates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'correlation_detector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_magnitudes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">details</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#correlation_detector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.correlation_detector" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.detrend">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">detrend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dtrend'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'simple'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#detrend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.detrend" title="Permalink to this definition"></a></dt>
<dd><p>This function removes a trend from the data, which is a mspasspy object. Note it is wrapped by mspass_func_wrapper,
so the processing history and error logs can be preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – input data, only mspasspy data objects are accepted, i.e. TimeSeries, Seismogram, Ensemble.</p></li>
<li><p><strong>type</strong> (<em>str</em>) – type of filter, ‘simple’, ‘linear’, ‘constant’, ‘polynomial’, ‘spline’. You can refer to
<cite>Obspy &lt;https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html&gt;</cite> for details.</p></li>
<li><p><strong>args</strong> – extra arguments</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper.</p></li>
<li><p><strong>options</strong> – extra kv options</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.filter">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'filter'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.filter" title="Permalink to this definition"></a></dt>
<dd><p>Applies a time invariant filter to a MsPASS data object.</p>
<p>This entry is a wrapper around the obspy filter function.  It accepts the
same arguments as the obspy function and runs the same implementation.
See their documentation for details, but note the idiosyncracy of
their API is inherited.  Because different types of filters are
enabled by the setting of the “type” argument, what kwarg values are
referenced depend upon the value of “type”.   In particular, note:</p>
<blockquote>
<div><ul class="simple">
<li><p>“bandpass” requires values for “freqmin” and “freqmax as corner frequenices</p></li>
<li><p>“lowpass” requires only a value for “freq” to define the one corner</p></li>
<li><p>“highpass” also requres only the value “freq” for the low corner</p></li>
</ul>
</div></blockquote>
<p>There are other options described in the obspy documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – input data, only mspasspy data objects are accepted, i.e. TimeSeries, Seismogram, Ensemble.</p></li>
<li><p><strong>type</strong> (<em>str</em>) – type of filter, ‘bandpass’, ‘bandstop’, ‘lowpass’, ‘highpass’, ‘lowpass_cheby_2’, ‘lowpass_fir’,
‘remez_fir’. You can refer to
<cite>Obspy &lt;https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.filter.html&gt;</cite> for details.</p></li>
<li><p><strong>args</strong> – extra arguments</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer to <code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper.</p></li>
<li><p><strong>options</strong> – extra kv options</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.interpolate">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'interpolate'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weighted_average_slopes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starttime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#interpolate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.interpolate" title="Permalink to this definition"></a></dt>
<dd><p>This function interpolates data, which is a mspasspy object. Note it is wrapped by mspass_func_wrapper,
so the processing history and error logs can be preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – input data, only mspasspy data objects are accepted, i.e. TimeSeries, Seismogram, Ensemble.</p></li>
<li><p><strong>sampling_rate</strong> – The new sampling rate in Hz.</p></li>
<li><p><strong>args</strong> – extra arguments.</p></li>
<li><p><strong>object_history</strong> – True to preserve the processing history. For details, refer to
<code class="xref py py-class docutils literal notranslate"><span class="pre">mspass_func_wrapper</span></code>.</p></li>
<li><p><strong>alg_name</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – alg_name is the name the func we are gonna save while preserving the history.</p></li>
<li><p><strong>alg_id</strong> (<a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bson.objectid.ObjectId</span></code></a>) – alg_id is a unique id to record the usage of func while preserving the history.</p></li>
<li><p><strong>dryrun</strong> – True for dry-run, which return “OK”. Used in the mspass_func_wrapper.</p></li>
<li><p><strong>inplace_return</strong> – True to return data in mspass_func_wrapper.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – One of “linear”, “nearest”, “zero”, “slinear”, “quadratic”, “cubic”, “lanczos”,
or “weighted_average_slopes”. You can refer to
<cite>Obspy &lt;https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.interpolate.html&gt;</cite> for details.</p></li>
<li><p><strong>starttime</strong> (<a class="reference external" href="https://docs.obspy.org/packages/autogen/obspy.core.utcdatetime.UTCDateTime.html#obspy.core.utcdatetime.UTCDateTime" title="(in ObsPy v1.4.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UTCDateTime</span></code></a> or int) – The start time (or timestamp) for the new interpolated stream.
Will be set to current start time of the data if not given.</p></li>
<li><p><strong>npts</strong> (<em>int</em>) – The new number of samples. Will be set to the best fitting number to retain the current end time
of the trace if not given.</p></li>
<li><p><strong>time_shift</strong> – Shift the trace by adding time_shift to the starttime. The time shift is always given in seconds.
A positive shift means the data is shifted towards the future, e.g. a positive time delta.
Note that this parameter solely affects the metadata. The actual interpolation of the underlaying data is governed
by the parameters sampling_rate, starttime and npts.</p></li>
<li><p><strong>kwargs</strong> – extra kv arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.templates_max_similarity">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">templates_max_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streams_templates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'templates_max_similarity'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#templates_max_similarity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.templates_max_similarity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.xcorr_3c">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">xcorr_3c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">st1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">st2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xcor_3c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">components</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_xcorr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#xcorr_3c"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.xcorr_3c" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.xcorr_max">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">xcorr_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xcor_max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#xcorr_max"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.xcorr_max" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.signals.xcorr_pick_correction">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.signals.</span></span><span class="sig-name descname"><span class="pre">xcorr_pick_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pick1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pick2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_before</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cc_maxlag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xcorr_pick_correction'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/signals.html#xcorr_pick_correction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.signals.xcorr_pick_correction" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-mspasspy.algorithms.snr">
<span id="snr"></span><h2>snr<a class="headerlink" href="#module-mspasspy.algorithms.snr" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.EstimateBandwidth">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">EstimateBandwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snr_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_smoother</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.algorithms.amplitudes.BandwidthData" title="mspasspy.ccore.algorithms.amplitudes.BandwidthData"><span class="pre">BandwidthData</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#EstimateBandwidth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.EstimateBandwidth" title="Permalink to this definition"></a></dt>
<dd><p>Estimates a set of signal bandwidth estimates returned in the the
class <cite>BandwidthData</cite>.  The algorithm is most appropriate for body
waves recorded at teleseimic distances from earthquake sources.
The reason is that the algorithm is most appropriate for signal
and noise spectra typical of that type of data.  In particular,
broadband noise is very colored by the microseisms.   Large enough
signals can exceed the microseism peak but smaller events will not.
The smallest events typically are only visible in the traditional
short-period band.   The most difficult are the ones that have
signals in both the short and long period band but have high
noise levels in the microseism band making a single bandwidth
the wrong model.  This function handles that by only returning the
band data for the section near the search start defined by the
“f0” argument.</p>
<p>The algorithm works by searching from a starting frequency defined
by the “f0” argument.  The basic idea is it hunts up and down the
frequency axis until it detects the band edge.   The “band edge”
detection is defined as the point where the signal-to-noise ratio
first falls below the value defined by the “snr_threshold” argument.
The algorithm has two variants of note:</p>
<ol class="arabic simple">
<li><p>If no point in the snr curve exceeds the valued defined by
“snr_threshold” the function returns immediately with all
attributes of the <cite>BandwidthData</cite> object set to 0.</p></li>
<li><p>If the snr value at f0 does not exceed the threshold it searches down
until it finds a value exceeding the threshold.  In that situation
it marks the first point found as the high frequency band
edge and continues hunt backward to attempt to define
the low frequency band edge.</p></li>
</ol>
<p>The “df_smoother” argument can be used to smooth the internally
generated signal-to-noise ratio vector.   It is particularly useful
for data with noise containing spectral lines that can create
incorrect bandwidth data.  It is rarely necessary if the
power spectra are computed with the multitaper method as that
method produces spectra that are inherently smooth at a specified
scale.  In that case if smoothing is desired we recommend the
smoothing width be of the form k*tbp*df where tbp is the time
bandwidth product, df is the Rayleigh bin size, and k is some
small multipler (note multitaper spectra a inherently smoothed
by 2*tbp*df).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.PowerSpectrum" title="mspasspy.ccore.seismic.PowerSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.PowerSpectrum</span></code></a>) – power spectrum computed from signal time window.</p></li>
<li><p><strong>N</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.PowerSpectrum" title="mspasspy.ccore.seismic.PowerSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.PowerSpectrum</span></code></a>) – power spectrum computed from noise time window
(Note S and N do not need to be on the same frequency
grid but the signal grid is used to compute the signal to
noise ratio curve)</p></li>
<li><p><strong>snr_threshold</strong> (<em>float</em><em> (</em><em>default 1.5</em><em>)
</em><em>grid but the signal grid is used to compute the signal to
spectrum within the range defined by this parameter.
i.e. the number</em><em> of </em><em>points in the smoother is
round</em><em>(</em><em>df_smoother/S.df</em><em>(</em><em>)</em><em>)</em>) – value of snr used to define the
band edges.   As noted above the algorithm searches from
the value f0 for the first points above and below that
frequency where the snr curve has a value less than or
equal to this value.</p></li>
<li><p><strong>f0</strong> (<em>float</em><em> (</em><em>default 1.0</em><em>)</em>) – frequency to start searching up and down
the frequency axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Returns an instance of the <cite>BandwidthData</cite> class.
<cite>BandwidthData</cite> has the following attributes that are
set by this function:</p>
<ul class="simple">
<li><p>”low_edge_f” low frequency corner of estimated bandwidth</p></li>
<li><p>”low_edge_snr” snr at low corner</p></li>
<li><p>”high_edge_f” high frequency corner of estimated bandwidth</p></li>
<li><p>”high_edge_snr” snr at high corner</p></li>
<li><p>”f_range” total frequency range of estimate (range of S)</p></li>
</ul>
<p>Note the low edge can be zero which must be handled
carefully if the output is used for designing a filter.
Further all values will be 0 if no points in the snr curve
exceed the defined threshold.</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.FD_snr_estimator">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">FD_snr_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_spectrum_engine=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_spectrum_engine=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">band_cutoff_snr=1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_detection_minimum_bandwidth=6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_low_zero_test=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tbp=4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntapers=6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0=1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poles=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc=95.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional_metrics=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_spectra=False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#FD_snr_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.FD_snr_estimator" title="Permalink to this definition"></a></dt>
<dd><p>Estimates one or more amplitude metrics of signal-to-noise from a TimeSeries object.
Results are returned as a set of key-value pairs in a python dict.</p>
<p>FD_snr_estimator first estimates bandwidth with the function in this
module called <cite>EstimateBandwidth</cite>.  See the docstring of that function
for how the bandwidth is estimated.  The metrics this function
computes all depend upon that bandwidth estimate.  The default return
of this function is the return of <cite>EstimateBandwidth</cite> translated to
keyp-value pairs.   Those are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>*low_f_band_edge* - lowest frequency exceeding threshold
*high_f_band_edge* - highest frequency exeeding threshold
*high_f_band_edge_snr* and *low_f_band_edge_snr* are the snr values
  at the band edges
*spectrum_frequency_range* - total frequency band for estimate
  (really just 0 to Nyquist).
*bandwidth* - bandwidth of estimate in dB.
  i.e. 20*log10(high_f_band_edge/low_f_band_edge)
*bandwidth_fraction* - bandwidth/spectrum_frequency_range
</pre></div>
</div>
<p>A set of optional metrics can be computed.  All optional metrics use
the bandwidth estimates in one way or another.   Optional metrics are
defined by the following keywords passed through a list (actually
any iterable container will work) of strings defining one or more
of the keywords. The metrics and a brief description of each follow:</p>
<p><em>snr_stats</em> computes what are commonly plotted in box plots for the
snr estimates within the estimated bandwidth:  minimum, maximum,
0.25 (1/4) point, 0.75 (3/4) point, and the median.   These are set
with following dict keys:   ‘snr_band_maximum’,’snr_band_minimum’,
‘snr_band_1/4’, ‘srn_band_3/4’, and ‘snr_band_median’ respectively.</p>
<p><em>filtered_envelope</em>, <em>filtered_L2</em>, <em>filtered_Linf</em>, <em>filtered_perc</em>, and <em>filtered_MAD</em>:
All of these optional metrics first copy the data_object and then
filter the copy with a Butterworth bandpass filter with the number of
poles specified by the npoles argument and corners at the estimated
band edge by the EstimateBandwidth function.  The algorithm automatically
handles the case of a zero low frequency edge.   That is, with large events
the low band edge can be computed as 0 frequency.   More commonly the band edge
is computed as one or two rayleigh bins above 0.  A bandpass filtered applied
with a corner too close to 0 can produced distorted (or null) results.
To prevent that the default behavior is to revert to a low pass filter
versus a bandpass filter when the estimated value of low_f_band_edge is small.
By default “small” is defined as &lt;= 2.0*tbp*df, where tbp is the
time bandwidth product for the multitaper spectral estimates (in optional
argument) and df is the frequency sampling interval of the spectrum computed from
the data in <cite>signal_window</cite>.  You can use a different recipe by passing
a value for the optional parameter “f_low_zero_test” which will replace
the computed value using the formula above for switching to a lowpass filter.
The optional metrics are time domain estimates computed from
the bandpass (lowpass) filtered data.  They are
actually computed from functions in this same module that can be
used independently and have their own docstring description. The
functions called have the following names in order of the keyword
list above:  <em>snr_envelope</em>, <em>snr_filtered_rms</em>, <em>snr_Linv</em>, and <em>snr_filtered_mad</em>.
When the computed they are set in the output dictionary with the
following (again in order) keys:  ‘snr_envelope’,’snr_filtered_rms’, ‘srn_Linf’,
and ‘snr_filtered_mad’.</p>
<p>It is important to note that all the metrics this function returns
are measures of amplitude NOT power.   You need to be particularly
aware of this if you unpickle the spectra created if you set
save_spectra true as those are power spectra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_object</strong> – TimeSeries object to be processed. For Seismogram
objects the assumption is algorithm would be used for a single
component (e.g longitudinal or vertical for a P phase)</p></li>
<li><p><strong>noise_window</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.algorithms.basic.TimeWindow" title="mspasspy.ccore.algorithms.basic.TimeWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.algorithms.basic.TimeWindow</span></code></a>
default -130 to -5 s.) – defines the time window to use for computing the
spectrum considered noise. The time span can be either relative or
UTC (absolute) time but we do not check for consistency.  This low
level function assumes they are consistent.  If not, the calculations
are nearly guaranteed to fail.  Type must be mspasspy.ccore.TimeWindow.</p></li>
<li><p><strong>signal_window</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.algorithms.basic.TimeWindow" title="mspasspy.ccore.algorithms.basic.TimeWindow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.algorithms.basic.TimeWindow</span></code></a>
default -5 to 120 s) – defines the time window to use that defines what
you consider “the signal”.  The time span can be either relative or
UTC (absolute) time but we do not check for consistency.  This low
level function assumes they are consistent.  If not, the calculations
are nearly guaranteed to fail.  Type must be mspasspy.ccore.TimeWindow.</p></li>
<li><p><strong>signal_spectrum_engine</strong> (None (default) or an instance of
<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.algorithms.deconvolution.MTPowerSpectrumEngine" title="mspasspy.ccore.algorithms.deconvolution.MTPowerSpectrumEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.algorithms.deconvolution.MTPowerSpectrumEngine</span></code></a>) – is the comparable MTPowerSpectralEngine
to use to compute the signal power spectrum.   Default is None with the
same caveat as above for the noise_spectrum_engine.</p></li>
<li><p><strong>band_cutoff_snr</strong> (<em>float</em>) – defines the signal-to-noise ratio floor
used in the search for band edges.  See description of the algorithm
above and in the user’s manual.  Default is 1.5</p></li>
<li><p><strong>signal_spectrum_engine</strong> – is the comparable MTPowerSpectralEngine
to use to compute the signal power spectrum.   Default is None with the
same caveat as above for the noise_spectrum_engine.</p></li>
<li><p><strong>band_cutoff_snr</strong> – defines the signal-to-noise ratio floor
used in the search for band edges.  See description of the algorithm
above and in the user’s manual.  Default is 2.0</p></li>
<li><p><strong>signal_detection_minimum_bandwidth</strong> (<em>float</em><em> (</em><em>default 6.0 dB</em><em>)</em>) – As noted above this
algorithm first tries to estimate the bandwidth of data where the
signal level exceeds the noise level defined by the parameter
band_cutoff_snr.  It then computes the bandwidth of the data in
dB computed as 20*log10(f_high/f_low).  For almost any application
if the working bandwidth falls below some threshold the data is
junk to all intends and purpose.  A factor more relevant to this
algorithm is that the “optional parameters”  will all be meaningless
and a waste of computational effort if the bandwidth is too small.
A particular extreme example is zero bandwidth that happens all the
time if no frequency band exceeds the band_cutoff_snr for a range
over that minimum defined by the time-bandwidth product.  The
default is 6.0. (One octave which is roughly the width of the traditional
short-period band) which allows optional metrics to be computed
but may be too small for some applications.  If your application
requires higher snr and wider bandwidth adjust this parameter
and/or band_cutoff_snr.</p></li>
<li><p><strong>f_low_zero_test</strong> (<em>float</em><em> (</em><em>default is None which causes the test to
revert to 2.0*tbp*df</em><em> (</em><em>see above</em><em>)</em><em>.</em>) – optional lower bound on frequency to use for
test to disable the low frequency corner.   (see above)</p></li>
<li><p><strong>tbp</strong> (<em>float</em><em> (</em><em>default 4.0</em><em>)</em>) – time-bandwidth product to use for computing the set of
Slepian functions used for the multitaper estimator.  This parameter is
used only if the noise_spectrum_engine or signal_spectrum_engine
arguments are set as None.</p></li>
<li><p><strong>ntapers</strong> (<em>integer</em><em> (</em><em>default 6</em><em>)</em>) – is the number of Slepian functions (tapers) to compute
for the multitaper estimators. Like tbp it is referenced only if
noise_spectrum_engine or signal_spectrum_engine are set to None.
Note the function will throw an exception if the ntaper parameter is
not consistent with the time-bandwidth product.</p></li>
<li><p><strong>f0</strong> (<em>float</em><em> (</em><em>default 1.0</em><em>)</em>) – frequency to use to start search for bandwidth up and down
the frequency axis (see above).</p></li>
<li><p><strong>npoles</strong> (<em>integer</em><em> (</em><em>default 3</em><em>)</em>) – defines number of poles to us for the Butterworth
bandpass or lowpass applied for the “filtered” metrics (see above).  Default is 3.</p></li>
<li><p><strong>perc</strong> (<em>float</em><em> (</em><em>default 95.0</em><em>)</em>) – used only if ‘filtered_perc’ is in the optional metrics list.
Specifies the perc parameter as used in seismic unix.  Uses the percentage
point specified of the sorted abs of all amplitudes.  (Not perc=50.0 is
identical to MAD)  Default is 95.0 which is 2 sigma for Gaussian noise.</p></li>
<li><p><strong>optional_metrics</strong> (<em>should be a list</em><em> of </em><em>strings matching the set</em><em> of
</em><em>required keywords.  Default is None which means none</em><em> of </em><em>the optional
metrics will be computed.</em>) – is an iterable container containing one or more
of the optional snr metrics discussed above. Typos in names will create
log messages but will not cause the function to abort.</p></li>
<li><p><strong>save_spectra</strong> – If set True (default is False) the function
will pickle the computed noise and signal spectra and save the
strings created along with a set of related metadata defining the
time range to the output python dict (these will be saved in MongoDB
when db is defined - see below).   This option should ONLY be used
for spot checking, discovery of why an snr metric has unexpected
results using graphics, or a research topic where the spectra would
be of interest.  It is a very bad idea to turn this option on if
you are processing a large quantity of data and saving the results
to MongoDB as it may bloat the database.  Consider a
different strategy if that essential for your work.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>python tuple with two components.  0 is a python dict with
the computed metrics associated with keys defined above.  1 is a
mspass.ccore.ErrorLogger object. Any errors in computng any of the
metrics will be posted to this logger.  Users should then test this
object using it’s size() method and if it the log is not empty (size &gt;0)
the caller should handle that condition.   For normal use that means
pushing any messages the log contains to the original data object’s
error log.  Component 0 will also be empty with no log entry if
the estimated bandwidth falls below the threshold defined by the
parameter signal_detection_minimum_bandwidth.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.arrival_snr">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">arrival_snr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data_object,</span> <span class="pre">*args,</span> <span class="pre">noise_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;,</span> <span class="pre">noise_spectrum_engine=None,</span> <span class="pre">signal_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;,</span> <span class="pre">signal_spectrum_engine=None,</span> <span class="pre">band_cutoff_snr=2.0,</span> <span class="pre">signal_detection_minimum_bandwidth=6.0,</span> <span class="pre">tbp=4.0,</span> <span class="pre">ntapers=6,</span> <span class="pre">f_low_zero_test=None,</span> <span class="pre">f0=1.0,</span> <span class="pre">poles=3,</span> <span class="pre">perc=95.0,</span> <span class="pre">save_spectra=False,</span> <span class="pre">phase_name='P',</span> <span class="pre">arrival_time_key='Ptime',</span> <span class="pre">metadata_output_key='Parrival',</span> <span class="pre">kill_null_signals=True,</span> <span class="pre">optional_metrics=['snr_stats',</span> <span class="pre">'filtered_envelope',</span> <span class="pre">'filtered_L2',</span> <span class="pre">'filtered_Linf',</span> <span class="pre">'filtered_MAD',</span> <span class="pre">'filtered_perc'],</span> <span class="pre">handles_ensembles=False,</span> <span class="pre">checks_arg0_type=True,</span> <span class="pre">handles_dead_data=True,</span> <span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#arrival_snr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.arrival_snr" title="Permalink to this definition"></a></dt>
<dd><p>Specialization of FD_snr_estimator.   A common situation where snr
data is a critical thing to estimate is data windowed around a given
seismic phase.   FD_snr_estimator is a bit more generic.  This function
removes some of the options from the more generic function and
has a frozen structure appropriate for measuring snr of a particular phase.
In particular it always stores the results as a subdocument (python dict)
keyed by the name defined in the metadata_output_key argument.
This function has a close sibling called “broadband_snr_QC” that
has similar behavior but add some additional functionality.   The
most significant limitation of this function relative to broadband_snr_QC
is that this function ONLY accepts TimeSeries data as input.</p>
<p>This function is most appropriate
for QC done within a workflow where the model is to process a large
data set and winnow it down to separate the wheat from the chaff, to
use a cliche consistent with “winnow”.   In that situation the normal
use would be to run this function with a map operator on atomic data
and follow it with a call to filter to remove dead data and/or filter
with tests on the computed metrics.  See User’s Manual for guidance on
this topic.  Because that is the expected normal use of this function
the kill_null_signals boolean defaults to True.</p>
<p>To be more robust the function tries to handle a common error.  That is,
if the input data has a UTC time standard then the noise and signal
windows would need to be shifted to some reference time to make any sense.
Consequently, this algorithm silently handles that situation automatically
with a simple test.  If the data are relative time no test of the
time window range is made.  If the data are UTC, however, it tests if
the signal time window is inside the data range.  If not, it shifts the
time windows by a time it tries to pull from the input with the key
defined by “arrival_time_key”.  If that attribute is not defined a
message is posted to elog of the input datum and it is returned with
no other change.   (i.e. the attribute normally output with the tag
defined by metadata_output_key will not exist in the output).
Large data workflows need to handle this condition,.</p>
<p>Dead inputs are handled the standard way - returned immediately with no change.</p>
<p>Most parameters for this function are described in detail in the
docstring for FD_snr_estimator.  The user is referred there to
see the usage.   The following are added for this specialization:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phase_name</strong> – Name tag for the seismic phase being analyzed.
This string is saved to the output subdocument with the key “phase”.
The default is “P”</p></li>
<li><p><strong>arrival_time_key</strong> – key (string) used to fetch an arrival time
if the data are in UTC and the time window received does not overlap
the data range (see above)</p></li>
<li><p><strong>kill_null_signals</strong> – boolean controlling how null snr estimator
returns are handled.  When True (default) if FD_snr_estimator returns a null
result (no apparent signal) that input datum is killed before being
returned.  In that situation no snr metrics will be in the output because
null means FD_snr_estimator couldn’t detect a signal and the algorithm
failed.   When False the datum is returned silently but
will have no snr data defined in a dict stored with the key
metadata_output_key (i.e. that attribute will be undefined in output)</p></li>
<li><p><strong>metadata_output_key</strong> – is a string used as a key under which the
subdocument (python dict) created internally is stored.  Default is
“Parrival”.   The idea is if multiple phases are being analyzed
each phase should have a different key set by this argument
(e.g. if PP were also being analyzed in the same workflow you
might use a key like “PParrival”).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a copy of data_object with the the results stored under
the key defined by the metadata_output_key argument.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.broadband_snr_QC">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">broadband_snr_QC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data_object,</span> <span class="pre">*args,</span> <span class="pre">component=2,</span> <span class="pre">noise_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;,</span> <span class="pre">noise_spectrum_engine=None,</span> <span class="pre">signal_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;,</span> <span class="pre">signal_spectrum_engine=None,</span> <span class="pre">band_cutoff_snr=1.5,</span> <span class="pre">signal_detection_minimum_bandwidth=6.0,</span> <span class="pre">f_low_zero_test=None,</span> <span class="pre">tbp=4.0,</span> <span class="pre">ntapers=6,</span> <span class="pre">f0=1.0,</span> <span class="pre">kill_null_signals=True,</span> <span class="pre">poles=3,</span> <span class="pre">perc=95.0,</span> <span class="pre">phase_name='P',</span> <span class="pre">metadata_output_key='Parrival',</span> <span class="pre">optional_metrics=['snr_stats',</span> <span class="pre">'filtered_envelope',</span> <span class="pre">'filtered_L2',</span> <span class="pre">'filtered_Linf',</span> <span class="pre">'filtered_MAD',</span> <span class="pre">'filtered_perc'],</span> <span class="pre">save_spectra=False,</span> <span class="pre">use_measured_arrival_time=False,</span> <span class="pre">measured_arrival_time_key='Ptime',</span> <span class="pre">taup_model=None,</span> <span class="pre">source_collection='source',</span> <span class="pre">receiver_collection=None,</span> <span class="pre">handles_ensembles=False,</span> <span class="pre">checks_arg0_type=True,</span> <span class="pre">handles_dead_data=True,</span> <span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#broadband_snr_QC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.broadband_snr_QC" title="Permalink to this definition"></a></dt>
<dd><p>Compute a series of metrics that can be used for quality control
filtering of seismic phase data.</p>
<p>This function is intended as a workhorse to be used for low-level,
automated QC of broadband data when the the data set is defined
by signals linked to a timeable seismic phase.   It can be
thought of as a version of a related function called
“arrival_snr” with some additional features.  See the docstring
for that function for what those base features are.   Features this
function adds not found in arrival_snr are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>This function allows Seismogram inputs.  Only TimeSeries
data are handled by arrival_snr.</p></li>
<li><p>This function provides an option to compute arrival times
from source coordinates, receiver coordinates, and a handle
to an obspy tau-p calculator.</p></li>
</ol>
</div></blockquote>
<p>Otherwise it behaves the same.  Note both functions may or may not
choose to interact with the function save_snr_arrival.   If you want to
save the computed metrics into a form more easily fetched
your workflow should extract the contents of the python dictionary
stored under the metadata_output_key tag and save the result to
MongoDB with the save_snr_arrival function.  That option is most
useful for test runs on a more limited data set to sort out
values of the computed metrics that are appropriate for a secondary
winnowing of the your data.   See User’s Manual for more on
this concept.</p>
<p>The input of arg0 (data_object) can be either a TimeSeries or
a Seismogram object.  If a Seismogram object is passed the “component”
argument is used to extract the specified single channel from the Seismogram
object and that component is used for processing.  That is necessary
because all the algorithms used are single channel algorithms.  To
use this function on all components use a loop over components BUT
make sure you use a unique value for the argument “metadata_output_key” for
each component.  Note this will also produce multiple documents per
input datum.</p>
<p>The type of the data_object also has a more subtle implication the
user must be aware of.  That is, in the MsPASS schema we store receiver coordinates
in one of two different collections:  “channel” for TimeSeries data and
“site” for Seismogram data.  When such data are loaded the generic keys
like lat are always converted to names like channel_lat or site_lat
for TimeSeries and Seismogram data respectively.   This function uses
the data type to set that naming.  i.e. if the input is TimeSeries
it tries to fetch the latitude data as channel_lat while if it the input
is a Seismogram it tries to fetch site_lat.   That is true of all coordinate
data loaded by normalization from a source and receiver collection.</p>
<p>Most of the arguments to this function are passed directly to
<cite>FD_snr_estimator</cite>.   See the docstring of that function for reference.
The following are additional parameters specific to this function:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_object</strong> – An atomic MsPASS data object to which the
algorithms requested should be applied.   Currently that means a
TimeSeries or Seismogram object.   Any other input will result
in a TypeError exception.  As noted above for Seismogram input the
component argument defines which data component is to be used for the
snr computations.</p></li>
<li><p><strong>component</strong> – integer (0, 1, or 2) defining which component of a
Seismogram object to use to compute the requested snr metrics.   This
parameter is ignored if the input is a TimeSeries.</p></li>
<li><p><strong>metadata_output_key</strong> – string defining the key where the results
are to be posted to the returned data_object.   The results are always
posted to a python dictionary and then posted to the returned
data_object with this key.   Default is “Parrival”</p></li>
<li><p><strong>use_measured_arrival_time</strong> – boolean defining the method used to
define the time reference for windowing used for snr calculations.
When True the function will attempt to fetch a phase arrival time with
the key defined by the “measured_arrival_time_key” argument.  In that
mode if the fetch fails the data_object will be killed and an error
posted to elog.   That somewhat brutal choice was intentional as the
expectation is if you want to use measured arrival times you don’t
want data where there are no picks.   The default is True to make
the defaults consistent.  The reason is that the tau-p calculator
handle is passed to the function when using model-based travel times.
There is no way to default that so it defaults to None.</p></li>
<li><p><strong>measured_arrival_time_key</strong> – is the key used to fetch a
measured arrival time.   This parameter is ignored if use_measured_arrival_time
is False.</p></li>
<li><p><strong>taup_model</strong> – when use_measured_arrival_time is False this argument
is required.  It defaults as None because there is no way the author
knows to initialize it to anything valid.  If set it MUST be an instance
of the obspy class TauPyModel
(<a class="reference external" href="https://docs.obspy.org/packages/autogen/obspy.taup.tau.TauPyModel.html#obspy.taup.tau.TauPyModel">https://docs.obspy.org/packages/autogen/obspy.taup.tau.TauPyModel.html#obspy.taup.tau.TauPyModel</a>)
Mistakes in use of this argument can cause a MsPASSError exception to
be thrown (not logged thrown as a fatal error) in one of two ways:
(1)  If use_measured_arrival_time is False this argument must be defined,
and (2) if it is defined it MUST be an instance of TauPyModel.</p></li>
<li><p><strong>source_collection</strong> – normalization collection for source data.
The default is the MsPASS name “source” which means the function will
try to load the source hypocenter coordinates (when required) as
source_lat, source_lon, source_depth, and source_time from the input
data_object.  The id of that document is posted to the output dictionary
stored under metadata_output_key.</p></li>
<li><p><strong>receiver_collection</strong> – when set this name will override the
automatic setting of the expected normalization collection naming
for receiver functions (see above).  The default is None which causes
the automatic switching to be involked.  If it is any other string
the automatic naming will be overridden.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the data_object modified by insertion of the snr QC data
in the object’s Metadata under the key defined by metadata_output_key.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.filter_by_snr_bandwidth">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">filter_by_snr_bandwidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qcdoc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdoc_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Parrival'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass_low_f_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#filter_by_snr_bandwidth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.filter_by_snr_bandwidth" title="Permalink to this definition"></a></dt>
<dd><p>Filter function to automatically handle data processed with arrival_snr
or broadband_snr_QC.</p>
<p>The two MsPASS functions <cite>arrival_snr</cite> and <cite>broadband_snr_QC</cite> are
front ends to a lower level function called <cite>FD_broadband_snr</cite>.
That function is designed to estimate the bandwidth of a signal
and compute a suite of snr metrics that can be used to winnow
data for further processing.   One often wants to then filter the
data so processed into the frequency band the algorithm determines.
This function does that automaticallty for any atomic datum
previously processed with <cite>arrival_snr</cite> or <cite>broadband_snr_QC</cite>.</p>
<p>An important complication this function handles is that for large
earthquakes the low frequency band edge can be 0 or close
(meaning within a few Rayleigh bins) of 0.   In that situation
a bandpass filter with the corner near 0 is unstable and the
filter operator would fail if you tried to use that corner.
This function handles that all automatically if you use the
defaults for <cite>arrival_snr</cite> or <cite>broadband_snr_QC</cite>.  If you
change any of the defaults you may need to change one of the kwargs
for this function.   See descriptions below for guidance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeries</span></code></a> or
<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.Seismogram</span></code></a>) – atomic MsPASS data object to be filtered.</p></li>
<li><p><strong>qcdoc</strong> – use attributes stored in a dictionary.
Use this approach if you want to impose attributes externally.
If defined the contents of this dictionary will be used.  If it
isn’t define the function will use subdoc_key to try to fetch
the same data. Using a dictionary passed via this argument
is a way to filter an ensemble in a common band for all members.</p></li>
<li><p><strong>subdoc_key</strong> (<em>string</em><em> (</em><em>default &quot;Parrival&quot;</em><em>)</em>) – subdocument Metadata key to use to fetch data posted
by <cite>arrival_snr</cite> or <cite>broadband_snr_QC</cite>.  Both by default post the
computed attributes to a subdocument (python dictionary) that can
be fetched from the Metadata of d with a particular key.  This
argument is the key that should be used to fetch that data.  The
default is the default for <cite>arrival_snr</cite> and <cite>broadband_snr_QC</cite>.
Note if no data is found for this key the function attempts to
extract the required attributes from the top level of the
Metadata container of d.  If that fails the function will kill
the datum and post an elog message.</p></li>
<li><p><strong>bandpass_low_f_limit</strong> (<em>float</em><em> (</em><em>default 0.02 = 1/50 s</em><em>)</em>) – </p></li>
<li><p><strong>npoles</strong> (<em>integer</em><em> (</em><em>default 4</em><em>)</em>) – number of poles to use for Butterworth filter function
if not defined in the datum’s Metadata.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.save_snr_arrival">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">save_snr_arrival</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">db</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc_to_save</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wfid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wf_collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'wf_Seismogram'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_collection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arrival'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdocument_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_wfid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://pymongo.readthedocs.io/en/stable/api/bson/objectid.html#bson.objectid.ObjectId" title="(in PyMongo v4.13.0)"><span class="pre">ObjectId</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#save_snr_arrival"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.save_snr_arrival" title="Permalink to this definition"></a></dt>
<dd><p>This function is a companion to broadband_snr_QC.   It handles the
situation where the workflow aims to post calculated snr metrics to
an output database (normally in the “arrival” collection but optionally
to a parent waveform collection.  ).   The alternative models as
noted in the User’s Manual is to use the kill option to broadband_snr_QC
followed by a call to the filter method of bag/rdd to remove the
deadwood and reduce the size of data passed downstream in large
parallel workflow.   That case is better handled by using
broadband_snr_QC directly.</p>
<p>How the data are saved is controlled by four parameters:   save_collection,
use_update, update_id and subdocument_key.   They interact in a way
that is best summarized as a set of cases that procuce behavior
you may want:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If save_collection is not the parent waveform collection,
behavior is driven by use_update combined with subdocument_key.
When use_update is False (default) the contents of doc_to_save
will be used to define a new document in save_collection
with the MongoDB insert_one method.</p></li>
<li><p>When use_update is True the update_id will be assumed to be
defined and point be the ObjectId of an existing document
in save_collection.   Specifically that id will be used as
the query clause for a call the insert_one method.   This
combination is useful if a workflow is being driven by
arrival data stored in save_collection created, for example,
for a css3.0 a event-&gt;origin-&gt;assoc-&gt;arrival catalog of
arrival picks.   A variant of this mode will occur if the
argument subdocument_key is defined (default is None).  If
you define subgdocument_key the contents of doc_to_save will
be stored as a subdocument in save_collection accessible
with the key defined by subdocument_key.</p></li>
<li><p>If save_collection is the same as the parent waveform collection
(defined via the input parameter wf_collection) the
value of use_update will be ignored and only an update will
be attempted.  The reason is that if one tried to save the
contents of doc_to_save to a waveform collection would corrupt
the database by have a bunch of documents that that could not
be used to construct a valid data object (the normal use for
one of the wf collections).</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>db</strong> – MongoDB database handle to use for transactions that
are the focus of this algorithm.</p></li>
<li><p><strong>doc_to_save</strong> – python dictionary containing data to be saved.
Where and now this is saved is controlled by save_collection,
use_update, and subdocument_key as described above.</p></li>
<li><p><strong>wfid</strong> – waveform document id of the parent datum.   It is
assumed to be an ObjectId of linking the data in doc_to_save to
the parent.   It is ALWAYS saved in the output with the key “wfid”.</p></li>
<li><p><strong>wf_collection</strong> – string defining the collection from which the
datum from which the data stored in doc_to_save are associated.   wfid
is assumed define a valid document in wf_collection.   Default is
“wf_Seismogram”.</p></li>
<li><p><strong>save_collection</strong> – string defining the collection name to which
doc_to_save should be pushed.   See above for how this name interacts
with other parameters.</p></li>
<li><p><strong>subdocument_key</strong> – Optional key for saving doc_to_save as a
a subdocument in the save_collection.   Default is None which means
the contents of doc_to_save will be saved (or update) as is.
For saves to (default) arrival collection this parameter should
normally be left None, but is allowed.   If save_collection is the
parent waveform collection setting this to some sensible key is
recommended to avoid possible name collisions with waveform
Metadata key-value pairs.    Default is None which means no
subdocuments are created.</p></li>
<li><p><strong>use_update</strong> – boolean controlling whether or not to use
updates or inserts for the contents of doc_to_save.  See above for
a description of how this interacts with other arguments to this
function.  Default is False.</p></li>
<li><p><strong>update_id</strong> – ObjectId of target document when running in update
mode.  When save_collection is the same as wf_collection this parameter
is ignored and the required id passed as wfid will be used for the
update key matching.   Also ignored with the default behavior if
inserting doc_to_save as a new document.  Required only if running
with a different collection and updating is desired.  The type example
noted above would be updates to existing arrival informations
created from a css3.0 database.</p></li>
<li><p><strong>validate_wfid</strong> – When set True the id defined by the
required argument wfid will be validated by querying wf_collection.
In this mode if wfid is not found the function will silently return None.
Callers using this mode should handle that condition.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ObjectId of saved record.  None if something went wrong
and nothing was saved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.snr">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">snr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_window=&lt;mspasspy.ccore.algorithms.basic.TimeWindow</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_metric='mad'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_metric='mad'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc=95.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#snr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.snr" title="Permalink to this definition"></a></dt>
<dd><p>Compute time-domain based signal-to-noise ratio with a specified metric.</p>
<p>Signal-to-noise ratio is a fundamental measurement in all forms of
seismic data processing.   There is, however, not a single unified metric
that ideal for all types of signals one may want to analyze.  One class
of metrics used time-domain metrics to use some measure of amplitude in
a signal and noise window cut from a single waveform segment.  A type
example is snr of some particular “seismic phase” (P, S, PP, ScS, etc)
relative to some measure of background noise.  e.g. for P phases it is
nearly universal to try to estimate snr from some window defined by the
arrival time of P and a noise window before the time P arrives (pre-event noise).</p>
<p>This function provides a generic api to measure a large range of metrics
using one of four choices for measuring the norm of the data in the
signal and noise windows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>rms - L2 norm</p></li>
<li><p>mad - median absolute difference, which is essentially the median amplitude in this context</p></li>
<li><p>perc - percentage norm ala seismic unix.  perc is defined at as the
amplitude level were perc percentage of the data have an amplitude
smaller than this value.  It is computed by ranking (sorting) the
data, computing the count of that perctage relative to the number of
amplitude samples, and returning the amplitude of the nearest value
to that position in the ranked data.</p></li>
<li><p>peak - is the peak value which in linear algebra is the L infinity norm</p></li>
</ol>
</div></blockquote>
<p>Note the user can specify a different norm for the signal and noise windows.
The perc metric requires specifying what percentage level to use.  It is
important to recognize that ALL of these metrics are scaled to amplitude
not power (amplitude squared).</p>
<p>This function will throw a MsPASSError exception if the window parameters
do not define a time period inside the range of the data_object. You will
need a custom function if the model of windows insider a larger waveform
segment does not match your data.</p>
<p>There is one final detail about an snr calculation that we handle carefully.
With simulation data it is very common to have error free simulations where
the “noise” window one would use with real data is all zeros.  An snr calculated
with this function in that situation would either return inf or NaN depending
on some picky details.  Neither is good as either can cause downstream
problems.  For that reason we trap any condition where the noise amplitude
measure is computed as zero.  If the signal amplitude is also zero we return
a -1.0.  Otherwise we return a large, constant, positive number.  Neither
condition will cause an exception to be thrown as that condition is considered
somewhat to be anticipated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_object</strong> – MsPASS atomic data object (TimeSeries or Seismogram)
to use for computing the snr.  Note that for Seismogram objects the
metrix always use L2 measures of amplitude of each sample (i.e. vector amplitudes)
If snr for components of a Seismogram are desired use ExtractComponent and
apply this function to each component separately.</p></li>
<li><p><strong>noise_window</strong> – TimeWindow objects defining the time range to extract
from data_object to define the part of the signal considered noise.
Times can be absolute or relative.  Default the range -5 to 120 which
is makes sense only as time relative to some phase arrival time.</p></li>
<li><p><strong>signal_window</strong> – TimeWindow object defining the time range to
extract from data_object to define the part of the signal defines as
signal to use for the required amplitude measure.  Default of -130 to
-5 is consistent with the default noise window (in terms of length) and
is assumes a time relative to a phase arrival time.  For absolute times
each call to this function may need its own time window.</p></li>
<li><p><strong>noise_metric</strong> – string defining one of the four metrics defined above
(‘mad’,’peak’,’perc’ or ‘rms’) to use for noise window measurement.</p></li>
<li><p><strong>signal_metric</strong> – string defining one of the four metrics defined above
(‘mad’,’peak’,’perc’ or ‘rms’) to use for signal window measurement.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>estimated signal-to-noise ratio as a single float.  Note the
special returns noted above for any situation where the noise window
amplitude is 0</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.snr.visualize_qcdata">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.snr.</span></span><span class="sig-name descname"><span class="pre">visualize_qcdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qc_subdoc_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Parrival'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/snr.html#visualize_qcdata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.snr.visualize_qcdata" title="Permalink to this definition"></a></dt>
<dd><p>Creates a set of plots to visualize qc results computed from
spectral estimates.  Requires the input datum d to have
the spectra stored in metadata as pickled serialization of
spectra used for the estimators.  That requires the data to
have been run with the option “save_spectra=True” in on
of the QC function that use FD_snr_estimator.  The function
with throw a MsPASSError exception if that metadata is missing.</p>
<p>This function generates graphics and must not be used in
a large data processing job.   It is for exploratory work only
for use on a small subset of data.   Note “exploratory” also
implies it is not as robust as a processing function and
may fail in ways that require debugging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeries</span></code></a> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">mapsspy.ccore.seismic.Seismogram</span></code>.) – Datum to display</p></li>
<li><p><strong>component</strong> (<em>integer</em>) – component to display if input is a
<cite>Seismogram</cite> object.  Ignore if input is a <cite>TimeSeries</cite>.</p></li>
<li><p><strong>qc_subdoc_key</strong> (string or None.  Default “Parrival”
is default of <cite>broadband_arrival_QC</cite>.) – key used to fetch the subdocument
from d normally used to store the output from
<cite>broadband_snr_QC</cite>.  If set to None will attempt
to fetch required attributes from Metdata container
of d.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-mspasspy.algorithms.window">
<span id="window"></span><h2>window<a class="headerlink" href="#module-mspasspy.algorithms.window" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.TopMute">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">TopMute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cosine'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#TopMute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.TopMute" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A top mute is a form of taper applied to the “front” of a signal.
Front in standard jargon means that with the time axis running from
left to right (normal unless your native language is Arabic) the time
period on the left side of a plot.   Data tagged at times less than what we
call the zero time here are always zeroed.  The mute defines a ramp function
running from the zero time to the “one” time.  In the ramp zone the
ramp function multiplies the sample data so it is a form of “taper” as
used in Fourier analysis.  This class should normally only be used on data with the time
reference type set Relative.  It can be applied to UTC time standard data but
with such data one of these objects would often need to be created for
each atomic data object, which would be horribly inefficient.  In most
cases conversion to relative time is an essential step before using
this algorithm.</p>
<p>This implementation uses an “apply” method for processing data.
That means for a parallel construct instead of the symbol for a function
you use the apply method as a function call.  (e.g. if tm is an is an
instance of this class and “d” is a TimeSeries or Seismogram object to be
muted the function call that applies the mute would be ts.apply(d))</p>
<dl class="py method">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.TopMute.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#TopMute.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.TopMute.apply" title="Permalink to this definition"></a></dt>
<dd><p>Use thie method to apply the defined top mute to one of the MsPASS
atomic data objects. The method does a sanity check on the input
data range.  If the starttime of the data is greater than t0 for
the mute the datum is killed and an error posted to elog.  The
reason is in that situation the data would be completely zeroed
anyway and it is better to define it dead and leave an error message
than to completely null data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>d</strong> – input atomic MsPASS data object (TimeSeries or Seismogram)</p>
</dd>
<dt class="field-even">Object_history<span class="colon">:</span></dt>
<dd class="field-even"><p>It set true the function will add define this
step as an map operation to preserve object level history.
(default is False)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.WindowData">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">WindowData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mspass_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_segment_handling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_recoverable_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retain_dead_members</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WindowData'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#WindowData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.WindowData" title="Permalink to this definition"></a></dt>
<dd><p>Apply a window operation to cut out data within a specified time range
to any MsPASS seismic data object.</p>
<p>Cutting a smaller waveform segment from a larger waveform segment
is a very common seismic data processing task.  Handling that low
level operation needs to be done efficiently but with a reasonable
number of options.   This function is very fast if the inputs
match the expected model where the requested time segment is
inside the range of the datum passed via arg0.   In that mode the
function is a thin wrapper on a C++ function that does most of
the work.   When the window is inconsistent with the data,
which is defined here as a “short segment”, more overhead
is involved if you want to recover something.   To be specific
a “short segment” means the requested time span for a the
window operation form win_start to win_end is not completely
inside (inclusive of the endpoints) the range of the data.</p>
<p>Handling of “short segments” has these elements:</p>
<ol class="arabic">
<li><p>If the window range is completely outside the range of
the data the result is always killed and returned
as a dead datum with no sample data. (d.npts=0)</p></li>
<li><p>Behavior if there is the window range overlaps but
has boundaries outside the data range depends on the setting
of the argument <cite>short_segment_handling</cite> and the
boolean argument <cite>log_recoverable_errors</cite>.
If <cite>log_recoverable_errors</cite> is set True (default) and
the result is returned live (i.e. the error was recoverable
but the data are flawed) a complaint message describing
what was done will be posted to the elog container
of the return.   If False recoveries will be done
silently.   That can be useful in some algorithms
(e.g. cross-correlation) where partial segments can be
handled.  What defines possible recovery is set by
the <cite>short_segment_handling</cite> string.  It must be
one of only three possible values or the function
will abort with a ValueError exception:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<dl class="simple">
<dt>“kill” - (default) does not recovery attempt and will</dt><dd><p>kill any data with time inconsistencies.</p>
</dd>
<dt>“truncate” - this truncates to the output to the</dt><dd><p>time range max(d.t0,win.starttime) to
min(d.endtime(),win.endtime).</p>
</dd>
<dt>“pad” - will cause the function to have data in</dt><dd><p>the span define dby win_start to win_end but
the sections where the data are undefined will
be set to zeros.</p>
</dd>
</dl>
</li>
</ol>
<p>This function handles input that is any valid MsPASS data
object.  For atomic data it is a very thin wrapper for the
related function <cite>WindowDataAtomic</cite>.   For atomic data this
is nothing more than a convenience function that allows you
to omit the “Atomic” qualifier.  For ensemble data
this function is more-or-less a loop over all ensemble
members running <cite>WindowDataAtomic</cite> on each member datum.
In all cases the return is the same type as the input but
either shortened to the specified range or killed.
A special case is ensembles where only some members
may be killed.</p>
<p>A special option for ensembles only can be triggered by
setting the optional argument <cite>overwrite_members</cite> to True.
Default behavior returns an independent ensemble created
from the input cut to the requested window interval.
When <cite>overwrite_members</cite> is set True the windowing of the
members will be done in place ovewriting the original
ensemble contents.  i.e. in tha output is a reference to
the same object as the input.  The primary use of the
<cite>overwrite_members == False</cite> option is for use in map
operators on large ensembles as it can significantly
reduce the memory footprint.</p>
<p>Note the description of subsample time handling in the
related docstring for <cite>WindowDataAtomic</cite>.   For ensembles
each member output preserves subsample timing.</p>
<p>Finally, how the function handles data marked dead is     important.  For atomic data the is no complexity.
dead is dead and the function just immediately returns
a reference to the input.  For ensembles some members
can be dead or the entire ensemble can be marked dead.
If the ensemble is marked dead the function immediately
returns a reference to the input.  If any members are
dead the result will depend on the boolean argument
“retain_data_members”.  When True (the default) dead
members will be copied verbatim to the output.
If False the dead members will be SILENTLY deleted.
The False option is only recommended if the windowing is
internal to a function and the windowed output will be
discarded during processing.  Otherwise the error log of why
data were killed will be lost.   If you need to save
memory by clearing dead bodies use the <cite>Undertaker</cite>
class to bury the dead and retain the error log data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – is the input data.  d must be either a
<a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.Seismogram</span></code></a>
object or the function will log an error to d and return a None.</p></li>
<li><p><strong>twin_start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – defines the start of timeWindow to be cut</p></li>
<li><p><strong>twin_end</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – defines the end of timeWindow to be cut</p></li>
<li><p><strong>t0shift</strong> (<em>real number</em><em> (</em><em>float</em><em>) or </em><em>a string that defines a
Metadata container key.</em>) – is an optional time shift to apply to the time window.
This parameter is convenient to avoid conversions to relative time.
A typical example would be to set t0shift to an arrival time and let
the window define time relative to that arrival time.  Default is None
which cause the function to assume twin is to be used directly.
It can be specified one of two ways:  (1) as a number where it
is assumed to be a time shift to apply in seconds, or (2) as a
a string.  In the later case the string is assumed to be a valid
key for fetching a time from a datum’s Metadata container.
Note the name t0shift is a bit inconsistent with this usage but
was retained as the original api did not have the string
option.</p></li>
<li><p><strong>short_segment_handling</strong> – <p>Defines method for handling data where
the requested interval is shorter than the requested window but does
have some overlap. <cite>segment_handling_methods</cite> must be one of the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>`kill` - in this mode any issues cause the return to be marked dead
         (this is the default)
&#39;pad&#39; -  in this mode return will have short segments will be padded
         with zeros to define data of the required length.
&#39;truncate&#39; - in this mode short segments will be truncated on left
            and/or right to match actual data range.
</pre></div>
</div>
<p>Note that if the input time range does not overlap the requested
interval “kiLl” is always the behavior as by definition the result
is null.</p>
</p></li>
<li><p><strong>log_recoverable_errors</strong> – When True (default) any recoverable
windowing error (meaning at least a partial overlap in time range)
will cause a log message to be posted to the elog container of the
output.  When False recovery will be done silently.  Note when
<cite>short_segment_handling</cite> is set to “kill” logging is not optional and
kill will always create an error log entry.</p></li>
<li><p><strong>overwrite_members</strong> (<em>boolean</em>) – controls handling of the member vector of
ensembles as described above.  When True the member atomic data will
be overwritten by the windowed version and the ensmble returned will
be a reference to the same container as the input.  When False
(the default) a new container is created and returned.  Note in that
mode dead data are copied to the same slot as the input unaltered.
This argument will be silently ignored if the input is an atomic
MsPASS seismic object.</p></li>
<li><p><strong>retain_dead_members</strong> (<em>boolean</em>) – Controls how dead data are handled with
ensembles.  When True (default) dead ensemble members are copied verbatim
to the output.  When False they are silently deleted. (see above for
a more complete description).  This argument is ignored for Atomic data.</p></li>
<li><p><strong>object_history</strong> – boolean to enable or disable saving object
level history.  Default is False.  Note this functionality is
implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>alg_name</strong> – When history is enabled this is the algorithm name
assigned to the stamp for applying this algorithm.
Default (“WindowData”) should normally be just used.
Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>ald_id</strong> – algorithm id to assign to history record (used only if
object_history is set True.)
Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>dryrun</strong> – Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
<li><p><strong>dryrun</strong> – Note this functionality is implemented via the mspass_func_wrapper decorator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>copy of d with sample range reduced to twin range.  Returns
an empty version of the parent data type (default constructor) if
the input is marked dead</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.WindowDataAtomic">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">WindowDataAtomic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_segment_handling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_recoverable_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#WindowDataAtomic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.WindowDataAtomic" title="Permalink to this definition"></a></dt>
<dd><p>Cut atomic data to a shorter time segment defined by a time range.</p>
<p>Cutting a smaller waveform segment from a larger waveform segment
is a very common seismic data processing task.  Handling that low
level operation needs to be done efficiently but with a reasonable
number of options.   This function is very fast if the inputs
match the expected model where the requested time segment is
inside the range of the datum passed via arg0.   In that mode the
function is a thin wrapper on a C++ function that does most of
the work.   When the window is inconsistent with the data,
which is defined here as a “short segment”, more overhead
is involved if you want to recover something.   To be specific
a “short segment” means the requested time span for a the
window operation form win_start to win_end is not completely
inside (inclusive of the endpoints) the range of the data.</p>
<p>Handling of “short segments” has these elements:</p>
<ol class="arabic">
<li><p>If the window range is completely outside the range of
the data the result is always killed and returned
as a dead datum with no sample data. (d.npts=0)</p></li>
<li><p>Behavior if there is the window range overlaps but
has boundaries outside the data range depends on the setting
of the argument <cite>short_segment_handling</cite> and the
boolean argument <cite>log_recoverable_errors</cite>.
If <cite>log_recoverable_errors</cite> is set True (default) and
the result is returned live (i.e. the error was recoverable
but the data are flawed) a complaint message describing
what was done will be posted to the elog container
of the return.   If False recoveries will be done
silently.   That can be useful in some algorithms
(e.g. cross-correlation) where partial segments can be
handled.  What defines possible recovery is set by
the <cite>short_segment_handling</cite> string.  It must be
one of only three possible values or the function
will abort with a ValueError exception:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<dl class="simple">
<dt>“kill” - (default) does not recovery attempt and will</dt><dd><p>kill any data with time inconsistencies.</p>
</dd>
<dt>“truncate” - this truncates to the output to the</dt><dd><p>time range max(d.t0,win.starttime) to
min(d.endtime(),win.endtime).</p>
</dd>
<dt>“pad” - will cause the function to have data in</dt><dd><p>the span define dby win_start to win_end but
the sections where the data are undefined will
be set to zeros.</p>
</dd>
</dl>
</li>
</ol>
<p>Users should also be aware that this function preserves subsample timing
in modern earthquake data.   All seismic reflection processing
systems treat timing as synchronous on all channels.   That assumption
is not true for data acquired by independent digitizers with
external timing systems (today always GPS timing).   In MsPASS
that is handled through the <cite>t0</cite> attribute of atomic data objects and
the (internal) time shift from GMT used when the time standard is
shifted to “relative”.   A detail of this function is it preserves
t0 subsample timing so if you carefully examine the t0 value
on the return of this function it will match the <cite>twin_start</cite>
value only to the nearest sample.   That way time computed with the
time method (endtime is a special case for sample npts-1)
will have subsample accuracy.</p>
<p>Note:  This function should not normally be used.  WindowData
calls it directy for atomic inputs and adds only a tiny overhead.
It can still be used as long as you don’t need object-level history.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – is the input data.  d must be either
a <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.TimeSeries</span></code></a> or <a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.Seismogram" title="mspasspy.ccore.seismic.Seismogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">mspasspy.ccore.seismic.Seismogram</span></code></a>
object or the function will log an error to d and return a None.</p></li>
<li><p><strong>twin_start</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – defines the start of timeWindow to be cut</p></li>
<li><p><strong>twin_end</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – defines the end of timeWindow to be cut</p></li>
<li><p><strong>t0shift</strong> (<em>real number</em><em> (</em><em>float</em><em>) or </em><em>a string that defines a
Metadata container key.</em>) – is an optional time shift to apply to the time window.
This parameter is convenient to avoid conversions to relative time.
A typical example would be to set t0shift to an arrival time and let
the window define time relative to that arrival time.  Default is None
which cause the function to assume twin is to be used directly.
It can be specified one of two ways:  (1) as a number where it
is assumed to be a time shift to apply in seconds, or (2) as a
a string.  In the later case the string is assumed to be a valid
key for fetching a time from a datum’s Metadata container.
Note the name t0shift is a bit inconsistent with this usage but
was retained as the original api did not have the string
option.</p></li>
<li><p><strong>short_segment_handling</strong> – <p>Defines method for handling data where
the requested interval is shorter than the requested window but does
have some overlap. <cite>segment_handling_methods</cite> must be one of the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<dl class="simple">
<dt><cite>kill</cite> - in this mode any issues cause the return to be marked dead</dt><dd><p>(this is the default)</p>
</dd>
<dt>’pad’ -  in this mode return will have short segments will be padded</dt><dd><p>with zeros to define data of the required length.</p>
</dd>
<dt>’truncate’ - in this mode short segments will be truncated on left</dt><dd><p>and/or right to match actual data range.</p>
</dd>
</dl>
<p>Note that if the input time range does not overlap the requested
interval “kill” is always the behavior as by definition the result
is null.</p>
</p></li>
<li><p><strong>log_recoverable_errors</strong> – When True (default) any recoverable
windowing error (meaning at least a partial overlap in time range)
will cause a log message to be posted to the elog container of the
output.  When False recovery will be done silently.  Note when
<cite>short_segment_handling</cite> is set to “kill” logging is not optional and
kill will always create an error log entry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>copy of d with sample range reduced to twin range.  Returns
an empty version of the parent data type (default constructor) if
the input is marked dead</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.WindowData_autopad">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">WindowData_autopad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">etime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_fraction_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WindowData_autopad'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#WindowData_autopad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.WindowData_autopad" title="Permalink to this definition"></a></dt>
<dd><p>Windows an atomic data object with automatic padding if the
undefined section is not too large.</p>
<p>When using numpy or MsPASS data arrays the : notation can be used
to drastically speed performance over using a python loop.
This function is most useful for contexts where the size of the
output of a window must exactly match what is expected from
the time range.   A type example is a multichannel algorithm
where you need to use an API that loads a set of signals into
a matrix that is used as the workspace for processing.  That is
the univeral model, for example, in seismic reflection processing.
This algorithm will silently zero pad any undefined samples
at the end of the window IF the fraction of undefined data relative to
the number of samples expected from the time range defined by
etime-stime is less than the “pad_fraction_cutoff”.  If
the input time span shorter than the computed mismatch limit
the result will be returned marked dead with an elog entry
highlighting the problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (works with either <cite>TimeSeries</cite> or <cite>Seismogram</cite>
objects.  Will raise a TypeError exception if d is not one of
the two atomic data types.) – atomic MsPASS seismic data object to be windowed.</p></li>
<li><p><strong>stime</strong> (<em>float</em>) – start time of window range</p></li>
<li><p><strong>etime</strong> (<em>float</em>) – end time of window range</p></li>
<li><p><strong>pad_fraction_cutoff</strong> – limit for the
fraction of data with undefined values before the datum is
killed.   (see above)  If set to 0.0 this is an expensive way
to behave the same as WindowData</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>object of the same type as d.   Will be marked dead
if the fraction of undefined data exceeds pad_fraction_cutoff.
Otherwise will return a data vector of constant size that may
be padded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.ensemble_error_post">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">ensemble_error_post</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">message</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">severity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#ensemble_error_post"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.ensemble_error_post" title="Permalink to this definition"></a></dt>
<dd><p>This is a small helper function useful for error handlers in except
blocks for ensemble objects.  If a function is called on an ensemble
object that throws an exception this function will post the message
posted to all ensemble members.  It silently does nothing if the
ensemble is empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – is the ensemble data to be handled.  It print and error message
and returns doing nothing if d is not one of the known ensemble
objects.</p></li>
<li><p><strong>alg</strong> – is the algorithm name posted to elog on each member</p></li>
<li><p><strong>message</strong> – is the string posted to all members</p></li>
<li><p><strong>severity</strong> – is the error severity level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.merge">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tsvector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starttime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_overlaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_gaps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="mspasspy.ccore.html#mspasspy.ccore.seismic.TimeSeries" title="mspasspy.ccore.seismic.TimeSeries"><span class="pre">TimeSeries</span></a></span></span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#merge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.merge" title="Permalink to this definition"></a></dt>
<dd><p>Splices a vector of TimeSeries objects together and optionally carves
out a specified time window.  It acts a bit like an obspy function
with the same name, but has completely different options and works
with native MsPASS TimeSeries objects.</p>
<p>This function is a workhorse for handling continuous data that are
universally stored today as a series of files.   The input to this
function is an array of TimeSeries objects that are assummed to be
created from a set of data stored in such files.   The data are assumed
to be from a common stream of a single channel and sorted so the
array index defines a time order.  The algorithm attempts to glue the
segments together into a single time series that is returned.
The algorithm by default assumes the input is “clean” which means
the endtime of each input TimeSeries is 1 sample ahead of the start time
of the next segment (i.e. (segment[i+1].t0()-segment[i].endtime()) == dt).
The actual test is that the time difference is less than dt/2.</p>
<p>This algorithm treats two conditions as a fatal error and will throw
a MsPASSError when the condition occurs:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>It checks that the input array of TimeSeries data are in
time order.</p></li>
<li><p>It checks that the inputs all have the same sample rate.</p></li>
<li><p>If fix_overlaps is False if an overlap is found it
is considered an exception.</p></li>
</ol>
</div></blockquote>
<p>Either of these conditions will cause the function to throw an
exception.  The assumption is that either is a user error created
by failing to reading the directions that emphasize this requirement
for the input.</p>
<p>Other conditions can cause the output to be marked dead with an
error message posted to the output’s elog attribute.  These are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>This algorithm aims to produce an output with data stored in
a continuous vector with a length defined by the total time
span of the input.  Naive use can create enormously long
vectors that would mostly be empty.   (e.g. two random
day files with a 5 year difference in start time)  The
algorithm refuses to try to merge data when the span exceeds
an internal threshold of 10^8 samples.</p></li>
<li><p>If fix_overlaps is false any overlap of successive endtime to
the next starttime of more than 0.5 samples will cause the
output to be killed.   The assumption is such data have a
serious timing problem retained even after any cleaning.</p></li>
</ol>
</div></blockquote>
<p>The above illustrates that this function behaves differently and makes
different assumption if the argument check_overlaps is True or False.
False is faster because it bypasses the algorithm used to fix overlaps,
but is safer if your data is not perfectly clean in the sense of
lacking any timing issues or problem with duplicates.   If the
fix_overlaps boolean is set True, the mspass overlap handler is
involked that is a C++ function with the name “repair_overlaps”.
The function was designed only to handle the following common
situations.  How they are handled is different for each situation.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Duplicate waveform segments spanning a common time interval
can exist in raw data and accidentally by indexing two copies
the same data.   If the samples in the overlapping section
match the algorithm will attempt to remove the overlapping
section.   The algorithm is known to work only for a pair of
pure duplicates and a smaller segment with a start time after
a more complete segment.   It may fail if there are more than
three or more copies of the same waveform in the input or
one of the waveforms spans a smaller time range than the other
but has the same start time.   The first is a gross user error.
The second should be rare an is conceivable only with raw
data where a packet or two was randomly saved twice - something
that shouldn’t happen but could with flakey hardware.</p></li>
<li><p>If an overlap is detected AND the sample data in the overlap
are different the algorithm assumes the data have a timing
problem that created this situation.   Our experience is this
situation only happens when an instrument has a timing problem.
All continuous data generating digitizers we know of use a
timing system slaved to an external reference (usually GPS time).
If the external signal is lost the clock drifts.  When the
signal is restored if the digitizer detects a large time
jump it may reset (time jerk) to tag the next packet of data
with the updated time based on the standard.  If that time
jump is forward it will leave an apparent gap in the data, which
we discuss below, but if the jump is backward it will leave an
apparent overlap with inconsistent samples.   The
repair_overlaps function assumes that is the cause of all overlaps
it detects.</p></li>
</ol>
</div></blockquote>
<p>The final common situation this function needs to handle is gaps.  A
gap is defined in this algorithm as any section where the endtime of
one segment is followed by a start time of the next segment that is
more than 1 sample in duration.  Specifically when</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(segment[i+1].t0()-segment[i].endtime()) &gt; 1.5*dt
</pre></div>
</div>
<p>The result depends on values of the (optional) windowing arguments
starttime and endtime and the boolean “zero_gaps” argument.
If windowing is enabled (done by changing
default None values of starttime and endtime) any gap will be harmless
unless it is present inside the specified time time range.  In all
cases what happens to the output depends upon the boolean zero_gaps.
When zero_gaps is False any gaps detected within the output range of
the result (windowed range if specified but the full time of the input otherwise)
When set True gap sections will be zeroed in the output data vector.
All outputs with gaps that have been zeroed will have the boolean
Metadata attribute “has_gap” set True and undefined otherwise.
When the has_data attribute is set true the tap windows will be
stored as a list of “TimeWindow” objects with the Metadata key “gaps”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tsvector</strong> – array of TimeSeries data that are to be spliced
together to create a single output.   The contents must all have
the same sample rate and be sorted by starttime.</p></li>
<li><p><strong>starttime</strong> (<em>double - assumed to be a UTC time expressed as a unix
epoch time.</em>) – (optional) start time to apply for windowing the
output.  Default is None which means the output will be created
as the merge of all the inputs.  When set WindowData is applied
with this start time.   Note if endtime is defined but starttime
is None windowing is enabled with starttime = earliest segment start time.</p></li>
<li><p><strong>endtime</strong> (<em>double - assumed to be a UTC time expressed as a unix
epoch time.</em>) – (optional) end time to apply for windowing the
output.  Default is None which means the output will be created
as the merge of all the inputs.  When set WindowData is applied
with this end time.   Note if starttime is defined but endtime
is None windowing is enabled with endtime = latest end time of
all segments.</p></li>
<li><p><strong>fix_overlaps</strong> (<em>boolean</em>) – when set True (default is False) if an overlap
is detected the algorithm will attempt to repair the overlap
to yield a continuous time series vectgor if it determined to have
matching data.  See description above for more details.</p></li>
<li><p><strong>zero_gaps</strong> (<em>boolean</em><em> (</em><em>default False</em><em>)</em>) – When set False, which is the default, any gaps
detected in the output window will cause the return to be marked
dead.  When set True, gaps will be zeroed and with a record of
gap positions posted to the Metadata of the output.  See above
for details.</p></li>
<li><p><strong>zero_gaps</strong> – boolean controlling how gaps are to be handled.
See above for details of the algorithm.</p></li>
<li><p><strong>object_history</strong> – boolean to enable or disable saving object
level history.  Default is False.  Note this functionality is
implemented via the mspass_func_wrapper decorator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>TimeSeries in the range defined by the time span of the input
vector of segments or if starttime or endtime are specified a reduced
time range.  The result may be marked dead for a variety of reasons
with error messages explaining why in the return elog attribute.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mspasspy.algorithms.window.scale">
<span class="sig-prename descclassname"><span class="pre">mspasspy.algorithms.window.</span></span><span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_from_window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'peak'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_by_section</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'scale'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alg_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dryrun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_return_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_ensembles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checks_arg0_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handles_dead_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mspasspy/algorithms/window.html#scale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mspasspy.algorithms.window.scale" title="Permalink to this definition"></a></dt>
<dd><p>Top level function interface to data scaling methods.</p>
<p>This function can be used to scale seismic data contained in any of
the four seismic data objects defined in mspass:  TimeSeries, Seismogram,
TimeSeriesEnsemble, and SeismogramEnsemble.   An extensive set of
amplitude estimation metrics are available by selecting one of the
allowed values for the method parameter.   Ensembles can be scaled
at the individual seismogram level or as a whole (scale_by_section=True).</p>
<p>Note all methods preserve the original amplitude by updating the
Metadata parameter calib to include the scaling.  i.e. as always the
amplitude of the data in physical units can be restored by multiplying
the data samples by calib.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> – is input data object.  If not one of the four mspass seismic
data types noted above the function will throw a RuntimeError exception.</p></li>
<li><p><strong>compute_from_window</strong> – boolean used to compute amplitude and scale
based on a windowed section of the input waveform.   By default (this
boolan False) the amplitude for scaling is computed from the full
waveform.  When True the window argument must contain a valid TimeWindow
that spans a time range smaller than the data range.  In that situation
if the window is inconsistent with the data range the return will be
marked dead and messages will be found posted in elog.  For ensembles
all or only  portion of the group will be killed if this happens.
Note this parameter is also ignored when scale_by_section is true.</p></li>
<li><p><strong>window</strong> – mspass TimeWindow object defining the time range
over which the amplitude for scaling is to be computed.  (see the
compute_from_window parameter description)</p></li>
<li><p><strong>method</strong> – string defining the gain method to use.  Currently supported
method values are:  peak, RMS (rms accepted), perc, and MAD
(also accepts mad or Mad).  Peak uses the largest amplitude for
scaling.  For 3C data that means vector amplitude while for scalar data
it is the largest absolute value. rms is the standard rms measure,
although for 3C data is is rms vector amplitudes so scaling is by the
number of vectors not the total number of samples (3 times number of
vectors).  perc uses a sorted percentage clip level metric as used in
seismic unix.  mad is a variant where the value returned is the
median absolute deviation (mad) that is actual the same as perc=1/2.
Default is peak.  WARNING:  if an invalid value for method is passed the
data will be returned unaltered with a complaint message issue for
very datum (indivually or in ensembles) run that way.</p></li>
<li><p><strong>level</strong> – For all but perc this defines the scale to which the data
are scaled.  For perc it is used to set the percent clip level.
If the value passed is illegal (0 or negative for most methods while
perc must also be positive but less or equal 1) a complain message will
be posted to elog and the level adjusted to 1.0.</p></li>
<li><p><strong>scale_by_section</strong> – is a boolean that controls the scaling
behavior on ensembles only (It is silently ignored for atomic
TimeSeries and Seismogram data).  When true a single gain factor is
applied to all members of an ensemble.  When false each member is
gained individually as if this function were applied in a loop to
each member.</p></li>
<li><p><strong>use_mean</strong> – boolean used only for ensembles and when scale_by_section is
True.   The algorithm used in that case has an option to use the mean
log amplitude for scaling the section instead of the default median
amplitude.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Data scaled to specified level.  Note the scaling always preserves
absolute amplitude by adjusting the value of the calib attribute of the
return so calib*data is the same value before and after the scaling.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>same as input</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Python API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mspasspy.ccore.html" class="btn btn-neutral float-right" title="mspasspy.ccore" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2021, Ian Wang.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>